target triple = "x86_64-apple-macosx10.8"

%..opaque = type {};
%..string = type {i8*, i64} ; Basic_string
%..rawptr = type i8* ; Basic_rawptr
%..complex32 = type {half, half} ; Basic_complex32
%..complex64 = type {float, float} ; Basic_complex64
%..complex128 = type {double, double} ; Basic_complex128
%..typeid = type i64 ; Basic_typeid
%..any = type {%..rawptr, %..typeid} ; Basic_any
declare void @llvm.dbg.declare(metadata, metadata, metadata) #3 

%runtime.Calling_Convention = type i64
%runtime.Type_Info_Enum_Value = type {[0 x <8 x i8>], [8 x i8], i8}
%runtime.Type_Info_Named = type {%..string, %runtime.Type_Info*}
%runtime.Type_Info_Integer = type {i8}
%runtime.Type_Info_Rune = type {}
%runtime.Type_Info_Float = type {}
%runtime.Type_Info_Complex = type {}
%runtime.Type_Info_String = type {i8}
%runtime.Type_Info_Boolean = type {}
%runtime.Type_Info_Any = type {}
%runtime.Type_Info_Type_Id = type {}
%runtime.Type_Info_Pointer = type {%runtime.Type_Info*}
%runtime.Type_Info_Procedure = type {%runtime.Type_Info*, %runtime.Type_Info*, i8, i64}
%runtime.Type_Info_Array = type {%runtime.Type_Info*, i64, i64}
%runtime.Type_Info_Dynamic_Array = type {%runtime.Type_Info*, i64}
%runtime.Type_Info_Slice = type {%runtime.Type_Info*, i64}
%runtime.Type_Info_Tuple = type {{%runtime.Type_Info**, i64}, {%..string*, i64}}
%runtime.Type_Info_Struct = type {{%runtime.Type_Info**, i64}, {%..string*, i64}, {i64*, i64}, {i8*, i64}, i8, i8, i8}
%runtime.Type_Info_Union = type {{%runtime.Type_Info**, i64}, i64, %runtime.Type_Info*, i8}
%runtime.Type_Info_Enum = type {%runtime.Type_Info*, {%..string*, i64}, {%runtime.Type_Info_Enum_Value*, i64}}
%runtime.Type_Info_Map = type {%runtime.Type_Info*, %runtime.Type_Info*, %runtime.Type_Info*}
%runtime.Type_Info_Bit_Field = type {{%..string*, i64}, {i32*, i64}, {i32*, i64}}
%runtime.Type_Info_Bit_Set = type {%runtime.Type_Info*, %runtime.Type_Info*, i64, i64}
%runtime.Type_Info = type {i64, i64, %..typeid, {[0 x <8 x i8>], [72 x i8], i8}}
%runtime.Typeid_Bit_Field = type {[0 x <8 x i8>], [8 x i8]}
%runtime.Source_Code_Location = type {%..string, i64, i64, %..string}
%runtime.Assertion_Failure_Proc = type void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*
%runtime.Context = type {%mem.Allocator, %mem.Allocator, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, %log.Logger, i64, %..any, i64, %..any}
%runtime.Map_Key = type {i64, %..string}
%runtime.Map_Find_Result = type {i64, i64, i64}
%runtime.Map_Entry_Header = type {%runtime.Map_Key, i64}
%runtime.Map_Header = type {%mem.Raw_Map*, i8, i64, i64, i64, i64}
%main.Entity = type i64
%main.Transform = type {i64, [3 x float]}
%main.Sprite_Renderer = type {i64, %workbench.Colorf}
%main.Spinner_Component = type {i64, float, float}
%main.Mesh_Renderer = type {i64, {i64*, i64, i64, %mem.Allocator}}
%mem.Raw_String = type {i8*, i64}
%mem.Raw_Slice = type {%..rawptr, i64}
%mem.Raw_Dynamic_Array = type {%..rawptr, i64, i64, %mem.Allocator}
%mem.Raw_Map = type {{i64*, i64}, %mem.Raw_Dynamic_Array}
%mem.Allocator_Mode = type i8
%mem.Allocator_Proc = type %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*
%mem.Allocator = type {%..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr}
%mem.Scratch_Allocator = type {{i8*, i64}, i64, i64, %mem.Allocator, {%..rawptr*, i64, i64, %mem.Allocator}}
%os.Handle = type i32
%os.File_Time = type i64
%os.Errno = type i64
%utf8.Accept_Range = type {i8, i8}
%log.Level = type i64
%log.Option = type i64
%log.Options = type i8
%log.Logger_Proc = type void (%..rawptr, i64, %..string, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)*
%log.Logger = type {void (%..rawptr, i64, %..string, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr}
%fmt.String_Buffer = type {i8*, i64, i64, %mem.Allocator}
%fmt.Fmt_Info = type {i8, i8, i8, i8, i8, i8, i8, i64, i64, i64, i8, i8, {i8*, i64, i64, %mem.Allocator}*, %..any}
%math.Vec2 = type [2 x float]
%math.Vec3 = type [3 x float]
%math.Vec4 = type [4 x float]
%math.Mat4 = type [4 x [4 x float]]
%workbench.Colorf = type {float, float, float, float}
%workbench.Colori = type {i8, i8, i8, i8}
%workbench.Button = type i64
%workbench.Key_Press = type {{[0 x <4 x i8>], [4 x i8], i8}}
%workbench.Controller_State = type {i8, {i8*, i64}, {i8*, i64}, {i8*, i64}, {float*, i64}}
%workbench.Subscriber = type {%..rawptr, void (%..rawptr, %..string, %runtime.Context*)*}
%workbench.Catalog_Item = type {%..string, %..string, i64, {%workbench.Subscriber*, i64, i64, %mem.Allocator}}
%workbench.Rendermode_Proc = type void (%runtime.Context*)*
%workbench.Buffered_Vertex = type {i64, i64, [3 x float], [2 x float], %workbench.Colorf, void (%runtime.Context*)*, i32, i32, i8, [4 x i64]}
%workbench.Vertex2D = type {[3 x float], [2 x float], %workbench.Colorf}
%workbench.Sprite = type {[4 x [2 x float]], float, float, i32}
%workbench.Vertex3D = type {[3 x float], [2 x float], %workbench.Colorf, [3 x float]}
%workbench.Mesh = type {{%workbench.Vertex3D*, i64, i64, %mem.Allocator}}
%workbench.MeshID = type i64
%"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29" = type {[100 x double], i64, i8}
%workbench.Scene = type {%..string, void (%runtime.Context*)*, void (float, %runtime.Context*)*, void (float, %runtime.Context*)*, void (%runtime.Context*)*}
%workbench._Scene_Internal = type {%workbench.Scene, i64}
%workbench.Scene_ID = type i64
%workbench.WB_Debug_Data = type {[3 x float], double, float, float, i32}
%workbench.Shader_Program = type i32
%workbench.Graphics_Buffer = type i32
%workbench.VAO = type i32
%workbench.VBO = type i32
%workbench.EBO = type i32
%workbench.Texture = type i32
%workbench.Location = type i32
%workbench.Tweener = type {%..rawptr, {[0 x <8 x i8>], [8 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}, float, float, float (float, %runtime.Context*)*, float, i8, i8, void (%..rawptr, %runtime.Context*)*, %..rawptr, %workbench.Tweener*}
%workbench.IMGUI_ID = type i64
%workbench.Location_ID_Mapping = type {i64, %runtime.Source_Code_Location, i64}
%"workbench.Rect-1229.Rect\28int\29" = type {i64, i64, i64, i64}
%"workbench.Rect-1229.Rect\28f32\29" = type {float, float, float, float}
%workbench.IMGUI_Rect_Kind = type i64
%workbench.IMGUI_Rect = type {i64, i64, %..string, %runtime.Source_Code_Location, %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28int\29", float, float, float, float, i64, i64, i64, i64}
%workbench.Scroll_View = type {%"workbench.Rect-1229.Rect\28int\29", [2 x float], [2 x float], [2 x float]}
%workbench.UI_Debug_File_Line = type {%..string, i64, %..string}
%assimp.aiVectorKey = type {double, %assimp.aiVector3D}
%assimp.aiQuatKey = type {double, %assimp.aiQuaternion}
%assimp.aiAnimBehaviour = type i32
%assimp.aiNodeAnim = type {%assimp.aiString, i32, %assimp.aiVectorKey*, i32, %assimp.aiQuatKey*, i32, %assimp.aiVectorKey*, i32, i32}
%assimp.aiAnimation = type {%assimp.aiString, double, double, i32, %assimp.aiNodeAnim**}
%assimp.aiString = type {i64, i8}
%assimp.aiCamera = type {%assimp.aiString, %assimp.aiVector3D, %assimp.aiVector3D, %assimp.aiVector3D, float, float, float, float}
%assimp.aiPropertyTypeInfo = type i32
%assimp.aiMaterialProperty = type {%assimp.aiString, i32, i32, i32, i32, i8*}
%assimp.aiMaterial = type {%assimp.aiMaterialProperty**, i32, i32}
%assimp.aiLightSourceType = type i32
%assimp.aiLight = type {%assimp.aiString, i32, %assimp.aiVector3D, %assimp.aiVector3D, float, float, float, %assimp.aiColor3D, %assimp.aiColor3D, %assimp.aiColor3D, float, float}
%assimp.aiFace = type {i32, i32*}
%assimp.aiVertexWeight = type {i32, float}
%assimp.aiBone = type {%assimp.aiString, i32, %assimp.aiVertexWeight*, %assimp.aiMatrix4x4}
%assimp.aiAnimMesh = type {%assimp.aiVector3D*, %assimp.aiVector3D*, %assimp.aiVector3D*, %assimp.aiVector3D*, [4 x %assimp.aiColor4D*], [4 x %assimp.aiVector3D*], i32}
%assimp.aiMesh = type {i32, i32, i32, %assimp.aiVector3D*, %assimp.aiVector3D*, %assimp.aiVector3D*, %assimp.aiVector3D*, [4 x %assimp.aiColor4D*], [4 x %assimp.aiVector3D*], [4 x i32], %assimp.aiFace*, i32, %assimp.aiBone**, i32, %assimp.aiString, i32, %assimp.aiAnimMesh**}
%assimp.aiVector3D = type {float, float, float}
%assimp.aiQuaternion = type {float, float, float, float}
%assimp.aiMatrix4x4 = type {float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float}
%assimp.aiColor3D = type {float, float, float}
%assimp.aiColor4D = type {float, float, float, float}
%assimp.aiTexel = type {i8}
%assimp.aiTexture = type {i32, i32, [4 x i8], %assimp.aiTexel*}
%assimp.aiNode = type {%assimp.aiString, %assimp.aiMatrix4x4, %assimp.aiNode*, i32, %assimp.aiNode**, i64, i32*}
%assimp.aiScene = type {i32, %assimp.aiNode*, i32, %assimp.aiMesh**, i32, %assimp.aiMaterial**, i32, %assimp.aiAnimation**, i32, %assimp.aiTexture**, i32, %assimp.aiLight**, i32, %assimp.aiCamera**}
%assimp.aiPostProcessSteps = type i32
%strconv.Int_Flag = type i64
%strconv.Int_Flags = type i8
%strconv.DecimalSlice = type {{i8*, i64}, i64, i64, i8}
%strconv.FloatInfo = type {i64, i64, i64}
%glfw.Window_Handle = type %..rawptr
%glfw.Monitor_Handle = type %..rawptr
%glfw.Vid_Mode = type {i32, i32, i32, i32, i32, i32}
%glfw.Window_Size_Proc = type void (%..rawptr, i32, i32)*
%glfw.Key_Proc = type void (%..rawptr, i32, i32, i32, i32)*
%glfw.Mouse_Button_Proc = type void (%..rawptr, i32, i32, i32)*
%glfw.Cursor_Pos_Proc = type void (%..rawptr, double, double)*
%glfw.Scroll_Proc = type void (%..rawptr, double, double)*
%glfw.Char_Proc = type void (%..rawptr, i32)*
%glfw.Error_Proc = type void (i32, i8*)*
%glfw.Action = type i32
%glfw.Key = type i32
%glfw.Mouse = type i32
%imgui.DrawIdx = type i16
%imgui.Wchar = type i16
%imgui.TextureID = type %..rawptr
%imgui.Font = type {}
%imgui.FontAtlas = type {}
%imgui.DrawList = type {}
%imgui.Vec2 = type {float, float}
%imgui.Vec4 = type {float, float, float, float}
%imgui.DrawCmd = type {i32, %imgui.Vec4, %..rawptr, void (%imgui.DrawList*, %imgui.DrawCmd*)*, %..rawptr}
%imgui.DrawVert = type {%imgui.Vec2, %imgui.Vec2, i32}
%imgui.DrawData = type {i8, %imgui.DrawList**, i32, i32, i32}
%imgui.FontConfig = type {%..rawptr, i32, i8, i32, float, i32, i32, i8, %imgui.Vec2, %imgui.Vec2, i16*, i8, i32, float, [32 x i8], %imgui.Font*}
%imgui.Style = type {float, %imgui.Vec2, float, float, %imgui.Vec2, %imgui.Vec2, float, float, float, float, %imgui.Vec2, float, float, %imgui.Vec2, %imgui.Vec2, %imgui.Vec2, float, float, float, float, float, float, %imgui.Vec2, %imgui.Vec2, %imgui.Vec2, i8, i8, float, [43 x %imgui.Vec4]}
%imgui.IO = type {%imgui.Vec2, float, float, i8*, i8*, float, float, float, [19 x i32], float, float, %..rawptr, %imgui.FontAtlas*, float, i8, %imgui.Font*, %imgui.Vec2, %imgui.Vec2, %imgui.Vec2, i8, i8, void (%imgui.DrawData*)*, i8* (%..rawptr)*, void (%..rawptr, i8*)*, %..rawptr, %..rawptr (i64)*, void (%..rawptr)*, void (i32, i32)*, %..rawptr, %imgui.Vec2, [5 x i8], float, i8, i8, i8, i8, i8, [512 x i8], [17 x i16], i8, i8, i8, float, i32, i32, i32, i32, %imgui.Vec2, %imgui.Vec2, [5 x i8], [5 x %imgui.Vec2], [5 x float], [5 x i8], [5 x i8], [5 x i8], [5 x float], [5 x float], [5 x %imgui.Vec2], [5 x float], [512 x float], [512 x float]}
%imgui.draw_callback = type void (%imgui.DrawList*, %imgui.DrawCmd*)*
%imgui.Window_Flags = type i32
%imgui.Tree_Node_Flags = type i32
%imgui.Key = type i32
%imgui.Color = type i32
%rand.Rand = type {i64, i64}
%gl.Set_Proc_Address_Type = type void (%..rawptr, i8*, %runtime.Context*)*
%gl.sync_t = type %..rawptr
%gl.debug_proc_t = type void (i32, i32, i32, i32, i32, i8*, %..rawptr)*
%gl.Shader_Type = type i32
%decimal.Decimal = type {[384 x i8], i64, i64, i8, i8}
%workbench._late_update_ui.UI_Debug_Info-1465 = type {i32}
%strconv.format_digits.Buffer-1466 = type {{i8*, i64}, i64}
%runtime.__get_map_header-21196.Entry-1467 = type {%runtime.Map_Key, i64, %workbench._Scene_Internal}

declare ccc void @llvm.debugtrap() #0 
declare ccc i32 @open(i8*, i64) #0 
declare ccc void @close(i32) #0 
declare ccc i64 @read(i32, %..rawptr, i64) #0 
declare ccc i64 @write(i32, %..rawptr, i64) #0 
declare ccc i64 @lseek(i32, i64, i64) #0 
declare ccc %..rawptr @calloc(i64, i64) #0 
declare ccc void @free(%..rawptr) #0 
declare ccc %..rawptr @realloc(%..rawptr, i64) #0 
declare ccc float @llvm.sin.f32(float) #0 
declare ccc float @llvm.cos.f32(float) #0 
declare ccc %assimp.aiScene* @aiImportFile(i8*, i32) #0 
declare ccc void @aiReleaseImport(%assimp.aiScene*) #0 
declare ccc i32 @glfwInit() #0 
declare ccc %..rawptr @glfwGetPrimaryMonitor() #0 
declare ccc %glfw.Vid_Mode* @glfwGetVideoMode(%..rawptr) #0 
declare ccc %..rawptr @glfwCreateWindow(i32, i32, i8*, %..rawptr, %..rawptr) #0 
declare ccc void @glfwWindowHint(i32, i32) #0 
declare ccc i32 @glfwWindowShouldClose(%..rawptr) #0 
declare ccc void @glfwSwapInterval(i32) #0 
declare ccc void @glfwSwapBuffers(%..rawptr) #0 
declare ccc void @glfwSetWindowPos(%..rawptr, i32, i32) #0 
declare ccc void @glfwPollEvents() #0 
declare ccc i32 @glfwGetMouseButton(%..rawptr, i32) #0 
declare ccc void @glfwGetCursorPos(%..rawptr, double*, double*) #0 
declare ccc float* @glfwGetJoystickAxes(i32, i32*) #0 
declare ccc i8* @glfwGetJoystickButtons(i32, i32*) #0 
declare ccc double @glfwGetTime() #0 
declare ccc void @glfwMakeContextCurrent(%..rawptr) #0 
declare ccc %..rawptr @glfwGetProcAddress(i8*) #0 
declare ccc void (%..rawptr, i32, i32)* @glfwSetWindowSizeCallback(%..rawptr, void (%..rawptr, i32, i32)*) #0 
declare ccc void (%..rawptr, i32, i32, i32, i32)* @glfwSetKeyCallback(%..rawptr, void (%..rawptr, i32, i32, i32, i32)*) #0 
declare ccc void (%..rawptr, i32, i32, i32)* @glfwSetMouseButtonCallback(%..rawptr, void (%..rawptr, i32, i32, i32)*) #0 
declare ccc void (%..rawptr, double, double)* @glfwSetCursorPosCallback(%..rawptr, void (%..rawptr, double, double)*) #0 
declare ccc void (%..rawptr, double, double)* @glfwSetScrollCallback(%..rawptr, void (%..rawptr, double, double)*) #0 
declare ccc void (%..rawptr, i32)* @glfwSetCharCallback(%..rawptr, void (%..rawptr, i32)*) #0 
declare ccc void (i32, i8*)* @glfwSetErrorCallback(void (i32, i8*)*) #0 
declare ccc %imgui.IO* @igGetIO() #0 
declare ccc %imgui.Style* @igGetStyle() #0 
declare ccc %imgui.DrawData* @igGetDrawData() #0 
declare ccc void @igNewFrame() #0 
declare ccc void @igRender() #0 
declare ccc i8 @igBegin(i8*, i8*, i32) #0 
declare ccc void @igEnd() #0 
declare ccc void @igPushFont(%imgui.Font*) #0 
declare ccc void @igPopFont() #0 
declare ccc void @igSameLine(float, float) #0 
declare ccc void @igIndent(float) #0 
declare ccc void @igUnindent(float) #0 
declare ccc void @igPushIDStr(i8*) #0 
declare ccc void @igPopID() #0 
declare ccc void @igTextUnformatted(i8*, i8*) #0 
declare ccc void @igBullet() #0 
declare ccc i8 @igSmallButton(i8*) #0 
declare ccc i8 @igCheckbox(i8*, i8*) #0 
declare ccc i8 @igSliderInt(i8*, i32*, i32, i32, i8*) #0 
declare ccc i8 @igCollapsingHeader(i8*, i32) #0 
declare ccc void @ImGuiIO_AddInputCharacter(i16) #0 
declare ccc void @ImFontAtlas_GetTexDataAsRGBA32(%imgui.FontAtlas*, i8**, i32*, i32*, i32*) #0 
declare ccc void @ImFontAtlas_SetTexID(%imgui.FontAtlas*, %..rawptr) #0 
declare ccc %imgui.Font* @ImFontAtlas_AddFontFromFileTTF(%imgui.FontAtlas*, i8*, float, %imgui.FontConfig*, i16*) #0 
declare ccc i32 @ImDrawList_GetVertexBufferSize(%imgui.DrawList*) #0 
declare ccc %imgui.DrawVert* @ImDrawList_GetVertexPtr(%imgui.DrawList*, i32) #0 
declare ccc i32 @ImDrawList_GetIndexBufferSize(%imgui.DrawList*) #0 
declare ccc i16* @ImDrawList_GetIndexPtr(%imgui.DrawList*, i32) #0 
declare ccc i32 @ImDrawList_GetCmdSize(%imgui.DrawList*) #0 
declare ccc %imgui.DrawCmd* @ImDrawList_GetCmdPtr(%imgui.DrawList*, i32) #0 

define void @runtime.print_u64(i32 %fd, i64 %u, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i64, align 16
	%2 = alloca %..string, align 16
	%3 = alloca [129 x i8], align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca {i8*, i64}, align 16
	%7 = alloca {i8*, i64}, align 16
	store i32 %fd, i32* %0
	store i64 %u, i64* %1
	; digits
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$0, i64 0, i32 0), i64 10}, %..string* %2
	; a
	%8 = bitcast [129 x i8]* %3 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 129) noinline
	store [129 x i8] zeroinitializer, [129 x i8]* %3
	; i
	store i64 129, i64* %4
	; b
	store i64 10, i64* %5
	; ForStmt
	br label %for.loop-1

for.loop-1:
	%10 = load i64, i64* %1, align 8
	%11 = load i64, i64* %5, align 8
	%12 = icmp uge i64 %10, %11
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %for.body-2, label %for.done-3

for.body-2:
	; AssignStmt
	%15 = load i64, i64* %4, align 8
	%16 = sub i64 %15, 1
	store i64 %16, i64* %4
	; AssignStmt
	; IndexExpr
	%17 = load i64, i64* %4, align 8
	%18 = trunc i64 %17 to i32
	%19 = getelementptr inbounds [129 x i8], [129 x i8]* %3, i64 0, i32 %18
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1, i64 0, i32 0), i64 62}, i64 15, i64 13, i64 %17, i64 129)
	; IndexExpr
	%20 = load %..string, %..string* %2, align 8
	%21 = extractvalue %..string %20, 0
	%22 = extractvalue %..string %20, 1
	%23 = load i64, i64* %1, align 8
	%24 = load i64, i64* %5, align 8
	%25 = urem i64 %23, %24
	%26 = bitcast i64 %25 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$2, i64 0, i32 0), i64 62}, i64 15, i64 25, i64 %26, i64 %22)
	%27 = getelementptr inbounds i8, i8* %21, i64 %26
	%28 = load i8, i8* %27, align 1
	store i8 %28, i8* %19
	; AssignStmt
	%29 = load i64, i64* %5, align 8
	%30 = load i64, i64* %1, align 8
	%31 = udiv i64 %30, %29
	store i64 %31, i64* %1
	br label %for.loop-1

for.done-3:
	; AssignStmt
	%32 = load i64, i64* %4, align 8
	%33 = sub i64 %32, 1
	store i64 %33, i64* %4
	; AssignStmt
	; IndexExpr
	%34 = load i64, i64* %4, align 8
	%35 = trunc i64 %34 to i32
	%36 = getelementptr inbounds [129 x i8], [129 x i8]* %3, i64 0, i32 %35
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$3, i64 0, i32 0), i64 62}, i64 18, i64 12, i64 %34, i64 129)
	; IndexExpr
	%37 = load %..string, %..string* %2, align 8
	%38 = extractvalue %..string %37, 0
	%39 = extractvalue %..string %37, 1
	%40 = load i64, i64* %1, align 8
	%41 = load i64, i64* %5, align 8
	%42 = urem i64 %40, %41
	%43 = bitcast i64 %42 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$4, i64 0, i32 0), i64 62}, i64 18, i64 24, i64 %43, i64 %39)
	%44 = getelementptr inbounds i8, i8* %38, i64 %43
	%45 = load i8, i8* %44, align 1
	store i8 %45, i8* %36
	; SelectorExpr
	%46 = load i32, i32* %0, align 4
	; SliceExpr
	%47 = load i64, i64* %4, align 8
	%48 = load [129 x i8], [129 x i8]* %3, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$5, i64 0, i32 0), i64 62}, i64 20, i64 16, i64 %47, i64 129, i64 129)
	%49 = getelementptr inbounds [129 x i8], [129 x i8]* %3, i64 0, i32 0
	%50 = getelementptr inbounds i8, i8* %49, i64 %47
	%51 = sub i64 129, %47
	%52 = bitcast {i8*, i64}* %6 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	%54 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %6, i64 0, i32 0
	store i8* %50, i8** %54
	%55 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %6, i64 0, i32 1
	store i64 %51, i64* %55
	%56 = load {i8*, i64}, {i8*, i64}* %6, align 8
	%57 = bitcast {i8*, i64}* %7 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %7
	store {i8*, i64} %56, {i8*, i64}* %7
	%59 = call {i64, i64} @os.write(i32 %46, {i8*, i64}* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @runtime.print_i64(i32 %fd, i64 %u, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i64, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	%4 = alloca [129 x i8], align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca {i8*, i64}, align 16
	%8 = alloca {i8*, i64}, align 16
	store i32 %fd, i32* %0
	store i64 %u, i64* %1
	; digits
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$6, i64 0, i32 0), i64 10}, %..string* %2
	; neg
	%9 = load i64, i64* %1, align 8
	%10 = icmp slt i64 %9, 0
	%11 = zext i1 %10 to i8
	store i8 %11, i8* %3
	; AssignStmt
	%12 = load i64, i64* %1, align 8
	; abs
	%13 = icmp slt i64 %12, 0
	%14 = sub i64 0, %12
	%15 = select i1 %13, i64 %14, i64 %12
	store i64 %15, i64* %1
	; a
	%16 = bitcast [129 x i8]* %4 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 129) noinline
	store [129 x i8] zeroinitializer, [129 x i8]* %4
	; i
	store i64 129, i64* %5
	; b
	store i64 10, i64* %6
	; ForStmt
	br label %for.loop-1

for.loop-1:
	%18 = load i64, i64* %1, align 8
	%19 = load i64, i64* %6, align 8
	%20 = icmp sge i64 %18, %19
	%21 = zext i1 %20 to i8
	%22 = trunc i8 %21 to i1
	br i1 %22, label %for.body-2, label %for.done-3

for.body-2:
	; AssignStmt
	%23 = load i64, i64* %5, align 8
	%24 = sub i64 %23, 1
	store i64 %24, i64* %5
	; AssignStmt
	; IndexExpr
	%25 = load i64, i64* %5, align 8
	%26 = trunc i64 %25 to i32
	%27 = getelementptr inbounds [129 x i8], [129 x i8]* %4, i64 0, i32 %26
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$7, i64 0, i32 0), i64 62}, i64 33, i64 13, i64 %25, i64 129)
	; IndexExpr
	%28 = load %..string, %..string* %2, align 8
	%29 = extractvalue %..string %28, 0
	%30 = extractvalue %..string %28, 1
	%31 = load i64, i64* %1, align 8
	%32 = load i64, i64* %6, align 8
	%33 = srem i64 %31, %32
	%34 = bitcast i64 %33 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$8, i64 0, i32 0), i64 62}, i64 33, i64 25, i64 %34, i64 %30)
	%35 = getelementptr inbounds i8, i8* %29, i64 %34
	%36 = load i8, i8* %35, align 1
	store i8 %36, i8* %27
	; AssignStmt
	%37 = load i64, i64* %6, align 8
	%38 = load i64, i64* %1, align 8
	%39 = sdiv i64 %38, %37
	store i64 %39, i64* %1
	br label %for.loop-1

for.done-3:
	; AssignStmt
	%40 = load i64, i64* %5, align 8
	%41 = sub i64 %40, 1
	store i64 %41, i64* %5
	; AssignStmt
	; IndexExpr
	%42 = load i64, i64* %5, align 8
	%43 = trunc i64 %42 to i32
	%44 = getelementptr inbounds [129 x i8], [129 x i8]* %4, i64 0, i32 %43
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$9, i64 0, i32 0), i64 62}, i64 36, i64 12, i64 %42, i64 129)
	; IndexExpr
	%45 = load %..string, %..string* %2, align 8
	%46 = extractvalue %..string %45, 0
	%47 = extractvalue %..string %45, 1
	%48 = load i64, i64* %1, align 8
	%49 = load i64, i64* %6, align 8
	%50 = srem i64 %48, %49
	%51 = bitcast i64 %50 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$a, i64 0, i32 0), i64 62}, i64 36, i64 24, i64 %51, i64 %47)
	%52 = getelementptr inbounds i8, i8* %46, i64 %51
	%53 = load i8, i8* %52, align 1
	store i8 %53, i8* %44
	; IfStmt
	%54 = load i8, i8* %3, align 1
	%55 = trunc i8 %54 to i1
	br i1 %55, label %if.then-4, label %if.done-5

if.then-4:
	; AssignStmt
	%56 = load i64, i64* %5, align 8
	%57 = sub i64 %56, 1
	store i64 %57, i64* %5
	; AssignStmt
	; IndexExpr
	%58 = load i64, i64* %5, align 8
	%59 = trunc i64 %58 to i32
	%60 = getelementptr inbounds [129 x i8], [129 x i8]* %4, i64 0, i32 %59
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$b, i64 0, i32 0), i64 62}, i64 38, i64 13, i64 %58, i64 129)
	store i8 45, i8* %60
	br label %if.done-5

if.done-5:
	; SelectorExpr
	%61 = load i32, i32* %0, align 4
	; SliceExpr
	%62 = load i64, i64* %5, align 8
	%63 = load [129 x i8], [129 x i8]* %4, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$c, i64 0, i32 0), i64 62}, i64 41, i64 16, i64 %62, i64 129, i64 129)
	%64 = getelementptr inbounds [129 x i8], [129 x i8]* %4, i64 0, i32 0
	%65 = getelementptr inbounds i8, i8* %64, i64 %62
	%66 = sub i64 129, %62
	%67 = bitcast {i8*, i64}* %7 to %..rawptr
	%68 = call %..rawptr @mem.zero(%..rawptr %67, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %7
	%69 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i64 0, i32 0
	store i8* %65, i8** %69
	%70 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i64 0, i32 1
	store i64 %66, i64* %70
	%71 = load {i8*, i64}, {i8*, i64}* %7, align 8
	%72 = bitcast {i8*, i64}* %8 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %8
	store {i8*, i64} %71, {i8*, i64}* %8
	%74 = call {i64, i64} @os.write(i32 %61, {i8*, i64}* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @runtime.print_caller_location(i32 %fd, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	store i32 %fd, i32* %0
	%1 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%2 = load i32, i32* %0, align 4
	%3 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, i64 0, i32 0
	%4 = load %..string, %..string* %3, align 8
	%5 = call {i64, i64} @os.write_string(i32 %2, %..string %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%6 = load i32, i32* %0, align 4
	%7 = call {i64, i64} @os.write_byte(i32 %6, i8 40, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%8 = load i32, i32* %0, align 4
	%9 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, i64 0, i32 1
	%10 = load i64, i64* %9, align 8
	%11 = bitcast i64 %10 to i64
	call void @runtime.print_u64(i32 %8, i64 %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%12 = load i32, i32* %0, align 4
	%13 = call {i64, i64} @os.write_byte(i32 %12, i8 58, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%14 = load i32, i32* %0, align 4
	%15 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, i64 0, i32 2
	%16 = load i64, i64* %15, align 8
	%17 = bitcast i64 %16 to i64
	call void @runtime.print_u64(i32 %14, i64 %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%18 = load i32, i32* %0, align 4
	%19 = call {i64, i64} @os.write_byte(i32 %18, i8 41, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @runtime.print_typeid(i32 %fd, %..typeid %id, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %..typeid, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	store i32 %fd, i32* %0
	store %..typeid %id, %..typeid* %1
	; ti
	%3 = load %..typeid, %..typeid* %1, align 8
	%4 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %3)
	store %runtime.Type_Info* %4, %runtime.Type_Info** %2
	%5 = load i32, i32* %0, align 4
	%6 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	call void @runtime.print_type(i32 %5, %runtime.Type_Info* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @runtime.print_type(i32 %fd, %runtime.Type_Info* %ti, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	%2 = alloca %runtime.Type_Info_Named, align 16
	%3 = alloca %runtime.Type_Info_Integer, align 16
	%4 = alloca %runtime.Type_Info_Rune, align 16
	%5 = alloca %runtime.Type_Info_Float, align 16
	%6 = alloca %runtime.Type_Info_Complex, align 16
	%7 = alloca %runtime.Type_Info_String, align 16
	%8 = alloca %runtime.Type_Info_Boolean, align 16
	%9 = alloca %runtime.Type_Info_Any, align 16
	%10 = alloca %runtime.Type_Info_Type_Id, align 16
	%11 = alloca %runtime.Type_Info_Pointer, align 16
	%12 = alloca %runtime.Type_Info_Procedure, align 16
	%13 = alloca %runtime.Type_Info_Tuple, align 16
	%14 = alloca {%runtime.Type_Info_Tuple, i8}, align 16
	%15 = alloca %runtime.Type_Info*, align 16
	%16 = alloca i64, align 16
	%17 = alloca i64, align 16
	%18 = alloca i64, align 16
	%19 = alloca %runtime.Type_Info_Tuple, align 16
	%20 = alloca i64, align 16
	%21 = alloca %..string, align 16
	%22 = alloca i64, align 16
	%23 = alloca i64, align 16
	%24 = alloca i64, align 16
	%25 = alloca %runtime.Type_Info*, align 16
	%26 = alloca %runtime.Type_Info_Array, align 16
	%27 = alloca %runtime.Type_Info_Dynamic_Array, align 16
	%28 = alloca %runtime.Type_Info_Slice, align 16
	%29 = alloca %runtime.Type_Info_Map, align 16
	%30 = alloca %runtime.Type_Info_Struct, align 16
	%31 = alloca %..string, align 16
	%32 = alloca i64, align 16
	%33 = alloca i64, align 16
	%34 = alloca i64, align 16
	%35 = alloca %runtime.Type_Info_Union, align 16
	%36 = alloca %runtime.Type_Info*, align 16
	%37 = alloca i64, align 16
	%38 = alloca i64, align 16
	%39 = alloca i64, align 16
	%40 = alloca %runtime.Type_Info_Enum, align 16
	%41 = alloca %..string, align 16
	%42 = alloca i64, align 16
	%43 = alloca i64, align 16
	%44 = alloca i64, align 16
	%45 = alloca %runtime.Type_Info_Bit_Field, align 16
	%46 = alloca %..string, align 16
	%47 = alloca i64, align 16
	%48 = alloca i64, align 16
	%49 = alloca i64, align 16
	%50 = alloca %runtime.Type_Info_Bit_Set, align 16
	%51 = alloca %runtime.Type_Info*, align 16
	%52 = alloca %runtime.Type_Info_Enum, align 16
	%53 = alloca %runtime.Type_Info_Rune, align 16
	%54 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	store i32 %fd, i32* %0
	store %runtime.Type_Info* %ti, %runtime.Type_Info** %1
	; IfStmt
	%55 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%56 = icmp eq %runtime.Type_Info* %55, zeroinitializer
	%57 = zext i1 %56 to i8
	%58 = trunc i8 %57 to i1
	br i1 %58, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	%59 = load i32, i32* %0, align 4
	%60 = call {i64, i64} @os.write_string(i32 %59, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$d, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-2:
	; TypeSwitchStmt
	; SelectorExpr
	%61 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%62 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %61, i64 0
	%63 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %62, i64 0, i32 3
	%64 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %63, align 8
	; get union's tag
	%65 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %63, i64 0, i32 2 ; UnionTagPtr
	%66 = load i8, i8* %65, align 1
	%67 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %63 to %..rawptr
	%68 = icmp eq i8 %66, 1
	br i1 %68, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.next-3:
	%69 = icmp eq i8 %66, 2
	br i1 %69, label %typeswitch.body-6, label %typeswitch.next-5

typeswitch.body-4:
	%70 = bitcast %..rawptr %67 to %runtime.Type_Info_Named*
	%71 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %70, align 8
	store %runtime.Type_Info_Named %71, %runtime.Type_Info_Named* %2
	; SelectorExpr
	%72 = load i32, i32* %0, align 4
	; SelectorExpr
	%73 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2, i64 0, i32 0
	%74 = load %..string, %..string* %73, align 8
	%75 = call {i64, i64} @os.write_string(i32 %72, %..string %74, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-5:
	%76 = icmp eq i8 %66, 3
	br i1 %76, label %typeswitch.body-18, label %typeswitch.next-17

typeswitch.body-6:
	%77 = bitcast %..rawptr %67 to %runtime.Type_Info_Integer*
	%78 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %77, align 1
	store %runtime.Type_Info_Integer %78, %runtime.Type_Info_Integer* %3
	; SwitchStmt
	; SelectorExpr
	%79 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%80 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %79, i64 0
	%81 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %80, i64 0, i32 2
	%82 = load %..typeid, %..typeid* %81, align 8
	%83 = icmp eq %..typeid %82, 4683743612465315846
	br i1 %83, label %switch.case.body-8, label %switch.case.next-7

switch.case.next-7:
	%84 = icmp eq %..typeid %82, 72057594037928003
	br i1 %84, label %switch.fall.body-10, label %switch.case.next-9

switch.case.body-8:
	; SelectorExpr
	%85 = load i32, i32* %0, align 4
	%86 = call {i64, i64} @os.write_string(i32 %85, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$e, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

switch.case.next-9:
	%87 = icmp eq %..typeid %82, 72057594037927986
	br i1 %87, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	; SelectorExpr
	%88 = load i32, i32* %0, align 4
	%89 = call {i64, i64} @os.write_string(i32 %88, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$f, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

switch.case.next-11:
	; SelectorExpr
	%90 = load i32, i32* %0, align 4
	; TernaryExpr
	; SelectorExpr
	%91 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %3, i64 0, i32 0
	%92 = load i8, i8* %91, align 1
	%93 = trunc i8 %92 to i1
	br i1 %93, label %if.then-13, label %if.else-14

switch.fall.body-12:
	; SelectorExpr
	%94 = load i32, i32* %0, align 4
	%95 = call {i64, i64} @os.write_string(i32 %94, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$10, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

if.then-13:
	br label %if.done-15

if.else-14:
	br label %if.done-15

if.done-15:
	%96 = phi i32 [ 105, %if.then-13 ], [ 117, %if.else-14 ]
	%97 = trunc i32 %96 to i8
	%98 = call {i64, i64} @os.write_byte(i32 %90, i8 %97, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%99 = load i32, i32* %0, align 4
	; SelectorExpr
	%100 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%101 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %100, i64 0
	%102 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %101, i64 0, i32 0
	%103 = load i64, i64* %102, align 8
	%104 = mul i64 8, %103
	%105 = bitcast i64 %104 to i64
	call void @runtime.print_u64(i32 %99, i64 %105, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

switch.done-16:
	br label %typeswitch.done-119

typeswitch.next-17:
	%106 = icmp eq i8 %66, 4
	br i1 %106, label %typeswitch.body-20, label %typeswitch.next-19

typeswitch.body-18:
	%107 = bitcast %..rawptr %67 to %runtime.Type_Info_Rune*
	%108 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %107, align 1
	store %runtime.Type_Info_Rune %108, %runtime.Type_Info_Rune* %4
	; SelectorExpr
	%109 = load i32, i32* %0, align 4
	%110 = call {i64, i64} @os.write_string(i32 %109, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$11, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-19:
	%111 = icmp eq i8 %66, 5
	br i1 %111, label %typeswitch.body-22, label %typeswitch.next-21

typeswitch.body-20:
	%112 = bitcast %..rawptr %67 to %runtime.Type_Info_Float*
	%113 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %112, align 1
	store %runtime.Type_Info_Float %113, %runtime.Type_Info_Float* %5
	; SelectorExpr
	%114 = load i32, i32* %0, align 4
	%115 = call {i64, i64} @os.write_byte(i32 %114, i8 102, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%116 = load i32, i32* %0, align 4
	; SelectorExpr
	%117 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%118 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %117, i64 0
	%119 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %118, i64 0, i32 0
	%120 = load i64, i64* %119, align 8
	%121 = mul i64 8, %120
	%122 = bitcast i64 %121 to i64
	call void @runtime.print_u64(i32 %116, i64 %122, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-21:
	%123 = icmp eq i8 %66, 6
	br i1 %123, label %typeswitch.body-24, label %typeswitch.next-23

typeswitch.body-22:
	%124 = bitcast %..rawptr %67 to %runtime.Type_Info_Complex*
	%125 = load %runtime.Type_Info_Complex, %runtime.Type_Info_Complex* %124, align 1
	store %runtime.Type_Info_Complex %125, %runtime.Type_Info_Complex* %6
	; SelectorExpr
	%126 = load i32, i32* %0, align 4
	%127 = call {i64, i64} @os.write_string(i32 %126, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$12, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%128 = load i32, i32* %0, align 4
	; SelectorExpr
	%129 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%130 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %129, i64 0
	%131 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %130, i64 0, i32 0
	%132 = load i64, i64* %131, align 8
	%133 = mul i64 8, %132
	%134 = bitcast i64 %133 to i64
	call void @runtime.print_u64(i32 %128, i64 %134, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-23:
	%135 = icmp eq i8 %66, 7
	br i1 %135, label %typeswitch.body-26, label %typeswitch.next-25

typeswitch.body-24:
	%136 = bitcast %..rawptr %67 to %runtime.Type_Info_String*
	%137 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %136, align 1
	store %runtime.Type_Info_String %137, %runtime.Type_Info_String* %7
	; SelectorExpr
	%138 = load i32, i32* %0, align 4
	%139 = call {i64, i64} @os.write_string(i32 %138, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$13, i64 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-25:
	%140 = icmp eq i8 %66, 8
	br i1 %140, label %typeswitch.body-31, label %typeswitch.next-30

typeswitch.body-26:
	%141 = bitcast %..rawptr %67 to %runtime.Type_Info_Boolean*
	%142 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %141, align 1
	store %runtime.Type_Info_Boolean %142, %runtime.Type_Info_Boolean* %8
	; SwitchStmt
	; SelectorExpr
	%143 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%144 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %143, i64 0
	%145 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %144, i64 0, i32 2
	%146 = load %..typeid, %..typeid* %145, align 8
	%147 = icmp eq %..typeid %146, 432345564227567636
	br i1 %147, label %switch.case.body-28, label %switch.case.next-27

switch.case.next-27:
	; SelectorExpr
	%148 = load i32, i32* %0, align 4
	%149 = call {i64, i64} @os.write_byte(i32 %148, i8 98, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%150 = load i32, i32* %0, align 4
	; SelectorExpr
	%151 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%152 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %151, i64 0
	%153 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %152, i64 0, i32 0
	%154 = load i64, i64* %153, align 8
	%155 = mul i64 8, %154
	%156 = bitcast i64 %155 to i64
	call void @runtime.print_u64(i32 %150, i64 %156, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-29

switch.case.body-28:
	; SelectorExpr
	%157 = load i32, i32* %0, align 4
	%158 = call {i64, i64} @os.write_string(i32 %157, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$14, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-29

switch.done-29:
	br label %typeswitch.done-119

typeswitch.next-30:
	%159 = icmp eq i8 %66, 9
	br i1 %159, label %typeswitch.body-33, label %typeswitch.next-32

typeswitch.body-31:
	%160 = bitcast %..rawptr %67 to %runtime.Type_Info_Any*
	%161 = load %runtime.Type_Info_Any, %runtime.Type_Info_Any* %160, align 1
	store %runtime.Type_Info_Any %161, %runtime.Type_Info_Any* %9
	; SelectorExpr
	%162 = load i32, i32* %0, align 4
	%163 = call {i64, i64} @os.write_string(i32 %162, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$15, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-32:
	%164 = icmp eq i8 %66, 10
	br i1 %164, label %typeswitch.body-35, label %typeswitch.next-34

typeswitch.body-33:
	%165 = bitcast %..rawptr %67 to %runtime.Type_Info_Type_Id*
	%166 = load %runtime.Type_Info_Type_Id, %runtime.Type_Info_Type_Id* %165, align 1
	store %runtime.Type_Info_Type_Id %166, %runtime.Type_Info_Type_Id* %10
	; SelectorExpr
	%167 = load i32, i32* %0, align 4
	%168 = call {i64, i64} @os.write_string(i32 %167, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$16, i64 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-34:
	%169 = icmp eq i8 %66, 11
	br i1 %169, label %typeswitch.body-40, label %typeswitch.next-39

typeswitch.body-35:
	%170 = bitcast %..rawptr %67 to %runtime.Type_Info_Pointer*
	%171 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %170, align 8
	store %runtime.Type_Info_Pointer %171, %runtime.Type_Info_Pointer* %11
	; IfStmt
	; SelectorExpr
	%172 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %11, i64 0, i32 0
	%173 = load %runtime.Type_Info*, %runtime.Type_Info** %172, align 8
	%174 = icmp eq %runtime.Type_Info* %173, zeroinitializer
	%175 = zext i1 %174 to i8
	%176 = trunc i8 %175 to i1
	br i1 %176, label %if.then-36, label %if.else-37

if.then-36:
	; SelectorExpr
	%177 = load i32, i32* %0, align 4
	%178 = call {i64, i64} @os.write_string(i32 %177, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$17, i64 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-38

if.else-37:
	; SelectorExpr
	%179 = load i32, i32* %0, align 4
	%180 = call {i64, i64} @os.write_string(i32 %179, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$18, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%181 = load i32, i32* %0, align 4
	; SelectorExpr
	%182 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %11, i64 0, i32 0
	%183 = load %runtime.Type_Info*, %runtime.Type_Info** %182, align 8
	call void @runtime.print_type(i32 %181, %runtime.Type_Info* %183, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-38

if.done-38:
	br label %typeswitch.done-119

typeswitch.next-39:
	%184 = icmp eq i8 %66, 15
	br i1 %184, label %typeswitch.body-54, label %typeswitch.next-53

typeswitch.body-40:
	%185 = bitcast %..rawptr %67 to %runtime.Type_Info_Procedure*
	%186 = load %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %185, align 8
	store %runtime.Type_Info_Procedure %186, %runtime.Type_Info_Procedure* %12
	; SelectorExpr
	%187 = load i32, i32* %0, align 4
	%188 = call {i64, i64} @os.write_string(i32 %187, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$19, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%189 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 0
	%190 = load %runtime.Type_Info*, %runtime.Type_Info** %189, align 8
	%191 = icmp eq %runtime.Type_Info* %190, zeroinitializer
	%192 = zext i1 %191 to i8
	%193 = trunc i8 %192 to i1
	br i1 %193, label %if.then-41, label %if.else-42

if.then-41:
	; SelectorExpr
	%194 = load i32, i32* %0, align 4
	%195 = call {i64, i64} @os.write_string(i32 %194, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1a, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-50

if.else-42:
	; t
	; SelectorExpr
	; SelectorExpr
	%196 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 0
	%197 = load %runtime.Type_Info*, %runtime.Type_Info** %196, align 8
	%198 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %197, i64 0
	%199 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %198, i64 0, i32 3
	%200 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %199, align 8
	; cast - union_cast
	%201 = bitcast {%runtime.Type_Info_Tuple, i8}* %14 to %..rawptr
	%202 = call %..rawptr @mem.zero(%..rawptr %201, i64 40) noinline
	store {%runtime.Type_Info_Tuple, i8} zeroinitializer, {%runtime.Type_Info_Tuple, i8}* %14
	%203 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %199, i64 0, i32 2 ; UnionTagPtr
	%204 = load i8, i8* %203, align 1
	%205 = icmp eq i8 %204, 15
	br i1 %205, label %union_cast.ok-43, label %union_cast.end-44

union_cast.ok-43:
	%206 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 0
	%207 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 1
	%208 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %199 to %runtime.Type_Info_Tuple*
	%209 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %208, align 8
	store %runtime.Type_Info_Tuple %209, %runtime.Type_Info_Tuple* %206
	store i8 1, i8* %207
	br label %union_cast.end-44

union_cast.end-44:
	%210 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 1
	%211 = load i8, i8* %210, align 1
	%212 = trunc i8 %211 to i1
	call void @runtime.type_assertion_check(i1 %212, %..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1b, i64 0, i32 0), i64 62}, i64 108, i64 21, %..typeid 1152921504606846991, %..typeid 3386706919782613033)
	%213 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 0
	%214 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %213, align 8
	store %runtime.Type_Info_Tuple %214, %runtime.Type_Info_Tuple* %13
	; SelectorExpr
	%215 = load i32, i32* %0, align 4
	%216 = call {i64, i64} @os.write_string(i32 %215, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$1c, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; t
	%217 = bitcast %runtime.Type_Info** %15 to %..rawptr
	%218 = call %..rawptr @mem.zero(%..rawptr %217, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %15
	; i
	%219 = bitcast i64* %16 to %..rawptr
	%220 = call %..rawptr @mem.zero(%..rawptr %219, i64 8) noinline
	store i64 zeroinitializer, i64* %16
	; SelectorExpr
	%221 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %13, i64 0, i32 0
	%222 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %221, align 8
	%223 = bitcast i64* %17 to %..rawptr
	%224 = call %..rawptr @mem.zero(%..rawptr %223, i64 8) noinline
	store i64 zeroinitializer, i64* %17
	%225 = extractvalue {%runtime.Type_Info**, i64} %222, 1
	store i64 %225, i64* %17
	%226 = bitcast i64* %18 to %..rawptr
	%227 = call %..rawptr @mem.zero(%..rawptr %226, i64 8) noinline
	store i64 zeroinitializer, i64* %18
	store i64 -1, i64* %18
	br label %for.index.loop-45

for.index.loop-45:
	%228 = load i64, i64* %18, align 8
	%229 = add i64 %228, 1
	store i64 %229, i64* %18
	%230 = load i64, i64* %17, align 8
	%231 = icmp slt i64 %229, %230
	br i1 %231, label %for.index.body-46, label %for.index.done-49

for.index.body-46:
	%232 = load i64, i64* %18, align 8
	%233 = extractvalue {%runtime.Type_Info**, i64} %222, 0
	%234 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %233, i64 %232
	%235 = load %runtime.Type_Info*, %runtime.Type_Info** %234, align 8
	store %runtime.Type_Info* %235, %runtime.Type_Info** %15
	store i64 %232, i64* %16
	; IfStmt
	%236 = load i64, i64* %16, align 8
	%237 = icmp sgt i64 %236, 0
	%238 = zext i1 %237 to i8
	%239 = trunc i8 %238 to i1
	br i1 %239, label %if.then-47, label %if.done-48

if.then-47:
	; SelectorExpr
	%240 = load i32, i32* %0, align 4
	%241 = call {i64, i64} @os.write_string(i32 %240, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1d, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-48

if.done-48:
	%242 = load i32, i32* %0, align 4
	%243 = load %runtime.Type_Info*, %runtime.Type_Info** %15, align 8
	call void @runtime.print_type(i32 %242, %runtime.Type_Info* %243, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-45

for.index.done-49:
	; SelectorExpr
	%244 = load i32, i32* %0, align 4
	%245 = call {i64, i64} @os.write_string(i32 %244, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$1e, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-50

if.done-50:
	; IfStmt
	; SelectorExpr
	%246 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 1
	%247 = load %runtime.Type_Info*, %runtime.Type_Info** %246, align 8
	%248 = icmp ne %runtime.Type_Info* %247, zeroinitializer
	%249 = zext i1 %248 to i8
	%250 = trunc i8 %249 to i1
	br i1 %250, label %if.then-51, label %if.done-52

if.then-51:
	; SelectorExpr
	%251 = load i32, i32* %0, align 4
	%252 = call {i64, i64} @os.write_string(i32 %251, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$1f, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%253 = load i32, i32* %0, align 4
	; SelectorExpr
	%254 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 1
	%255 = load %runtime.Type_Info*, %runtime.Type_Info** %254, align 8
	call void @runtime.print_type(i32 %253, %runtime.Type_Info* %255, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-52

if.done-52:
	br label %typeswitch.done-119

typeswitch.next-53:
	%256 = icmp eq i8 %66, 12
	br i1 %256, label %typeswitch.body-67, label %typeswitch.next-66

typeswitch.body-54:
	%257 = bitcast %..rawptr %67 to %runtime.Type_Info_Tuple*
	%258 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %257, align 8
	store %runtime.Type_Info_Tuple %258, %runtime.Type_Info_Tuple* %19
	; count
	; SelectorExpr
	%259 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %19, i64 0, i32 1
	%260 = load {%..string*, i64}, {%..string*, i64}* %259, align 8
	%261 = extractvalue {%..string*, i64} %260, 1
	store i64 %261, i64* %20
	; IfStmt
	%262 = load i64, i64* %20, align 8
	%263 = icmp ne i64 %262, 1
	%264 = zext i1 %263 to i8
	%265 = trunc i8 %264 to i1
	br i1 %265, label %if.then-55, label %if.done-56

if.then-55:
	; SelectorExpr
	%266 = load i32, i32* %0, align 4
	%267 = call {i64, i64} @os.write_string(i32 %266, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$20, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-56

if.done-56:
	; RangeStmt
	; name
	%268 = bitcast %..string* %21 to %..rawptr
	%269 = call %..rawptr @mem.zero(%..rawptr %268, i64 16) noinline
	store %..string zeroinitializer, %..string* %21
	; i
	%270 = bitcast i64* %22 to %..rawptr
	%271 = call %..rawptr @mem.zero(%..rawptr %270, i64 8) noinline
	store i64 zeroinitializer, i64* %22
	; SelectorExpr
	%272 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %19, i64 0, i32 1
	%273 = load {%..string*, i64}, {%..string*, i64}* %272, align 8
	%274 = bitcast i64* %23 to %..rawptr
	%275 = call %..rawptr @mem.zero(%..rawptr %274, i64 8) noinline
	store i64 zeroinitializer, i64* %23
	%276 = extractvalue {%..string*, i64} %273, 1
	store i64 %276, i64* %23
	%277 = bitcast i64* %24 to %..rawptr
	%278 = call %..rawptr @mem.zero(%..rawptr %277, i64 8) noinline
	store i64 zeroinitializer, i64* %24
	store i64 -1, i64* %24
	br label %for.index.loop-57

for.index.loop-57:
	%279 = load i64, i64* %24, align 8
	%280 = add i64 %279, 1
	store i64 %280, i64* %24
	%281 = load i64, i64* %23, align 8
	%282 = icmp slt i64 %280, %281
	br i1 %282, label %for.index.body-58, label %for.index.done-63

for.index.body-58:
	%283 = load i64, i64* %24, align 8
	%284 = extractvalue {%..string*, i64} %273, 0
	%285 = getelementptr inbounds %..string, %..string* %284, i64 %283
	%286 = load %..string, %..string* %285, align 8
	store %..string %286, %..string* %21
	store i64 %283, i64* %22
	; IfStmt
	%287 = load i64, i64* %22, align 8
	%288 = icmp sgt i64 %287, 0
	%289 = zext i1 %288 to i8
	%290 = trunc i8 %289 to i1
	br i1 %290, label %if.then-59, label %if.done-60

if.then-59:
	; SelectorExpr
	%291 = load i32, i32* %0, align 4
	%292 = call {i64, i64} @os.write_string(i32 %291, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$21, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-60

if.done-60:
	; t
	; IndexExpr
	; SelectorExpr
	%293 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %19, i64 0, i32 0
	%294 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %293, align 8
	%295 = extractvalue {%runtime.Type_Info**, i64} %294, 0
	%296 = load i64, i64* %22, align 8
	%297 = extractvalue {%runtime.Type_Info**, i64} %294, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$22, i64 0, i32 0), i64 62}, i64 126, i64 20, i64 %296, i64 %297)
	%298 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %295, i64 %296
	%299 = load %runtime.Type_Info*, %runtime.Type_Info** %298, align 8
	store %runtime.Type_Info* %299, %runtime.Type_Info** %25
	; IfStmt
	%300 = load %..string, %..string* %21, align 8
	%301 = extractvalue %..string %300, 1
	%302 = icmp sgt i64 %301, 0
	%303 = zext i1 %302 to i8
	%304 = trunc i8 %303 to i1
	br i1 %304, label %if.then-61, label %if.done-62

if.then-61:
	; SelectorExpr
	%305 = load i32, i32* %0, align 4
	%306 = load %..string, %..string* %21, align 8
	%307 = call {i64, i64} @os.write_string(i32 %305, %..string %306, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%308 = load i32, i32* %0, align 4
	%309 = call {i64, i64} @os.write_string(i32 %308, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$23, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-62

if.done-62:
	%310 = load i32, i32* %0, align 4
	%311 = load %runtime.Type_Info*, %runtime.Type_Info** %25, align 8
	call void @runtime.print_type(i32 %310, %runtime.Type_Info* %311, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-57

for.index.done-63:
	; IfStmt
	%312 = load i64, i64* %20, align 8
	%313 = icmp ne i64 %312, 1
	%314 = zext i1 %313 to i8
	%315 = trunc i8 %314 to i1
	br i1 %315, label %if.then-64, label %if.done-65

if.then-64:
	; SelectorExpr
	%316 = load i32, i32* %0, align 4
	%317 = call {i64, i64} @os.write_string(i32 %316, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$24, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-65

if.done-65:
	br label %typeswitch.done-119

typeswitch.next-66:
	%318 = icmp eq i8 %66, 13
	br i1 %318, label %typeswitch.body-69, label %typeswitch.next-68

typeswitch.body-67:
	%319 = bitcast %..rawptr %67 to %runtime.Type_Info_Array*
	%320 = load %runtime.Type_Info_Array, %runtime.Type_Info_Array* %319, align 8
	store %runtime.Type_Info_Array %320, %runtime.Type_Info_Array* %26
	; SelectorExpr
	%321 = load i32, i32* %0, align 4
	%322 = call {i64, i64} @os.write_string(i32 %321, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$25, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%323 = load i32, i32* %0, align 4
	; SelectorExpr
	%324 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %26, i64 0, i32 2
	%325 = load i64, i64* %324, align 8
	%326 = bitcast i64 %325 to i64
	call void @runtime.print_u64(i32 %323, i64 %326, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%327 = load i32, i32* %0, align 4
	%328 = call {i64, i64} @os.write_string(i32 %327, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$26, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%329 = load i32, i32* %0, align 4
	; SelectorExpr
	%330 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %26, i64 0, i32 0
	%331 = load %runtime.Type_Info*, %runtime.Type_Info** %330, align 8
	call void @runtime.print_type(i32 %329, %runtime.Type_Info* %331, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-68:
	%332 = icmp eq i8 %66, 14
	br i1 %332, label %typeswitch.body-71, label %typeswitch.next-70

typeswitch.body-69:
	%333 = bitcast %..rawptr %67 to %runtime.Type_Info_Dynamic_Array*
	%334 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %333, align 8
	store %runtime.Type_Info_Dynamic_Array %334, %runtime.Type_Info_Dynamic_Array* %27
	; SelectorExpr
	%335 = load i32, i32* %0, align 4
	%336 = call {i64, i64} @os.write_string(i32 %335, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$27, i64 0, i32 0), i64 9}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%337 = load i32, i32* %0, align 4
	; SelectorExpr
	%338 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %27, i64 0, i32 0
	%339 = load %runtime.Type_Info*, %runtime.Type_Info** %338, align 8
	call void @runtime.print_type(i32 %337, %runtime.Type_Info* %339, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-70:
	%340 = icmp eq i8 %66, 19
	br i1 %340, label %typeswitch.body-73, label %typeswitch.next-72

typeswitch.body-71:
	%341 = bitcast %..rawptr %67 to %runtime.Type_Info_Slice*
	%342 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %341, align 8
	store %runtime.Type_Info_Slice %342, %runtime.Type_Info_Slice* %28
	; SelectorExpr
	%343 = load i32, i32* %0, align 4
	%344 = call {i64, i64} @os.write_string(i32 %343, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$28, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%345 = load i32, i32* %0, align 4
	; SelectorExpr
	%346 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %28, i64 0, i32 0
	%347 = load %runtime.Type_Info*, %runtime.Type_Info** %346, align 8
	call void @runtime.print_type(i32 %345, %runtime.Type_Info* %347, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-72:
	%348 = icmp eq i8 %66, 16
	br i1 %348, label %typeswitch.body-75, label %typeswitch.next-74

typeswitch.body-73:
	%349 = bitcast %..rawptr %67 to %runtime.Type_Info_Map*
	%350 = load %runtime.Type_Info_Map, %runtime.Type_Info_Map* %349, align 8
	store %runtime.Type_Info_Map %350, %runtime.Type_Info_Map* %29
	; SelectorExpr
	%351 = load i32, i32* %0, align 4
	%352 = call {i64, i64} @os.write_string(i32 %351, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$29, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%353 = load i32, i32* %0, align 4
	; SelectorExpr
	%354 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %29, i64 0, i32 0
	%355 = load %runtime.Type_Info*, %runtime.Type_Info** %354, align 8
	call void @runtime.print_type(i32 %353, %runtime.Type_Info* %355, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%356 = load i32, i32* %0, align 4
	%357 = call {i64, i64} @os.write_byte(i32 %356, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%358 = load i32, i32* %0, align 4
	; SelectorExpr
	%359 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %29, i64 0, i32 1
	%360 = load %runtime.Type_Info*, %runtime.Type_Info** %359, align 8
	call void @runtime.print_type(i32 %358, %runtime.Type_Info* %360, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-74:
	%361 = icmp eq i8 %66, 17
	br i1 %361, label %typeswitch.body-88, label %typeswitch.next-87

typeswitch.body-75:
	%362 = bitcast %..rawptr %67 to %runtime.Type_Info_Struct*
	%363 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %362, align 8
	store %runtime.Type_Info_Struct %363, %runtime.Type_Info_Struct* %30
	; SelectorExpr
	%364 = load i32, i32* %0, align 4
	%365 = call {i64, i64} @os.write_string(i32 %364, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$2a, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%366 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 4
	%367 = load i8, i8* %366, align 1
	%368 = trunc i8 %367 to i1
	br i1 %368, label %if.then-76, label %if.done-77

if.then-76:
	; SelectorExpr
	%369 = load i32, i32* %0, align 4
	%370 = call {i64, i64} @os.write_string(i32 %369, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$2b, i64 0, i32 0), i64 8}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-77

if.done-77:
	; IfStmt
	; SelectorExpr
	%371 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 5
	%372 = load i8, i8* %371, align 1
	%373 = trunc i8 %372 to i1
	br i1 %373, label %if.then-78, label %if.done-79

if.then-78:
	; SelectorExpr
	%374 = load i32, i32* %0, align 4
	%375 = call {i64, i64} @os.write_string(i32 %374, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$2c, i64 0, i32 0), i64 11}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-79

if.done-79:
	; IfStmt
	; SelectorExpr
	%376 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 6
	%377 = load i8, i8* %376, align 1
	%378 = trunc i8 %377 to i1
	br i1 %378, label %if.then-80, label %if.done-81

if.then-80:
	; SelectorExpr
	%379 = load i32, i32* %0, align 4
	%380 = call {i64, i64} @os.write_string(i32 %379, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$2d, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%381 = load i32, i32* %0, align 4
	; SelectorExpr
	%382 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%383 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %382, i64 0
	%384 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %383, i64 0, i32 1
	%385 = load i64, i64* %384, align 8
	%386 = bitcast i64 %385 to i64
	call void @runtime.print_u64(i32 %381, i64 %386, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%387 = load i32, i32* %0, align 4
	%388 = call {i64, i64} @os.write_byte(i32 %387, i8 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-81

if.done-81:
	; SelectorExpr
	%389 = load i32, i32* %0, align 4
	%390 = call {i64, i64} @os.write_byte(i32 %389, i8 123, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; name
	%391 = bitcast %..string* %31 to %..rawptr
	%392 = call %..rawptr @mem.zero(%..rawptr %391, i64 16) noinline
	store %..string zeroinitializer, %..string* %31
	; i
	%393 = bitcast i64* %32 to %..rawptr
	%394 = call %..rawptr @mem.zero(%..rawptr %393, i64 8) noinline
	store i64 zeroinitializer, i64* %32
	; SelectorExpr
	%395 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 1
	%396 = load {%..string*, i64}, {%..string*, i64}* %395, align 8
	%397 = bitcast i64* %33 to %..rawptr
	%398 = call %..rawptr @mem.zero(%..rawptr %397, i64 8) noinline
	store i64 zeroinitializer, i64* %33
	%399 = extractvalue {%..string*, i64} %396, 1
	store i64 %399, i64* %33
	%400 = bitcast i64* %34 to %..rawptr
	%401 = call %..rawptr @mem.zero(%..rawptr %400, i64 8) noinline
	store i64 zeroinitializer, i64* %34
	store i64 -1, i64* %34
	br label %for.index.loop-82

for.index.loop-82:
	%402 = load i64, i64* %34, align 8
	%403 = add i64 %402, 1
	store i64 %403, i64* %34
	%404 = load i64, i64* %33, align 8
	%405 = icmp slt i64 %403, %404
	br i1 %405, label %for.index.body-83, label %for.index.done-86

for.index.body-83:
	%406 = load i64, i64* %34, align 8
	%407 = extractvalue {%..string*, i64} %396, 0
	%408 = getelementptr inbounds %..string, %..string* %407, i64 %406
	%409 = load %..string, %..string* %408, align 8
	store %..string %409, %..string* %31
	store i64 %406, i64* %32
	; IfStmt
	%410 = load i64, i64* %32, align 8
	%411 = icmp sgt i64 %410, 0
	%412 = zext i1 %411 to i8
	%413 = trunc i8 %412 to i1
	br i1 %413, label %if.then-84, label %if.done-85

if.then-84:
	; SelectorExpr
	%414 = load i32, i32* %0, align 4
	%415 = call {i64, i64} @os.write_string(i32 %414, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$2e, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-85

if.done-85:
	; SelectorExpr
	%416 = load i32, i32* %0, align 4
	%417 = load %..string, %..string* %31, align 8
	%418 = call {i64, i64} @os.write_string(i32 %416, %..string %417, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%419 = load i32, i32* %0, align 4
	%420 = call {i64, i64} @os.write_string(i32 %419, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$2f, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%421 = load i32, i32* %0, align 4
	; IndexExpr
	; SelectorExpr
	%422 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 0
	%423 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %422, align 8
	%424 = extractvalue {%runtime.Type_Info**, i64} %423, 0
	%425 = load i64, i64* %32, align 8
	%426 = extractvalue {%runtime.Type_Info**, i64} %423, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$30, i64 0, i32 0), i64 62}, i64 168, i64 30, i64 %425, i64 %426)
	%427 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %424, i64 %425
	%428 = load %runtime.Type_Info*, %runtime.Type_Info** %427, align 8
	call void @runtime.print_type(i32 %421, %runtime.Type_Info* %428, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-82

for.index.done-86:
	; SelectorExpr
	%429 = load i32, i32* %0, align 4
	%430 = call {i64, i64} @os.write_byte(i32 %429, i8 125, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-87:
	%431 = icmp eq i8 %66, 18
	br i1 %431, label %typeswitch.body-95, label %typeswitch.next-94

typeswitch.body-88:
	%432 = bitcast %..rawptr %67 to %runtime.Type_Info_Union*
	%433 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %432, align 8
	store %runtime.Type_Info_Union %433, %runtime.Type_Info_Union* %35
	; SelectorExpr
	%434 = load i32, i32* %0, align 4
	%435 = call {i64, i64} @os.write_string(i32 %434, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$31, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; variant
	%436 = bitcast %runtime.Type_Info** %36 to %..rawptr
	%437 = call %..rawptr @mem.zero(%..rawptr %436, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %36
	; i
	%438 = bitcast i64* %37 to %..rawptr
	%439 = call %..rawptr @mem.zero(%..rawptr %438, i64 8) noinline
	store i64 zeroinitializer, i64* %37
	; SelectorExpr
	%440 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %35, i64 0, i32 0
	%441 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %440, align 8
	%442 = bitcast i64* %38 to %..rawptr
	%443 = call %..rawptr @mem.zero(%..rawptr %442, i64 8) noinline
	store i64 zeroinitializer, i64* %38
	%444 = extractvalue {%runtime.Type_Info**, i64} %441, 1
	store i64 %444, i64* %38
	%445 = bitcast i64* %39 to %..rawptr
	%446 = call %..rawptr @mem.zero(%..rawptr %445, i64 8) noinline
	store i64 zeroinitializer, i64* %39
	store i64 -1, i64* %39
	br label %for.index.loop-89

for.index.loop-89:
	%447 = load i64, i64* %39, align 8
	%448 = add i64 %447, 1
	store i64 %448, i64* %39
	%449 = load i64, i64* %38, align 8
	%450 = icmp slt i64 %448, %449
	br i1 %450, label %for.index.body-90, label %for.index.done-93

for.index.body-90:
	%451 = load i64, i64* %39, align 8
	%452 = extractvalue {%runtime.Type_Info**, i64} %441, 0
	%453 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %452, i64 %451
	%454 = load %runtime.Type_Info*, %runtime.Type_Info** %453, align 8
	store %runtime.Type_Info* %454, %runtime.Type_Info** %36
	store i64 %451, i64* %37
	; IfStmt
	%455 = load i64, i64* %37, align 8
	%456 = icmp sgt i64 %455, 0
	%457 = zext i1 %456 to i8
	%458 = trunc i8 %457 to i1
	br i1 %458, label %if.then-91, label %if.done-92

if.then-91:
	; SelectorExpr
	%459 = load i32, i32* %0, align 4
	%460 = call {i64, i64} @os.write_string(i32 %459, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$32, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-92

if.done-92:
	%461 = load i32, i32* %0, align 4
	%462 = load %runtime.Type_Info*, %runtime.Type_Info** %36, align 8
	call void @runtime.print_type(i32 %461, %runtime.Type_Info* %462, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-89

for.index.done-93:
	; SelectorExpr
	%463 = load i32, i32* %0, align 4
	%464 = call {i64, i64} @os.write_string(i32 %463, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$33, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-94:
	%465 = icmp eq i8 %66, 20
	br i1 %465, label %typeswitch.body-102, label %typeswitch.next-101

typeswitch.body-95:
	%466 = bitcast %..rawptr %67 to %runtime.Type_Info_Enum*
	%467 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %466, align 8
	store %runtime.Type_Info_Enum %467, %runtime.Type_Info_Enum* %40
	; SelectorExpr
	%468 = load i32, i32* %0, align 4
	%469 = call {i64, i64} @os.write_string(i32 %468, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$34, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%470 = load i32, i32* %0, align 4
	; SelectorExpr
	%471 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %40, i64 0, i32 0
	%472 = load %runtime.Type_Info*, %runtime.Type_Info** %471, align 8
	call void @runtime.print_type(i32 %470, %runtime.Type_Info* %472, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%473 = load i32, i32* %0, align 4
	%474 = call {i64, i64} @os.write_string(i32 %473, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$35, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; name
	%475 = bitcast %..string* %41 to %..rawptr
	%476 = call %..rawptr @mem.zero(%..rawptr %475, i64 16) noinline
	store %..string zeroinitializer, %..string* %41
	; i
	%477 = bitcast i64* %42 to %..rawptr
	%478 = call %..rawptr @mem.zero(%..rawptr %477, i64 8) noinline
	store i64 zeroinitializer, i64* %42
	; SelectorExpr
	%479 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %40, i64 0, i32 1
	%480 = load {%..string*, i64}, {%..string*, i64}* %479, align 8
	%481 = bitcast i64* %43 to %..rawptr
	%482 = call %..rawptr @mem.zero(%..rawptr %481, i64 8) noinline
	store i64 zeroinitializer, i64* %43
	%483 = extractvalue {%..string*, i64} %480, 1
	store i64 %483, i64* %43
	%484 = bitcast i64* %44 to %..rawptr
	%485 = call %..rawptr @mem.zero(%..rawptr %484, i64 8) noinline
	store i64 zeroinitializer, i64* %44
	store i64 -1, i64* %44
	br label %for.index.loop-96

for.index.loop-96:
	%486 = load i64, i64* %44, align 8
	%487 = add i64 %486, 1
	store i64 %487, i64* %44
	%488 = load i64, i64* %43, align 8
	%489 = icmp slt i64 %487, %488
	br i1 %489, label %for.index.body-97, label %for.index.done-100

for.index.body-97:
	%490 = load i64, i64* %44, align 8
	%491 = extractvalue {%..string*, i64} %480, 0
	%492 = getelementptr inbounds %..string, %..string* %491, i64 %490
	%493 = load %..string, %..string* %492, align 8
	store %..string %493, %..string* %41
	store i64 %490, i64* %42
	; IfStmt
	%494 = load i64, i64* %42, align 8
	%495 = icmp sgt i64 %494, 0
	%496 = zext i1 %495 to i8
	%497 = trunc i8 %496 to i1
	br i1 %497, label %if.then-98, label %if.done-99

if.then-98:
	; SelectorExpr
	%498 = load i32, i32* %0, align 4
	%499 = call {i64, i64} @os.write_string(i32 %498, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$36, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-99

if.done-99:
	; SelectorExpr
	%500 = load i32, i32* %0, align 4
	%501 = load %..string, %..string* %41, align 8
	%502 = call {i64, i64} @os.write_string(i32 %500, %..string %501, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-96

for.index.done-100:
	; SelectorExpr
	%503 = load i32, i32* %0, align 4
	%504 = call {i64, i64} @os.write_string(i32 %503, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$37, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-101:
	%505 = icmp eq i8 %66, 21
	br i1 %505, label %typeswitch.body-111, label %typeswitch.next-110

typeswitch.body-102:
	%506 = bitcast %..rawptr %67 to %runtime.Type_Info_Bit_Field*
	%507 = load %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %506, align 8
	store %runtime.Type_Info_Bit_Field %507, %runtime.Type_Info_Bit_Field* %45
	; SelectorExpr
	%508 = load i32, i32* %0, align 4
	%509 = call {i64, i64} @os.write_string(i32 %508, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$38, i64 0, i32 0), i64 10}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%510 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%511 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %510, i64 0
	%512 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %511, i64 0, i32 1
	%513 = load i64, i64* %512, align 8
	%514 = icmp ne i64 %513, 1
	%515 = zext i1 %514 to i8
	%516 = trunc i8 %515 to i1
	br i1 %516, label %if.then-103, label %if.done-104

if.then-103:
	; SelectorExpr
	%517 = load i32, i32* %0, align 4
	%518 = call {i64, i64} @os.write_string(i32 %517, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$39, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%519 = load i32, i32* %0, align 4
	; SelectorExpr
	%520 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%521 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %520, i64 0
	%522 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %521, i64 0, i32 1
	%523 = load i64, i64* %522, align 8
	%524 = bitcast i64 %523 to i64
	call void @runtime.print_u64(i32 %519, i64 %524, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%525 = load i32, i32* %0, align 4
	%526 = call {i64, i64} @os.write_byte(i32 %525, i8 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-104

if.done-104:
	; SelectorExpr
	%527 = load i32, i32* %0, align 4
	%528 = call {i64, i64} @os.write_string(i32 %527, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$3a, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; name
	%529 = bitcast %..string* %46 to %..rawptr
	%530 = call %..rawptr @mem.zero(%..rawptr %529, i64 16) noinline
	store %..string zeroinitializer, %..string* %46
	; i
	%531 = bitcast i64* %47 to %..rawptr
	%532 = call %..rawptr @mem.zero(%..rawptr %531, i64 8) noinline
	store i64 zeroinitializer, i64* %47
	; SelectorExpr
	%533 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %45, i64 0, i32 0
	%534 = load {%..string*, i64}, {%..string*, i64}* %533, align 8
	%535 = bitcast i64* %48 to %..rawptr
	%536 = call %..rawptr @mem.zero(%..rawptr %535, i64 8) noinline
	store i64 zeroinitializer, i64* %48
	%537 = extractvalue {%..string*, i64} %534, 1
	store i64 %537, i64* %48
	%538 = bitcast i64* %49 to %..rawptr
	%539 = call %..rawptr @mem.zero(%..rawptr %538, i64 8) noinline
	store i64 zeroinitializer, i64* %49
	store i64 -1, i64* %49
	br label %for.index.loop-105

for.index.loop-105:
	%540 = load i64, i64* %49, align 8
	%541 = add i64 %540, 1
	store i64 %541, i64* %49
	%542 = load i64, i64* %48, align 8
	%543 = icmp slt i64 %541, %542
	br i1 %543, label %for.index.body-106, label %for.index.done-109

for.index.body-106:
	%544 = load i64, i64* %49, align 8
	%545 = extractvalue {%..string*, i64} %534, 0
	%546 = getelementptr inbounds %..string, %..string* %545, i64 %544
	%547 = load %..string, %..string* %546, align 8
	store %..string %547, %..string* %46
	store i64 %544, i64* %47
	; IfStmt
	%548 = load i64, i64* %47, align 8
	%549 = icmp sgt i64 %548, 0
	%550 = zext i1 %549 to i8
	%551 = trunc i8 %550 to i1
	br i1 %551, label %if.then-107, label %if.done-108

if.then-107:
	; SelectorExpr
	%552 = load i32, i32* %0, align 4
	%553 = call {i64, i64} @os.write_string(i32 %552, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$3b, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-108

if.done-108:
	; SelectorExpr
	%554 = load i32, i32* %0, align 4
	%555 = load %..string, %..string* %46, align 8
	%556 = call {i64, i64} @os.write_string(i32 %554, %..string %555, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%557 = load i32, i32* %0, align 4
	%558 = call {i64, i64} @os.write_string(i32 %557, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$3c, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%559 = load i32, i32* %0, align 4
	; IndexExpr
	; SelectorExpr
	%560 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %45, i64 0, i32 1
	%561 = load {i32*, i64}, {i32*, i64}* %560, align 8
	%562 = extractvalue {i32*, i64} %561, 0
	%563 = load i64, i64* %47, align 8
	%564 = extractvalue {i32*, i64} %561, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$3d, i64 0, i32 0), i64 62}, i64 202, i64 32, i64 %563, i64 %564)
	%565 = getelementptr inbounds i32, i32* %562, i64 %563
	%566 = load i32, i32* %565, align 4
	%567 = sext i32 %566 to i64
	call void @runtime.print_u64(i32 %559, i64 %567, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-105

for.index.done-109:
	; SelectorExpr
	%568 = load i32, i32* %0, align 4
	%569 = call {i64, i64} @os.write_string(i32 %568, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$3e, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-110:
	br label %typeswitch.done-119

typeswitch.body-111:
	%570 = bitcast %..rawptr %67 to %runtime.Type_Info_Bit_Set*
	%571 = load %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %570, align 8
	store %runtime.Type_Info_Bit_Set %571, %runtime.Type_Info_Bit_Set* %50
	; SelectorExpr
	%572 = load i32, i32* %0, align 4
	%573 = call {i64, i64} @os.write_string(i32 %572, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$3f, i64 0, i32 0), i64 8}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; TypeSwitchStmt
	; SelectorExpr
	; SelectorExpr
	%574 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 0
	%575 = load %runtime.Type_Info*, %runtime.Type_Info** %574, align 8
	%576 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %575)
	%577 = bitcast %runtime.Type_Info** %51 to %..rawptr
	%578 = call %..rawptr @mem.zero(%..rawptr %577, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %51
	store %runtime.Type_Info* %576, %runtime.Type_Info** %51
	%579 = load %runtime.Type_Info*, %runtime.Type_Info** %51, align 8
	%580 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %579, i64 0
	%581 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %580, i64 0, i32 3
	%582 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %581, align 8
	; get union's tag
	%583 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %581, i64 0, i32 2 ; UnionTagPtr
	%584 = load i8, i8* %583, align 1
	%585 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %581 to %..rawptr
	%586 = icmp eq i8 %584, 18
	br i1 %586, label %typeswitch.body-113, label %typeswitch.next-112

typeswitch.next-112:
	%587 = icmp eq i8 %584, 3
	br i1 %587, label %typeswitch.body-115, label %typeswitch.next-114

typeswitch.body-113:
	%588 = bitcast %..rawptr %585 to %runtime.Type_Info_Enum*
	%589 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %588, align 8
	store %runtime.Type_Info_Enum %589, %runtime.Type_Info_Enum* %52
	%590 = load i32, i32* %0, align 4
	; SelectorExpr
	%591 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 0
	%592 = load %runtime.Type_Info*, %runtime.Type_Info** %591, align 8
	call void @runtime.print_type(i32 %590, %runtime.Type_Info* %592, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-116

typeswitch.next-114:
	store {[0 x <8 x i8>], [72 x i8], i8} %582, {[0 x <8 x i8>], [72 x i8], i8}* %54
	%593 = load i32, i32* %0, align 4
	; SelectorExpr
	%594 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 2
	%595 = load i64, i64* %594, align 8
	call void @runtime.print_i64(i32 %593, i64 %595, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%596 = load i32, i32* %0, align 4
	%597 = call {i64, i64} @os.write_string(i32 %596, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$40, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%598 = load i32, i32* %0, align 4
	; SelectorExpr
	%599 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 3
	%600 = load i64, i64* %599, align 8
	call void @runtime.print_i64(i32 %598, i64 %600, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-116

typeswitch.body-115:
	%601 = bitcast %..rawptr %585 to %runtime.Type_Info_Rune*
	%602 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %601, align 1
	store %runtime.Type_Info_Rune %602, %runtime.Type_Info_Rune* %53
	; SelectorExpr
	%603 = load i32, i32* %0, align 4
	; SelectorExpr
	%604 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 2
	%605 = load i64, i64* %604, align 8
	%606 = trunc i64 %605 to i32
	call void @os.write_encoded_rune(i32 %603, i32 %606, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%607 = load i32, i32* %0, align 4
	%608 = call {i64, i64} @os.write_string(i32 %607, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$41, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%609 = load i32, i32* %0, align 4
	; SelectorExpr
	%610 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 3
	%611 = load i64, i64* %610, align 8
	%612 = trunc i64 %611 to i32
	call void @os.write_encoded_rune(i32 %609, i32 %612, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-116

typeswitch.done-116:
	; IfStmt
	; SelectorExpr
	%613 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 1
	%614 = load %runtime.Type_Info*, %runtime.Type_Info** %613, align 8
	%615 = icmp ne %runtime.Type_Info* %614, zeroinitializer
	%616 = zext i1 %615 to i8
	%617 = trunc i8 %616 to i1
	br i1 %617, label %if.then-117, label %if.done-118

if.then-117:
	; SelectorExpr
	%618 = load i32, i32* %0, align 4
	%619 = call {i64, i64} @os.write_string(i32 %618, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$42, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%620 = load i32, i32* %0, align 4
	; SelectorExpr
	%621 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 1
	%622 = load %runtime.Type_Info*, %runtime.Type_Info** %621, align 8
	call void @runtime.print_type(i32 %620, %runtime.Type_Info* %622, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-118

if.done-118:
	; SelectorExpr
	%623 = load i32, i32* %0, align 4
	%624 = call {i64, i64} @os.write_byte(i32 %623, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.done-119:
	ret void
}

define i8 @runtime.string_eq(%..string %a, %..string %b) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	store %..string %a, %..string* %0
	store %..string %b, %..string* %1
	; SwitchStmt
	%2 = load %..string, %..string* %0, align 8
	%3 = extractvalue %..string %2, 1
	%4 = load %..string, %..string* %1, align 8
	%5 = extractvalue %..string %4, 1
	%6 = icmp ne i64 %3, %5
	%7 = zext i1 %6 to i8
	%8 = icmp eq i8 1, %7
	br i1 %8, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%9 = load %..string, %..string* %0, align 8
	%10 = extractvalue %..string %9, 1
	%11 = icmp eq i64 %10, 0
	%12 = zext i1 %11 to i8
	%13 = icmp eq i8 1, %12
	br i1 %13, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	; ReturnStmt
	ret i8 0

switch.case.next-3:
	; IndexExpr
	%14 = load %..string, %..string* %0, align 8
	%15 = extractvalue %..string %14, 0
	%16 = extractvalue %..string %14, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$43, i64 0, i32 0), i64 62}, i64 233, i64 10, i64 0, i64 %16)
	%17 = getelementptr inbounds i8, i8* %15, i64 0
	; IndexExpr
	%18 = load %..string, %..string* %1, align 8
	%19 = extractvalue %..string %18, 0
	%20 = extractvalue %..string %18, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$44, i64 0, i32 0), i64 62}, i64 233, i64 19, i64 0, i64 %20)
	%21 = getelementptr inbounds i8, i8* %19, i64 0
	%22 = icmp eq i8* %17, %21
	%23 = zext i1 %22 to i8
	%24 = icmp eq i8 1, %23
	br i1 %24, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	; ReturnStmt
	ret i8 1

switch.case.next-5:
	; ReturnStmt
	%25 = load %..string, %..string* %0, align 8
	%26 = load %..string, %..string* %1, align 8
	%27 = call i64 @runtime.string_cmp(%..string %25, %..string %26)
	%28 = icmp eq i64 %27, 0
	%29 = zext i1 %28 to i8
	ret i8 %29

switch.fall.body-6:
	; ReturnStmt
	ret i8 1
}

define i64 @runtime.string_cmp(%..string %a, %..string %b) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	store %..string %a, %..string* %0
	store %..string %b, %..string* %1
	; ReturnStmt
	; SelectorExpr
	; IndexExpr
	%2 = load %..string, %..string* %0, align 8
	%3 = extractvalue %..string %2, 0
	%4 = extractvalue %..string %2, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$45, i64 0, i32 0), i64 62}, i64 239, i64 34, i64 0, i64 %4)
	%5 = getelementptr inbounds i8, i8* %3, i64 0
	; IndexExpr
	%6 = load %..string, %..string* %1, align 8
	%7 = extractvalue %..string %6, 0
	%8 = extractvalue %..string %6, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$46, i64 0, i32 0), i64 62}, i64 239, i64 41, i64 0, i64 %8)
	%9 = getelementptr inbounds i8, i8* %7, i64 0
	; min
	%10 = load %..string, %..string* %0, align 8
	%11 = extractvalue %..string %10, 1
	%12 = load %..string, %..string* %1, align 8
	%13 = extractvalue %..string %12, 1
	%14 = icmp slt i64 %11, %13
	%15 = select i1 %14, i64 %11, i64 %13
	%16 = call i64 @mem.compare_byte_ptrs(i8* %5, i8* %9, i64 %15)
	ret i64 %16
}

define i8 @runtime.string_ne(%..string %a, %..string %b) alwaysinline #1 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	store %..string %a, %..string* %0
	store %..string %b, %..string* %1
	; ReturnStmt
	%2 = load %..string, %..string* %0, align 8
	%3 = load %..string, %..string* %1, align 8
	%4 = call i8 @runtime.string_eq(%..string %2, %..string %3) alwaysinline
	%5 = icmp eq i8 %4, 0
	%6 = zext i1 %5 to i8
	ret i8 %6
}

define i64 @runtime.cstring_len(i8* %s) #0 {
decls-0:
	%0 = alloca i8*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8*, align 16
	store i8* %s, i8** %0
	; n
	store i64 0, i64* %1
	; ForStmt
	; p
	%3 = load i8*, i8** %0, align 8
	%4 = bitcast i8* %3 to i8*
	store i8* %4, i8** %2
	br label %for.loop-1

for.loop-1:
	%5 = load i8*, i8** %2, align 8
	%6 = icmp ne i8* %5, zeroinitializer
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	br i1 %8, label %cmp.and-2, label %for.done-4

cmp.and-2:
	%9 = load i8*, i8** %2, align 8
	%10 = getelementptr inbounds i8, i8* %9, i64 0
	%11 = load i8, i8* %10, align 1
	%12 = icmp ne i8 %11, 0
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %for.body-3, label %for.done-4

for.body-3:
	; AssignStmt
	%15 = load i64, i64* %1, align 8
	%16 = add i64 %15, 1
	store i64 %16, i64* %1
	; AssignStmt
	; SelectorExpr
	%17 = load i8*, i8** %2, align 8
	%18 = call i8* @mem.ptr_offset-13926(i8* %17, i64 1)
	store i8* %18, i8** %2
	br label %for.loop-1

for.done-4:
	; ReturnStmt
	%19 = load i64, i64* %1, align 8
	ret i64 %19
}

define %..string @runtime.cstring_to_string(i8* %s) #0 {
decls-0:
	%0 = alloca i8*, align 16
	%1 = alloca i8*, align 16
	%2 = alloca i64, align 16
	%3 = alloca %mem.Raw_String, align 16
	store i8* %s, i8** %0
	; IfStmt
	%4 = load i8*, i8** %0, align 8
	%5 = bitcast i8* %4 to i8*
	%6 = bitcast %..rawptr null to i8*
	%7 = icmp eq i8* %5, %6
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	br i1 %9, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %..string zeroinitializer

if.done-2:
	; ptr
	%10 = load i8*, i8** %0, align 8
	%11 = bitcast i8* %10 to i8*
	store i8* %11, i8** %1
	; n
	%12 = load i8*, i8** %0, align 8
	%13 = call i64 @runtime.cstring_len(i8* %12)
	store i64 %13, i64* %2
	; ReturnStmt
	; CompoundLit
	%14 = bitcast %mem.Raw_String* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 16) noinline
	store %mem.Raw_String zeroinitializer, %mem.Raw_String* %3
	store %mem.Raw_String {i8* zeroinitializer, i64 zeroinitializer}, %mem.Raw_String* %3
	%16 = load i8*, i8** %1, align 8
	%17 = getelementptr inbounds %mem.Raw_String, %mem.Raw_String* %3, i64 0, i32 0
	store i8* %16, i8** %17
	%18 = load i64, i64* %2, align 8
	%19 = getelementptr inbounds %mem.Raw_String, %mem.Raw_String* %3, i64 0, i32 1
	store i64 %18, i64* %19
	%20 = load %mem.Raw_String, %mem.Raw_String* %3, align 8
	%21 = bitcast %mem.Raw_String* %3 to %..string*
	%22 = load %..string, %..string* %21, align 8
	ret %..string %22
}

define void @runtime.bounds_check_error(%..string %file, i64 %line, i64 %column, i64 %index, i64 %count) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i32, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca %runtime.Context, align 16
	%8 = bitcast %runtime.Context* %7 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %7
	%10 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %10, %runtime.Context* %7
	call void @runtime.__init_context(%runtime.Context* %7)
	%11 = alloca %runtime.Source_Code_Location, align 16
	store %..string %file, %..string* %0
	store i64 %line, i64* %1
	store i64 %column, i64* %2
	store i64 %index, i64* %3
	store i64 %count, i64* %4
	; IfStmt
	%12 = load i64, i64* %3, align 8
	%13 = icmp sle i64 0, %12
	%14 = zext i1 %13 to i8
	%15 = trunc i8 %14 to i1
	br i1 %15, label %cmp.and-1, label %if.done-3

cmp.and-1:
	%16 = load i64, i64* %3, align 8
	%17 = load i64, i64* %4, align 8
	%18 = icmp slt i64 %16, %17
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	; fd
	; SelectorExpr
	%21 = load i32, i32* @os.stderr, align 4
	store i32 %21, i32* %5
	%22 = load i32, i32* %5, align 4
	; CompoundLit
	%23 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %..string zeroinitializer}, %runtime.Source_Code_Location* %6
	%25 = load %..string, %..string* %0, align 8
	%26 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %6, i64 0, i32 0
	store %..string %25, %..string* %26
	%27 = load i64, i64* %1, align 8
	%28 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %6, i64 0, i32 1
	store i64 %27, i64* %28
	%29 = load i64, i64* %2, align 8
	%30 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %6, i64 0, i32 2
	store i64 %29, i64* %30
	%31 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %6, align 8
	%32 = bitcast %runtime.Source_Code_Location* %11 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %11
	store %runtime.Source_Code_Location %31, %runtime.Source_Code_Location* %11
	call void @runtime.print_caller_location(i32 %22, %runtime.Source_Code_Location* %11, %runtime.Context* noalias nonnull nocapture inreg %7)
	; SelectorExpr
	%34 = load i32, i32* %5, align 4
	%35 = call {i64, i64} @os.write_string(i32 %34, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$47, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %7)
	%36 = load i32, i32* %5, align 4
	%37 = load i64, i64* %3, align 8
	%38 = bitcast i64 %37 to i64
	call void @runtime.print_i64(i32 %36, i64 %38, %runtime.Context* noalias nonnull nocapture inreg %7)
	; SelectorExpr
	%39 = load i32, i32* %5, align 4
	%40 = call {i64, i64} @os.write_string(i32 %39, %..string {i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$48, i64 0, i32 0), i64 26}, %runtime.Context* noalias nonnull nocapture inreg %7)
	%41 = load i32, i32* %5, align 4
	%42 = load i64, i64* %4, align 8
	%43 = bitcast i64 %42 to i64
	call void @runtime.print_i64(i32 %41, i64 %43, %runtime.Context* noalias nonnull nocapture inreg %7)
	; SelectorExpr
	%44 = load i32, i32* %5, align 4
	%45 = call {i64, i64} @os.write_byte(i32 %44, i8 10, %runtime.Context* noalias nonnull nocapture inreg %7)
	call ccc void @llvm.debugtrap()
	ret void
}

define void @runtime.slice_expr_error(%..string %file, i64 %line, i64 %column, i64 %lo, i64 %hi, i64 %len) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i32, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca %runtime.Context, align 16
	%9 = bitcast %runtime.Context* %8 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %8
	%11 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %11, %runtime.Context* %8
	call void @runtime.__init_context(%runtime.Context* %8)
	%12 = alloca %runtime.Source_Code_Location, align 16
	store %..string %file, %..string* %0
	store i64 %line, i64* %1
	store i64 %column, i64* %2
	store i64 %lo, i64* %3
	store i64 %hi, i64* %4
	store i64 %len, i64* %5
	; IfStmt
	%13 = load i64, i64* %3, align 8
	%14 = icmp sle i64 0, %13
	%15 = zext i1 %14 to i8
	%16 = trunc i8 %15 to i1
	br i1 %16, label %cmp.and-1, label %if.done-4

cmp.and-1:
	%17 = load i64, i64* %3, align 8
	%18 = load i64, i64* %4, align 8
	%19 = icmp sle i64 %17, %18
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %cmp.and-2, label %if.done-4

cmp.and-2:
	%22 = load i64, i64* %4, align 8
	%23 = load i64, i64* %5, align 8
	%24 = icmp sle i64 %22, %23
	%25 = zext i1 %24 to i8
	%26 = trunc i8 %25 to i1
	br i1 %26, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret void

if.done-4:
	; fd
	; SelectorExpr
	%27 = load i32, i32* @os.stderr, align 4
	store i32 %27, i32* %6
	%28 = load i32, i32* %6, align 4
	; CompoundLit
	%29 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %..string zeroinitializer}, %runtime.Source_Code_Location* %7
	%31 = load %..string, %..string* %0, align 8
	%32 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 0
	store %..string %31, %..string* %32
	%33 = load i64, i64* %1, align 8
	%34 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 1
	store i64 %33, i64* %34
	%35 = load i64, i64* %2, align 8
	%36 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 2
	store i64 %35, i64* %36
	%37 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, align 8
	%38 = bitcast %runtime.Source_Code_Location* %12 to %..rawptr
	%39 = call %..rawptr @mem.zero(%..rawptr %38, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %12
	store %runtime.Source_Code_Location %37, %runtime.Source_Code_Location* %12
	call void @runtime.print_caller_location(i32 %28, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%40 = load i32, i32* %6, align 4
	%41 = call {i64, i64} @os.write_string(i32 %40, %..string {i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$49, i64 0, i32 0), i64 24}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%42 = load i32, i32* %6, align 4
	%43 = load i64, i64* %3, align 8
	%44 = bitcast i64 %43 to i64
	call void @runtime.print_i64(i32 %42, i64 %44, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%45 = load i32, i32* %6, align 4
	%46 = call {i64, i64} @os.write_string(i32 %45, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$4a, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%47 = load i32, i32* %6, align 4
	%48 = load i64, i64* %4, align 8
	%49 = bitcast i64 %48 to i64
	call void @runtime.print_i64(i32 %47, i64 %49, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%50 = load i32, i32* %6, align 4
	%51 = call {i64, i64} @os.write_string(i32 %50, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$4b, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%52 = load i32, i32* %6, align 4
	%53 = load i64, i64* %5, align 8
	%54 = bitcast i64 %53 to i64
	call void @runtime.print_i64(i32 %52, i64 %54, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%55 = load i32, i32* %6, align 4
	%56 = call {i64, i64} @os.write_byte(i32 %55, i8 10, %runtime.Context* noalias nonnull nocapture inreg %8)
	call ccc void @llvm.debugtrap()
	ret void
}

define void @runtime.dynamic_array_expr_error(%..string %file, i64 %line, i64 %column, i64 %low, i64 %high, i64 %max) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i32, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca %runtime.Context, align 16
	%9 = bitcast %runtime.Context* %8 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %8
	%11 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %11, %runtime.Context* %8
	call void @runtime.__init_context(%runtime.Context* %8)
	%12 = alloca %runtime.Source_Code_Location, align 16
	store %..string %file, %..string* %0
	store i64 %line, i64* %1
	store i64 %column, i64* %2
	store i64 %low, i64* %3
	store i64 %high, i64* %4
	store i64 %max, i64* %5
	; IfStmt
	%13 = load i64, i64* %3, align 8
	%14 = icmp sle i64 0, %13
	%15 = zext i1 %14 to i8
	%16 = trunc i8 %15 to i1
	br i1 %16, label %cmp.and-1, label %if.done-4

cmp.and-1:
	%17 = load i64, i64* %3, align 8
	%18 = load i64, i64* %4, align 8
	%19 = icmp sle i64 %17, %18
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %cmp.and-2, label %if.done-4

cmp.and-2:
	%22 = load i64, i64* %4, align 8
	%23 = load i64, i64* %5, align 8
	%24 = icmp sle i64 %22, %23
	%25 = zext i1 %24 to i8
	%26 = trunc i8 %25 to i1
	br i1 %26, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret void

if.done-4:
	; fd
	; SelectorExpr
	%27 = load i32, i32* @os.stderr, align 4
	store i32 %27, i32* %6
	%28 = load i32, i32* %6, align 4
	; CompoundLit
	%29 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %..string zeroinitializer}, %runtime.Source_Code_Location* %7
	%31 = load %..string, %..string* %0, align 8
	%32 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 0
	store %..string %31, %..string* %32
	%33 = load i64, i64* %1, align 8
	%34 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 1
	store i64 %33, i64* %34
	%35 = load i64, i64* %2, align 8
	%36 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 2
	store i64 %35, i64* %36
	%37 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, align 8
	%38 = bitcast %runtime.Source_Code_Location* %12 to %..rawptr
	%39 = call %..rawptr @mem.zero(%..rawptr %38, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %12
	store %runtime.Source_Code_Location %37, %runtime.Source_Code_Location* %12
	call void @runtime.print_caller_location(i32 %28, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%40 = load i32, i32* %6, align 4
	%41 = call {i64, i64} @os.write_string(i32 %40, %..string {i8* getelementptr inbounds ([32 x i8], [32 x i8]* @str$4c, i64 0, i32 0), i64 31}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%42 = load i32, i32* %6, align 4
	%43 = load i64, i64* %3, align 8
	%44 = bitcast i64 %43 to i64
	call void @runtime.print_i64(i32 %42, i64 %44, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%45 = load i32, i32* %6, align 4
	%46 = call {i64, i64} @os.write_string(i32 %45, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$4d, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%47 = load i32, i32* %6, align 4
	%48 = load i64, i64* %4, align 8
	%49 = bitcast i64 %48 to i64
	call void @runtime.print_i64(i32 %47, i64 %49, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%50 = load i32, i32* %6, align 4
	%51 = call {i64, i64} @os.write_string(i32 %50, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$4e, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%52 = load i32, i32* %6, align 4
	%53 = load i64, i64* %5, align 8
	%54 = bitcast i64 %53 to i64
	call void @runtime.print_i64(i32 %52, i64 %54, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%55 = load i32, i32* %6, align 4
	%56 = call {i64, i64} @os.write_byte(i32 %55, i8 10, %runtime.Context* noalias nonnull nocapture inreg %8)
	call ccc void @llvm.debugtrap()
	ret void
}

define void @runtime.type_assertion_check(i1 %ok, %..string %file, i64 %line, i64 %column, %..typeid %from, %..typeid %to) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..typeid, align 16
	%5 = alloca %..typeid, align 16
	%6 = alloca i32, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca %runtime.Context, align 16
	%9 = bitcast %runtime.Context* %8 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %8
	%11 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %11, %runtime.Context* %8
	call void @runtime.__init_context(%runtime.Context* %8)
	%12 = alloca %runtime.Source_Code_Location, align 16
	%13 = zext i1 %ok to i8
	store i8 %13, i8* %0
	store %..string %file, %..string* %1
	store i64 %line, i64* %2
	store i64 %column, i64* %3
	store %..typeid %from, %..typeid* %4
	store %..typeid %to, %..typeid* %5
	; IfStmt
	%14 = load i8, i8* %0, align 1
	%15 = trunc i8 %14 to i1
	br i1 %15, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; fd
	; SelectorExpr
	%16 = load i32, i32* @os.stderr, align 4
	store i32 %16, i32* %6
	%17 = load i32, i32* %6, align 4
	; CompoundLit
	%18 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %..string zeroinitializer}, %runtime.Source_Code_Location* %7
	%20 = load %..string, %..string* %1, align 8
	%21 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 0
	store %..string %20, %..string* %21
	%22 = load i64, i64* %2, align 8
	%23 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 1
	store i64 %22, i64* %23
	%24 = load i64, i64* %3, align 8
	%25 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 2
	store i64 %24, i64* %25
	%26 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, align 8
	%27 = bitcast %runtime.Source_Code_Location* %12 to %..rawptr
	%28 = call %..rawptr @mem.zero(%..rawptr %27, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %12
	store %runtime.Source_Code_Location %26, %runtime.Source_Code_Location* %12
	call void @runtime.print_caller_location(i32 %17, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%29 = load i32, i32* %6, align 4
	%30 = call {i64, i64} @os.write_string(i32 %29, %..string {i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$4f, i64 0, i32 0), i64 29}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%31 = load i32, i32* %6, align 4
	%32 = load %..typeid, %..typeid* %4, align 8
	call void @runtime.print_typeid(i32 %31, %..typeid %32, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%33 = load i32, i32* %6, align 4
	%34 = call {i64, i64} @os.write_string(i32 %33, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$50, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%35 = load i32, i32* %6, align 4
	%36 = load %..typeid, %..typeid* %5, align 8
	call void @runtime.print_typeid(i32 %35, %..typeid %36, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%37 = load i32, i32* %6, align 4
	%38 = call {i64, i64} @os.write_byte(i32 %37, i8 10, %runtime.Context* noalias nonnull nocapture inreg %8)
	call ccc void @llvm.debugtrap()
	ret void
}

define void @runtime.make_slice_error_loc(%runtime.Source_Code_Location* %loc, i64 %len) alwaysinline #1 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i32, align 16
	%2 = alloca %runtime.Context, align 16
	%3 = bitcast %runtime.Context* %2 to %..rawptr
	%4 = call %..rawptr @mem.zero(%..rawptr %3, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %2
	%5 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %5, %runtime.Context* %2
	call void @runtime.__init_context(%runtime.Context* %2) alwaysinline
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	store i64 %len, i64* %0
	; IfStmt
	%8 = load i64, i64* %0, align 8
	%9 = icmp sle i64 0, %8
	%10 = zext i1 %9 to i8
	%11 = trunc i8 %10 to i1
	br i1 %11, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; fd
	; SelectorExpr
	%12 = load i32, i32* @os.stderr, align 4
	store i32 %12, i32* %1
	%13 = load i32, i32* %1, align 4
	%14 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%15 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location %14, %runtime.Source_Code_Location* %6
	call void @runtime.print_caller_location(i32 %13, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture inreg %2) alwaysinline
	; SelectorExpr
	%17 = load i32, i32* %1, align 4
	%18 = call {i64, i64} @os.write_string(i32 %17, %..string {i8* getelementptr inbounds ([33 x i8], [33 x i8]* @str$51, i64 0, i32 0), i64 32}, %runtime.Context* noalias nonnull nocapture inreg %2) alwaysinline
	%19 = load i32, i32* %1, align 4
	%20 = load i64, i64* %0, align 8
	%21 = bitcast i64 %20 to i64
	call void @runtime.print_i64(i32 %19, i64 %21, %runtime.Context* noalias nonnull nocapture inreg %2) alwaysinline
	; SelectorExpr
	%22 = load i32, i32* %1, align 4
	%23 = call {i64, i64} @os.write_byte(i32 %22, i8 10, %runtime.Context* noalias nonnull nocapture inreg %2) alwaysinline
	call ccc void @llvm.debugtrap() alwaysinline
	ret void
}

define void @runtime.make_dynamic_array_error_loc(%runtime.Source_Code_Location* %loc, i64 %len, i64 %cap) alwaysinline #1 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca i32, align 16
	%3 = alloca %runtime.Context, align 16
	%4 = bitcast %runtime.Context* %3 to %..rawptr
	%5 = call %..rawptr @mem.zero(%..rawptr %4, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %3
	%6 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %6, %runtime.Context* %3
	call void @runtime.__init_context(%runtime.Context* %3) alwaysinline
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	store i64 %len, i64* %0
	store i64 %cap, i64* %1
	; IfStmt
	%9 = load i64, i64* %0, align 8
	%10 = icmp sle i64 0, %9
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %cmp.and-1, label %if.done-3

cmp.and-1:
	%13 = load i64, i64* %0, align 8
	%14 = load i64, i64* %1, align 8
	%15 = icmp sle i64 %13, %14
	%16 = zext i1 %15 to i8
	%17 = trunc i8 %16 to i1
	br i1 %17, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	; fd
	; SelectorExpr
	%18 = load i32, i32* @os.stderr, align 4
	store i32 %18, i32* %2
	%19 = load i32, i32* %2, align 4
	%20 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%21 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location %20, %runtime.Source_Code_Location* %7
	call void @runtime.print_caller_location(i32 %19, %runtime.Source_Code_Location* %7, %runtime.Context* noalias nonnull nocapture inreg %3) alwaysinline
	; SelectorExpr
	%23 = load i32, i32* %2, align 4
	%24 = call {i64, i64} @os.write_string(i32 %23, %..string {i8* getelementptr inbounds ([45 x i8], [45 x i8]* @str$52, i64 0, i32 0), i64 44}, %runtime.Context* noalias nonnull nocapture inreg %3) alwaysinline
	%25 = load i32, i32* %2, align 4
	%26 = load i64, i64* %0, align 8
	%27 = bitcast i64 %26 to i64
	call void @runtime.print_i64(i32 %25, i64 %27, %runtime.Context* noalias nonnull nocapture inreg %3) alwaysinline
	; SelectorExpr
	%28 = load i32, i32* %2, align 4
	%29 = call {i64, i64} @os.write_byte(i32 %28, i8 58, %runtime.Context* noalias nonnull nocapture inreg %3) alwaysinline
	%30 = load i32, i32* %2, align 4
	%31 = load i64, i64* %1, align 8
	%32 = bitcast i64 %31 to i64
	call void @runtime.print_i64(i32 %30, i64 %32, %runtime.Context* noalias nonnull nocapture inreg %3) alwaysinline
	; SelectorExpr
	%33 = load i32, i32* %2, align 4
	%34 = call {i64, i64} @os.write_byte(i32 %33, i8 10, %runtime.Context* noalias nonnull nocapture inreg %3) alwaysinline
	call ccc void @llvm.debugtrap() alwaysinline
	ret void
}

define float @runtime.abs_f32(float %x) alwaysinline #1 {
decls-0:
	%0 = alloca float, align 16
	store float %x, float* %0
	; ReturnStmt
	%1 = load float, float* %0, align 4
	%2 = call ccc float @llvm.fabs.f32(float %1) alwaysinline
	ret float %2
}
declare ccc float @llvm.fabs.f32(float) #0 

define double @runtime.abs_f64(double %x) alwaysinline #1 {
decls-0:
	%0 = alloca double, align 16
	store double %x, double* %0
	; ReturnStmt
	%1 = load double, double* %0, align 8
	%2 = call ccc double @llvm.fabs.f64(double %1) alwaysinline
	ret double %2
}
declare ccc double @llvm.fabs.f64(double) #0 

define %..complex64 @runtime.quo_complex64(%..complex64 %n, %..complex64 %m, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..complex64, align 16
	%1 = alloca %..complex64, align 16
	%2 = alloca float, align 16
	%3 = alloca float, align 16
	%4 = alloca float, align 16
	%5 = alloca float, align 16
	%6 = alloca float, align 16
	%7 = alloca float, align 16
	%8 = alloca %..complex64, align 16
	store %..complex64 %n, %..complex64* %0
	store %..complex64 %m, %..complex64* %1
	; e
	%9 = bitcast float* %2 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 4) noinline
	store float zeroinitializer, float* %2
	; f
	%11 = bitcast float* %3 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 4) noinline
	store float zeroinitializer, float* %3
	; IfStmt
	; real
	%13 = load %..complex64, %..complex64* %1, align 4
	%14 = extractvalue %..complex64 %13, 0
	; abs
	%15 = call float @runtime.abs_f32(float %14)
	; imag
	%16 = load %..complex64, %..complex64* %1, align 4
	%17 = extractvalue %..complex64 %16, 1
	; abs
	%18 = call float @runtime.abs_f32(float %17)
	%19 = fcmp oge float %15, %18
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %if.then-1, label %if.else-2

if.then-1:
	; ratio
	; imag
	%22 = load %..complex64, %..complex64* %1, align 4
	%23 = extractvalue %..complex64 %22, 1
	; real
	%24 = load %..complex64, %..complex64* %1, align 4
	%25 = extractvalue %..complex64 %24, 0
	%26 = fdiv float %23, %25
	store float %26, float* %4
	; denom
	; real
	%27 = load %..complex64, %..complex64* %1, align 4
	%28 = extractvalue %..complex64 %27, 0
	%29 = load float, float* %4, align 4
	; imag
	%30 = load %..complex64, %..complex64* %1, align 4
	%31 = extractvalue %..complex64 %30, 1
	%32 = fmul float %29, %31
	%33 = fadd float %28, %32
	store float %33, float* %5
	; AssignStmt
	; real
	%34 = load %..complex64, %..complex64* %0, align 4
	%35 = extractvalue %..complex64 %34, 0
	; imag
	%36 = load %..complex64, %..complex64* %0, align 4
	%37 = extractvalue %..complex64 %36, 1
	%38 = load float, float* %4, align 4
	%39 = fmul float %37, %38
	%40 = fadd float %35, %39
	%41 = load float, float* %5, align 4
	%42 = fdiv float %40, %41
	store float %42, float* %2
	; AssignStmt
	; imag
	%43 = load %..complex64, %..complex64* %0, align 4
	%44 = extractvalue %..complex64 %43, 1
	; real
	%45 = load %..complex64, %..complex64* %0, align 4
	%46 = extractvalue %..complex64 %45, 0
	%47 = load float, float* %4, align 4
	%48 = fmul float %46, %47
	%49 = fsub float %44, %48
	%50 = load float, float* %5, align 4
	%51 = fdiv float %49, %50
	store float %51, float* %3
	br label %if.done-3

if.else-2:
	; ratio
	; real
	%52 = load %..complex64, %..complex64* %1, align 4
	%53 = extractvalue %..complex64 %52, 0
	; imag
	%54 = load %..complex64, %..complex64* %1, align 4
	%55 = extractvalue %..complex64 %54, 1
	%56 = fdiv float %53, %55
	store float %56, float* %6
	; denom
	; imag
	%57 = load %..complex64, %..complex64* %1, align 4
	%58 = extractvalue %..complex64 %57, 1
	%59 = load float, float* %6, align 4
	; real
	%60 = load %..complex64, %..complex64* %1, align 4
	%61 = extractvalue %..complex64 %60, 0
	%62 = fmul float %59, %61
	%63 = fadd float %58, %62
	store float %63, float* %7
	; AssignStmt
	; real
	%64 = load %..complex64, %..complex64* %0, align 4
	%65 = extractvalue %..complex64 %64, 0
	%66 = load float, float* %6, align 4
	%67 = fmul float %65, %66
	; imag
	%68 = load %..complex64, %..complex64* %0, align 4
	%69 = extractvalue %..complex64 %68, 1
	%70 = fadd float %67, %69
	%71 = load float, float* %7, align 4
	%72 = fdiv float %70, %71
	store float %72, float* %2
	; AssignStmt
	; imag
	%73 = load %..complex64, %..complex64* %0, align 4
	%74 = extractvalue %..complex64 %73, 1
	%75 = load float, float* %6, align 4
	%76 = fmul float %74, %75
	; real
	%77 = load %..complex64, %..complex64* %0, align 4
	%78 = extractvalue %..complex64 %77, 0
	%79 = fsub float %76, %78
	%80 = load float, float* %7, align 4
	%81 = fdiv float %79, %80
	store float %81, float* %3
	br label %if.done-3

if.done-3:
	; ReturnStmt
	; complex
	%82 = load float, float* %2, align 4
	%83 = load float, float* %3, align 4
	%84 = bitcast %..complex64* %8 to %..rawptr
	%85 = call %..rawptr @mem.zero(%..rawptr %84, i64 8) noinline
	store %..complex64 zeroinitializer, %..complex64* %8
	%86 = getelementptr inbounds %..complex64, %..complex64* %8, i64 0, i32 0
	store float %82, float* %86
	%87 = getelementptr inbounds %..complex64, %..complex64* %8, i64 0, i32 1
	store float %83, float* %87
	%88 = load %..complex64, %..complex64* %8, align 4
	ret %..complex64 %88
}

define %..complex128 @runtime.quo_complex128(%..complex128* %n, %..complex128* %m, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca double, align 16
	%1 = alloca double, align 16
	%2 = alloca double, align 16
	%3 = alloca double, align 16
	%4 = alloca double, align 16
	%5 = alloca double, align 16
	%6 = alloca %..complex128, align 16
	%7 = load %..complex128, %..complex128* %n, align 8
	%8 = load %..complex128, %..complex128* %m, align 8
	; e
	%9 = bitcast double* %0 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 8) noinline
	store double zeroinitializer, double* %0
	; f
	%11 = bitcast double* %1 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 8) noinline
	store double zeroinitializer, double* %1
	; IfStmt
	; real
	%13 = load %..complex128, %..complex128* %m, align 8
	%14 = extractvalue %..complex128 %13, 0
	; abs
	%15 = call double @runtime.abs_f64(double %14)
	; imag
	%16 = load %..complex128, %..complex128* %m, align 8
	%17 = extractvalue %..complex128 %16, 1
	; abs
	%18 = call double @runtime.abs_f64(double %17)
	%19 = fcmp oge double %15, %18
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %if.then-1, label %if.else-2

if.then-1:
	; ratio
	; imag
	%22 = load %..complex128, %..complex128* %m, align 8
	%23 = extractvalue %..complex128 %22, 1
	; real
	%24 = load %..complex128, %..complex128* %m, align 8
	%25 = extractvalue %..complex128 %24, 0
	%26 = fdiv double %23, %25
	store double %26, double* %2
	; denom
	; real
	%27 = load %..complex128, %..complex128* %m, align 8
	%28 = extractvalue %..complex128 %27, 0
	%29 = load double, double* %2, align 8
	; imag
	%30 = load %..complex128, %..complex128* %m, align 8
	%31 = extractvalue %..complex128 %30, 1
	%32 = fmul double %29, %31
	%33 = fadd double %28, %32
	store double %33, double* %3
	; AssignStmt
	; real
	%34 = load %..complex128, %..complex128* %n, align 8
	%35 = extractvalue %..complex128 %34, 0
	; imag
	%36 = load %..complex128, %..complex128* %n, align 8
	%37 = extractvalue %..complex128 %36, 1
	%38 = load double, double* %2, align 8
	%39 = fmul double %37, %38
	%40 = fadd double %35, %39
	%41 = load double, double* %3, align 8
	%42 = fdiv double %40, %41
	store double %42, double* %0
	; AssignStmt
	; imag
	%43 = load %..complex128, %..complex128* %n, align 8
	%44 = extractvalue %..complex128 %43, 1
	; real
	%45 = load %..complex128, %..complex128* %n, align 8
	%46 = extractvalue %..complex128 %45, 0
	%47 = load double, double* %2, align 8
	%48 = fmul double %46, %47
	%49 = fsub double %44, %48
	%50 = load double, double* %3, align 8
	%51 = fdiv double %49, %50
	store double %51, double* %1
	br label %if.done-3

if.else-2:
	; ratio
	; real
	%52 = load %..complex128, %..complex128* %m, align 8
	%53 = extractvalue %..complex128 %52, 0
	; imag
	%54 = load %..complex128, %..complex128* %m, align 8
	%55 = extractvalue %..complex128 %54, 1
	%56 = fdiv double %53, %55
	store double %56, double* %4
	; denom
	; imag
	%57 = load %..complex128, %..complex128* %m, align 8
	%58 = extractvalue %..complex128 %57, 1
	%59 = load double, double* %4, align 8
	; real
	%60 = load %..complex128, %..complex128* %m, align 8
	%61 = extractvalue %..complex128 %60, 0
	%62 = fmul double %59, %61
	%63 = fadd double %58, %62
	store double %63, double* %5
	; AssignStmt
	; real
	%64 = load %..complex128, %..complex128* %n, align 8
	%65 = extractvalue %..complex128 %64, 0
	%66 = load double, double* %4, align 8
	%67 = fmul double %65, %66
	; imag
	%68 = load %..complex128, %..complex128* %n, align 8
	%69 = extractvalue %..complex128 %68, 1
	%70 = fadd double %67, %69
	%71 = load double, double* %5, align 8
	%72 = fdiv double %70, %71
	store double %72, double* %0
	; AssignStmt
	; imag
	%73 = load %..complex128, %..complex128* %n, align 8
	%74 = extractvalue %..complex128 %73, 1
	%75 = load double, double* %4, align 8
	%76 = fmul double %74, %75
	; real
	%77 = load %..complex128, %..complex128* %n, align 8
	%78 = extractvalue %..complex128 %77, 0
	%79 = fsub double %76, %78
	%80 = load double, double* %5, align 8
	%81 = fdiv double %79, %80
	store double %81, double* %1
	br label %if.done-3

if.done-3:
	; ReturnStmt
	; complex
	%82 = load double, double* %0, align 8
	%83 = load double, double* %1, align 8
	%84 = bitcast %..complex128* %6 to %..rawptr
	%85 = call %..rawptr @mem.zero(%..rawptr %84, i64 16) noinline
	store %..complex128 zeroinitializer, %..complex128* %6
	%86 = getelementptr inbounds %..complex128, %..complex128* %6, i64 0, i32 0
	store double %82, double* %86
	%87 = getelementptr inbounds %..complex128, %..complex128* %6, i64 0, i32 1
	store double %83, double* %87
	%88 = load %..complex128, %..complex128* %6, align 8
	ret %..complex128 %88
}

define %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %info) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	%2 = alloca %runtime.Type_Info_Named, align 16
	%3 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	store %runtime.Type_Info* %info, %runtime.Type_Info** %0
	; IfStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%5 = icmp eq %runtime.Type_Info* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %runtime.Type_Info* zeroinitializer

if.done-2:
	; base
	%8 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	store %runtime.Type_Info* %8, %runtime.Type_Info** %1
	; ForStmt
	br label %for.body-3

for.body-3:
	; TypeSwitchStmt
	; SelectorExpr
	%9 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%10 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %9, i64 0
	%11 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %10, i64 0, i32 3
	%12 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %11, align 8
	; get union's tag
	%13 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %11, i64 0, i32 2 ; UnionTagPtr
	%14 = load i8, i8* %13, align 1
	%15 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %11 to %..rawptr
	%16 = icmp eq i8 %14, 1
	br i1 %16, label %typeswitch.body-5, label %typeswitch.next-4

typeswitch.next-4:
	store {[0 x <8 x i8>], [72 x i8], i8} %12, {[0 x <8 x i8>], [72 x i8], i8}* %3
	; break
	; ReturnStmt
	%17 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	ret %runtime.Type_Info* %17

typeswitch.body-5:
	%18 = bitcast %..rawptr %15 to %runtime.Type_Info_Named*
	%19 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %18, align 8
	store %runtime.Type_Info_Named %19, %runtime.Type_Info_Named* %2
	; AssignStmt
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2, i64 0, i32 1
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	store %runtime.Type_Info* %21, %runtime.Type_Info** %1
	br label %for.body-3
}

define %runtime.Type_Info* @runtime.type_info_base_without_enum(%runtime.Type_Info* %info) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	%2 = alloca %runtime.Type_Info_Named, align 16
	%3 = alloca %runtime.Type_Info_Enum, align 16
	%4 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	store %runtime.Type_Info* %info, %runtime.Type_Info** %0
	; IfStmt
	%5 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%6 = icmp eq %runtime.Type_Info* %5, zeroinitializer
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	br i1 %8, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %runtime.Type_Info* zeroinitializer

if.done-2:
	; base
	%9 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	store %runtime.Type_Info* %9, %runtime.Type_Info** %1
	; ForStmt
	br label %for.body-3

for.body-3:
	; TypeSwitchStmt
	; SelectorExpr
	%10 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%11 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %10, i64 0
	%12 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %11, i64 0, i32 3
	%13 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %12, align 8
	; get union's tag
	%14 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %12, i64 0, i32 2 ; UnionTagPtr
	%15 = load i8, i8* %14, align 1
	%16 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %12 to %..rawptr
	%17 = icmp eq i8 %15, 1
	br i1 %17, label %typeswitch.body-5, label %typeswitch.next-4

typeswitch.next-4:
	%18 = icmp eq i8 %15, 18
	br i1 %18, label %typeswitch.body-7, label %typeswitch.next-6

typeswitch.body-5:
	%19 = bitcast %..rawptr %16 to %runtime.Type_Info_Named*
	%20 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %19, align 8
	store %runtime.Type_Info_Named %20, %runtime.Type_Info_Named* %2
	; AssignStmt
	; SelectorExpr
	%21 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2, i64 0, i32 1
	%22 = load %runtime.Type_Info*, %runtime.Type_Info** %21, align 8
	store %runtime.Type_Info* %22, %runtime.Type_Info** %1
	br label %typeswitch.done-8

typeswitch.next-6:
	store {[0 x <8 x i8>], [72 x i8], i8} %13, {[0 x <8 x i8>], [72 x i8], i8}* %4
	; break
	; ReturnStmt
	%23 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	ret %runtime.Type_Info* %23

typeswitch.body-7:
	%24 = bitcast %..rawptr %16 to %runtime.Type_Info_Enum*
	%25 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %24, align 8
	store %runtime.Type_Info_Enum %25, %runtime.Type_Info_Enum* %3
	; AssignStmt
	; SelectorExpr
	%26 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %3, i64 0, i32 0
	%27 = load %runtime.Type_Info*, %runtime.Type_Info** %26, align 8
	store %runtime.Type_Info* %27, %runtime.Type_Info** %1
	br label %typeswitch.done-8

typeswitch.done-8:
	br label %for.body-3
}

define %runtime.Type_Info* @runtime.__type_info_of(%..typeid %id) #0 {
decls-0:
	%0 = alloca %..typeid, align 16
	%1 = alloca {[0 x <8 x i8>], [8 x i8]}, align 16
	%2 = alloca i64, align 16
	store %..typeid %id, %..typeid* %0
	; data
	%3 = load %..typeid, %..typeid* %0, align 8
	%4 = bitcast %..typeid* %0 to {[0 x <8 x i8>], [8 x i8]}*
	%5 = load {[0 x <8 x i8>], [8 x i8]}, {[0 x <8 x i8>], [8 x i8]}* %4, align 8
	store {[0 x <8 x i8>], [8 x i8]} %5, {[0 x <8 x i8>], [8 x i8]}* %1
	; n
	; SelectorExpr
	%6 = bitcast {[0 x <8 x i8>], [8 x i8]}* %1 to i8*
	%7 = getelementptr inbounds i8, i8* %6, i64 0
	%8 = bitcast i8* %7 to i64*
	%9 = load i64, i64* %8, align 8
	%10 = shl i64 %9, 8
	%11 = lshr i64 %10, 8
	%12 = bitcast i64 %11 to i64
	store i64 %12, i64* %2
	; IfStmt
	%13 = load i64, i64* %2, align 8
	%14 = icmp slt i64 %13, 0
	%15 = zext i1 %14 to i8
	%16 = trunc i8 %15 to i1
	br i1 %16, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%17 = load i64, i64* %2, align 8
	%18 = load {%runtime.Type_Info*, i64}, {%runtime.Type_Info*, i64}* @runtime.type_table, align 8
	%19 = extractvalue {%runtime.Type_Info*, i64} %18, 1
	%20 = icmp sge i64 %17, %19
	%21 = zext i1 %20 to i8
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-2, label %if.done-3

if.then-2:
	; AssignStmt
	store i64 0, i64* %2
	br label %if.done-3

if.done-3:
	; ReturnStmt
	; IndexExpr
	%23 = load {%runtime.Type_Info*, i64}, {%runtime.Type_Info*, i64}* @runtime.type_table, align 8
	%24 = extractvalue {%runtime.Type_Info*, i64} %23, 0
	%25 = load i64, i64* %2, align 8
	%26 = extractvalue {%runtime.Type_Info*, i64} %23, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$53, i64 0, i32 0), i64 58}, i64 279, i64 21, i64 %25, i64 %26)
	%27 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %24, i64 %25
	ret %runtime.Type_Info* %27
}

define %..typeid @runtime.typeid_base(%..typeid %id) #0 {
decls-0:
	%0 = alloca %..typeid, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	store %..typeid %id, %..typeid* %0
	; ti
	%2 = load %..typeid, %..typeid* %0, align 8
	%3 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %2)
	store %runtime.Type_Info* %3, %runtime.Type_Info** %1
	; AssignStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%5 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %4)
	store %runtime.Type_Info* %5, %runtime.Type_Info** %1
	; ReturnStmt
	; SelectorExpr
	%6 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%7 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %6, i64 0
	%8 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %7, i64 0, i32 2
	%9 = load %..typeid, %..typeid* %8, align 8
	ret %..typeid %9
}

define void @runtime.__init_context(%runtime.Context* %c) #0 {
decls-0:
	%0 = alloca %runtime.Context*, align 16
	store %runtime.Context* %c, %runtime.Context** %0
	; IfStmt
	%1 = load %runtime.Context*, %runtime.Context** %0, align 8
	%2 = icmp eq %runtime.Context* %1, zeroinitializer
	%3 = zext i1 %2 to i8
	%4 = trunc i8 %3 to i1
	br i1 %4, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%5 = load %runtime.Context*, %runtime.Context** %0, align 8
	%6 = getelementptr inbounds %runtime.Context, %runtime.Context* %5, i64 0
	%7 = getelementptr inbounds %runtime.Context, %runtime.Context* %6, i64 0, i32 0
	%8 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %7, i64 0, i32 0
	; SelectorExpr
	%9 = bitcast %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* @os.heap_allocator_proc to %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*
	store %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %9, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %8
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%10 = load %runtime.Context*, %runtime.Context** %0, align 8
	%11 = getelementptr inbounds %runtime.Context, %runtime.Context* %10, i64 0
	%12 = getelementptr inbounds %runtime.Context, %runtime.Context* %11, i64 0, i32 0
	%13 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %12, i64 0, i32 1
	store %..rawptr zeroinitializer, %..rawptr* %13
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%14 = load %runtime.Context*, %runtime.Context** %0, align 8
	%15 = getelementptr inbounds %runtime.Context, %runtime.Context* %14, i64 0
	%16 = getelementptr inbounds %runtime.Context, %runtime.Context* %15, i64 0, i32 1
	%17 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %16, i64 0, i32 0
	; SelectorExpr
	%18 = bitcast %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* @mem.scratch_allocator_proc to %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*
	store %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %18, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %17
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%19 = load %runtime.Context*, %runtime.Context** %0, align 8
	%20 = getelementptr inbounds %runtime.Context, %runtime.Context* %19, i64 0
	%21 = getelementptr inbounds %runtime.Context, %runtime.Context* %20, i64 0, i32 1
	%22 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %21, i64 0, i32 1
	%23 = bitcast %mem.Scratch_Allocator* @runtime.global_scratch_allocator_data to %..rawptr
	store %..rawptr %23, %..rawptr* %22
	; AssignStmt
	; SelectorExpr
	%24 = load %runtime.Context*, %runtime.Context** %0, align 8
	%25 = getelementptr inbounds %runtime.Context, %runtime.Context* %24, i64 0
	%26 = getelementptr inbounds %runtime.Context, %runtime.Context* %25, i64 0, i32 4
	; SelectorExpr
	%27 = call i64 @os.current_thread_id()
	store i64 %27, i64* %26
	; AssignStmt
	; SelectorExpr
	%28 = load %runtime.Context*, %runtime.Context** %0, align 8
	%29 = getelementptr inbounds %runtime.Context, %runtime.Context* %28, i64 0
	%30 = getelementptr inbounds %runtime.Context, %runtime.Context* %29, i64 0, i32 2
	%31 = bitcast void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* @runtime.default_assertion_failure_proc to void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*
	store void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %31, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %30
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%32 = load %runtime.Context*, %runtime.Context** %0, align 8
	%33 = getelementptr inbounds %runtime.Context, %runtime.Context* %32, i64 0
	%34 = getelementptr inbounds %runtime.Context, %runtime.Context* %33, i64 0, i32 3
	%35 = getelementptr inbounds %log.Logger, %log.Logger* %34, i64 0, i32 0
	; SelectorExpr
	%36 = bitcast void (%..rawptr, i64, %..string, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)* @log.nil_logger_proc to void (%..rawptr, i64, %..string, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)*
	store void (%..rawptr, i64, %..string, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)* %36, void (%..rawptr, i64, %..string, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)** %35
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%37 = load %runtime.Context*, %runtime.Context** %0, align 8
	%38 = getelementptr inbounds %runtime.Context, %runtime.Context* %37, i64 0
	%39 = getelementptr inbounds %runtime.Context, %runtime.Context* %38, i64 0, i32 3
	%40 = getelementptr inbounds %log.Logger, %log.Logger* %39, i64 0, i32 1
	store %..rawptr zeroinitializer, %..rawptr* %40
	ret void
}

define void @runtime.default_assertion_failure_proc(%..string %prefix, %..string %message, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i32, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	store %..string %prefix, %..string* %0
	store %..string %message, %..string* %1
	%4 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; fd
	; SelectorExpr
	%5 = load i32, i32* @os.stderr, align 4
	store i32 %5, i32* %2
	%6 = load i32, i32* %2, align 4
	%7 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%8 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %7, %runtime.Source_Code_Location* %3
	call void @runtime.print_caller_location(i32 %6, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%10 = load i32, i32* %2, align 4
	%11 = call {i64, i64} @os.write_string(i32 %10, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$54, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%12 = load i32, i32* %2, align 4
	%13 = load %..string, %..string* %0, align 8
	%14 = call {i64, i64} @os.write_string(i32 %12, %..string %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	%15 = load %..string, %..string* %1, align 8
	%16 = extractvalue %..string %15, 1
	%17 = icmp sgt i64 %16, 0
	%18 = zext i1 %17 to i8
	%19 = trunc i8 %18 to i1
	br i1 %19, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	%20 = load i32, i32* %2, align 4
	%21 = call {i64, i64} @os.write_string(i32 %20, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$55, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%22 = load i32, i32* %2, align 4
	%23 = load %..string, %..string* %1, align 8
	%24 = call {i64, i64} @os.write_string(i32 %22, %..string %23, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-2

if.done-2:
	; SelectorExpr
	%25 = load i32, i32* %2, align 4
	%26 = call {i64, i64} @os.write_byte(i32 %25, i8 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call ccc void @llvm.debugtrap()
	ret void
}

define i8 @runtime.assert(i1 %condition, %..string %message, %runtime.Source_Code_Location* %loc) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca %..string, align 16
	%2 = alloca void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, align 16
	%3 = alloca %runtime.Context, align 16
	%4 = bitcast %runtime.Context* %3 to %..rawptr
	%5 = call %..rawptr @mem.zero(%..rawptr %4, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %3
	%6 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %6, %runtime.Context* %3
	call void @runtime.__init_context(%runtime.Context* %3)
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = zext i1 %condition to i8
	store i8 %8, i8* %0
	store %..string %message, %..string* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load i8, i8* %0, align 1
	%11 = trunc i8 %10 to i1
	br i1 %11, label %if.done-4, label %if.then-1

if.then-1:
	; p
	; SelectorExpr
	%12 = getelementptr inbounds %runtime.Context, %runtime.Context* %3, i64 0, i32 2
	%13 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %12, align 8
	store void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %13, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %2
	; IfStmt
	%14 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %2, align 8
	%15 = icmp eq void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %14, zeroinitializer
	%16 = zext i1 %15 to i8
	%17 = trunc i8 %16 to i1
	br i1 %17, label %if.then-2, label %if.done-3

if.then-2:
	; AssignStmt
	%18 = bitcast void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* @runtime.default_assertion_failure_proc to void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*
	store void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %18, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %2
	br label %if.done-3

if.done-3:
	%19 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %2, align 8
	%20 = load %..string, %..string* %1, align 8
	%21 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%22 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location %21, %runtime.Source_Code_Location* %7
	call void %19(%..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$56, i64 0, i32 0), i64 17}, %..string %20, %runtime.Source_Code_Location* %7, %runtime.Context* noalias nonnull nocapture inreg %3)
	br label %if.done-4

if.done-4:
	; ReturnStmt
	%24 = load i8, i8* %0, align 1
	ret i8 %24
}

define void @runtime.panic(%..string %message, %runtime.Source_Code_Location* %loc) #0 noreturn {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, align 16
	%2 = alloca %runtime.Context, align 16
	%3 = bitcast %runtime.Context* %2 to %..rawptr
	%4 = call %..rawptr @mem.zero(%..rawptr %3, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %2
	%5 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %5, %runtime.Context* %2
	call void @runtime.__init_context(%runtime.Context* %2)
	%6 = alloca %runtime.Source_Code_Location, align 16
	store %..string %message, %..string* %0
	%7 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; p
	; SelectorExpr
	%8 = getelementptr inbounds %runtime.Context, %runtime.Context* %2, i64 0, i32 2
	%9 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %8, align 8
	store void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %9, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1
	; IfStmt
	%10 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1, align 8
	%11 = icmp eq void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	%14 = bitcast void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* @runtime.default_assertion_failure_proc to void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*
	store void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %14, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1
	br label %if.done-2

if.done-2:
	%15 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1, align 8
	%16 = load %..string, %..string* %0, align 8
	%17 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%18 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location %17, %runtime.Source_Code_Location* %6
	call void %15(%..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$57, i64 0, i32 0), i64 5}, %..string %16, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture inreg %2)
	ret void
}

define i8 @runtime.__dynamic_array_reserve(%..rawptr %array_, i64 %elem_size, i64 %elem_align, i64 %cap, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca i64, align 16
	%7 = alloca i64, align 16
	%8 = alloca %mem.Allocator, align 16
	%9 = alloca %..rawptr, align 16
	%10 = alloca %runtime.Source_Code_Location, align 16
	store %..rawptr %array_, %..rawptr* %0
	store i64 %elem_size, i64* %1
	store i64 %elem_align, i64* %2
	store i64 %cap, i64* %3
	%11 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; array
	%12 = load %..rawptr, %..rawptr* %0, align 8
	%13 = bitcast %..rawptr %12 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %13, %mem.Raw_Dynamic_Array** %4
	; IfStmt
	%14 = load i64, i64* %3, align 8
	; SelectorExpr
	%15 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%16 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %15, i64 0
	%17 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %16, i64 0, i32 2
	%18 = load i64, i64* %17, align 8
	%19 = icmp sle i64 %14, %18
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 1

if.done-2:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%22 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%23 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %22, i64 0
	%24 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %23, i64 0, i32 3
	%25 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %24, i64 0, i32 0
	%26 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %25, align 8
	%27 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %26, zeroinitializer
	%28 = zext i1 %27 to i8
	%29 = trunc i8 %28 to i1
	br i1 %29, label %if.then-3, label %if.done-4

if.then-3:
	; AssignStmt
	; SelectorExpr
	%30 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%31 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %30, i64 0
	%32 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %31, i64 0, i32 3
	; SelectorExpr
	%33 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%34 = load %mem.Allocator, %mem.Allocator* %33, align 8
	store %mem.Allocator %34, %mem.Allocator* %32
	br label %if.done-4

if.done-4:
	; SelectorExpr
	; SelectorExpr
	%35 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%36 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %35, i64 0
	%37 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %36, i64 0, i32 3
	%38 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %37, i64 0, i32 0
	%39 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %38, align 8
	%40 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %39, zeroinitializer
	%41 = zext i1 %40 to i8
	%42 = trunc i8 %41 to i1
	%43 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	%44 = call %..rawptr @mem.zero(%..rawptr %43, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$58, i64 0, i32 0), i64 58}, i64 682, i64 2, %..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$59, i64 0, i32 0), i64 23}}, %runtime.Source_Code_Location* %5
	%45 = call i8 @runtime.assert(i1 %42, %..string zeroinitializer, %runtime.Source_Code_Location* %5)
	; old_size
	; SelectorExpr
	%46 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%47 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %46, i64 0
	%48 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %47, i64 0, i32 2
	%49 = load i64, i64* %48, align 8
	%50 = load i64, i64* %1, align 8
	%51 = mul i64 %49, %50
	store i64 %51, i64* %6
	; new_size
	%52 = load i64, i64* %3, align 8
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %52, %53
	store i64 %54, i64* %7
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %8
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %8, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %8, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %7, align 8
	%64 = load i64, i64* %2, align 8
	; SelectorExpr
	%65 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0
	%67 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %66, i64 0, i32 0
	%68 = load %..rawptr, %..rawptr* %67, align 8
	%69 = load i64, i64* %6, align 8
	%70 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%71 = bitcast %runtime.Source_Code_Location* %10 to %..rawptr
	%72 = call %..rawptr @mem.zero(%..rawptr %71, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %10
	store %runtime.Source_Code_Location %70, %runtime.Source_Code_Location* %10
	%73 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 %64, %..rawptr %68, i64 %69, i64 0, %runtime.Source_Code_Location* %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %73, %..rawptr* %9
	; IfStmt
	%74 = load %..rawptr, %..rawptr* %9, align 8
	%75 = icmp eq %..rawptr %74, zeroinitializer
	%76 = zext i1 %75 to i8
	%77 = trunc i8 %76 to i1
	br i1 %77, label %if.then-5, label %if.done-6

if.then-5:
	; ReturnStmt
	ret i8 0

if.done-6:
	; AssignStmt
	; SelectorExpr
	%78 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0
	%80 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %79, i64 0, i32 0
	%81 = load %..rawptr, %..rawptr* %9, align 8
	store %..rawptr %81, %..rawptr* %80
	; AssignStmt
	; SelectorExpr
	%82 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0
	%84 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %83, i64 0, i32 2
	%85 = load i64, i64* %3, align 8
	store i64 %85, i64* %84
	; ReturnStmt
	ret i8 1
}

define i64 @runtime.__dynamic_array_append_nothing(%..rawptr %array_, i64 %elem_size, i64 %elem_align, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %mem.Raw_Dynamic_Array*, align 16
	%4 = alloca i8, align 16
	%5 = alloca i64, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca i64, align 16
	store %..rawptr %array_, %..rawptr* %0
	store i64 %elem_size, i64* %1
	store i64 %elem_align, i64* %2
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; array
	%10 = load %..rawptr, %..rawptr* %0, align 8
	%11 = bitcast %..rawptr %10 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %11, %mem.Raw_Dynamic_Array** %3
	; ok
	store i8 1, i8* %4
	; IfStmt
	; SelectorExpr
	%12 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%13 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %12, i64 0
	%14 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %13, i64 0, i32 2
	%15 = load i64, i64* %14, align 8
	; SelectorExpr
	%16 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%17 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %16, i64 0
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0, i32 1
	%19 = load i64, i64* %18, align 8
	%20 = add i64 %19, 1
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.done-2

if.then-1:
	; cap
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 2
	%27 = load i64, i64* %26, align 8
	%28 = mul i64 2, %27
	%29 = add i64 %28, 8
	store i64 %29, i64* %5
	; AssignStmt
	%30 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%31 = load i64, i64* %1, align 8
	%32 = load i64, i64* %2, align 8
	%33 = load i64, i64* %5, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %mem.Raw_Dynamic_Array* %30 to %..rawptr
	%36 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%37 = call %..rawptr @mem.zero(%..rawptr %36, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %6
	%38 = call i8 @runtime.__dynamic_array_reserve(%..rawptr %35, i64 %31, i64 %32, i64 %33, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i8 %38, i8* %4
	br label %if.done-2

if.done-2:
	; IfStmt
	%39 = load i8, i8* %4, align 1
	%40 = trunc i8 %39 to i1
	br i1 %40, label %if.done-4, label %if.then-3

if.then-3:
	; ReturnStmt
	; SelectorExpr
	%41 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%42 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %41, i64 0
	%43 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %42, i64 0, i32 1
	%44 = load i64, i64* %43, align 8
	ret i64 %44

if.done-4:
	; SelectorExpr
	%45 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%46 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %45, i64 0
	%47 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %46, i64 0, i32 0
	%48 = load %..rawptr, %..rawptr* %47, align 8
	%49 = icmp ne %..rawptr %48, zeroinitializer
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	%52 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$5a, i64 0, i32 0), i64 58}, i64 740, i64 2, %..string {i8* getelementptr inbounds ([31 x i8], [31 x i8]* @str$5b, i64 0, i32 0), i64 30}}, %runtime.Source_Code_Location* %7
	%54 = call i8 @runtime.assert(i1 %51, %..string zeroinitializer, %runtime.Source_Code_Location* %7)
	; data
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 0
	%58 = load %..rawptr, %..rawptr* %57, align 8
	%59 = ptrtoint %..rawptr %58 to i64
	%60 = load i64, i64* %1, align 8
	; SelectorExpr
	%61 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%62 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %61, i64 0
	%63 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %62, i64 0, i32 1
	%64 = load i64, i64* %63, align 8
	%65 = mul i64 %60, %64
	%66 = bitcast i64 %65 to i64
	%67 = add i64 %59, %66
	store i64 %67, i64* %8
	; SelectorExpr
	%68 = load i64, i64* %8, align 8
	%69 = inttoptr i64 %68 to %..rawptr
	%70 = load i64, i64* %1, align 8
	%71 = call %..rawptr @mem.zero(%..rawptr %69, i64 %70)
	; AssignStmt
	; SelectorExpr
	%72 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%73 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %72, i64 0
	%74 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %73, i64 0, i32 1
	%75 = load i64, i64* %74, align 8
	%76 = add i64 %75, 1
	store i64 %76, i64* %74
	; ReturnStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 1
	%80 = load i64, i64* %79, align 8
	ret i64 %80
}

define i64 @runtime.default_hash({i8*, i64}* %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64}, align 16
	%1 = load {i8*, i64}, {i8*, i64}* %data, align 8
	; ReturnStmt
	%2 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%3 = bitcast {i8*, i64}* %0 to %..rawptr
	%4 = call %..rawptr @mem.zero(%..rawptr %3, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %0
	store {i8*, i64} %2, {i8*, i64}* %0
	%5 = call i64 @runtime.default_hash.fnv64a-0({i8*, i64}* %0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret i64 %5
}

define i64 @runtime.default_hash.fnv64a-0({i8*, i64}* %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = load {i8*, i64}, {i8*, i64}* %data, align 8
	; h
	store i64 -3750763034362895579, i64* %0
	; RangeStmt
	; b
	%5 = bitcast i8* %1 to %..rawptr
	%6 = call %..rawptr @mem.zero(%..rawptr %5, i64 1) noinline
	store i8 zeroinitializer, i8* %1
	%7 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%8 = bitcast i64* %2 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	%10 = extractvalue {i8*, i64} %7, 1
	store i64 %10, i64* %2
	%11 = bitcast i64* %3 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	store i64 -1, i64* %3
	br label %for.index.loop-1

for.index.loop-1:
	%13 = load i64, i64* %3, align 8
	%14 = add i64 %13, 1
	store i64 %14, i64* %3
	%15 = load i64, i64* %2, align 8
	%16 = icmp slt i64 %14, %15
	br i1 %16, label %for.index.body-2, label %for.index.done-3

for.index.body-2:
	%17 = load i64, i64* %3, align 8
	%18 = extractvalue {i8*, i64} %7, 0
	%19 = getelementptr inbounds i8, i8* %18, i64 %17
	%20 = load i8, i8* %19, align 1
	store i8 %20, i8* %1
	; AssignStmt
	%21 = load i64, i64* %0, align 8
	%22 = load i8, i8* %1, align 1
	%23 = zext i8 %22 to i64
	%24 = xor i64 %21, %23
	%25 = mul i64 %24, 1099511628211
	store i64 %25, i64* %0
	br label %for.index.loop-1

for.index.done-3:
	; ReturnStmt
	%26 = load i64, i64* %0, align 8
	ret i64 %26
}

define i64 @runtime.default_hash_string(%..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i8*, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca {i8*, i64}, align 16
	store %..string %s, %..string* %0
	; ReturnStmt
	%4 = load %..string, %..string* %0, align 8
	%5 = extractvalue %..string %4, 0
	%6 = bitcast i8** %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 8) noinline
	store i8* zeroinitializer, i8** %1
	store i8* %5, i8** %1
	%8 = extractvalue %..string %4, 1
	%9 = sub i64 %8, 0
	%10 = load i8*, i8** %1, align 8
	%11 = getelementptr inbounds i8, i8* %10, i64 0
	%12 = bitcast {i8*, i64}* %2 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %2
	%14 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 0
	store i8* %11, i8** %14
	%15 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 1
	store i64 %9, i64* %15
	%16 = load {i8*, i64}, {i8*, i64}* %2, align 8
	%17 = bitcast {i8*, i64}* %3 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %3
	store {i8*, i64} %16, {i8*, i64}* %3
	%19 = call i64 @runtime.default_hash({i8*, i64}* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret i64 %19
}

define void @runtime.__dynamic_map_reserve(%runtime.Map_Header* %header, i64 %cap, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = alloca i64, align 16
	%3 = alloca %mem.Allocator, align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i64, align 16
	%8 = load %runtime.Map_Header, %runtime.Map_Header* %header, align 8
	store i64 %cap, i64* %0
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%10 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%11 = load %mem.Raw_Map*, %mem.Raw_Map** %10, align 8
	%12 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %11, i64 0
	%13 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %12, i64 0, i32 1
	%14 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 2
	%15 = load i64, i64* %14, align 8
	%16 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 3
	%17 = load i64, i64* %16, align 8
	%18 = load i64, i64* %0, align 8
	%19 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%20 = bitcast %mem.Raw_Dynamic_Array* %13 to %..rawptr
	%21 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %19, %runtime.Source_Code_Location* %1
	%23 = call i8 @runtime.__dynamic_array_reserve(%..rawptr %20, i64 %15, i64 %17, i64 %18, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; old_len
	; SelectorExpr
	%24 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%25 = load %mem.Raw_Map*, %mem.Raw_Map** %24, align 8
	%26 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %25, i64 0
	%27 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %26, i64 0, i32 0
	%28 = load {i64*, i64}, {i64*, i64}* %27, align 8
	%29 = extractvalue {i64*, i64} %28, 1
	store i64 %29, i64* %2
	; SelectorExpr
	%30 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%31 = load %mem.Raw_Map*, %mem.Raw_Map** %30, align 8
	%32 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %31, i64 0
	%33 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %32, i64 0, i32 0
	%34 = load i64, i64* %0, align 8
	; SelectorExpr
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%36 = load %mem.Raw_Map*, %mem.Raw_Map** %35, align 8
	%37 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %36, i64 0
	%38 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %37, i64 0, i32 1
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = load %mem.Allocator, %mem.Allocator* %39, align 8
	%41 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%42 = bitcast %mem.Allocator* %3 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %3
	store %mem.Allocator %40, %mem.Allocator* %3
	%44 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location %41, %runtime.Source_Code_Location* %4
	%46 = call i8 @runtime.__slice_resize-14067({i64*, i64}* %33, i64 %34, %mem.Allocator* %3, %runtime.Source_Code_Location* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; i
	%47 = bitcast i64* %5 to %..rawptr
	%48 = call %..rawptr @mem.zero(%..rawptr %47, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	%49 = load i64, i64* %2, align 8
	%50 = bitcast i64* %6 to %..rawptr
	%51 = call %..rawptr @mem.zero(%..rawptr %50, i64 8) noinline
	store i64 zeroinitializer, i64* %6
	store i64 %49, i64* %6
	%52 = bitcast i64* %7 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 8) noinline
	store i64 zeroinitializer, i64* %7
	store i64 0, i64* %7
	br label %for.interval.loop-1

for.interval.loop-1:
	; SelectorExpr
	%54 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%55 = load %mem.Raw_Map*, %mem.Raw_Map** %54, align 8
	%56 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %56, i64 0, i32 0
	%58 = load {i64*, i64}, {i64*, i64}* %57, align 8
	%59 = extractvalue {i64*, i64} %58, 1
	%60 = sub i64 %59, 1
	%61 = load i64, i64* %6, align 8
	%62 = icmp sle i64 %61, %60
	br i1 %62, label %for.interval.body-2, label %for.interval.done-3

for.interval.body-2:
	%63 = load i64, i64* %6, align 8
	%64 = load i64, i64* %7, align 8
	%65 = load i64, i64* %6, align 8
	%66 = add i64 %65, 1
	store i64 %66, i64* %6
	%67 = load i64, i64* %7, align 8
	%68 = add i64 %67, 1
	store i64 %68, i64* %7
	store i64 %63, i64* %5
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%69 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%70 = load %mem.Raw_Map*, %mem.Raw_Map** %69, align 8
	%71 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %70, i64 0
	%72 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %71, i64 0, i32 0
	%73 = load {i64*, i64}, {i64*, i64}* %72, align 8
	%74 = extractvalue {i64*, i64} %73, 0
	%75 = load i64, i64* %5, align 8
	%76 = extractvalue {i64*, i64} %73, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$5c, i64 0, i32 0), i64 58}, i64 837, i64 48, i64 %75, i64 %76)
	%77 = getelementptr inbounds i64, i64* %74, i64 %75
	store i64 -1, i64* %77
	br label %for.interval.loop-1

for.interval.done-3:
	ret void
}

define void @runtime.__dynamic_map_rehash(%runtime.Map_Header* %header, i64 %new_count, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Map_Header, align 16
	%2 = alloca %mem.Raw_Map, align 16
	%3 = alloca %runtime.Context, align 16
	%4 = alloca %runtime.Context, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	%10 = alloca i64, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca %runtime.Map_Header, align 16
	%15 = alloca %runtime.Source_Code_Location, align 16
	%16 = alloca %runtime.Map_Entry_Header*, align 16
	%17 = alloca %runtime.Map_Header, align 16
	%18 = alloca i64, align 16
	%19 = alloca %runtime.Map_Find_Result, align 16
	%20 = alloca %runtime.Map_Header, align 16
	%21 = alloca %runtime.Map_Key, align 16
	%22 = alloca i64, align 16
	%23 = alloca %runtime.Map_Header, align 16
	%24 = alloca %runtime.Map_Key, align 16
	%25 = alloca %runtime.Source_Code_Location, align 16
	%26 = alloca %runtime.Map_Entry_Header*, align 16
	%27 = alloca %runtime.Map_Header, align 16
	%28 = alloca %runtime.Map_Entry_Header*, align 16
	%29 = alloca %runtime.Map_Header, align 16
	%30 = alloca i64, align 16
	%31 = alloca %runtime.Map_Header, align 16
	%32 = alloca %runtime.Map_Header, align 16
	%33 = alloca %runtime.Source_Code_Location, align 16
	%34 = alloca {i64*, i64}, align 16
	%35 = alloca %mem.Allocator, align 16
	%36 = alloca %runtime.Source_Code_Location, align 16
	%37 = alloca %mem.Allocator, align 16
	%38 = alloca %runtime.Source_Code_Location, align 16
	%39 = load %runtime.Map_Header, %runtime.Map_Header* %header, align 8
	store i64 %new_count, i64* %0
	%40 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; new_header
	%41 = load %runtime.Map_Header, %runtime.Map_Header* %header, align 8
	store %runtime.Map_Header %41, %runtime.Map_Header* %1
	; nm
	store %mem.Raw_Map zeroinitializer, %mem.Raw_Map* %2
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%42 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %2, i64 0, i32 1
	%43 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %42, i64 0, i32 3
	; SelectorExpr
	; SelectorExpr
	%44 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%45 = load %mem.Raw_Map*, %mem.Raw_Map** %44, align 8
	%46 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %45, i64 0
	%47 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %46, i64 0, i32 1
	%48 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %47, i64 0, i32 3
	%49 = load %mem.Allocator, %mem.Allocator* %48, align 8
	store %mem.Allocator %49, %mem.Allocator* %43
	; AssignStmt
	; SelectorExpr
	%50 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %1, i64 0, i32 0
	store %mem.Raw_Map* %2, %mem.Raw_Map** %50
	; c
	%51 = load %runtime.Context, %runtime.Context* %__.context_ptr, align 8
	store %runtime.Context %51, %runtime.Context* %3
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	; SelectorExpr
	%52 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%53 = load %mem.Raw_Map*, %mem.Raw_Map** %52, align 8
	%54 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %53, i64 0
	%55 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %54, i64 0, i32 1
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 3
	%57 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %56, i64 0, i32 0
	%58 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %57, align 8
	%59 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %58, zeroinitializer
	%60 = zext i1 %59 to i8
	%61 = trunc i8 %60 to i1
	br i1 %61, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; SelectorExpr
	%62 = getelementptr inbounds %runtime.Context, %runtime.Context* %3, i64 0, i32 0
	; SelectorExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%64 = load %mem.Raw_Map*, %mem.Raw_Map** %63, align 8
	%65 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %65, i64 0, i32 1
	%67 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %66, i64 0, i32 3
	%68 = load %mem.Allocator, %mem.Allocator* %67, align 8
	store %mem.Allocator %68, %mem.Allocator* %62
	br label %if.done-2

if.done-2:
	; AssignStmt
	%69 = load %runtime.Context, %runtime.Context* %3, align 8
	%70 = load %runtime.Context, %runtime.Context* %__.context_ptr, align 8
	%71 = bitcast %runtime.Context* %4 to %..rawptr
	%72 = call %..rawptr @mem.zero(%..rawptr %71, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %4
	store %runtime.Context %70, %runtime.Context* %4
	store %runtime.Context %69, %runtime.Context* %4
	; SelectorExpr
	%73 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %2, i64 0, i32 1
	%74 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 2
	%75 = load i64, i64* %74, align 8
	%76 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 3
	%77 = load i64, i64* %76, align 8
	; SelectorExpr
	; SelectorExpr
	%78 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%79 = load %mem.Raw_Map*, %mem.Raw_Map** %78, align 8
	%80 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %79, i64 0
	%81 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %80, i64 0, i32 1
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0, i32 1
	%83 = load i64, i64* %82, align 8
	%84 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%85 = bitcast %mem.Raw_Dynamic_Array* %73 to %..rawptr
	%86 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location %84, %runtime.Source_Code_Location* %5
	%88 = call i8 @runtime.__dynamic_array_reserve(%..rawptr %85, i64 %75, i64 %77, i64 %83, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %4)
	; SelectorExpr
	%89 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %2, i64 0, i32 0
	%90 = load i64, i64* %0, align 8
	; SelectorExpr
	; SelectorExpr
	%91 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%92 = load %mem.Raw_Map*, %mem.Raw_Map** %91, align 8
	%93 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %92, i64 0
	%94 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %93, i64 0, i32 1
	%95 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %94, i64 0, i32 3
	%96 = load %mem.Allocator, %mem.Allocator* %95, align 8
	%97 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%98 = bitcast %mem.Allocator* %6 to %..rawptr
	%99 = call %..rawptr @mem.zero(%..rawptr %98, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %6
	store %mem.Allocator %96, %mem.Allocator* %6
	%100 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%101 = call %..rawptr @mem.zero(%..rawptr %100, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location %97, %runtime.Source_Code_Location* %7
	%102 = call i8 @runtime.__slice_resize-14067({i64*, i64}* %89, i64 %90, %mem.Allocator* %6, %runtime.Source_Code_Location* %7, %runtime.Context* noalias nonnull nocapture inreg %4)
	; RangeStmt
	; i
	%103 = bitcast i64* %8 to %..rawptr
	%104 = call %..rawptr @mem.zero(%..rawptr %103, i64 8) noinline
	store i64 zeroinitializer, i64* %8
	%105 = bitcast i64* %9 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 8) noinline
	store i64 zeroinitializer, i64* %9
	store i64 0, i64* %9
	%107 = bitcast i64* %10 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 8) noinline
	store i64 zeroinitializer, i64* %10
	store i64 0, i64* %10
	br label %for.interval.loop-3

for.interval.loop-3:
	%109 = load i64, i64* %0, align 8
	%110 = sub i64 %109, 1
	%111 = load i64, i64* %9, align 8
	%112 = icmp sle i64 %111, %110
	br i1 %112, label %for.interval.body-4, label %for.interval.done-5

for.interval.body-4:
	%113 = load i64, i64* %9, align 8
	%114 = load i64, i64* %10, align 8
	%115 = load i64, i64* %9, align 8
	%116 = add i64 %115, 1
	store i64 %116, i64* %9
	%117 = load i64, i64* %10, align 8
	%118 = add i64 %117, 1
	store i64 %118, i64* %10
	store i64 %113, i64* %8
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%119 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %2, i64 0, i32 0
	%120 = load {i64*, i64}, {i64*, i64}* %119, align 8
	%121 = extractvalue {i64*, i64} %120, 0
	%122 = load i64, i64* %8, align 8
	%123 = extractvalue {i64*, i64} %120, 1
	%124 = getelementptr inbounds i64, i64* %121, i64 %122
	store i64 -1, i64* %124
	br label %for.interval.loop-3

for.interval.done-5:
	; RangeStmt
	; i
	%125 = bitcast i64* %11 to %..rawptr
	%126 = call %..rawptr @mem.zero(%..rawptr %125, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	%127 = bitcast i64* %12 to %..rawptr
	%128 = call %..rawptr @mem.zero(%..rawptr %127, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	store i64 0, i64* %12
	%129 = bitcast i64* %13 to %..rawptr
	%130 = call %..rawptr @mem.zero(%..rawptr %129, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 0, i64* %13
	br label %for.interval.loop-6

for.interval.loop-6:
	; SelectorExpr
	; SelectorExpr
	%131 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%132 = load %mem.Raw_Map*, %mem.Raw_Map** %131, align 8
	%133 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %132, i64 0
	%134 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %133, i64 0, i32 1
	%135 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %134, i64 0, i32 1
	%136 = load i64, i64* %135, align 8
	%137 = sub i64 %136, 1
	%138 = load i64, i64* %12, align 8
	%139 = icmp sle i64 %138, %137
	br i1 %139, label %for.interval.body-7, label %for.interval.done-15

for.interval.body-7:
	%140 = load i64, i64* %12, align 8
	%141 = load i64, i64* %13, align 8
	%142 = load i64, i64* %12, align 8
	%143 = add i64 %142, 1
	store i64 %143, i64* %12
	%144 = load i64, i64* %13, align 8
	%145 = add i64 %144, 1
	store i64 %145, i64* %13
	store i64 %140, i64* %11
	; IfStmt
	; SelectorExpr
	%146 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %2, i64 0, i32 0
	%147 = load {i64*, i64}, {i64*, i64}* %146, align 8
	%148 = extractvalue {i64*, i64} %147, 1
	%149 = icmp eq i64 %148, 0
	%150 = zext i1 %149 to i8
	%151 = trunc i8 %150 to i1
	br i1 %151, label %if.then-8, label %if.done-9

if.then-8:
	%152 = load %runtime.Map_Header, %runtime.Map_Header* %1, align 8
	%153 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%154 = bitcast %runtime.Map_Header* %14 to %..rawptr
	%155 = call %..rawptr @mem.zero(%..rawptr %154, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %14
	store %runtime.Map_Header %152, %runtime.Map_Header* %14
	%156 = bitcast %runtime.Source_Code_Location* %15 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %15
	store %runtime.Source_Code_Location %153, %runtime.Source_Code_Location* %15
	call void @runtime.__dynamic_map_grow(%runtime.Map_Header* %14, %runtime.Source_Code_Location* %15, %runtime.Context* noalias nonnull nocapture inreg %4)
	br label %if.done-9

if.done-9:
	; entry_header
	%158 = load %runtime.Map_Header, %runtime.Map_Header* %header, align 8
	%159 = load i64, i64* %11, align 8
	%160 = bitcast %runtime.Map_Header* %17 to %..rawptr
	%161 = call %..rawptr @mem.zero(%..rawptr %160, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %17
	store %runtime.Map_Header %158, %runtime.Map_Header* %17
	%162 = call %runtime.Map_Entry_Header* @runtime.__dynamic_map_get_entry(%runtime.Map_Header* %17, i64 %159, %runtime.Context* noalias nonnull nocapture inreg %4)
	store %runtime.Map_Entry_Header* %162, %runtime.Map_Entry_Header** %16
	; data
	%163 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %16, align 8
	%164 = ptrtoint %runtime.Map_Entry_Header* %163 to i64
	store i64 %164, i64* %18
	; fr
	%165 = load %runtime.Map_Header, %runtime.Map_Header* %1, align 8
	; SelectorExpr
	%166 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %16, align 8
	%167 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %166, i64 0
	%168 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %167, i64 0, i32 0
	%169 = load %runtime.Map_Key, %runtime.Map_Key* %168, align 8
	%170 = bitcast %runtime.Map_Header* %20 to %..rawptr
	%171 = call %..rawptr @mem.zero(%..rawptr %170, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %20
	store %runtime.Map_Header %165, %runtime.Map_Header* %20
	%172 = bitcast %runtime.Map_Key* %21 to %..rawptr
	%173 = call %..rawptr @mem.zero(%..rawptr %172, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %21
	store %runtime.Map_Key %169, %runtime.Map_Key* %21
	%174 = call %runtime.Map_Find_Result @runtime.__dynamic_map_find(%runtime.Map_Header* %20, %runtime.Map_Key* %21, %runtime.Context* noalias nonnull nocapture inreg %4)
	store %runtime.Map_Find_Result %174, %runtime.Map_Find_Result* %19
	; j
	%175 = load %runtime.Map_Header, %runtime.Map_Header* %1, align 8
	; SelectorExpr
	%176 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %16, align 8
	%177 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %176, i64 0
	%178 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %177, i64 0, i32 0
	%179 = load %runtime.Map_Key, %runtime.Map_Key* %178, align 8
	%180 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%181 = bitcast %runtime.Map_Header* %23 to %..rawptr
	%182 = call %..rawptr @mem.zero(%..rawptr %181, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %23
	store %runtime.Map_Header %175, %runtime.Map_Header* %23
	%183 = bitcast %runtime.Map_Key* %24 to %..rawptr
	%184 = call %..rawptr @mem.zero(%..rawptr %183, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %24
	store %runtime.Map_Key %179, %runtime.Map_Key* %24
	%185 = bitcast %runtime.Source_Code_Location* %25 to %..rawptr
	%186 = call %..rawptr @mem.zero(%..rawptr %185, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %25
	store %runtime.Source_Code_Location %180, %runtime.Source_Code_Location* %25
	%187 = call i64 @runtime.__dynamic_map_add_entry(%runtime.Map_Header* %23, %runtime.Map_Key* %24, %runtime.Source_Code_Location* %25, %runtime.Context* noalias nonnull nocapture inreg %4)
	store i64 %187, i64* %22
	; IfStmt
	; SelectorExpr
	%188 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %19, i64 0, i32 1
	%189 = load i64, i64* %188, align 8
	%190 = icmp slt i64 %189, 0
	%191 = zext i1 %190 to i8
	%192 = trunc i8 %191 to i1
	br i1 %192, label %if.then-10, label %if.else-11

if.then-10:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%193 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %2, i64 0, i32 0
	%194 = load {i64*, i64}, {i64*, i64}* %193, align 8
	%195 = extractvalue {i64*, i64} %194, 0
	; SelectorExpr
	%196 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %19, i64 0, i32 0
	%197 = load i64, i64* %196, align 8
	%198 = extractvalue {i64*, i64} %194, 1
	%199 = getelementptr inbounds i64, i64* %195, i64 %197
	%200 = load i64, i64* %22, align 8
	store i64 %200, i64* %199
	br label %if.done-12

if.else-11:
	; e
	%201 = load %runtime.Map_Header, %runtime.Map_Header* %1, align 8
	; SelectorExpr
	%202 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %19, i64 0, i32 1
	%203 = load i64, i64* %202, align 8
	%204 = bitcast %runtime.Map_Header* %27 to %..rawptr
	%205 = call %..rawptr @mem.zero(%..rawptr %204, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %27
	store %runtime.Map_Header %201, %runtime.Map_Header* %27
	%206 = call %runtime.Map_Entry_Header* @runtime.__dynamic_map_get_entry(%runtime.Map_Header* %27, i64 %203, %runtime.Context* noalias nonnull nocapture inreg %4)
	store %runtime.Map_Entry_Header* %206, %runtime.Map_Entry_Header** %26
	; AssignStmt
	; SelectorExpr
	%207 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %26, align 8
	%208 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %207, i64 0
	%209 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %208, i64 0, i32 1
	%210 = load i64, i64* %22, align 8
	store i64 %210, i64* %209
	br label %if.done-12

if.done-12:
	; e
	%211 = load %runtime.Map_Header, %runtime.Map_Header* %1, align 8
	%212 = load i64, i64* %22, align 8
	%213 = bitcast %runtime.Map_Header* %29 to %..rawptr
	%214 = call %..rawptr @mem.zero(%..rawptr %213, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %29
	store %runtime.Map_Header %211, %runtime.Map_Header* %29
	%215 = call %runtime.Map_Entry_Header* @runtime.__dynamic_map_get_entry(%runtime.Map_Header* %29, i64 %212, %runtime.Context* noalias nonnull nocapture inreg %4)
	store %runtime.Map_Entry_Header* %215, %runtime.Map_Entry_Header** %28
	; AssignStmt
	; SelectorExpr
	%216 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %28, align 8
	%217 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %216, i64 0
	%218 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %217, i64 0, i32 1
	; SelectorExpr
	%219 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %19, i64 0, i32 2
	%220 = load i64, i64* %219, align 8
	store i64 %220, i64* %218
	; ndata
	%221 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %28, align 8
	%222 = ptrtoint %runtime.Map_Entry_Header* %221 to i64
	store i64 %222, i64* %30
	; SelectorExpr
	%223 = load i64, i64* %30, align 8
	%224 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 4
	%225 = load i64, i64* %224, align 8
	%226 = add i64 %223, %225
	%227 = inttoptr i64 %226 to %..rawptr
	%228 = load i64, i64* %18, align 8
	%229 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 4
	%230 = load i64, i64* %229, align 8
	%231 = add i64 %228, %230
	%232 = inttoptr i64 %231 to %..rawptr
	%233 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 5
	%234 = load i64, i64* %233, align 8
	%235 = call %..rawptr @mem.copy(%..rawptr %227, %..rawptr %232, i64 %234)
	; IfStmt
	%236 = load %runtime.Map_Header, %runtime.Map_Header* %1, align 8
	%237 = bitcast %runtime.Map_Header* %31 to %..rawptr
	%238 = call %..rawptr @mem.zero(%..rawptr %237, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %31
	store %runtime.Map_Header %236, %runtime.Map_Header* %31
	%239 = call i8 @runtime.__dynamic_map_full(%runtime.Map_Header* %31, %runtime.Context* noalias nonnull nocapture inreg %4)
	%240 = trunc i8 %239 to i1
	br i1 %240, label %if.then-13, label %if.done-14

if.then-13:
	%241 = load %runtime.Map_Header, %runtime.Map_Header* %1, align 8
	%242 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%243 = bitcast %runtime.Map_Header* %32 to %..rawptr
	%244 = call %..rawptr @mem.zero(%..rawptr %243, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %32
	store %runtime.Map_Header %241, %runtime.Map_Header* %32
	%245 = bitcast %runtime.Source_Code_Location* %33 to %..rawptr
	%246 = call %..rawptr @mem.zero(%..rawptr %245, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %33
	store %runtime.Source_Code_Location %242, %runtime.Source_Code_Location* %33
	call void @runtime.__dynamic_map_grow(%runtime.Map_Header* %32, %runtime.Source_Code_Location* %33, %runtime.Context* noalias nonnull nocapture inreg %4)
	br label %if.done-14

if.done-14:
	br label %for.interval.loop-6

for.interval.done-15:
	; SelectorExpr
	%247 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%248 = load %mem.Raw_Map*, %mem.Raw_Map** %247, align 8
	%249 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %248, i64 0
	%250 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %249, i64 0, i32 0
	%251 = load {i64*, i64}, {i64*, i64}* %250, align 8
	; SelectorExpr
	; SelectorExpr
	%252 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%253 = load %mem.Raw_Map*, %mem.Raw_Map** %252, align 8
	%254 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %253, i64 0
	%255 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %254, i64 0, i32 1
	%256 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %255, i64 0, i32 3
	%257 = load %mem.Allocator, %mem.Allocator* %256, align 8
	%258 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%259 = bitcast {i64*, i64}* %34 to %..rawptr
	%260 = call %..rawptr @mem.zero(%..rawptr %259, i64 16) noinline
	store {i64*, i64} zeroinitializer, {i64*, i64}* %34
	store {i64*, i64} %251, {i64*, i64}* %34
	%261 = bitcast %mem.Allocator* %35 to %..rawptr
	%262 = call %..rawptr @mem.zero(%..rawptr %261, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %35
	store %mem.Allocator %257, %mem.Allocator* %35
	%263 = bitcast %runtime.Source_Code_Location* %36 to %..rawptr
	%264 = call %..rawptr @mem.zero(%..rawptr %263, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %36
	store %runtime.Source_Code_Location %258, %runtime.Source_Code_Location* %36
	call void @mem.delete_slice-14104({i64*, i64}* %34, %mem.Allocator* %35, %runtime.Source_Code_Location* %36, %runtime.Context* noalias nonnull nocapture inreg %4)
	; SelectorExpr
	; SelectorExpr
	%265 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%266 = load %mem.Raw_Map*, %mem.Raw_Map** %265, align 8
	%267 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %266, i64 0
	%268 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %267, i64 0, i32 1
	%269 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %268, i64 0, i32 0
	%270 = load %..rawptr, %..rawptr* %269, align 8
	; SelectorExpr
	; SelectorExpr
	%271 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%272 = load %mem.Raw_Map*, %mem.Raw_Map** %271, align 8
	%273 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %272, i64 0
	%274 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %273, i64 0, i32 1
	%275 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %274, i64 0, i32 3
	%276 = load %mem.Allocator, %mem.Allocator* %275, align 8
	%277 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%278 = bitcast %mem.Allocator* %37 to %..rawptr
	%279 = call %..rawptr @mem.zero(%..rawptr %278, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %37
	store %mem.Allocator %276, %mem.Allocator* %37
	%280 = bitcast %runtime.Source_Code_Location* %38 to %..rawptr
	%281 = call %..rawptr @mem.zero(%..rawptr %280, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %38
	store %runtime.Source_Code_Location %277, %runtime.Source_Code_Location* %38
	call void @mem.free(%..rawptr %270, %mem.Allocator* %37, %runtime.Source_Code_Location* %38, %runtime.Context* noalias nonnull nocapture inreg %4)
	; AssignStmt
	; SelectorExpr
	%282 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %header, i64 0, i32 0
	%283 = load %mem.Raw_Map*, %mem.Raw_Map** %282, align 8
	%284 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %283, i64 0
	%285 = load %mem.Raw_Map, %mem.Raw_Map* %2, align 8
	store %mem.Raw_Map %285, %mem.Raw_Map* %284
	ret void
}

define %..rawptr @runtime.__dynamic_map_get(%runtime.Map_Header* %h, %runtime.Map_Key* %key, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Map_Header, align 16
	%2 = alloca %runtime.Map_Key, align 16
	%3 = alloca %runtime.Map_Find_Result, align 16
	%4 = alloca i64, align 16
	%5 = alloca %runtime.Map_Header, align 16
	%6 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%7 = load %runtime.Map_Key, %runtime.Map_Key* %key, align 8
	; index
	; SelectorExpr
	%8 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%9 = load %runtime.Map_Key, %runtime.Map_Key* %key, align 8
	%10 = bitcast %runtime.Map_Header* %1 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %1
	store %runtime.Map_Header %8, %runtime.Map_Header* %1
	%12 = bitcast %runtime.Map_Key* %2 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %2
	store %runtime.Map_Key %9, %runtime.Map_Key* %2
	%14 = call %runtime.Map_Find_Result @runtime.__dynamic_map_find(%runtime.Map_Header* %1, %runtime.Map_Key* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = bitcast %runtime.Map_Find_Result* %3 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 24) noinline
	store %runtime.Map_Find_Result zeroinitializer, %runtime.Map_Find_Result* %3
	store %runtime.Map_Find_Result %14, %runtime.Map_Find_Result* %3
	%17 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %3, i64 0, i32 2
	%18 = load i64, i64* %17, align 8
	store i64 %18, i64* %0
	; IfStmt
	%19 = load i64, i64* %0, align 8
	%20 = icmp sge i64 %19, 0
	%21 = zext i1 %20 to i8
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.done-2

if.then-1:
	; data
	%23 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%24 = load i64, i64* %0, align 8
	%25 = bitcast %runtime.Map_Header* %5 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %5
	store %runtime.Map_Header %23, %runtime.Map_Header* %5
	%27 = call %runtime.Map_Entry_Header* @runtime.__dynamic_map_get_entry(%runtime.Map_Header* %5, i64 %24, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%28 = ptrtoint %runtime.Map_Entry_Header* %27 to i64
	store i64 %28, i64* %4
	; ReturnStmt
	%29 = load i64, i64* %4, align 8
	; SelectorExpr
	%30 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 4
	%31 = load i64, i64* %30, align 8
	%32 = add i64 %29, %31
	%33 = inttoptr i64 %32 to %..rawptr
	ret %..rawptr %33

if.done-2:
	; ReturnStmt
	ret %..rawptr zeroinitializer
}

define void @runtime.__dynamic_map_set(%runtime.Map_Header* %h, %runtime.Map_Key* %key, %..rawptr %value, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %runtime.Map_Header, align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	%5 = alloca %runtime.Map_Header, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca %runtime.Map_Find_Result, align 16
	%8 = alloca %runtime.Map_Header, align 16
	%9 = alloca %runtime.Map_Key, align 16
	%10 = alloca %runtime.Map_Header, align 16
	%11 = alloca %runtime.Map_Key, align 16
	%12 = alloca %runtime.Source_Code_Location, align 16
	%13 = alloca %runtime.Map_Entry_Header*, align 16
	%14 = alloca %runtime.Map_Header, align 16
	%15 = alloca %runtime.Map_Entry_Header*, align 16
	%16 = alloca %runtime.Map_Header, align 16
	%17 = alloca i8*, align 16
	%18 = alloca %runtime.Map_Header, align 16
	%19 = alloca %runtime.Map_Header, align 16
	%20 = alloca %runtime.Source_Code_Location, align 16
	%21 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%22 = load %runtime.Map_Key, %runtime.Map_Key* %key, align 8
	store %..rawptr %value, %..rawptr* %0
	%23 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; index
	%24 = bitcast i64* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 8) noinline
	store i64 zeroinitializer, i64* %1
	%26 = load %..rawptr, %..rawptr* %0, align 8
	%27 = icmp ne %..rawptr %26, zeroinitializer
	%28 = zext i1 %27 to i8
	%29 = trunc i8 %28 to i1
	%30 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$5d, i64 0, i32 0), i64 58}, i64 895, i64 2, %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$5e, i64 0, i32 0), i64 17}}, %runtime.Source_Code_Location* %2
	%32 = call i8 @runtime.assert(i1 %29, %..string zeroinitializer, %runtime.Source_Code_Location* %2)
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%33 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%34 = load %mem.Raw_Map*, %mem.Raw_Map** %33, align 8
	%35 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %34, i64 0
	%36 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %35, i64 0, i32 0
	%37 = load {i64*, i64}, {i64*, i64}* %36, align 8
	%38 = extractvalue {i64*, i64} %37, 1
	%39 = icmp eq i64 %38, 0
	%40 = zext i1 %39 to i8
	%41 = trunc i8 %40 to i1
	br i1 %41, label %if.then-1, label %if.done-2

if.then-1:
	%42 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%43 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%44 = bitcast %runtime.Map_Header* %3 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %3
	store %runtime.Map_Header %42, %runtime.Map_Header* %3
	%46 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	%47 = call %..rawptr @mem.zero(%..rawptr %46, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location %43, %runtime.Source_Code_Location* %4
	call void @runtime.__dynamic_map_reserve(%runtime.Map_Header* %3, i64 16, %runtime.Source_Code_Location* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%48 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%49 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%50 = bitcast %runtime.Map_Header* %5 to %..rawptr
	%51 = call %..rawptr @mem.zero(%..rawptr %50, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %5
	store %runtime.Map_Header %48, %runtime.Map_Header* %5
	%52 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location %49, %runtime.Source_Code_Location* %6
	call void @runtime.__dynamic_map_grow(%runtime.Map_Header* %5, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-2

if.done-2:
	; fr
	%54 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%55 = load %runtime.Map_Key, %runtime.Map_Key* %key, align 8
	%56 = bitcast %runtime.Map_Header* %8 to %..rawptr
	%57 = call %..rawptr @mem.zero(%..rawptr %56, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %8
	store %runtime.Map_Header %54, %runtime.Map_Header* %8
	%58 = bitcast %runtime.Map_Key* %9 to %..rawptr
	%59 = call %..rawptr @mem.zero(%..rawptr %58, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %9
	store %runtime.Map_Key %55, %runtime.Map_Key* %9
	%60 = call %runtime.Map_Find_Result @runtime.__dynamic_map_find(%runtime.Map_Header* %8, %runtime.Map_Key* %9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %runtime.Map_Find_Result %60, %runtime.Map_Find_Result* %7
	; IfStmt
	; SelectorExpr
	%61 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %7, i64 0, i32 2
	%62 = load i64, i64* %61, align 8
	%63 = icmp sge i64 %62, 0
	%64 = zext i1 %63 to i8
	%65 = trunc i8 %64 to i1
	br i1 %65, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	; SelectorExpr
	%66 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %7, i64 0, i32 2
	%67 = load i64, i64* %66, align 8
	store i64 %67, i64* %1
	br label %if.done-8

if.else-4:
	; AssignStmt
	%68 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%69 = load %runtime.Map_Key, %runtime.Map_Key* %key, align 8
	%70 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%71 = bitcast %runtime.Map_Header* %10 to %..rawptr
	%72 = call %..rawptr @mem.zero(%..rawptr %71, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %10
	store %runtime.Map_Header %68, %runtime.Map_Header* %10
	%73 = bitcast %runtime.Map_Key* %11 to %..rawptr
	%74 = call %..rawptr @mem.zero(%..rawptr %73, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %11
	store %runtime.Map_Key %69, %runtime.Map_Key* %11
	%75 = bitcast %runtime.Source_Code_Location* %12 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %12
	store %runtime.Source_Code_Location %70, %runtime.Source_Code_Location* %12
	%77 = call i64 @runtime.__dynamic_map_add_entry(%runtime.Map_Header* %10, %runtime.Map_Key* %11, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %77, i64* %1
	; IfStmt
	; SelectorExpr
	%78 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %7, i64 0, i32 1
	%79 = load i64, i64* %78, align 8
	%80 = icmp sge i64 %79, 0
	%81 = zext i1 %80 to i8
	%82 = trunc i8 %81 to i1
	br i1 %82, label %if.then-5, label %if.else-6

if.then-5:
	; entry
	%83 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	; SelectorExpr
	%84 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %7, i64 0, i32 1
	%85 = load i64, i64* %84, align 8
	%86 = bitcast %runtime.Map_Header* %14 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %14
	store %runtime.Map_Header %83, %runtime.Map_Header* %14
	%88 = call %runtime.Map_Entry_Header* @runtime.__dynamic_map_get_entry(%runtime.Map_Header* %14, i64 %85, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %runtime.Map_Entry_Header* %88, %runtime.Map_Entry_Header** %13
	; AssignStmt
	; SelectorExpr
	%89 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %13, align 8
	%90 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %89, i64 0
	%91 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %90, i64 0, i32 1
	%92 = load i64, i64* %1, align 8
	store i64 %92, i64* %91
	br label %if.done-7

if.else-6:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	; SelectorExpr
	%93 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%94 = load %mem.Raw_Map*, %mem.Raw_Map** %93, align 8
	%95 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %94, i64 0
	%96 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %95, i64 0, i32 0
	%97 = load {i64*, i64}, {i64*, i64}* %96, align 8
	%98 = extractvalue {i64*, i64} %97, 0
	; SelectorExpr
	%99 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %7, i64 0, i32 0
	%100 = load i64, i64* %99, align 8
	%101 = extractvalue {i64*, i64} %97, 1
	%102 = getelementptr inbounds i64, i64* %98, i64 %100
	%103 = load i64, i64* %1, align 8
	store i64 %103, i64* %102
	br label %if.done-7

if.done-7:
	br label %if.done-8

if.done-8:
	; e
	%104 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%105 = load i64, i64* %1, align 8
	%106 = bitcast %runtime.Map_Header* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %16
	store %runtime.Map_Header %104, %runtime.Map_Header* %16
	%108 = call %runtime.Map_Entry_Header* @runtime.__dynamic_map_get_entry(%runtime.Map_Header* %16, i64 %105, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %runtime.Map_Entry_Header* %108, %runtime.Map_Entry_Header** %15
	; AssignStmt
	; SelectorExpr
	%109 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %15, align 8
	%110 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %109, i64 0
	%111 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %110, i64 0, i32 0
	%112 = load %runtime.Map_Key, %runtime.Map_Key* %key, align 8
	store %runtime.Map_Key %112, %runtime.Map_Key* %111
	; val
	%113 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %15, align 8
	%114 = ptrtoint %runtime.Map_Entry_Header* %113 to i64
	; SelectorExpr
	%115 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 4
	%116 = load i64, i64* %115, align 8
	%117 = add i64 %114, %116
	%118 = inttoptr i64 %117 to i8*
	store i8* %118, i8** %17
	; SelectorExpr
	%119 = load i8*, i8** %17, align 8
	%120 = load %..rawptr, %..rawptr* %0, align 8
	; SelectorExpr
	%121 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 5
	%122 = load i64, i64* %121, align 8
	%123 = bitcast i8* %119 to %..rawptr
	%124 = call %..rawptr @mem.copy(%..rawptr %123, %..rawptr %120, i64 %122)
	; IfStmt
	%125 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%126 = bitcast %runtime.Map_Header* %18 to %..rawptr
	%127 = call %..rawptr @mem.zero(%..rawptr %126, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %18
	store %runtime.Map_Header %125, %runtime.Map_Header* %18
	%128 = call i8 @runtime.__dynamic_map_full(%runtime.Map_Header* %18, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%129 = trunc i8 %128 to i1
	br i1 %129, label %if.then-9, label %if.done-10

if.then-9:
	%130 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%131 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%132 = bitcast %runtime.Map_Header* %19 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %19
	store %runtime.Map_Header %130, %runtime.Map_Header* %19
	%134 = bitcast %runtime.Source_Code_Location* %20 to %..rawptr
	%135 = call %..rawptr @mem.zero(%..rawptr %134, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %20
	store %runtime.Source_Code_Location %131, %runtime.Source_Code_Location* %20
	call void @runtime.__dynamic_map_grow(%runtime.Map_Header* %19, %runtime.Source_Code_Location* %20, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-10

if.done-10:
	ret void
}

define void @runtime.__dynamic_map_grow(%runtime.Map_Header* %h, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Map_Header, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%4 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; new_count
	; max
	; SelectorExpr
	; SelectorExpr
	%5 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%6 = load %mem.Raw_Map*, %mem.Raw_Map** %5, align 8
	%7 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %6, i64 0
	%8 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %7, i64 0, i32 1
	%9 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %8, i64 0, i32 2
	%10 = load i64, i64* %9, align 8
	%11 = mul i64 4, %10
	%12 = add i64 %11, 7
	%13 = icmp sgt i64 %12, 16
	%14 = select i1 %13, i64 %12, i64 16
	store i64 %14, i64* %0
	%15 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%16 = load i64, i64* %0, align 8
	%17 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%18 = bitcast %runtime.Map_Header* %1 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %1
	store %runtime.Map_Header %15, %runtime.Map_Header* %1
	%20 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %17, %runtime.Source_Code_Location* %2
	call void @runtime.__dynamic_map_rehash(%runtime.Map_Header* %1, i64 %16, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define i8 @runtime.__dynamic_map_full(%runtime.Map_Header* %h, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	; ReturnStmt
	; SelectorExpr
	%1 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%2 = load %mem.Raw_Map*, %mem.Raw_Map** %1, align 8
	%3 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %2, i64 0
	%4 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %3, i64 0, i32 0
	%5 = load {i64*, i64}, {i64*, i64}* %4, align 8
	%6 = extractvalue {i64*, i64} %5, 1
	%7 = sitofp i64 %6 to double
	%8 = fmul double 0x3fe8000000000000, %7
	%9 = fptosi double %8 to i64
	; SelectorExpr
	; SelectorExpr
	%10 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%11 = load %mem.Raw_Map*, %mem.Raw_Map** %10, align 8
	%12 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %11, i64 0
	%13 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %12, i64 0, i32 1
	%14 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %13, i64 0, i32 2
	%15 = load i64, i64* %14, align 8
	%16 = icmp sle i64 %9, %15
	%17 = zext i1 %16 to i8
	ret i8 %17
}

define i8 @runtime.__dynamic_map_hash_equal(%runtime.Map_Header* %h, %runtime.Map_Key* %a, %runtime.Map_Key* %b, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%1 = load %runtime.Map_Key, %runtime.Map_Key* %a, align 8
	%2 = load %runtime.Map_Key, %runtime.Map_Key* %b, align 8
	; IfStmt
	; SelectorExpr
	%3 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %a, i64 0, i32 0
	%4 = load i64, i64* %3, align 8
	; SelectorExpr
	%5 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %b, i64 0, i32 0
	%6 = load i64, i64* %5, align 8
	%7 = icmp eq i64 %4, %6
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	br i1 %9, label %if.then-1, label %if.done-4

if.then-1:
	; IfStmt
	; SelectorExpr
	%10 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 1
	%11 = load i8, i8* %10, align 1
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	; SelectorExpr
	%13 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %a, i64 0, i32 1
	%14 = load %..string, %..string* %13, align 8
	; SelectorExpr
	%15 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %b, i64 0, i32 1
	%16 = load %..string, %..string* %15, align 8
	%17 = call i8 @runtime.string_eq(%..string %14, %..string %16)
	ret i8 %17

if.done-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; ReturnStmt
	ret i8 0
}

define %runtime.Map_Find_Result @runtime.__dynamic_map_find(%runtime.Map_Header* %h, %runtime.Map_Key* %key, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Map_Find_Result, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Map_Entry_Header*, align 16
	%3 = alloca %runtime.Map_Header, align 16
	%4 = alloca %runtime.Map_Header, align 16
	%5 = alloca %runtime.Map_Key, align 16
	%6 = alloca %runtime.Map_Key, align 16
	%7 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%8 = load %runtime.Map_Key, %runtime.Map_Key* %key, align 8
	; fr
	store %runtime.Map_Find_Result {i64 -1, i64 -1, i64 -1}, %runtime.Map_Find_Result* %0
	; IfStmt
	; n
	; SelectorExpr
	%9 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%10 = load %mem.Raw_Map*, %mem.Raw_Map** %9, align 8
	%11 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %10, i64 0
	%12 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %11, i64 0, i32 0
	%13 = load {i64*, i64}, {i64*, i64}* %12, align 8
	%14 = extractvalue {i64*, i64} %13, 1
	%15 = bitcast i64 %14 to i64
	store i64 %15, i64* %1
	%16 = load i64, i64* %1, align 8
	%17 = icmp ugt i64 %16, 0
	%18 = zext i1 %17 to i8
	%19 = trunc i8 %18 to i1
	br i1 %19, label %if.then-1, label %if.done-7

if.then-1:
	; AssignStmt
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %0, i64 0, i32 0
	; SelectorExpr
	%21 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %key, i64 0, i32 0
	%22 = load i64, i64* %21, align 8
	%23 = load i64, i64* %1, align 8
	%24 = urem i64 %22, %23
	%25 = bitcast i64 %24 to i64
	store i64 %25, i64* %20
	; AssignStmt
	; SelectorExpr
	%26 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %0, i64 0, i32 2
	; IndexExpr
	; SelectorExpr
	%27 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%28 = load %mem.Raw_Map*, %mem.Raw_Map** %27, align 8
	%29 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %28, i64 0
	%30 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %29, i64 0, i32 0
	%31 = load {i64*, i64}, {i64*, i64}* %30, align 8
	%32 = extractvalue {i64*, i64} %31, 0
	; SelectorExpr
	%33 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %0, i64 0, i32 0
	%34 = load i64, i64* %33, align 8
	%35 = extractvalue {i64*, i64} %31, 1
	%36 = getelementptr inbounds i64, i64* %32, i64 %34
	%37 = load i64, i64* %36, align 8
	store i64 %37, i64* %26
	; ForStmt
	br label %for.loop-2

for.loop-2:
	; SelectorExpr
	%38 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %0, i64 0, i32 2
	%39 = load i64, i64* %38, align 8
	%40 = icmp sge i64 %39, 0
	%41 = zext i1 %40 to i8
	%42 = trunc i8 %41 to i1
	br i1 %42, label %for.body-3, label %for.done-6

for.body-3:
	; entry
	%43 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	; SelectorExpr
	%44 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %0, i64 0, i32 2
	%45 = load i64, i64* %44, align 8
	%46 = bitcast %runtime.Map_Header* %3 to %..rawptr
	%47 = call %..rawptr @mem.zero(%..rawptr %46, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %3
	store %runtime.Map_Header %43, %runtime.Map_Header* %3
	%48 = call %runtime.Map_Entry_Header* @runtime.__dynamic_map_get_entry(%runtime.Map_Header* %3, i64 %45, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %runtime.Map_Entry_Header* %48, %runtime.Map_Entry_Header** %2
	; IfStmt
	%49 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	; SelectorExpr
	%50 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %2, align 8
	%51 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %50, i64 0
	%52 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %51, i64 0, i32 0
	%53 = load %runtime.Map_Key, %runtime.Map_Key* %52, align 8
	%54 = load %runtime.Map_Key, %runtime.Map_Key* %key, align 8
	%55 = bitcast %runtime.Map_Header* %4 to %..rawptr
	%56 = call %..rawptr @mem.zero(%..rawptr %55, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %4
	store %runtime.Map_Header %49, %runtime.Map_Header* %4
	%57 = bitcast %runtime.Map_Key* %5 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %5
	store %runtime.Map_Key %53, %runtime.Map_Key* %5
	%59 = bitcast %runtime.Map_Key* %6 to %..rawptr
	%60 = call %..rawptr @mem.zero(%..rawptr %59, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %6
	store %runtime.Map_Key %54, %runtime.Map_Key* %6
	%61 = call i8 @runtime.__dynamic_map_hash_equal(%runtime.Map_Header* %4, %runtime.Map_Key* %5, %runtime.Map_Key* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-4, label %if.done-5

if.then-4:
	; ReturnStmt
	%63 = load %runtime.Map_Find_Result, %runtime.Map_Find_Result* %0, align 8
	ret %runtime.Map_Find_Result %63

if.done-5:
	; AssignStmt
	; SelectorExpr
	%64 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %0, i64 0, i32 1
	; SelectorExpr
	%65 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %0, i64 0, i32 2
	%66 = load i64, i64* %65, align 8
	store i64 %66, i64* %64
	; AssignStmt
	; SelectorExpr
	%67 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %0, i64 0, i32 2
	; SelectorExpr
	%68 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %2, align 8
	%69 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %68, i64 0
	%70 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %69, i64 0, i32 1
	%71 = load i64, i64* %70, align 8
	store i64 %71, i64* %67
	br label %for.loop-2

for.done-6:
	br label %if.done-7

if.done-7:
	; ReturnStmt
	%72 = load %runtime.Map_Find_Result, %runtime.Map_Find_Result* %0, align 8
	ret %runtime.Map_Find_Result %72
}

define i64 @runtime.__dynamic_map_add_entry(%runtime.Map_Header* %h, %runtime.Map_Key* %key, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %runtime.Map_Entry_Header*, align 16
	%4 = alloca %runtime.Map_Header, align 16
	%5 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%6 = load %runtime.Map_Key, %runtime.Map_Key* %key, align 8
	%7 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; prev
	; SelectorExpr
	; SelectorExpr
	%8 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%9 = load %mem.Raw_Map*, %mem.Raw_Map** %8, align 8
	%10 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %9, i64 0
	%11 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %10, i64 0, i32 1
	%12 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %11, i64 0, i32 1
	%13 = load i64, i64* %12, align 8
	store i64 %13, i64* %0
	; c
	; SelectorExpr
	%14 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%15 = load %mem.Raw_Map*, %mem.Raw_Map** %14, align 8
	%16 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %15, i64 0
	%17 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %16, i64 0, i32 1
	%18 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 2
	%19 = load i64, i64* %18, align 8
	%20 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 3
	%21 = load i64, i64* %20, align 8
	%22 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%23 = bitcast %mem.Raw_Dynamic_Array* %17 to %..rawptr
	%24 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %22, %runtime.Source_Code_Location* %2
	%26 = call i64 @runtime.__dynamic_array_append_nothing(%..rawptr %23, i64 %19, i64 %21, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %26, i64* %1
	; IfStmt
	%27 = load i64, i64* %1, align 8
	%28 = load i64, i64* %0, align 8
	%29 = icmp ne i64 %27, %28
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-1, label %if.done-2

if.then-1:
	; end
	%32 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%33 = load i64, i64* %1, align 8
	%34 = sub i64 %33, 1
	%35 = bitcast %runtime.Map_Header* %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %4
	store %runtime.Map_Header %32, %runtime.Map_Header* %4
	%37 = call %runtime.Map_Entry_Header* @runtime.__dynamic_map_get_entry(%runtime.Map_Header* %4, i64 %34, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %runtime.Map_Entry_Header* %37, %runtime.Map_Entry_Header** %3
	; AssignStmt
	; SelectorExpr
	%38 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %3, align 8
	%39 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %38, i64 0
	%40 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %39, i64 0, i32 0
	%41 = load %runtime.Map_Key, %runtime.Map_Key* %key, align 8
	store %runtime.Map_Key %41, %runtime.Map_Key* %40
	; AssignStmt
	; SelectorExpr
	%42 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %3, align 8
	%43 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %42, i64 0
	%44 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %43, i64 0, i32 1
	store i64 -1, i64* %44
	br label %if.done-2

if.done-2:
	; ReturnStmt
	%45 = load i64, i64* %0, align 8
	ret i64 %45
}

define void @runtime.__dynamic_map_delete_key(%runtime.Map_Header* %h, %runtime.Map_Key* %key, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Map_Find_Result, align 16
	%1 = alloca %runtime.Map_Header, align 16
	%2 = alloca %runtime.Map_Key, align 16
	%3 = alloca %runtime.Map_Header, align 16
	%4 = alloca %runtime.Map_Find_Result, align 16
	%5 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%6 = load %runtime.Map_Key, %runtime.Map_Key* %key, align 8
	; fr
	%7 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%8 = load %runtime.Map_Key, %runtime.Map_Key* %key, align 8
	%9 = bitcast %runtime.Map_Header* %1 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %1
	store %runtime.Map_Header %7, %runtime.Map_Header* %1
	%11 = bitcast %runtime.Map_Key* %2 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %2
	store %runtime.Map_Key %8, %runtime.Map_Key* %2
	%13 = call %runtime.Map_Find_Result @runtime.__dynamic_map_find(%runtime.Map_Header* %1, %runtime.Map_Key* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %runtime.Map_Find_Result %13, %runtime.Map_Find_Result* %0
	; IfStmt
	; SelectorExpr
	%14 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %0, i64 0, i32 2
	%15 = load i64, i64* %14, align 8
	%16 = icmp sge i64 %15, 0
	%17 = zext i1 %16 to i8
	%18 = trunc i8 %17 to i1
	br i1 %18, label %if.then-1, label %if.done-2

if.then-1:
	%19 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%20 = load %runtime.Map_Find_Result, %runtime.Map_Find_Result* %0, align 8
	%21 = bitcast %runtime.Map_Header* %3 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %3
	store %runtime.Map_Header %19, %runtime.Map_Header* %3
	%23 = bitcast %runtime.Map_Find_Result* %4 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 24) noinline
	store %runtime.Map_Find_Result zeroinitializer, %runtime.Map_Find_Result* %4
	store %runtime.Map_Find_Result %20, %runtime.Map_Find_Result* %4
	call void @runtime.__dynamic_map_erase(%runtime.Map_Header* %3, %runtime.Map_Find_Result* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-2

if.done-2:
	ret void
}

define %runtime.Map_Entry_Header* @runtime.__dynamic_map_get_entry(%runtime.Map_Header* %h, i64 %index, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	store i64 %index, i64* %0
	%3 = load i64, i64* %0, align 8
	%4 = icmp sle i64 0, %3
	%5 = zext i1 %4 to i8
	%6 = load i64, i64* %0, align 8
	%7 = icmp sle i64 0, %6
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	br i1 %9, label %logical.cmp.rhs-1, label %logical.cmp.done-2

logical.cmp.rhs-1:
	%10 = load i64, i64* %0, align 8
	; SelectorExpr
	; SelectorExpr
	%11 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%12 = load %mem.Raw_Map*, %mem.Raw_Map** %11, align 8
	%13 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %12, i64 0
	%14 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %13, i64 0, i32 1
	%15 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %14, i64 0, i32 1
	%16 = load i64, i64* %15, align 8
	%17 = icmp slt i64 %10, %16
	%18 = zext i1 %17 to i8
	br label %logical.cmp.done-2

logical.cmp.done-2:
	%19 = phi i8 [ 0, %decls-0 ], [ %18, %logical.cmp.rhs-1 ]
	%20 = trunc i8 %19 to i1
	%21 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$5f, i64 0, i32 0), i64 58}, i64 980, i64 2, %..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$60, i64 0, i32 0), i64 23}}, %runtime.Source_Code_Location* %1
	%23 = call i8 @runtime.assert(i1 %20, %..string zeroinitializer, %runtime.Source_Code_Location* %1)
	; ReturnStmt
	; SelectorExpr
	; SelectorExpr
	%24 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%25 = load %mem.Raw_Map*, %mem.Raw_Map** %24, align 8
	%26 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %25, i64 0
	%27 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %26, i64 0, i32 1
	%28 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %27, i64 0, i32 0
	%29 = load %..rawptr, %..rawptr* %28, align 8
	%30 = ptrtoint %..rawptr %29 to i64
	%31 = load i64, i64* %0, align 8
	%32 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 2
	%33 = load i64, i64* %32, align 8
	%34 = mul i64 %31, %33
	%35 = bitcast i64 %34 to i64
	%36 = add i64 %30, %35
	%37 = inttoptr i64 %36 to %runtime.Map_Entry_Header*
	ret %runtime.Map_Entry_Header* %37
}

define void @runtime.__dynamic_map_erase(%runtime.Map_Header* %h, %runtime.Map_Find_Result* %fr, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Map_Header, align 16
	%1 = alloca %runtime.Map_Entry_Header*, align 16
	%2 = alloca %runtime.Map_Entry_Header*, align 16
	%3 = alloca %runtime.Map_Header, align 16
	%4 = alloca %runtime.Map_Entry_Header*, align 16
	%5 = alloca %runtime.Map_Header, align 16
	%6 = alloca %runtime.Map_Entry_Header*, align 16
	%7 = alloca %runtime.Map_Header, align 16
	%8 = alloca %runtime.Map_Entry_Header*, align 16
	%9 = alloca %runtime.Map_Header, align 16
	%10 = alloca %runtime.Map_Find_Result, align 16
	%11 = alloca %runtime.Map_Header, align 16
	%12 = alloca %runtime.Map_Key, align 16
	%13 = alloca %runtime.Map_Entry_Header*, align 16
	%14 = alloca %runtime.Map_Header, align 16
	%15 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	%16 = load %runtime.Map_Find_Result, %runtime.Map_Find_Result* %fr, align 8
	; IfStmt
	; SelectorExpr
	%17 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %fr, i64 0, i32 1
	%18 = load i64, i64* %17, align 8
	%19 = icmp slt i64 %18, 0
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %if.then-1, label %if.else-2

if.then-1:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%22 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%23 = load %mem.Raw_Map*, %mem.Raw_Map** %22, align 8
	%24 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %23, i64 0
	%25 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %24, i64 0, i32 0
	%26 = load {i64*, i64}, {i64*, i64}* %25, align 8
	%27 = extractvalue {i64*, i64} %26, 0
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %fr, i64 0, i32 0
	%29 = load i64, i64* %28, align 8
	%30 = extractvalue {i64*, i64} %26, 1
	%31 = getelementptr inbounds i64, i64* %27, i64 %29
	; SelectorExpr
	%32 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	; SelectorExpr
	%33 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %fr, i64 0, i32 2
	%34 = load i64, i64* %33, align 8
	%35 = bitcast %runtime.Map_Header* %0 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %0
	store %runtime.Map_Header %32, %runtime.Map_Header* %0
	%37 = call %runtime.Map_Entry_Header* @runtime.__dynamic_map_get_entry(%runtime.Map_Header* %0, i64 %34, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%38 = bitcast %runtime.Map_Entry_Header** %1 to %..rawptr
	%39 = call %..rawptr @mem.zero(%..rawptr %38, i64 8) noinline
	store %runtime.Map_Entry_Header* zeroinitializer, %runtime.Map_Entry_Header** %1
	store %runtime.Map_Entry_Header* %37, %runtime.Map_Entry_Header** %1
	%40 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %1, align 8
	%41 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %40, i64 0
	%42 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %41, i64 0, i32 1
	%43 = load i64, i64* %42, align 8
	store i64 %43, i64* %31
	br label %if.done-3

if.else-2:
	; prev
	%44 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	; SelectorExpr
	%45 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %fr, i64 0, i32 1
	%46 = load i64, i64* %45, align 8
	%47 = bitcast %runtime.Map_Header* %3 to %..rawptr
	%48 = call %..rawptr @mem.zero(%..rawptr %47, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %3
	store %runtime.Map_Header %44, %runtime.Map_Header* %3
	%49 = call %runtime.Map_Entry_Header* @runtime.__dynamic_map_get_entry(%runtime.Map_Header* %3, i64 %46, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %runtime.Map_Entry_Header* %49, %runtime.Map_Entry_Header** %2
	; curr
	%50 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	; SelectorExpr
	%51 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %fr, i64 0, i32 2
	%52 = load i64, i64* %51, align 8
	%53 = bitcast %runtime.Map_Header* %5 to %..rawptr
	%54 = call %..rawptr @mem.zero(%..rawptr %53, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %5
	store %runtime.Map_Header %50, %runtime.Map_Header* %5
	%55 = call %runtime.Map_Entry_Header* @runtime.__dynamic_map_get_entry(%runtime.Map_Header* %5, i64 %52, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %runtime.Map_Entry_Header* %55, %runtime.Map_Entry_Header** %4
	; AssignStmt
	; SelectorExpr
	%56 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %2, align 8
	%57 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %56, i64 0
	%58 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %57, i64 0, i32 1
	; SelectorExpr
	%59 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %4, align 8
	%60 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %59, i64 0
	%61 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %60, i64 0, i32 1
	%62 = load i64, i64* %61, align 8
	store i64 %62, i64* %58
	br label %if.done-3

if.done-3:
	; IfStmt
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %fr, i64 0, i32 2
	%64 = load i64, i64* %63, align 8
	; SelectorExpr
	; SelectorExpr
	%65 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%66 = load %mem.Raw_Map*, %mem.Raw_Map** %65, align 8
	%67 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %66, i64 0
	%68 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %67, i64 0, i32 1
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = sub i64 %70, 1
	%72 = icmp eq i64 %64, %71
	%73 = zext i1 %72 to i8
	%74 = trunc i8 %73 to i1
	br i1 %74, label %if.then-4, label %if.else-5

if.then-4:
	br label %if.done-9

if.else-5:
	; old
	%75 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	; SelectorExpr
	%76 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %fr, i64 0, i32 2
	%77 = load i64, i64* %76, align 8
	%78 = bitcast %runtime.Map_Header* %7 to %..rawptr
	%79 = call %..rawptr @mem.zero(%..rawptr %78, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %7
	store %runtime.Map_Header %75, %runtime.Map_Header* %7
	%80 = call %runtime.Map_Entry_Header* @runtime.__dynamic_map_get_entry(%runtime.Map_Header* %7, i64 %77, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %runtime.Map_Entry_Header* %80, %runtime.Map_Entry_Header** %6
	; end
	%81 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	; SelectorExpr
	; SelectorExpr
	%82 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%83 = load %mem.Raw_Map*, %mem.Raw_Map** %82, align 8
	%84 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %83, i64 0
	%85 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %84, i64 0, i32 1
	%86 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %85, i64 0, i32 1
	%87 = load i64, i64* %86, align 8
	%88 = sub i64 %87, 1
	%89 = bitcast %runtime.Map_Header* %9 to %..rawptr
	%90 = call %..rawptr @mem.zero(%..rawptr %89, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %9
	store %runtime.Map_Header %81, %runtime.Map_Header* %9
	%91 = call %runtime.Map_Entry_Header* @runtime.__dynamic_map_get_entry(%runtime.Map_Header* %9, i64 %88, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %runtime.Map_Entry_Header* %91, %runtime.Map_Entry_Header** %8
	; SelectorExpr
	%92 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %6, align 8
	%93 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %8, align 8
	%94 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 2
	%95 = load i64, i64* %94, align 8
	%96 = bitcast %runtime.Map_Entry_Header* %92 to %..rawptr
	%97 = bitcast %runtime.Map_Entry_Header* %93 to %..rawptr
	%98 = call %..rawptr @mem.copy(%..rawptr %96, %..rawptr %97, i64 %95)
	; IfStmt
	; last
	%99 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	; SelectorExpr
	%100 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %6, align 8
	%101 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %100, i64 0
	%102 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %101, i64 0, i32 0
	%103 = load %runtime.Map_Key, %runtime.Map_Key* %102, align 8
	%104 = bitcast %runtime.Map_Header* %11 to %..rawptr
	%105 = call %..rawptr @mem.zero(%..rawptr %104, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %11
	store %runtime.Map_Header %99, %runtime.Map_Header* %11
	%106 = bitcast %runtime.Map_Key* %12 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %12
	store %runtime.Map_Key %103, %runtime.Map_Key* %12
	%108 = call %runtime.Map_Find_Result @runtime.__dynamic_map_find(%runtime.Map_Header* %11, %runtime.Map_Key* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %runtime.Map_Find_Result %108, %runtime.Map_Find_Result* %10
	; SelectorExpr
	%109 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %10, i64 0, i32 1
	%110 = load i64, i64* %109, align 8
	%111 = icmp sge i64 %110, 0
	%112 = zext i1 %111 to i8
	%113 = trunc i8 %112 to i1
	br i1 %113, label %if.then-6, label %if.else-7

if.then-6:
	; last_entry
	%114 = load %runtime.Map_Header, %runtime.Map_Header* %h, align 8
	; SelectorExpr
	%115 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %10, i64 0, i32 1
	%116 = load i64, i64* %115, align 8
	%117 = bitcast %runtime.Map_Header* %14 to %..rawptr
	%118 = call %..rawptr @mem.zero(%..rawptr %117, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %14
	store %runtime.Map_Header %114, %runtime.Map_Header* %14
	%119 = call %runtime.Map_Entry_Header* @runtime.__dynamic_map_get_entry(%runtime.Map_Header* %14, i64 %116, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %runtime.Map_Entry_Header* %119, %runtime.Map_Entry_Header** %13
	; AssignStmt
	; SelectorExpr
	%120 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %13, align 8
	%121 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %120, i64 0
	%122 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %121, i64 0, i32 1
	; SelectorExpr
	%123 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %fr, i64 0, i32 2
	%124 = load i64, i64* %123, align 8
	store i64 %124, i64* %122
	br label %if.done-8

if.else-7:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%126 = load %mem.Raw_Map*, %mem.Raw_Map** %125, align 8
	%127 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %126, i64 0
	%128 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %127, i64 0, i32 0
	%129 = load {i64*, i64}, {i64*, i64}* %128, align 8
	%130 = extractvalue {i64*, i64} %129, 0
	; SelectorExpr
	%131 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %10, i64 0, i32 0
	%132 = load i64, i64* %131, align 8
	%133 = extractvalue {i64*, i64} %129, 1
	%134 = getelementptr inbounds i64, i64* %130, i64 %132
	; SelectorExpr
	%135 = getelementptr inbounds %runtime.Map_Find_Result, %runtime.Map_Find_Result* %fr, i64 0, i32 2
	%136 = load i64, i64* %135, align 8
	store i64 %136, i64* %134
	br label %if.done-8

if.done-8:
	br label %if.done-9

if.done-9:
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%137 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %h, i64 0, i32 0
	%138 = load %mem.Raw_Map*, %mem.Raw_Map** %137, align 8
	%139 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %138, i64 0
	%140 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %139, i64 0, i32 1
	%141 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %140, i64 0, i32 1
	%142 = load i64, i64* %141, align 8
	%143 = sub i64 %142, 1
	store i64 %143, i64* %141
	ret void
}

define void @main.main() #0 {
decls-0:
	%0 = alloca %workbench.Scene, align 16
	%1 = alloca %runtime.Context, align 16
	%2 = bitcast %runtime.Context* %1 to %..rawptr
	%3 = call %..rawptr @mem.zero(%..rawptr %2, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %1
	%4 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %4, %runtime.Context* %1
	call void @runtime.__init_context(%runtime.Context* %1)
	%5 = alloca %workbench.Scene, align 16
	; SelectorExpr
	; CompoundLit
	%6 = bitcast %workbench.Scene* %0 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 48) noinline
	store %workbench.Scene zeroinitializer, %workbench.Scene* %0
	store %workbench.Scene {%..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$61, i64 0, i32 0), i64 4}, void (%runtime.Context*)* zeroinitializer, void (float, %runtime.Context*)* zeroinitializer, void (float, %runtime.Context*)* zeroinitializer, void (%runtime.Context*)* zeroinitializer}, %workbench.Scene* %0
	%8 = getelementptr inbounds %workbench.Scene, %workbench.Scene* %0, i64 0, i32 1
	store void (%runtime.Context*)* @main.main_init, void (%runtime.Context*)** %8
	%9 = getelementptr inbounds %workbench.Scene, %workbench.Scene* %0, i64 0, i32 2
	store void (float, %runtime.Context*)* @main.main_update, void (float, %runtime.Context*)** %9
	%10 = getelementptr inbounds %workbench.Scene, %workbench.Scene* %0, i64 0, i32 3
	store void (float, %runtime.Context*)* @main.main_render, void (float, %runtime.Context*)** %10
	%11 = getelementptr inbounds %workbench.Scene, %workbench.Scene* %0, i64 0, i32 4
	store void (%runtime.Context*)* @main.main_end, void (%runtime.Context*)** %11
	%12 = load %workbench.Scene, %workbench.Scene* %0, align 8
	%13 = bitcast %workbench.Scene* %5 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 48) noinline
	store %workbench.Scene zeroinitializer, %workbench.Scene* %5
	store %workbench.Scene %12, %workbench.Scene* %5
	call void @workbench.make_simple_window(%..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$62, i64 0, i32 0), i64 9}, i64 1920, i64 1080, i64 3, i64 3, float 0x405e000000000000, %workbench.Scene* %5, %runtime.Context* noalias nonnull nocapture inreg %1)
	ret void
}

define void @main.main_init(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %main.Mesh_Renderer*, align 16
	; SelectorExpr
	call void @workbench.perspective_camera(float 0x4055400000000000, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @main.init_entities(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	; SelectorExpr
	store [3 x float] [float 0x0000000000000000, float 0x0000000000000000, float 0xc024000000000000], [3 x float]* @workbench.camera_position
	; AssignStmt
	%1 = call i64 @main.new_entity(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %1, i64* @main.mesh_entity
	%2 = load i64, i64* @main.mesh_entity, align 8
	%3 = call %main.Transform* @main.add_component-14177(i64 %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%4 = load i64, i64* @main.mesh_entity, align 8
	%5 = call %main.Mesh_Renderer* @main.add_component-14181(i64 %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%6 = load i64, i64* @main.mesh_entity, align 8
	%7 = call %main.Sprite_Renderer* @main.add_component-14185(i64 %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%8 = load i64, i64* @main.mesh_entity, align 8
	%9 = call %main.Spinner_Component* @main.add_component-14189(i64 %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; mesh_comp
	%10 = load i64, i64* @main.mesh_entity, align 8
	%11 = call %main.Mesh_Renderer* @main.get_component-14194(i64 %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %main.Mesh_Renderer* %11, %main.Mesh_Renderer** %0
	; AssignStmt
	; SelectorExpr
	%12 = load %main.Mesh_Renderer*, %main.Mesh_Renderer** %0, align 8
	%13 = getelementptr inbounds %main.Mesh_Renderer, %main.Mesh_Renderer* %12, i64 0
	%14 = getelementptr inbounds %main.Mesh_Renderer, %main.Mesh_Renderer* %13, i64 0, i32 1
	; SelectorExpr
	%15 = call {i64*, i64, i64, %mem.Allocator} @workbench.load_asset(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$63, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i64*, i64, i64, %mem.Allocator} %15, {i64*, i64, i64, %mem.Allocator}* %14
	ret void
}

define void @main.main_update(float %dt, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca float, align 16
	store float %dt, float* %0
	; IfStmt
	; SelectorExpr
	%1 = call i8 @workbench.get_key_down(i32 256, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%2 = trunc i8 %1 to i1
	br i1 %2, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	call void @workbench.exit(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-2

if.done-2:
	; IfStmt
	; SelectorExpr
	%3 = call i8 @workbench.get_key(i32 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%4 = trunc i8 %3 to i1
	br i1 %4, label %if.then-3, label %if.done-4

if.then-3:
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%5 = getelementptr inbounds [3 x float], [3 x float]* @workbench.camera_position, i64 0, i32 1
	%6 = load float, float* %5, align 4
	%7 = fadd float %6, 0x3fb9999980000000
	store float %7, float* %5
	br label %if.done-4

if.done-4:
	; IfStmt
	; SelectorExpr
	%8 = call i8 @workbench.get_key(i32 341, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = trunc i8 %8 to i1
	br i1 %9, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%10 = getelementptr inbounds [3 x float], [3 x float]* @workbench.camera_position, i64 0, i32 1
	%11 = load float, float* %10, align 4
	%12 = fsub float %11, 0x3fb9999980000000
	store float %12, float* %10
	br label %if.done-6

if.done-6:
	; IfStmt
	; SelectorExpr
	%13 = call i8 @workbench.get_key(i32 87, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%14 = trunc i8 %13 to i1
	br i1 %14, label %if.then-7, label %if.done-8

if.then-7:
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%15 = getelementptr inbounds [3 x float], [3 x float]* @workbench.camera_position, i64 0, i32 2
	%16 = load float, float* %15, align 4
	%17 = fadd float %16, 0x3fb9999980000000
	store float %17, float* %15
	br label %if.done-8

if.done-8:
	; IfStmt
	; SelectorExpr
	%18 = call i8 @workbench.get_key(i32 83, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = trunc i8 %18 to i1
	br i1 %19, label %if.then-9, label %if.done-10

if.then-9:
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds [3 x float], [3 x float]* @workbench.camera_position, i64 0, i32 2
	%21 = load float, float* %20, align 4
	%22 = fsub float %21, 0x3fb9999980000000
	store float %22, float* %20
	br label %if.done-10

if.done-10:
	; IfStmt
	; SelectorExpr
	%23 = call i8 @workbench.get_key(i32 65, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%24 = trunc i8 %23 to i1
	br i1 %24, label %if.then-11, label %if.done-12

if.then-11:
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%25 = getelementptr inbounds [3 x float], [3 x float]* @workbench.camera_position, i64 0, i32 0
	%26 = load float, float* %25, align 4
	%27 = fadd float %26, 0x3fb9999980000000
	store float %27, float* %25
	br label %if.done-12

if.done-12:
	; IfStmt
	; SelectorExpr
	%28 = call i8 @workbench.get_key(i32 68, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%29 = trunc i8 %28 to i1
	br i1 %29, label %if.then-13, label %if.done-14

if.then-13:
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%30 = getelementptr inbounds [3 x float], [3 x float]* @workbench.camera_position, i64 0, i32 0
	%31 = load float, float* %30, align 4
	%32 = fsub float %31, 0x3fb9999980000000
	store float %32, float* %30
	br label %if.done-14

if.done-14:
	call void @main.update_entities(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @main.main_render(float %dt, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca float, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	store float %dt, float* %0
	; SelectorExpr
	; SelectorExpr
	%2 = load i32, i32* @workbench.shader_rgba_3d, align 4
	%3 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%4 = call %..rawptr @mem.zero(%..rawptr %3, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([55 x i8], [55 x i8]* @str$64, i64 0, i32 0), i64 54}, i64 46, i64 5, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$65, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %1
	call void @workbench.use_program(i32 %2, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @main.render_entities(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @main.main_end(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	call void @main.shutdown_entities(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @main.call_component_updates(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %main.Spinner_Component*, align 16
	; RangeStmt
	; i
	%3 = bitcast i64* %0 to %..rawptr
	%4 = call %..rawptr @mem.zero(%..rawptr %3, i64 8) noinline
	store i64 zeroinitializer, i64* %0
	%5 = getelementptr inbounds {%main.Spinner_Component*, i64, i64, %mem.Allocator}, {%main.Spinner_Component*, i64, i64, %mem.Allocator}* @main.all_spinners, i64 0, i32 1
	%6 = bitcast i64* %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 8) noinline
	store i64 zeroinitializer, i64* %1
	store i64 -1, i64* %1
	br label %for.index.loop-1

for.index.loop-1:
	%8 = load i64, i64* %1, align 8
	%9 = add i64 %8, 1
	store i64 %9, i64* %1
	%10 = load i64, i64* %5, align 8
	%11 = icmp slt i64 %9, %10
	br i1 %11, label %for.index.body-2, label %for.index.done-3

for.index.body-2:
	%12 = load i64, i64* %1, align 8
	store i64 %12, i64* %0
	; c
	; IndexExpr
	%13 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}, {%main.Spinner_Component*, i64, i64, %mem.Allocator}* @main.all_spinners, align 8
	%14 = extractvalue {%main.Spinner_Component*, i64, i64, %mem.Allocator} %13, 0
	%15 = extractvalue {%main.Spinner_Component*, i64, i64, %mem.Allocator} %13, 1
	%16 = load i64, i64* %0, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$66, i64 0, i32 0), i64 74}, i64 70, i64 22, i64 %16, i64 %15)
	%17 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %14, i64 %16
	store %main.Spinner_Component* %17, %main.Spinner_Component** %2
	%18 = load %main.Spinner_Component*, %main.Spinner_Component** %2, align 8
	call void @main.update_spinner(%main.Spinner_Component* %18, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-1

for.index.done-3:
	ret void
}

define void @main.call_component_renders(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %main.Sprite_Renderer*, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca %main.Mesh_Renderer*, align 16
	; RangeStmt
	; i
	%6 = bitcast i64* %0 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 8) noinline
	store i64 zeroinitializer, i64* %0
	%8 = getelementptr inbounds {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* @main.all_sprite_renderers, i64 0, i32 1
	%9 = bitcast i64* %1 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 8) noinline
	store i64 zeroinitializer, i64* %1
	store i64 -1, i64* %1
	br label %for.index.loop-1

for.index.loop-1:
	%11 = load i64, i64* %1, align 8
	%12 = add i64 %11, 1
	store i64 %12, i64* %1
	%13 = load i64, i64* %8, align 8
	%14 = icmp slt i64 %12, %13
	br i1 %14, label %for.index.body-2, label %for.index.done-3

for.index.body-2:
	%15 = load i64, i64* %1, align 8
	store i64 %15, i64* %0
	; c
	; IndexExpr
	%16 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* @main.all_sprite_renderers, align 8
	%17 = extractvalue {%main.Sprite_Renderer*, i64, i64, %mem.Allocator} %16, 0
	%18 = extractvalue {%main.Sprite_Renderer*, i64, i64, %mem.Allocator} %16, 1
	%19 = load i64, i64* %0, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$67, i64 0, i32 0), i64 74}, i64 76, i64 30, i64 %19, i64 %18)
	%20 = getelementptr inbounds %main.Sprite_Renderer, %main.Sprite_Renderer* %17, i64 %19
	store %main.Sprite_Renderer* %20, %main.Sprite_Renderer** %2
	%21 = load %main.Sprite_Renderer*, %main.Sprite_Renderer** %2, align 8
	call void @main.render_sprite_renderer(%main.Sprite_Renderer* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-1

for.index.done-3:
	; RangeStmt
	; i
	%22 = bitcast i64* %3 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%24 = getelementptr inbounds {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* @main.all_mesh_renderers, i64 0, i32 1
	%25 = bitcast i64* %4 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-4

for.index.loop-4:
	%27 = load i64, i64* %4, align 8
	%28 = add i64 %27, 1
	store i64 %28, i64* %4
	%29 = load i64, i64* %24, align 8
	%30 = icmp slt i64 %28, %29
	br i1 %30, label %for.index.body-5, label %for.index.done-6

for.index.body-5:
	%31 = load i64, i64* %4, align 8
	store i64 %31, i64* %3
	; c
	; IndexExpr
	%32 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* @main.all_mesh_renderers, align 8
	%33 = extractvalue {%main.Mesh_Renderer*, i64, i64, %mem.Allocator} %32, 0
	%34 = extractvalue {%main.Mesh_Renderer*, i64, i64, %mem.Allocator} %32, 1
	%35 = load i64, i64* %3, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$68, i64 0, i32 0), i64 74}, i64 79, i64 28, i64 %35, i64 %34)
	%36 = getelementptr inbounds %main.Mesh_Renderer, %main.Mesh_Renderer* %33, i64 %35
	store %main.Mesh_Renderer* %36, %main.Mesh_Renderer** %5
	%37 = load %main.Mesh_Renderer*, %main.Mesh_Renderer** %5, align 8
	call void @main.render_mesh_renderer(%main.Mesh_Renderer* %37, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-4

for.index.done-6:
	ret void
}

define i64 @main.new_entity(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	; AssignStmt
	%0 = load i64, i64* @main.last_entity_id, align 8
	%1 = add i64 %0, 1
	store i64 %1, i64* @main.last_entity_id
	; ReturnStmt
	%2 = load i64, i64* @main.last_entity_id, align 8
	ret i64 %2
}

define void @main.render_sprite_renderer(%main.Sprite_Renderer* %sprite, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %main.Sprite_Renderer*, align 16
	%1 = alloca %main.Transform*, align 16
	%2 = alloca [3 x float], align 16
	%3 = alloca [3 x float], align 16
	%4 = alloca [3 x float], align 16
	%5 = alloca [3 x float], align 16
	%6 = alloca [3 x float], align 16
	%7 = alloca [3 x float], align 16
	%8 = alloca %workbench.Colorf, align 16
	store %main.Sprite_Renderer* %sprite, %main.Sprite_Renderer** %0
	; tf
	%9 = load %main.Sprite_Renderer*, %main.Sprite_Renderer** %0, align 8
	%10 = getelementptr inbounds %main.Sprite_Renderer, %main.Sprite_Renderer* %9, i64 0
	%11 = getelementptr inbounds %main.Sprite_Renderer, %main.Sprite_Renderer* %10, i64 0, i32 0
	%12 = load i64, i64* %11, align 8
	%13 = call %main.Transform* @main.get_component-14223(i64 %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	store %main.Transform* %13, %main.Transform** %1
	; SelectorExpr
	; SelectorExpr
	; SelectorExpr
	%14 = load i32, i32* @workbench.shader_rgba, align 4
	; SelectorExpr
	%15 = load %main.Transform*, %main.Transform** %1, align 8
	%16 = getelementptr inbounds %main.Transform, %main.Transform* %15, i64 0
	%17 = getelementptr inbounds %main.Transform, %main.Transform* %16, i64 0, i32 1
	%18 = load [3 x float], [3 x float]* %17, align 4
	; array.arith.begin
	%19 = bitcast [3 x float]* %2 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %2
	store [3 x float] [float 0x3ff0000000000000, float 0x3ff0000000000000, float 0x0000000000000000], [3 x float]* %2
	%21 = bitcast [3 x float]* %3 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %3
	%23 = getelementptr inbounds [3 x float], [3 x float]* %17, i64 0, i32 0
	%24 = load float, float* %23, align 4
	%25 = getelementptr inbounds [3 x float], [3 x float]* %2, i64 0, i32 0
	%26 = load float, float* %25, align 4
	%27 = fsub float %24, %26
	%28 = getelementptr inbounds [3 x float], [3 x float]* %3, i64 0, i32 0
	store float %27, float* %28
	%29 = getelementptr inbounds [3 x float], [3 x float]* %17, i64 0, i32 1
	%30 = load float, float* %29, align 4
	%31 = getelementptr inbounds [3 x float], [3 x float]* %2, i64 0, i32 1
	%32 = load float, float* %31, align 4
	%33 = fsub float %30, %32
	%34 = getelementptr inbounds [3 x float], [3 x float]* %3, i64 0, i32 1
	store float %33, float* %34
	%35 = getelementptr inbounds [3 x float], [3 x float]* %17, i64 0, i32 2
	%36 = load float, float* %35, align 4
	%37 = getelementptr inbounds [3 x float], [3 x float]* %2, i64 0, i32 2
	%38 = load float, float* %37, align 4
	%39 = fsub float %36, %38
	%40 = getelementptr inbounds [3 x float], [3 x float]* %3, i64 0, i32 2
	store float %39, float* %40
	; array.arith.end
	%41 = load [3 x float], [3 x float]* %3, align 4
	; SelectorExpr
	%42 = load %main.Transform*, %main.Transform** %1, align 8
	%43 = getelementptr inbounds %main.Transform, %main.Transform* %42, i64 0
	%44 = getelementptr inbounds %main.Transform, %main.Transform* %43, i64 0, i32 1
	%45 = load [3 x float], [3 x float]* %44, align 4
	; array.arith.begin
	%46 = bitcast [3 x float]* %4 to %..rawptr
	%47 = call %..rawptr @mem.zero(%..rawptr %46, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %4
	store [3 x float] [float 0x3ff0000000000000, float 0x3ff0000000000000, float 0x0000000000000000], [3 x float]* %4
	%48 = bitcast [3 x float]* %5 to %..rawptr
	%49 = call %..rawptr @mem.zero(%..rawptr %48, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %5
	%50 = getelementptr inbounds [3 x float], [3 x float]* %44, i64 0, i32 0
	%51 = load float, float* %50, align 4
	%52 = getelementptr inbounds [3 x float], [3 x float]* %4, i64 0, i32 0
	%53 = load float, float* %52, align 4
	%54 = fadd float %51, %53
	%55 = getelementptr inbounds [3 x float], [3 x float]* %5, i64 0, i32 0
	store float %54, float* %55
	%56 = getelementptr inbounds [3 x float], [3 x float]* %44, i64 0, i32 1
	%57 = load float, float* %56, align 4
	%58 = getelementptr inbounds [3 x float], [3 x float]* %4, i64 0, i32 1
	%59 = load float, float* %58, align 4
	%60 = fadd float %57, %59
	%61 = getelementptr inbounds [3 x float], [3 x float]* %5, i64 0, i32 1
	store float %60, float* %61
	%62 = getelementptr inbounds [3 x float], [3 x float]* %44, i64 0, i32 2
	%63 = load float, float* %62, align 4
	%64 = getelementptr inbounds [3 x float], [3 x float]* %4, i64 0, i32 2
	%65 = load float, float* %64, align 4
	%66 = fadd float %63, %65
	%67 = getelementptr inbounds [3 x float], [3 x float]* %5, i64 0, i32 2
	store float %66, float* %67
	; array.arith.end
	%68 = load [3 x float], [3 x float]* %5, align 4
	%69 = load %main.Sprite_Renderer*, %main.Sprite_Renderer** %0, align 8
	%70 = getelementptr inbounds %main.Sprite_Renderer, %main.Sprite_Renderer* %69, i64 0
	%71 = getelementptr inbounds %main.Sprite_Renderer, %main.Sprite_Renderer* %70, i64 0, i32 1
	%72 = load %workbench.Colorf, %workbench.Colorf* %71, align 4
	%73 = load i64, i64* @workbench.current_render_layer, align 8
	%74 = bitcast void (%runtime.Context*)* @workbench.rendermode_world to void (%runtime.Context*)*
	%75 = bitcast [3 x float]* %6 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %6
	store [3 x float] %41, [3 x float]* %6
	%77 = bitcast [3 x float]* %7 to %..rawptr
	%78 = call %..rawptr @mem.zero(%..rawptr %77, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %7
	store [3 x float] %68, [3 x float]* %7
	%79 = bitcast %workbench.Colorf* %8 to %..rawptr
	%80 = call %..rawptr @mem.zero(%..rawptr %79, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %8
	store %workbench.Colorf %72, %workbench.Colorf* %8
	call void @workbench.im_quad_color(void (%runtime.Context*)* %74, i32 %14, [3 x float]* %6, [3 x float]* %7, %workbench.Colorf* %8, i64 %73, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define void @main.init_spinner(%main.Spinner_Component* %spinner, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %main.Spinner_Component*, align 16
	%1 = alloca %main.Sprite_Renderer*, align 16
	%2 = alloca %workbench.Colorf, align 16
	store %main.Spinner_Component* %spinner, %main.Spinner_Component** %0
	; AssignStmt
	%3 = load %main.Spinner_Component*, %main.Spinner_Component** %0, align 8
	%4 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %3, i64 0
	%5 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %4, i64 0, i32 1
	; SelectorExpr
	%6 = call float @workbench.random_range(float 0x3fd6666660000000, float 0x3ff0000000000000, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	store float %6, float* %5
	; AssignStmt
	%7 = load %main.Spinner_Component*, %main.Spinner_Component** %0, align 8
	%8 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %7, i64 0
	%9 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %8, i64 0, i32 2
	; SelectorExpr
	%10 = call float @workbench.random01(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%11 = fmul float %10, 0x4014000000000000
	store float %11, float* %9
	; sprite
	%12 = load %main.Spinner_Component*, %main.Spinner_Component** %0, align 8
	%13 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %12, i64 0
	%14 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %13, i64 0, i32 0
	%15 = load i64, i64* %14, align 8
	%16 = call %main.Sprite_Renderer* @main.get_component-14231(i64 %15, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	store %main.Sprite_Renderer* %16, %main.Sprite_Renderer** %1
	; AssignStmt
	; SelectorExpr
	%17 = load %main.Sprite_Renderer*, %main.Sprite_Renderer** %1, align 8
	%18 = getelementptr inbounds %main.Sprite_Renderer, %main.Sprite_Renderer* %17, i64 0
	%19 = getelementptr inbounds %main.Sprite_Renderer, %main.Sprite_Renderer* %18, i64 0, i32 1
	; CompoundLit
	%20 = bitcast %workbench.Colorf* %2 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %2
	store %workbench.Colorf {float zeroinitializer, float zeroinitializer, float zeroinitializer, float 0x3ff0000000000000}, %workbench.Colorf* %2
	; SelectorExpr
	%22 = call float @workbench.random01(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%23 = getelementptr inbounds %workbench.Colorf, %workbench.Colorf* %2, i64 0, i32 0
	store float %22, float* %23
	; SelectorExpr
	%24 = call float @workbench.random01(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%25 = getelementptr inbounds %workbench.Colorf, %workbench.Colorf* %2, i64 0, i32 1
	store float %24, float* %25
	; SelectorExpr
	%26 = call float @workbench.random01(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%27 = getelementptr inbounds %workbench.Colorf, %workbench.Colorf* %2, i64 0, i32 2
	store float %26, float* %27
	%28 = load %workbench.Colorf, %workbench.Colorf* %2, align 4
	store %workbench.Colorf %28, %workbench.Colorf* %19
	ret void
}

define void @main.update_spinner(%main.Spinner_Component* %spinner, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %main.Spinner_Component*, align 16
	%1 = alloca %main.Transform*, align 16
	%2 = alloca [3 x float], align 16
	store %main.Spinner_Component* %spinner, %main.Spinner_Component** %0
	; tf
	%3 = load %main.Spinner_Component*, %main.Spinner_Component** %0, align 8
	%4 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %3, i64 0
	%5 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %4, i64 0, i32 0
	%6 = load i64, i64* %5, align 8
	%7 = call %main.Transform* @main.get_component-14223(i64 %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	store %main.Transform* %7, %main.Transform** %1
	; AssignStmt
	; SelectorExpr
	%8 = load %main.Transform*, %main.Transform** %1, align 8
	%9 = getelementptr inbounds %main.Transform, %main.Transform* %8, i64 0
	%10 = getelementptr inbounds %main.Transform, %main.Transform* %9, i64 0, i32 1
	; CompoundLit
	%11 = bitcast [3 x float]* %2 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %2
	store [3 x float] [float zeroinitializer, float zeroinitializer, float 0x0000000000000000], [3 x float]* %2
	; SelectorExpr
	%13 = load float, float* @workbench.time, align 4
	%14 = load %main.Spinner_Component*, %main.Spinner_Component** %0, align 8
	%15 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %14, i64 0
	%16 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %15, i64 0, i32 1
	%17 = load float, float* %16, align 4
	%18 = fmul float %13, %17
	%19 = call ccc float @llvm.sin.f32(float %18) alwaysinline
	%20 = load %main.Spinner_Component*, %main.Spinner_Component** %0, align 8
	%21 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %20, i64 0
	%22 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %21, i64 0, i32 2
	%23 = load float, float* %22, align 4
	%24 = fmul float %19, %23
	%25 = getelementptr inbounds [3 x float], [3 x float]* %2, i64 0, i32 0
	store float %24, float* %25
	; SelectorExpr
	%26 = load float, float* @workbench.time, align 4
	%27 = load %main.Spinner_Component*, %main.Spinner_Component** %0, align 8
	%28 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %27, i64 0
	%29 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %28, i64 0, i32 1
	%30 = load float, float* %29, align 4
	%31 = fmul float %26, %30
	%32 = call ccc float @llvm.cos.f32(float %31) alwaysinline
	%33 = load %main.Spinner_Component*, %main.Spinner_Component** %0, align 8
	%34 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %33, i64 0
	%35 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %34, i64 0, i32 2
	%36 = load float, float* %35, align 4
	%37 = fmul float %32, %36
	%38 = getelementptr inbounds [3 x float], [3 x float]* %2, i64 0, i32 1
	store float %37, float* %38
	%39 = load [3 x float], [3 x float]* %2, align 4
	store [3 x float] %39, [3 x float]* %10
	ret void
}

define void @main.render_mesh_renderer(%main.Mesh_Renderer* %meshComp, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %main.Mesh_Renderer*, align 16
	%1 = alloca %main.Transform*, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca [3 x float], align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	store %main.Mesh_Renderer* %meshComp, %main.Mesh_Renderer** %0
	; tf
	%6 = load %main.Mesh_Renderer*, %main.Mesh_Renderer** %0, align 8
	%7 = getelementptr inbounds %main.Mesh_Renderer, %main.Mesh_Renderer* %6, i64 0
	%8 = getelementptr inbounds %main.Mesh_Renderer, %main.Mesh_Renderer* %7, i64 0, i32 0
	%9 = load i64, i64* %8, align 8
	%10 = call %main.Transform* @main.get_component-14223(i64 %9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	store %main.Transform* %10, %main.Transform** %1
	; RangeStmt
	; meshId
	%11 = bitcast i64* %2 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	%13 = load %main.Mesh_Renderer*, %main.Mesh_Renderer** %0, align 8
	%14 = getelementptr inbounds %main.Mesh_Renderer, %main.Mesh_Renderer* %13, i64 0
	%15 = getelementptr inbounds %main.Mesh_Renderer, %main.Mesh_Renderer* %14, i64 0, i32 1
	%16 = getelementptr inbounds {i64*, i64, i64, %mem.Allocator}, {i64*, i64, i64, %mem.Allocator}* %15, i64 0, i32 1
	%17 = bitcast i64* %3 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	store i64 -1, i64* %3
	br label %for.index.loop-1

for.index.loop-1:
	%19 = load i64, i64* %3, align 8
	%20 = add i64 %19, 1
	store i64 %20, i64* %3
	%21 = load i64, i64* %16, align 8
	%22 = icmp slt i64 %20, %21
	br i1 %22, label %for.index.body-2, label %for.index.done-3

for.index.body-2:
	%23 = load i64, i64* %3, align 8
	%24 = getelementptr inbounds {i64*, i64, i64, %mem.Allocator}, {i64*, i64, i64, %mem.Allocator}* %15, i64 0, i32 0
	%25 = load i64*, i64** %24, align 8
	%26 = getelementptr inbounds i64, i64* %25, i64 %23
	%27 = load i64, i64* %26, align 8
	store i64 %27, i64* %2
	; SelectorExpr
	%28 = load i64, i64* %2, align 8
	; SelectorExpr
	%29 = load %main.Transform*, %main.Transform** %1, align 8
	%30 = getelementptr inbounds %main.Transform, %main.Transform* %29, i64 0
	%31 = getelementptr inbounds %main.Transform, %main.Transform* %30, i64 0, i32 1
	%32 = load [3 x float], [3 x float]* %31, align 4
	%33 = bitcast [3 x float]* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %4
	store [3 x float] %32, [3 x float]* %4
	%35 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$69, i64 0, i32 0), i64 58}, i64 89, i64 6, %..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$6a, i64 0, i32 0), i64 20}}, %runtime.Source_Code_Location* %5
	call void @workbench.draw_mesh(i64 %28, [3 x float]* %4, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	br label %for.index.loop-1

for.index.done-3:
	ret void
}

define void @main.init_entities(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	ret void
}

define void @main.update_entities(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	call void @main.call_component_updates(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @main.render_entities(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	call void @main.call_component_renders(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @main.shutdown_entities(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	ret void
}

define %..rawptr @mem.set(%..rawptr %data, i8 %value, i64 %len) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	store %..rawptr %data, %..rawptr* %0
	store i8 %value, i8* %1
	store i64 %len, i64* %2
	; IfStmt
	%3 = load %..rawptr, %..rawptr* %0, align 8
	%4 = icmp eq %..rawptr %3, zeroinitializer
	%5 = zext i1 %4 to i8
	%6 = trunc i8 %5 to i1
	br i1 %6, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %..rawptr zeroinitializer

if.done-2:
	; IfStmt
	%7 = load i64, i64* %2, align 8
	%8 = icmp slt i64 %7, 0
	%9 = zext i1 %8 to i8
	%10 = trunc i8 %9 to i1
	br i1 %10, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	%11 = load %..rawptr, %..rawptr* %0, align 8
	ret %..rawptr %11

if.done-4:
	%12 = load %..rawptr, %..rawptr* %0, align 8
	%13 = load i8, i8* %1, align 1
	%14 = load i64, i64* %2, align 8
	call ccc void @llvm.memset.p0i8.i64(%..rawptr %12, i8 %13, i64 %14, i32 1, i1 false)
	; ReturnStmt
	%15 = load %..rawptr, %..rawptr* %0, align 8
	ret %..rawptr %15
}
declare ccc void @llvm.memset.p0i8.i64(%..rawptr, i8, i64, i32, i1) #0 

define %..rawptr @mem.zero(%..rawptr %data, i64 %len) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i64, align 16
	store %..rawptr %data, %..rawptr* %0
	store i64 %len, i64* %1
	; ReturnStmt
	%2 = load %..rawptr, %..rawptr* %0, align 8
	%3 = load i64, i64* %1, align 8
	%4 = call %..rawptr @mem.set(%..rawptr %2, i8 0, i64 %3)
	ret %..rawptr %4
}

define %..rawptr @mem.copy(%..rawptr %dst, %..rawptr %src, i64 %len) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca i64, align 16
	store %..rawptr %dst, %..rawptr* %0
	store %..rawptr %src, %..rawptr* %1
	store i64 %len, i64* %2
	; IfStmt
	%3 = load %..rawptr, %..rawptr* %1, align 8
	%4 = icmp eq %..rawptr %3, zeroinitializer
	%5 = zext i1 %4 to i8
	%6 = trunc i8 %5 to i1
	br i1 %6, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%7 = load %..rawptr, %..rawptr* %0, align 8
	ret %..rawptr %7

if.done-2:
	%8 = load %..rawptr, %..rawptr* %0, align 8
	%9 = load %..rawptr, %..rawptr* %1, align 8
	%10 = load i64, i64* %2, align 8
	call ccc void @llvm.memmove.p0i8.p0i8.i64(%..rawptr %8, %..rawptr %9, i64 %10, i32 1, i1 false)
	; ReturnStmt
	%11 = load %..rawptr, %..rawptr* %0, align 8
	ret %..rawptr %11
}
declare ccc void @llvm.memmove.p0i8.p0i8.i64(%..rawptr, %..rawptr, i64, i32, i1) #0 

define i64 @mem.compare_byte_ptrs(i8* %a, i8* %b, i64 %n) #0 {
decls-0:
	%0 = alloca i8*, align 16
	%1 = alloca i8*, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	store i8* %a, i8** %0
	store i8* %b, i8** %1
	store i64 %n, i64* %2
	; RangeStmt
	; i
	%6 = bitcast i64* %3 to %..rawptr
	store i64 zeroinitializer, i64* %3
	%7 = bitcast i64* %4 to %..rawptr
	store i64 zeroinitializer, i64* %4
	store i64 0, i64* %4
	%8 = bitcast i64* %5 to %..rawptr
	store i64 zeroinitializer, i64* %5
	store i64 0, i64* %5
	br label %for.interval.loop-1

for.interval.loop-1:
	%9 = load i64, i64* %2, align 8
	%10 = sub i64 %9, 1
	%11 = load i64, i64* %4, align 8
	%12 = icmp sle i64 %11, %10
	br i1 %12, label %for.interval.body-2, label %for.interval.done-7

for.interval.body-2:
	%13 = load i64, i64* %4, align 8
	%14 = load i64, i64* %5, align 8
	%15 = load i64, i64* %4, align 8
	%16 = add i64 %15, 1
	store i64 %16, i64* %4
	%17 = load i64, i64* %5, align 8
	%18 = add i64 %17, 1
	store i64 %18, i64* %5
	store i64 %13, i64* %3
	; SwitchStmt
	%19 = load i8*, i8** %0, align 8
	%20 = load i64, i64* %3, align 8
	%21 = call i8* @mem.ptr_offset-13926(i8* %19, i64 %20)
	%22 = getelementptr inbounds i8, i8* %21, i64 0
	%23 = load i8, i8* %22, align 1
	%24 = load i8*, i8** %1, align 8
	%25 = load i64, i64* %3, align 8
	%26 = call i8* @mem.ptr_offset-13926(i8* %24, i64 %25)
	%27 = getelementptr inbounds i8, i8* %26, i64 0
	%28 = load i8, i8* %27, align 1
	%29 = icmp ult i8 %23, %28
	%30 = zext i1 %29 to i8
	%31 = icmp eq i8 1, %30
	br i1 %31, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%32 = load i8*, i8** %0, align 8
	%33 = load i64, i64* %3, align 8
	%34 = call i8* @mem.ptr_offset-13926(i8* %32, i64 %33)
	%35 = getelementptr inbounds i8, i8* %34, i64 0
	%36 = load i8, i8* %35, align 1
	%37 = load i8*, i8** %1, align 8
	%38 = load i64, i64* %3, align 8
	%39 = call i8* @mem.ptr_offset-13926(i8* %37, i64 %38)
	%40 = getelementptr inbounds i8, i8* %39, i64 0
	%41 = load i8, i8* %40, align 1
	%42 = icmp ugt i8 %36, %41
	%43 = zext i1 %42 to i8
	%44 = icmp eq i8 1, %43
	br i1 %44, label %switch.fall.body-6, label %switch.case.next-5

switch.case.body-4:
	; ReturnStmt
	ret i64 -1

switch.case.next-5:
	br label %for.interval.loop-1

switch.fall.body-6:
	; ReturnStmt
	ret i64 1

for.interval.done-7:
	; ReturnStmt
	ret i64 0
}

define i8 @mem.is_power_of_two(i64 %x, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	store i64 %x, i64* %0
	; IfStmt
	%1 = load i64, i64* %0, align 8
	%2 = icmp ule i64 %1, 0
	%3 = zext i1 %2 to i8
	%4 = trunc i8 %3 to i1
	br i1 %4, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ReturnStmt
	%5 = load i64, i64* %0, align 8
	%6 = load i64, i64* %0, align 8
	%7 = sub i64 %6, 1
	%8 = and i64 %5, %7
	%9 = icmp eq i64 %8, 0
	%10 = zext i1 %9 to i8
	ret i8 %10
}

define i64 @mem.align_forward_uintptr(i64 %ptr, i64 %align, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	store i64 %ptr, i64* %0
	store i64 %align, i64* %1
	%6 = load i64, i64* %1, align 8
	%7 = call i8 @mem.is_power_of_two(i64 %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%8 = trunc i8 %7 to i1
	%9 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$6b, i64 0, i32 0), i64 53}, i64 149, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6c, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %2
	%10 = call i8 @runtime.assert(i1 %8, %..string zeroinitializer, %runtime.Source_Code_Location* %2)
	; a
	%11 = load i64, i64* %1, align 8
	store i64 %11, i64* %3
	; p
	%12 = load i64, i64* %0, align 8
	store i64 %12, i64* %4
	; modulo
	%13 = load i64, i64* %4, align 8
	%14 = load i64, i64* %3, align 8
	%15 = sub i64 %14, 1
	%16 = and i64 %13, %15
	store i64 %16, i64* %5
	; IfStmt
	%17 = load i64, i64* %5, align 8
	%18 = icmp ne i64 %17, 0
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	%21 = load i64, i64* %3, align 8
	%22 = load i64, i64* %5, align 8
	%23 = sub i64 %21, %22
	%24 = load i64, i64* %4, align 8
	%25 = add i64 %24, %23
	store i64 %25, i64* %4
	br label %if.done-2

if.done-2:
	; ReturnStmt
	%26 = load i64, i64* %4, align 8
	ret i64 %26
}

define %..rawptr @mem.alloc(i64 %size, i64 %alignment, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	store i64 %size, i64* %0
	store i64 %alignment, i64* %1
	%3 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%4 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%5 = load i64, i64* %0, align 8
	%6 = icmp eq i64 %5, 0
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	br i1 %8, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %..rawptr zeroinitializer

if.done-2:
	; IfStmt
	; SelectorExpr
	%9 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 0
	%10 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %9, align 8
	%11 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret %..rawptr zeroinitializer

if.done-4:
	; ReturnStmt
	; SelectorExpr
	%14 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 0
	%15 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %14, align 8
	; SelectorExpr
	%16 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 1
	%17 = load %..rawptr, %..rawptr* %16, align 8
	%18 = load i64, i64* %0, align 8
	%19 = load i64, i64* %1, align 8
	%20 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%21 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %20, %runtime.Source_Code_Location* %2
	%22 = call %..rawptr %15(%..rawptr %17, i8 0, i64 %18, i64 %19, %..rawptr zeroinitializer, i64 0, i64 0, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret %..rawptr %22
}

define void @mem.free(%..rawptr %ptr, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	store %..rawptr %ptr, %..rawptr* %0
	%2 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%3 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%4 = load %..rawptr, %..rawptr* %0, align 8
	%5 = icmp eq %..rawptr %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; IfStmt
	; SelectorExpr
	%8 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 0
	%9 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %8, align 8
	%10 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret void

if.done-4:
	; SelectorExpr
	%13 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 0
	%14 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %13, align 8
	; SelectorExpr
	%15 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 1
	%16 = load %..rawptr, %..rawptr* %15, align 8
	%17 = load %..rawptr, %..rawptr* %0, align 8
	%18 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%19 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %18, %runtime.Source_Code_Location* %1
	%20 = call %..rawptr %14(%..rawptr %16, i8 1, i64 0, i64 0, %..rawptr %17, i64 0, i64 0, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define %..rawptr @mem.resize(%..rawptr %ptr, i64 %old_size, i64 %new_size, i64 %alignment, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %mem.Allocator, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	store %..rawptr %ptr, %..rawptr* %0
	store i64 %old_size, i64* %1
	store i64 %new_size, i64* %2
	store i64 %alignment, i64* %3
	%8 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	; SelectorExpr
	%10 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 0
	%11 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %10, align 8
	%12 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %11, zeroinitializer
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %..rawptr zeroinitializer

if.done-2:
	; IfStmt
	%15 = load i64, i64* %2, align 8
	%16 = icmp eq i64 %15, 0
	%17 = zext i1 %16 to i8
	%18 = trunc i8 %17 to i1
	br i1 %18, label %if.then-3, label %if.else-4

if.then-3:
	%19 = load %..rawptr, %..rawptr* %0, align 8
	%20 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%21 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%22 = bitcast %mem.Allocator* %4 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %4
	store %mem.Allocator %20, %mem.Allocator* %4
	%23 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location %21, %runtime.Source_Code_Location* %5
	call void @mem.free(%..rawptr %19, %mem.Allocator* %4, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	; ReturnStmt
	ret %..rawptr zeroinitializer

if.else-4:
	; IfStmt
	%24 = load %..rawptr, %..rawptr* %0, align 8
	%25 = icmp eq %..rawptr %24, zeroinitializer
	%26 = zext i1 %25 to i8
	%27 = trunc i8 %26 to i1
	br i1 %27, label %if.then-5, label %if.done-6

if.then-5:
	; ReturnStmt
	; SelectorExpr
	%28 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 0
	%29 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %28, align 8
	; SelectorExpr
	%30 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 1
	%31 = load %..rawptr, %..rawptr* %30, align 8
	%32 = load i64, i64* %2, align 8
	%33 = load i64, i64* %3, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %6
	%36 = call %..rawptr %29(%..rawptr %31, i8 0, i64 %32, i64 %33, %..rawptr zeroinitializer, i64 0, i64 0, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret %..rawptr %36

if.done-6:
	; ReturnStmt
	; SelectorExpr
	%37 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 0
	%38 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %37, align 8
	; SelectorExpr
	%39 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 1
	%40 = load %..rawptr, %..rawptr* %39, align 8
	%41 = load i64, i64* %2, align 8
	%42 = load i64, i64* %3, align 8
	%43 = load %..rawptr, %..rawptr* %0, align 8
	%44 = load i64, i64* %1, align 8
	%45 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%46 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location %45, %runtime.Source_Code_Location* %7
	%47 = call %..rawptr %38(%..rawptr %40, i8 3, i64 %41, i64 %42, %..rawptr %43, i64 %44, i64 0, %runtime.Source_Code_Location* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret %..rawptr %47
}

define void @mem.delete_string(%..string %str, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %mem.Allocator, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	store %..string %str, %..string* %0
	%3 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%4 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%5 = load %..string, %..string* %0, align 8
	%6 = call i8* @mem.raw_string_data-14018(%..string %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%9 = bitcast i8* %6 to %..rawptr
	%10 = bitcast %mem.Allocator* %1 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %1
	store %mem.Allocator %7, %mem.Allocator* %1
	%11 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %8, %runtime.Source_Code_Location* %2
	call void @mem.free(%..rawptr %9, %mem.Allocator* %1, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @mem.delete_cstring(i8* %str, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i8*, align 16
	%1 = alloca %mem.Allocator, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	store i8* %str, i8** %0
	%3 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%4 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%5 = load i8*, i8** %0, align 8
	%6 = bitcast i8* %5 to i8*
	%7 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%9 = bitcast i8* %6 to %..rawptr
	%10 = bitcast %mem.Allocator* %1 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %1
	store %mem.Allocator %7, %mem.Allocator* %1
	%11 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %8, %runtime.Source_Code_Location* %2
	call void @mem.free(%..rawptr %9, %mem.Allocator* %1, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define %..rawptr @mem.nil_allocator_proc(%..rawptr %allocator_data, i8 %mode, i64 %size, i64 %alignment, %..rawptr %old_memory, i64 %old_size, i64 %flags, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..rawptr, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	store %..rawptr %allocator_data, %..rawptr* %0
	store i8 %mode, i8* %1
	store i64 %size, i64* %2
	store i64 %alignment, i64* %3
	store %..rawptr %old_memory, %..rawptr* %4
	store i64 %old_size, i64* %5
	store i64 %flags, i64* %6
	%7 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; ReturnStmt
	ret %..rawptr zeroinitializer
}

define %mem.Allocator @mem.nil_allocator(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Allocator, align 16
	; ReturnStmt
	; CompoundLit
	%1 = bitcast %mem.Allocator* %0 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %0
	store %mem.Allocator {%..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* zeroinitializer, %..rawptr zeroinitializer}, %mem.Allocator* %0
	%2 = bitcast %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* @mem.nil_allocator_proc to %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*
	%3 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %0, i64 0, i32 0
	store %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %2, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %3
	%4 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %0, i64 0, i32 1
	store %..rawptr zeroinitializer, %..rawptr* %4
	%5 = load %mem.Allocator, %mem.Allocator* %0, align 8
	ret %mem.Allocator %5
}

define void @mem.scratch_allocator_init(%mem.Scratch_Allocator* %scratch, {i8*, i64}* %data, %mem.Allocator* %backup_allocator, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Scratch_Allocator*, align 16
	store %mem.Scratch_Allocator* %scratch, %mem.Scratch_Allocator** %0
	%1 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%2 = load %mem.Allocator, %mem.Allocator* %backup_allocator, align 8
	; AssignStmt
	; SelectorExpr
	%3 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %0, align 8
	%4 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %3, i64 0
	%5 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %4, i64 0, i32 0
	%6 = load {i8*, i64}, {i8*, i64}* %data, align 8
	store {i8*, i64} %6, {i8*, i64}* %5
	; AssignStmt
	; SelectorExpr
	%7 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %0, align 8
	%8 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %7, i64 0
	%9 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %8, i64 0, i32 1
	store i64 0, i64* %9
	; AssignStmt
	; SelectorExpr
	%10 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %0, align 8
	%11 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %10, i64 0
	%12 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %11, i64 0, i32 2
	store i64 0, i64* %12
	; AssignStmt
	; SelectorExpr
	%13 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %0, align 8
	%14 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %13, i64 0
	%15 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %14, i64 0, i32 3
	%16 = load %mem.Allocator, %mem.Allocator* %backup_allocator, align 8
	store %mem.Allocator %16, %mem.Allocator* %15
	ret void
}

define %..rawptr @mem.scratch_allocator_proc(%..rawptr %allocator_data, i8 %mode, i64 %size, i64 %alignment, %..rawptr %old_memory, i64 %old_size, i64 %flags, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..rawptr, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca %mem.Scratch_Allocator*, align 16
	%8 = alloca %mem.Allocator, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca {i8*, i64}, align 16
	%11 = alloca %mem.Allocator, align 16
	%12 = alloca i64, align 16
	%13 = alloca i8*, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8*, align 16
	%16 = alloca %mem.Allocator, align 16
	%17 = alloca %..rawptr, align 16
	%18 = alloca %mem.Allocator, align 16
	%19 = alloca %runtime.Source_Code_Location, align 16
	%20 = alloca %mem.Allocator, align 16
	%21 = alloca %runtime.Source_Code_Location, align 16
	%22 = alloca %runtime.Source_Code_Location, align 16
	%23 = alloca %..rawptr, align 16
	%24 = alloca i64, align 16
	%25 = alloca %..rawptr, align 16
	%26 = alloca i64, align 16
	%27 = alloca %mem.Allocator, align 16
	%28 = alloca %runtime.Source_Code_Location, align 16
	%29 = alloca %..rawptr, align 16
	%30 = alloca %runtime.Source_Code_Location, align 16
	store %..rawptr %allocator_data, %..rawptr* %0
	store i8 %mode, i8* %1
	store i64 %size, i64* %2
	store i64 %alignment, i64* %3
	store %..rawptr %old_memory, %..rawptr* %4
	store i64 %old_size, i64* %5
	store i64 %flags, i64* %6
	%31 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; scratch
	%32 = load %..rawptr, %..rawptr* %0, align 8
	%33 = bitcast %..rawptr %32 to %mem.Scratch_Allocator*
	store %mem.Scratch_Allocator* %33, %mem.Scratch_Allocator** %7
	; IfStmt
	; SelectorExpr
	%34 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%35 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %34, i64 0
	%36 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %35, i64 0, i32 0
	%37 = load {i8*, i64}, {i8*, i64}* %36, align 8
	%38 = extractvalue {i8*, i64} %37, 0
	%39 = extractvalue {i8*, i64} %37, 1
	%40 = bitcast %..rawptr null to i8*
	%41 = icmp eq i8* %38, %40
	%42 = icmp eq i64 %39, 0
	%43 = zext i1 %41 to i8
	%44 = zext i1 %42 to i8
	%45 = or i8 %43, %44
	%46 = trunc i8 %45 to i1
	br i1 %46, label %if.then-1, label %if.done-2

if.then-1:
	%47 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	; SelectorExpr
	%48 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%49 = load %mem.Allocator, %mem.Allocator* %48, align 8
	%50 = bitcast %mem.Allocator* %8 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %8
	store %mem.Allocator %49, %mem.Allocator* %8
	%51 = bitcast %runtime.Source_Code_Location* %9 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %9
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$6d, i64 0, i32 0), i64 55}, i64 190, i64 35, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$6e, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %9
	%52 = call {i8*, i64} @mem.make_slice-14353(i64 4194304, %mem.Allocator* %8, %runtime.Source_Code_Location* %9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%53 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%54 = load %mem.Allocator, %mem.Allocator* %53, align 8
	%55 = bitcast {i8*, i64}* %10 to %..rawptr
	store {i8*, i64} zeroinitializer, {i8*, i64}* %10
	store {i8*, i64} %52, {i8*, i64}* %10
	%56 = bitcast %mem.Allocator* %11 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %11
	store %mem.Allocator %54, %mem.Allocator* %11
	call void @mem.scratch_allocator_init(%mem.Scratch_Allocator* %47, {i8*, i64}* %10, %mem.Allocator* %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-2

if.done-2:
	; SwitchStmt
	%57 = load i8, i8* %1, align 1
	%58 = icmp eq i8 %57, 0
	br i1 %58, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%59 = icmp eq i8 %57, 1
	br i1 %59, label %switch.fall.body-14, label %switch.case.next-13

switch.case.body-4:
	; SwitchStmt
	; SelectorExpr
	%60 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%61 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %60, i64 0
	%62 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %61, i64 0, i32 1
	%63 = load i64, i64* %62, align 8
	%64 = load i64, i64* %2, align 8
	%65 = add i64 %63, %64
	; SelectorExpr
	%66 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%67 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %66, i64 0
	%68 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %67, i64 0, i32 0
	%69 = load {i8*, i64}, {i8*, i64}* %68, align 8
	%70 = extractvalue {i8*, i64} %69, 1
	%71 = icmp sle i64 %65, %70
	%72 = zext i1 %71 to i8
	%73 = icmp eq i8 1, %72
	br i1 %73, label %switch.case.body-6, label %switch.case.next-5

switch.case.next-5:
	%74 = load i64, i64* %2, align 8
	; SelectorExpr
	%75 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%76 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %75, i64 0
	%77 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %76, i64 0, i32 0
	%78 = load {i8*, i64}, {i8*, i64}* %77, align 8
	%79 = extractvalue {i8*, i64} %78, 1
	%80 = icmp sle i64 %74, %79
	%81 = zext i1 %80 to i8
	%82 = icmp eq i8 1, %81
	br i1 %82, label %switch.fall.body-8, label %switch.case.next-7

switch.case.body-6:
	; offset
	; SelectorExpr
	%83 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%84 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %83, i64 0
	%85 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %84, i64 0, i32 1
	%86 = load i64, i64* %85, align 8
	%87 = bitcast i64 %86 to i64
	%88 = load i64, i64* %3, align 8
	%89 = bitcast i64 %88 to i64
	%90 = call i64 @mem.align_forward_uintptr(i64 %87, i64 %89, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %90, i64* %12
	; ptr
	; IndexExpr
	; SelectorExpr
	%91 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%92 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %91, i64 0
	%93 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %92, i64 0, i32 0
	%94 = load {i8*, i64}, {i8*, i64}* %93, align 8
	%95 = extractvalue {i8*, i64} %94, 0
	%96 = load i64, i64* %12, align 8
	%97 = bitcast i64 %96 to i64
	%98 = extractvalue {i8*, i64} %94, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$6f, i64 0, i32 0), i64 55}, i64 198, i64 25, i64 %97, i64 %98)
	%99 = getelementptr inbounds i8, i8* %95, i64 %97
	store i8* %99, i8** %13
	%100 = load i8*, i8** %13, align 8
	%101 = load i64, i64* %2, align 8
	%102 = bitcast i8* %100 to %..rawptr
	%103 = call %..rawptr @mem.zero(%..rawptr %102, i64 %101)
	; AssignStmt
	; SelectorExpr
	%104 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%105 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %104, i64 0
	%106 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %105, i64 0, i32 2
	%107 = load i64, i64* %12, align 8
	%108 = bitcast i64 %107 to i64
	store i64 %108, i64* %106
	; AssignStmt
	; SelectorExpr
	%109 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%110 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %109, i64 0
	%111 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %110, i64 0, i32 1
	%112 = load i64, i64* %12, align 8
	%113 = bitcast i64 %112 to i64
	%114 = load i64, i64* %2, align 8
	%115 = add i64 %113, %114
	store i64 %115, i64* %111
	; ReturnStmt
	%116 = load i8*, i8** %13, align 8
	%117 = bitcast i8* %116 to %..rawptr
	ret %..rawptr %117

switch.case.next-7:
	; a
	; SelectorExpr
	%118 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%119 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %118, i64 0
	%120 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %119, i64 0, i32 3
	%121 = load %mem.Allocator, %mem.Allocator* %120, align 8
	store %mem.Allocator %121, %mem.Allocator* %16
	; IfStmt
	; SelectorExpr
	%122 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %16, i64 0, i32 0
	%123 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %122, align 8
	%124 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %123, zeroinitializer
	%125 = zext i1 %124 to i8
	%126 = trunc i8 %125 to i1
	br i1 %126, label %if.then-9, label %if.done-10

switch.fall.body-8:
	; offset
	%127 = load i64, i64* %3, align 8
	%128 = bitcast i64 %127 to i64
	%129 = call i64 @mem.align_forward_uintptr(i64 0, i64 %128, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %129, i64* %14
	; ptr
	; IndexExpr
	; SelectorExpr
	%130 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%131 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %130, i64 0
	%132 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %131, i64 0, i32 0
	%133 = load {i8*, i64}, {i8*, i64}* %132, align 8
	%134 = extractvalue {i8*, i64} %133, 0
	%135 = load i64, i64* %14, align 8
	%136 = bitcast i64 %135 to i64
	%137 = extractvalue {i8*, i64} %133, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$70, i64 0, i32 0), i64 55}, i64 205, i64 25, i64 %136, i64 %137)
	%138 = getelementptr inbounds i8, i8* %134, i64 %136
	store i8* %138, i8** %15
	%139 = load i8*, i8** %15, align 8
	%140 = load i64, i64* %2, align 8
	%141 = bitcast i8* %139 to %..rawptr
	%142 = call %..rawptr @mem.zero(%..rawptr %141, i64 %140)
	; AssignStmt
	; SelectorExpr
	%143 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%144 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %143, i64 0
	%145 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %144, i64 0, i32 2
	%146 = load i64, i64* %14, align 8
	%147 = bitcast i64 %146 to i64
	store i64 %147, i64* %145
	; AssignStmt
	; SelectorExpr
	%148 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%149 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %148, i64 0
	%150 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %149, i64 0, i32 1
	%151 = load i64, i64* %14, align 8
	%152 = bitcast i64 %151 to i64
	%153 = load i64, i64* %2, align 8
	%154 = add i64 %152, %153
	store i64 %154, i64* %150
	; ReturnStmt
	%155 = load i8*, i8** %15, align 8
	%156 = bitcast i8* %155 to %..rawptr
	ret %..rawptr %156

if.then-9:
	; AssignStmt
	; SelectorExpr
	%157 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%158 = load %mem.Allocator, %mem.Allocator* %157, align 8
	store %mem.Allocator %158, %mem.Allocator* %16
	; AssignStmt
	; SelectorExpr
	%159 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%160 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %159, i64 0
	%161 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %160, i64 0, i32 3
	%162 = load %mem.Allocator, %mem.Allocator* %16, align 8
	store %mem.Allocator %162, %mem.Allocator* %161
	br label %if.done-10

if.done-10:
	; ptr
	%163 = load i64, i64* %2, align 8
	%164 = load i64, i64* %3, align 8
	%165 = load %mem.Allocator, %mem.Allocator* %16, align 8
	%166 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%167 = bitcast %mem.Allocator* %18 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %18
	store %mem.Allocator %165, %mem.Allocator* %18
	%168 = bitcast %runtime.Source_Code_Location* %19 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %19
	store %runtime.Source_Code_Location %166, %runtime.Source_Code_Location* %19
	%169 = call %..rawptr @mem.alloc(i64 %163, i64 %164, %mem.Allocator* %18, %runtime.Source_Code_Location* %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %169, %..rawptr* %17
	; IfStmt
	; SelectorExpr
	%170 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%171 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %170, i64 0
	%172 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %171, i64 0, i32 4
	%173 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %172, align 8
	%174 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %173, 0
	%175 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %173, 2
	%176 = bitcast %..rawptr null to %..rawptr*
	%177 = icmp eq %..rawptr* %174, %176
	%178 = icmp eq i64 %175, 0
	%179 = zext i1 %177 to i8
	%180 = zext i1 %178 to i8
	%181 = or i8 %179, %180
	%182 = trunc i8 %181 to i1
	br i1 %182, label %if.then-11, label %if.done-12

if.then-11:
	; AssignStmt
	; SelectorExpr
	%183 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%184 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %183, i64 0
	%185 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %184, i64 0, i32 4
	%186 = load %mem.Allocator, %mem.Allocator* %16, align 8
	%187 = bitcast %mem.Allocator* %20 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %20
	store %mem.Allocator %186, %mem.Allocator* %20
	%188 = bitcast %runtime.Source_Code_Location* %21 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %21
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$71, i64 0, i32 0), i64 55}, i64 220, i64 33, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$72, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %21
	%189 = call {%..rawptr*, i64, i64, %mem.Allocator} @mem.make_dynamic_array-14458(%mem.Allocator* %20, %runtime.Source_Code_Location* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {%..rawptr*, i64, i64, %mem.Allocator} %189, {%..rawptr*, i64, i64, %mem.Allocator}* %185
	br label %if.done-12

if.done-12:
	; SelectorExpr
	%190 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%191 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %190, i64 0
	%192 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %191, i64 0, i32 4
	%193 = load %..rawptr, %..rawptr* %17, align 8
	%194 = bitcast %runtime.Source_Code_Location* %22 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %22
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$73, i64 0, i32 0), i64 55}, i64 222, i64 3, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$74, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %22
	%195 = call i64 @runtime.append_elem-14503({%..rawptr*, i64, i64, %mem.Allocator}* %192, %..rawptr %193, %runtime.Source_Code_Location* %22, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%196 = load %..rawptr, %..rawptr* %17, align 8
	ret %..rawptr %196

switch.case.next-13:
	%197 = icmp eq i8 %57, 2
	br i1 %197, label %switch.fall.body-18, label %switch.case.next-17

switch.fall.body-14:
	; last_ptr
	; IndexExpr
	; SelectorExpr
	%198 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%199 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %198, i64 0
	%200 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %199, i64 0, i32 0
	%201 = load {i8*, i64}, {i8*, i64}* %200, align 8
	%202 = extractvalue {i8*, i64} %201, 0
	; SelectorExpr
	%203 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%204 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %203, i64 0
	%205 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %204, i64 0, i32 2
	%206 = load i64, i64* %205, align 8
	%207 = extractvalue {i8*, i64} %201, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$75, i64 0, i32 0), i64 55}, i64 227, i64 44, i64 %206, i64 %207)
	%208 = getelementptr inbounds i8, i8* %202, i64 %206
	%209 = bitcast i8* %208 to %..rawptr
	store %..rawptr %209, %..rawptr* %23
	; IfStmt
	%210 = load %..rawptr, %..rawptr* %4, align 8
	%211 = load %..rawptr, %..rawptr* %23, align 8
	%212 = icmp eq %..rawptr %210, %211
	%213 = zext i1 %212 to i8
	%214 = trunc i8 %213 to i1
	br i1 %214, label %if.then-15, label %if.done-16

if.then-15:
	; size
	; SelectorExpr
	%215 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%216 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %215, i64 0
	%217 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %216, i64 0, i32 1
	%218 = load i64, i64* %217, align 8
	; SelectorExpr
	%219 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%220 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %219, i64 0
	%221 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %220, i64 0, i32 2
	%222 = load i64, i64* %221, align 8
	%223 = sub i64 %218, %222
	store i64 %223, i64* %24
	; AssignStmt
	; SelectorExpr
	%224 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%225 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %224, i64 0
	%226 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %225, i64 0, i32 1
	; SelectorExpr
	%227 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%228 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %227, i64 0
	%229 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %228, i64 0, i32 2
	%230 = load i64, i64* %229, align 8
	store i64 %230, i64* %226
	%231 = load %..rawptr, %..rawptr* %23, align 8
	%232 = load i64, i64* %24, align 8
	%233 = call %..rawptr @mem.zero(%..rawptr %231, i64 %232)
	; ReturnStmt
	ret %..rawptr zeroinitializer

if.done-16:
	br label %switch.done-27

switch.case.next-17:
	%234 = icmp eq i8 %57, 3
	br i1 %234, label %switch.fall.body-23, label %switch.case.next-22

switch.fall.body-18:
	; AssignStmt
	; SelectorExpr
	%235 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%236 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %235, i64 0
	%237 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %236, i64 0, i32 1
	store i64 0, i64* %237
	; AssignStmt
	; SelectorExpr
	%238 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%239 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %238, i64 0
	%240 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %239, i64 0, i32 2
	store i64 0, i64* %240
	; RangeStmt
	; ptr
	%241 = bitcast %..rawptr* %25 to %..rawptr
	store %..rawptr zeroinitializer, %..rawptr* %25
	; SelectorExpr
	%242 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%243 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %242, i64 0
	%244 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %243, i64 0, i32 4
	%245 = getelementptr inbounds {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %244, i64 0, i32 1
	%246 = bitcast i64* %26 to %..rawptr
	store i64 zeroinitializer, i64* %26
	store i64 -1, i64* %26
	br label %for.index.loop-19

for.index.loop-19:
	%247 = load i64, i64* %26, align 8
	%248 = add i64 %247, 1
	store i64 %248, i64* %26
	%249 = load i64, i64* %245, align 8
	%250 = icmp slt i64 %248, %249
	br i1 %250, label %for.index.body-20, label %for.index.done-21

for.index.body-20:
	%251 = load i64, i64* %26, align 8
	%252 = getelementptr inbounds {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %244, i64 0, i32 0
	%253 = load %..rawptr*, %..rawptr** %252, align 8
	%254 = getelementptr inbounds %..rawptr, %..rawptr* %253, i64 %251
	%255 = load %..rawptr, %..rawptr* %254, align 8
	store %..rawptr %255, %..rawptr* %25
	%256 = load %..rawptr, %..rawptr* %25, align 8
	; SelectorExpr
	%257 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%258 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %257, i64 0
	%259 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %258, i64 0, i32 3
	%260 = load %mem.Allocator, %mem.Allocator* %259, align 8
	%261 = bitcast %mem.Allocator* %27 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %27
	store %mem.Allocator %260, %mem.Allocator* %27
	%262 = bitcast %runtime.Source_Code_Location* %28 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %28
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$76, i64 0, i32 0), i64 55}, i64 240, i64 4, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$77, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %28
	call void @mem.free(%..rawptr %256, %mem.Allocator* %27, %runtime.Source_Code_Location* %28, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-19

for.index.done-21:
	; SelectorExpr
	%263 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%264 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %263, i64 0
	%265 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %264, i64 0, i32 4
	call void @runtime.clear_dynamic_array-14532({%..rawptr*, i64, i64, %mem.Allocator}* %265)
	br label %switch.done-27

switch.case.next-22:
	br label %switch.done-27

switch.fall.body-23:
	; last_ptr
	; IndexExpr
	; SelectorExpr
	%266 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%267 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %266, i64 0
	%268 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %267, i64 0, i32 0
	%269 = load {i8*, i64}, {i8*, i64}* %268, align 8
	%270 = extractvalue {i8*, i64} %269, 0
	; SelectorExpr
	%271 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%272 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %271, i64 0
	%273 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %272, i64 0, i32 2
	%274 = load i64, i64* %273, align 8
	%275 = extractvalue {i8*, i64} %269, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$78, i64 0, i32 0), i64 55}, i64 245, i64 44, i64 %274, i64 %275)
	%276 = getelementptr inbounds i8, i8* %270, i64 %274
	%277 = bitcast i8* %276 to %..rawptr
	store %..rawptr %277, %..rawptr* %29
	; IfStmt
	%278 = load %..rawptr, %..rawptr* %4, align 8
	%279 = load %..rawptr, %..rawptr* %29, align 8
	%280 = icmp eq %..rawptr %278, %279
	%281 = zext i1 %280 to i8
	%282 = trunc i8 %281 to i1
	br i1 %282, label %cmp.and-24, label %if.done-26

cmp.and-24:
	; SelectorExpr
	%283 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%284 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %283, i64 0
	%285 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %284, i64 0, i32 0
	%286 = load {i8*, i64}, {i8*, i64}* %285, align 8
	%287 = extractvalue {i8*, i64} %286, 1
	; SelectorExpr
	%288 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%289 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %288, i64 0
	%290 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %289, i64 0, i32 2
	%291 = load i64, i64* %290, align 8
	%292 = sub i64 %287, %291
	%293 = load i64, i64* %2, align 8
	%294 = icmp sge i64 %292, %293
	%295 = zext i1 %294 to i8
	%296 = trunc i8 %295 to i1
	br i1 %296, label %if.then-25, label %if.done-26

if.then-25:
	; AssignStmt
	; SelectorExpr
	%297 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%298 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %297, i64 0
	%299 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %298, i64 0, i32 1
	; SelectorExpr
	%300 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%301 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %300, i64 0
	%302 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %301, i64 0, i32 2
	%303 = load i64, i64* %302, align 8
	%304 = load i64, i64* %2, align 8
	%305 = add i64 %303, %304
	store i64 %305, i64* %299
	; ReturnStmt
	%306 = load %..rawptr, %..rawptr* %4, align 8
	ret %..rawptr %306

if.done-26:
	; ReturnStmt
	%307 = load %..rawptr, %..rawptr* %0, align 8
	%308 = load i64, i64* %2, align 8
	%309 = load i64, i64* %3, align 8
	%310 = load %..rawptr, %..rawptr* %4, align 8
	%311 = load i64, i64* %5, align 8
	%312 = load i64, i64* %6, align 8
	%313 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%314 = bitcast %runtime.Source_Code_Location* %30 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %30
	store %runtime.Source_Code_Location %313, %runtime.Source_Code_Location* %30
	%315 = call %..rawptr @mem.scratch_allocator_proc(%..rawptr %307, i8 0, i64 %308, i64 %309, %..rawptr %310, i64 %311, i64 %312, %runtime.Source_Code_Location* %30, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret %..rawptr %315

switch.done-27:
	; ReturnStmt
	ret %..rawptr zeroinitializer
}

define {i64, i64} @os.write_string(i32 %fd, %..string %str, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i8*, align 16
	%3 = alloca {i8*, i64}, align 16
	%4 = alloca {i8*, i64}, align 16
	%5 = alloca {i64, i64}, align 16
	store i32 %fd, i32* %0
	store %..string %str, %..string* %1
	; ReturnStmt
	%6 = load i32, i32* %0, align 4
	%7 = load %..string, %..string* %1, align 8
	%8 = extractvalue %..string %7, 0
	%9 = bitcast i8** %2 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 8) noinline
	store i8* zeroinitializer, i8** %2
	store i8* %8, i8** %2
	%11 = extractvalue %..string %7, 1
	%12 = sub i64 %11, 0
	%13 = load i8*, i8** %2, align 8
	%14 = getelementptr inbounds i8, i8* %13, i64 0
	%15 = bitcast {i8*, i64}* %3 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %3
	%17 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3, i64 0, i32 0
	store i8* %14, i8** %17
	%18 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3, i64 0, i32 1
	store i64 %12, i64* %18
	%19 = load {i8*, i64}, {i8*, i64}* %3, align 8
	%20 = bitcast {i8*, i64}* %4 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %4
	store {i8*, i64} %19, {i8*, i64}* %4
	%22 = call {i64, i64} @os.write(i32 %6, {i8*, i64}* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = extractvalue {i64, i64} %22, 0
	%24 = extractvalue {i64, i64} %22, 1
	%25 = bitcast {i64, i64}* %5 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %5
	%27 = getelementptr inbounds {i64, i64}, {i64, i64}* %5, i64 0, i32 0
	store i64 %23, i64* %27
	%28 = getelementptr inbounds {i64, i64}, {i64, i64}* %5, i64 0, i32 1
	store i64 %24, i64* %28
	%29 = load {i64, i64}, {i64, i64}* %5, align 8
	ret {i64, i64} %29
}

define {i64, i64} @os.write_byte(i32 %fd, i8 %b, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i8, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca {i8*, i64}, align 16
	%4 = alloca {i64, i64}, align 16
	store i32 %fd, i32* %0
	store i8 %b, i8* %1
	; ReturnStmt
	%5 = load i32, i32* %0, align 4
	; CompoundLit
	%6 = bitcast {i8*, i64}* %2 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %2
	%8 = getelementptr inbounds [1 x i8], [1 x i8]* @csba$0, i64 0, i32 0
	%9 = load i8, i8* %1, align 1
	%10 = getelementptr inbounds i8, i8* %8, i64 0
	store i8 %9, i8* %10
	%11 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 0
	store i8* %8, i8** %11
	%12 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 1
	store i64 1, i64* %12
	%13 = load {i8*, i64}, {i8*, i64}* %2, align 8
	%14 = bitcast {i8*, i64}* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %3
	store {i8*, i64} %13, {i8*, i64}* %3
	%16 = call {i64, i64} @os.write(i32 %5, {i8*, i64}* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = extractvalue {i64, i64} %16, 0
	%18 = extractvalue {i64, i64} %16, 1
	%19 = bitcast {i64, i64}* %4 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %4
	%21 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 0
	store i64 %17, i64* %21
	%22 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 1
	store i64 %18, i64* %22
	%23 = load {i64, i64}, {i64, i64}* %4, align 8
	ret {i64, i64} %23
}

define {i64, i64} @os.write_rune(i32 %fd, i32 %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i32, align 16
	%2 = alloca {i64, i64}, align 16
	%3 = alloca [4 x i8], align 16
	%4 = alloca i64, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca {i8*, i64}, align 16
	%7 = alloca {i64, i64}, align 16
	store i32 %fd, i32* %0
	store i32 %r, i32* %1
	; IfStmt
	%8 = load i32, i32* %1, align 4
	%9 = icmp slt i32 %8, 128
	%10 = zext i1 %9 to i8
	%11 = trunc i8 %10 to i1
	br i1 %11, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%12 = load i32, i32* %0, align 4
	%13 = load i32, i32* %1, align 4
	%14 = trunc i32 %13 to i8
	%15 = call {i64, i64} @os.write_byte(i32 %12, i8 %14, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%16 = extractvalue {i64, i64} %15, 0
	%17 = extractvalue {i64, i64} %15, 1
	%18 = bitcast {i64, i64}* %2 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %2
	%20 = getelementptr inbounds {i64, i64}, {i64, i64}* %2, i64 0, i32 0
	store i64 %16, i64* %20
	%21 = getelementptr inbounds {i64, i64}, {i64, i64}* %2, i64 0, i32 1
	store i64 %17, i64* %21
	%22 = load {i64, i64}, {i64, i64}* %2, align 8
	ret {i64, i64} %22

if.done-2:
	; b
	; n
	; SelectorExpr
	%23 = load i32, i32* %1, align 4
	%24 = call {[4 x i8], i64} @utf8.encode_rune(i32 %23, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%25 = extractvalue {[4 x i8], i64} %24, 0
	%26 = extractvalue {[4 x i8], i64} %24, 1
	store [4 x i8] %25, [4 x i8]* %3
	store i64 %26, i64* %4
	; ReturnStmt
	%27 = load i32, i32* %0, align 4
	; SliceExpr
	%28 = load i64, i64* %4, align 8
	%29 = load [4 x i8], [4 x i8]* %3, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([52 x i8], [52 x i8]* @str$79, i64 0, i32 0), i64 51}, i64 21, i64 20, i64 0, i64 %28, i64 4)
	%30 = getelementptr inbounds [4 x i8], [4 x i8]* %3, i64 0, i32 0
	%31 = getelementptr inbounds i8, i8* %30, i64 0
	%32 = sub i64 %28, 0
	%33 = bitcast {i8*, i64}* %5 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	%35 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 0
	store i8* %31, i8** %35
	%36 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 1
	store i64 %32, i64* %36
	%37 = load {i8*, i64}, {i8*, i64}* %5, align 8
	%38 = bitcast {i8*, i64}* %6 to %..rawptr
	%39 = call %..rawptr @mem.zero(%..rawptr %38, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	store {i8*, i64} %37, {i8*, i64}* %6
	%40 = call {i64, i64} @os.write(i32 %27, {i8*, i64}* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%41 = extractvalue {i64, i64} %40, 0
	%42 = extractvalue {i64, i64} %40, 1
	%43 = bitcast {i64, i64}* %7 to %..rawptr
	%44 = call %..rawptr @mem.zero(%..rawptr %43, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %7
	%45 = getelementptr inbounds {i64, i64}, {i64, i64}* %7, i64 0, i32 0
	store i64 %41, i64* %45
	%46 = getelementptr inbounds {i64, i64}, {i64, i64}* %7, i64 0, i32 1
	store i64 %42, i64* %46
	%47 = load {i64, i64}, {i64, i64}* %7, align 8
	ret {i64, i64} %47
}

define void @os.write_encoded_rune(i32 %fd, i32 %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i32, align 16
	%2 = alloca [2 x i8], align 16
	%3 = alloca %..string, align 16
	%4 = alloca {i8*, i64}, align 16
	%5 = alloca {i8*, i64}, align 16
	store i32 %fd, i32* %0
	store i32 %r, i32* %1
	%6 = load i32, i32* %0, align 4
	%7 = call {i64, i64} @os.write_byte(i32 %6, i8 39, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SwitchStmt
	%8 = load i32, i32* %1, align 4
	%9 = icmp eq i32 %8, 7
	br i1 %9, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%10 = icmp eq i32 %8, 8
	br i1 %10, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	%11 = load i32, i32* %0, align 4
	%12 = call {i64, i64} @os.write_string(i32 %11, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7a, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-3:
	%13 = icmp eq i32 %8, 27
	br i1 %13, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	%14 = load i32, i32* %0, align 4
	%15 = call {i64, i64} @os.write_string(i32 %14, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7b, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-5:
	%16 = icmp eq i32 %8, 12
	br i1 %16, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	%17 = load i32, i32* %0, align 4
	%18 = call {i64, i64} @os.write_string(i32 %17, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7c, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-7:
	%19 = icmp eq i32 %8, 10
	br i1 %19, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	%20 = load i32, i32* %0, align 4
	%21 = call {i64, i64} @os.write_string(i32 %20, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7d, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-9:
	%22 = icmp eq i32 %8, 13
	br i1 %22, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	%23 = load i32, i32* %0, align 4
	%24 = call {i64, i64} @os.write_string(i32 %23, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7e, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-11:
	%25 = icmp eq i32 %8, 9
	br i1 %25, label %switch.fall.body-14, label %switch.case.next-13

switch.fall.body-12:
	%26 = load i32, i32* %0, align 4
	%27 = call {i64, i64} @os.write_string(i32 %26, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7f, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-13:
	%28 = icmp eq i32 %8, 11
	br i1 %28, label %switch.fall.body-16, label %switch.case.next-15

switch.fall.body-14:
	%29 = load i32, i32* %0, align 4
	%30 = call {i64, i64} @os.write_string(i32 %29, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$80, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-15:
	; IfStmt
	%31 = load i32, i32* %1, align 4
	%32 = icmp slt i32 %31, 32
	%33 = zext i1 %32 to i8
	%34 = trunc i8 %33 to i1
	br i1 %34, label %if.then-17, label %if.else-25

switch.fall.body-16:
	%35 = load i32, i32* %0, align 4
	%36 = call {i64, i64} @os.write_string(i32 %35, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$81, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

if.then-17:
	%37 = load i32, i32* %0, align 4
	%38 = call {i64, i64} @os.write_string(i32 %37, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$82, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; b
	%39 = bitcast [2 x i8]* %2 to %..rawptr
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 2) noinline
	store [2 x i8] zeroinitializer, [2 x i8]* %2
	; s
	; SelectorExpr
	; SliceExpr
	%41 = load [2 x i8], [2 x i8]* %2, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([52 x i8], [52 x i8]* @str$83, i64 0, i32 0), i64 51}, i64 40, i64 30, i64 0, i64 2, i64 2)
	%42 = getelementptr inbounds [2 x i8], [2 x i8]* %2, i64 0, i32 0
	%43 = getelementptr inbounds i8, i8* %42, i64 0
	%44 = sub i64 2, 0
	%45 = bitcast {i8*, i64}* %4 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %4
	%47 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4, i64 0, i32 0
	store i8* %43, i8** %47
	%48 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4, i64 0, i32 1
	store i64 %44, i64* %48
	%49 = load {i8*, i64}, {i8*, i64}* %4, align 8
	%50 = load i32, i32* %1, align 4
	%51 = sext i32 %50 to i64
	; SelectorExpr
	%52 = load %..string, %..string* @strconv.digits, align 8
	%53 = bitcast {i8*, i64}* %5 to %..rawptr
	%54 = call %..rawptr @mem.zero(%..rawptr %53, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	store {i8*, i64} %49, {i8*, i64}* %5
	%55 = call %..string @strconv.append_bits({i8*, i64}* %5, i64 %51, i64 16, i1 true, i64 64, %..string %52, i8 zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %55, %..string* %3
	; SwitchStmt
	%56 = load %..string, %..string* %3, align 8
	%57 = extractvalue %..string %56, 1
	%58 = icmp eq i64 %57, 0
	br i1 %58, label %switch.case.body-19, label %switch.case.next-18

switch.case.next-18:
	%59 = icmp eq i64 %57, 1
	br i1 %59, label %switch.fall.body-21, label %switch.case.next-20

switch.case.body-19:
	%60 = load i32, i32* %0, align 4
	%61 = call {i64, i64} @os.write_string(i32 %60, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$84, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-20:
	%62 = icmp eq i64 %57, 2
	br i1 %62, label %switch.fall.body-23, label %switch.case.next-22

switch.fall.body-21:
	%63 = load i32, i32* %0, align 4
	%64 = call {i64, i64} @os.write_rune(i32 %63, i32 48, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-22:
	br label %switch.done-24

switch.fall.body-23:
	%65 = load i32, i32* %0, align 4
	%66 = load %..string, %..string* %3, align 8
	%67 = call {i64, i64} @os.write_string(i32 %65, %..string %66, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.done-24:
	br label %if.done-26

if.else-25:
	%68 = load i32, i32* %0, align 4
	%69 = load i32, i32* %1, align 4
	%70 = call {i64, i64} @os.write_rune(i32 %68, i32 %69, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-26

if.done-26:
	br label %switch.done-27

switch.done-27:
	%71 = load i32, i32* %0, align 4
	%72 = call {i64, i64} @os.write_byte(i32 %71, i8 39, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define {{i8*, i64}, i8} @os.read_entire_file(%..string %name, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca {i8*, i64}, align 16
	%2 = alloca i8, align 16
	%3 = alloca i32, align 16
	%4 = alloca i64, align 16
	%5 = alloca {{i8*, i64}, i8}, align 16
	%6 = alloca i64, align 16
	%7 = alloca {{i8*, i64}, i8}, align 16
	%8 = alloca {{i8*, i64}, i8}, align 16
	%9 = alloca %mem.Allocator, align 16
	%10 = alloca %runtime.Source_Code_Location, align 16
	%11 = alloca {{i8*, i64}, i8}, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca {i8*, i64}, align 16
	%15 = alloca {i8*, i64}, align 16
	%16 = alloca %mem.Allocator, align 16
	%17 = alloca %runtime.Source_Code_Location, align 16
	%18 = alloca {{i8*, i64}, i8}, align 16
	%19 = alloca {i8*, i64}, align 16
	%20 = alloca {{i8*, i64}, i8}, align 16
	store %..string %name, %..string* %0
	%21 = bitcast {i8*, i64}* %1 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %1
	%23 = bitcast i8* %2 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 1) noinline
	store i8 zeroinitializer, i8* %2
	; fd
	; err
	%25 = load %..string, %..string* %0, align 8
	%26 = call {i32, i64} @os.open(%..string %25, i64 0, i32 0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%27 = extractvalue {i32, i64} %26, 0
	%28 = extractvalue {i32, i64} %26, 1
	store i32 %27, i32* %3
	store i64 %28, i64* %4
	; IfStmt
	%29 = load i64, i64* %4, align 8
	%30 = icmp ne i64 %29, 0
	%31 = zext i1 %30 to i8
	%32 = trunc i8 %31 to i1
	br i1 %32, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%33 = bitcast {{i8*, i64}, i8}* %5 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 24) noinline
	store {{i8*, i64}, i8} zeroinitializer, {{i8*, i64}, i8}* %5
	%35 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %5, i64 0, i32 0
	store {i8*, i64} zeroinitializer, {i8*, i64}* %35
	%36 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %5, i64 0, i32 1
	store i8 0, i8* %36
	%37 = load {{i8*, i64}, i8}, {{i8*, i64}, i8}* %5, align 8
	ret {{i8*, i64}, i8} %37

if.done-2:
	; DeferStmt
	; length
	%38 = bitcast i64* %6 to %..rawptr
	%39 = call %..rawptr @mem.zero(%..rawptr %38, i64 8) noinline
	store i64 zeroinitializer, i64* %6
	; IfStmt
	; AssignStmt
	%40 = load i32, i32* %3, align 4
	%41 = call {i64, i64} @os.file_size(i32 %40, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%42 = extractvalue {i64, i64} %41, 0
	%43 = extractvalue {i64, i64} %41, 1
	store i64 %42, i64* %6
	store i64 %43, i64* %4
	%44 = load i64, i64* %4, align 8
	%45 = icmp ne i64 %44, 0
	%46 = zext i1 %45 to i8
	%47 = trunc i8 %46 to i1
	br i1 %47, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	%48 = bitcast {{i8*, i64}, i8}* %7 to %..rawptr
	%49 = call %..rawptr @mem.zero(%..rawptr %48, i64 24) noinline
	store {{i8*, i64}, i8} zeroinitializer, {{i8*, i64}, i8}* %7
	%50 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %7, i64 0, i32 0
	store {i8*, i64} zeroinitializer, {i8*, i64}* %50
	%51 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %7, i64 0, i32 1
	store i8 0, i8* %51
	%52 = load {{i8*, i64}, i8}, {{i8*, i64}, i8}* %7, align 8
	; defer
	%53 = load i32, i32* %3, align 4
	call void @os.close(i32 %53, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {{i8*, i64}, i8} %52

if.done-4:
	; IfStmt
	%54 = load i64, i64* %6, align 8
	%55 = icmp sle i64 %54, 0
	%56 = zext i1 %55 to i8
	%57 = trunc i8 %56 to i1
	br i1 %57, label %if.then-5, label %if.done-6

if.then-5:
	; ReturnStmt
	%58 = bitcast {{i8*, i64}, i8}* %8 to %..rawptr
	%59 = call %..rawptr @mem.zero(%..rawptr %58, i64 24) noinline
	store {{i8*, i64}, i8} zeroinitializer, {{i8*, i64}, i8}* %8
	%60 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %8, i64 0, i32 0
	store {i8*, i64} zeroinitializer, {i8*, i64}* %60
	%61 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %8, i64 0, i32 1
	store i8 1, i8* %61
	%62 = load {{i8*, i64}, i8}, {{i8*, i64}, i8}* %8, align 8
	; defer
	%63 = load i32, i32* %3, align 4
	call void @os.close(i32 %63, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {{i8*, i64}, i8} %62

if.done-6:
	; AssignStmt
	%64 = load i64, i64* %6, align 8
	%65 = bitcast i64 %64 to i64
	; SelectorExpr
	%66 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%67 = load %mem.Allocator, %mem.Allocator* %66, align 8
	%68 = bitcast %mem.Allocator* %9 to %..rawptr
	%69 = call %..rawptr @mem.zero(%..rawptr %68, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %9
	store %mem.Allocator %67, %mem.Allocator* %9
	%70 = bitcast %runtime.Source_Code_Location* %10 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %10
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([52 x i8], [52 x i8]* @str$85, i64 0, i32 0), i64 51}, i64 70, i64 9, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$86, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %10
	%72 = call {i8*, i64} @mem.make_slice-14353(i64 %65, %mem.Allocator* %9, %runtime.Source_Code_Location* %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64} %72, {i8*, i64}* %1
	; IfStmt
	%73 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%74 = extractvalue {i8*, i64} %73, 0
	%75 = extractvalue {i8*, i64} %73, 1
	%76 = bitcast %..rawptr null to i8*
	%77 = icmp eq i8* %74, %76
	%78 = icmp eq i64 %75, 0
	%79 = zext i1 %77 to i8
	%80 = zext i1 %78 to i8
	%81 = or i8 %79, %80
	%82 = trunc i8 %81 to i1
	br i1 %82, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	%83 = bitcast {{i8*, i64}, i8}* %11 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 24) noinline
	store {{i8*, i64}, i8} zeroinitializer, {{i8*, i64}, i8}* %11
	%85 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %11, i64 0, i32 0
	store {i8*, i64} zeroinitializer, {i8*, i64}* %85
	%86 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %11, i64 0, i32 1
	store i8 0, i8* %86
	%87 = load {{i8*, i64}, i8}, {{i8*, i64}, i8}* %11, align 8
	; defer
	%88 = load i32, i32* %3, align 4
	call void @os.close(i32 %88, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {{i8*, i64}, i8} %87

if.done-8:
	; bytes_read
	; read_err
	%89 = load i32, i32* %3, align 4
	%90 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%91 = bitcast {i8*, i64}* %14 to %..rawptr
	%92 = call %..rawptr @mem.zero(%..rawptr %91, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %14
	store {i8*, i64} %90, {i8*, i64}* %14
	%93 = call {i64, i64} @os.read(i32 %89, {i8*, i64}* %14, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%94 = extractvalue {i64, i64} %93, 0
	%95 = extractvalue {i64, i64} %93, 1
	store i64 %94, i64* %12
	store i64 %95, i64* %13
	; IfStmt
	%96 = load i64, i64* %13, align 8
	%97 = icmp ne i64 %96, 0
	%98 = zext i1 %97 to i8
	%99 = trunc i8 %98 to i1
	br i1 %99, label %if.then-9, label %if.done-10

if.then-9:
	%100 = load {i8*, i64}, {i8*, i64}* %1, align 8
	; SelectorExpr
	%101 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%102 = load %mem.Allocator, %mem.Allocator* %101, align 8
	%103 = bitcast {i8*, i64}* %15 to %..rawptr
	%104 = call %..rawptr @mem.zero(%..rawptr %103, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %15
	store {i8*, i64} %100, {i8*, i64}* %15
	%105 = bitcast %mem.Allocator* %16 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %16
	store %mem.Allocator %102, %mem.Allocator* %16
	%107 = bitcast %runtime.Source_Code_Location* %17 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %17
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([52 x i8], [52 x i8]* @str$87, i64 0, i32 0), i64 51}, i64 77, i64 3, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$88, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %17
	call void @mem.delete_slice-14873({i8*, i64}* %15, %mem.Allocator* %16, %runtime.Source_Code_Location* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%109 = bitcast {{i8*, i64}, i8}* %18 to %..rawptr
	%110 = call %..rawptr @mem.zero(%..rawptr %109, i64 24) noinline
	store {{i8*, i64}, i8} zeroinitializer, {{i8*, i64}, i8}* %18
	%111 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %18, i64 0, i32 0
	store {i8*, i64} zeroinitializer, {i8*, i64}* %111
	%112 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %18, i64 0, i32 1
	store i8 0, i8* %112
	%113 = load {{i8*, i64}, i8}, {{i8*, i64}, i8}* %18, align 8
	; defer
	%114 = load i32, i32* %3, align 4
	call void @os.close(i32 %114, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {{i8*, i64}, i8} %113

if.done-10:
	; ReturnStmt
	; SliceExpr
	%115 = load i64, i64* %12, align 8
	%116 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%117 = extractvalue {i8*, i64} %116, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([52 x i8], [52 x i8]* @str$89, i64 0, i32 0), i64 51}, i64 80, i64 13, i64 0, i64 %115, i64 %117)
	%118 = extractvalue {i8*, i64} %116, 0
	%119 = getelementptr inbounds i8, i8* %118, i64 0
	%120 = sub i64 %115, 0
	%121 = bitcast {i8*, i64}* %19 to %..rawptr
	%122 = call %..rawptr @mem.zero(%..rawptr %121, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %19
	%123 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %19, i64 0, i32 0
	store i8* %119, i8** %123
	%124 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %19, i64 0, i32 1
	store i64 %120, i64* %124
	%125 = load {i8*, i64}, {i8*, i64}* %19, align 8
	%126 = bitcast {{i8*, i64}, i8}* %20 to %..rawptr
	%127 = call %..rawptr @mem.zero(%..rawptr %126, i64 24) noinline
	store {{i8*, i64}, i8} zeroinitializer, {{i8*, i64}, i8}* %20
	%128 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %20, i64 0, i32 0
	store {i8*, i64} %125, {i8*, i64}* %128
	%129 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %20, i64 0, i32 1
	store i8 1, i8* %129
	%130 = load {{i8*, i64}, i8}, {{i8*, i64}, i8}* %20, align 8
	; defer
	%131 = load i32, i32* %3, align 4
	call void @os.close(i32 %131, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {{i8*, i64}, i8} %130
}

define %..rawptr @os.heap_allocator_proc(%..rawptr %allocator_data, i8 %mode, i64 %size, i64 %alignment, %..rawptr %old_memory, i64 %old_size, i64 %flags, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..rawptr, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store %..rawptr %allocator_data, %..rawptr* %0
	store i8 %mode, i8* %1
	store i64 %size, i64* %2
	store i64 %alignment, i64* %3
	store %..rawptr %old_memory, %..rawptr* %4
	store i64 %old_size, i64* %5
	store i64 %flags, i64* %6
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SwitchStmt
	%10 = load i8, i8* %1, align 1
	%11 = icmp eq i8 %10, 0
	br i1 %11, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%12 = icmp eq i8 %10, 1
	br i1 %12, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	; ReturnStmt
	%13 = load i64, i64* %2, align 8
	%14 = call %..rawptr @os.heap_alloc(i64 %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret %..rawptr %14

switch.case.next-3:
	%15 = icmp eq i8 %10, 2
	br i1 %15, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	%16 = load %..rawptr, %..rawptr* %4, align 8
	call void @os.heap_free(%..rawptr %16, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret %..rawptr zeroinitializer

switch.case.next-5:
	%17 = icmp eq i8 %10, 3
	br i1 %17, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	br label %switch.done-11

switch.case.next-7:
	br label %switch.done-11

switch.fall.body-8:
	; IfStmt
	%18 = load %..rawptr, %..rawptr* %4, align 8
	%19 = icmp eq %..rawptr %18, zeroinitializer
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %if.then-9, label %if.done-10

if.then-9:
	; ReturnStmt
	%22 = load i64, i64* %2, align 8
	%23 = call %..rawptr @os.heap_alloc(i64 %22, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret %..rawptr %23

if.done-10:
	; ptr
	%24 = load %..rawptr, %..rawptr* %4, align 8
	%25 = load i64, i64* %2, align 8
	%26 = call %..rawptr @os.heap_resize(%..rawptr %24, i64 %25, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %26, %..rawptr* %7
	%27 = load %..rawptr, %..rawptr* %7, align 8
	%28 = icmp ne %..rawptr %27, zeroinitializer
	%29 = zext i1 %28 to i8
	%30 = trunc i8 %29 to i1
	%31 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%32 = call %..rawptr @mem.zero(%..rawptr %31, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([52 x i8], [52 x i8]* @str$8a, i64 0, i32 0), i64 51}, i64 130, i64 3, %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$8b, i64 0, i32 0), i64 19}}, %runtime.Source_Code_Location* %8
	%33 = call i8 @runtime.assert(i1 %30, %..string zeroinitializer, %runtime.Source_Code_Location* %8)
	; ReturnStmt
	%34 = load %..rawptr, %..rawptr* %7, align 8
	ret %..rawptr %34

switch.done-11:
	; ReturnStmt
	ret %..rawptr zeroinitializer
}

define %mem.Allocator @os.heap_allocator(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Allocator, align 16
	; ReturnStmt
	; CompoundLit
	%1 = bitcast %mem.Allocator* %0 to %..rawptr
	%2 = call %..rawptr @mem.zero(%..rawptr %1, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %0
	store %mem.Allocator {%..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* zeroinitializer, %..rawptr zeroinitializer}, %mem.Allocator* %0
	%3 = bitcast %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* @os.heap_allocator_proc to %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*
	%4 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %0, i64 0, i32 0
	store %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %3, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %4
	%5 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %0, i64 0, i32 1
	store %..rawptr zeroinitializer, %..rawptr* %5
	%6 = load %mem.Allocator, %mem.Allocator* %0, align 8
	ret %mem.Allocator %6
}

define {i32, i64} @os.open_simple(%..string %path, i64 %mode, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8*, align 16
	%3 = alloca i32, align 16
	%4 = alloca {i32, i64}, align 16
	%5 = alloca %mem.Allocator, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca {i32, i64}, align 16
	%8 = alloca %mem.Allocator, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca %mem.Allocator, align 16
	%11 = alloca %runtime.Source_Code_Location, align 16
	store %..string %path, %..string* %0
	store i64 %mode, i64* %1
	; cstr
	; SelectorExpr
	%12 = load %..string, %..string* %0, align 8
	%13 = call i8* @strings.new_cstring(%..string %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i8* %13, i8** %2
	; DeferStmt
	; handle
	%14 = load i8*, i8** %2, align 8
	%15 = load i64, i64* %1, align 8
	%16 = call ccc i32 @open(i8* %14, i64 %15)
	store i32 %16, i32* %3
	; IfStmt
	%17 = load i32, i32* %3, align 4
	%18 = icmp eq i32 %17, -1
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%21 = bitcast {i32, i64}* %4 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %4
	%23 = getelementptr inbounds {i32, i64}, {i32, i64}* %4, i64 0, i32 0
	store i32 0, i32* %23
	%24 = getelementptr inbounds {i32, i64}, {i32, i64}* %4, i64 0, i32 1
	store i64 1, i64* %24
	%25 = load {i32, i64}, {i32, i64}* %4, align 8
	; defer
	%26 = load i8*, i8** %2, align 8
	; SelectorExpr
	%27 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%28 = load %mem.Allocator, %mem.Allocator* %27, align 8
	%29 = bitcast %mem.Allocator* %5 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %5
	store %mem.Allocator %28, %mem.Allocator* %5
	%31 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%32 = call %..rawptr @mem.zero(%..rawptr %31, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$8c, i64 0, i32 0), i64 55}, i64 157, i64 8, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$8d, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	call void @mem.delete_cstring(i8* %26, %mem.Allocator* %5, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i32, i64} %25

if.done-2:
	; ReturnStmt
	%33 = load i32, i32* %3, align 4
	%34 = bitcast {i32, i64}* %7 to %..rawptr
	%35 = call %..rawptr @mem.zero(%..rawptr %34, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %7
	%36 = getelementptr inbounds {i32, i64}, {i32, i64}* %7, i64 0, i32 0
	store i32 %33, i32* %36
	%37 = getelementptr inbounds {i32, i64}, {i32, i64}* %7, i64 0, i32 1
	store i64 0, i64* %37
	%38 = load {i32, i64}, {i32, i64}* %7, align 8
	; defer
	%39 = load i8*, i8** %2, align 8
	; SelectorExpr
	%40 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%41 = load %mem.Allocator, %mem.Allocator* %40, align 8
	%42 = bitcast %mem.Allocator* %8 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %8
	store %mem.Allocator %41, %mem.Allocator* %8
	%44 = bitcast %runtime.Source_Code_Location* %9 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %9
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$8e, i64 0, i32 0), i64 55}, i64 157, i64 8, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$8f, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %9
	call void @mem.delete_cstring(i8* %39, %mem.Allocator* %8, %runtime.Source_Code_Location* %9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i32, i64} %38
}

define {i32, i64} @os.open(%..string %path, i64 %mode, i32 %perm, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i32, align 16
	%3 = alloca {i32, i64}, align 16
	store %..string %path, %..string* %0
	store i64 %mode, i64* %1
	store i32 %perm, i32* %2
	; ReturnStmt
	%4 = load %..string, %..string* %0, align 8
	%5 = load i64, i64* %1, align 8
	%6 = call {i32, i64} @os.open_simple(%..string %4, i64 %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = extractvalue {i32, i64} %6, 0
	%8 = extractvalue {i32, i64} %6, 1
	%9 = bitcast {i32, i64}* %3 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %3
	%11 = getelementptr inbounds {i32, i64}, {i32, i64}* %3, i64 0, i32 0
	store i32 %7, i32* %11
	%12 = getelementptr inbounds {i32, i64}, {i32, i64}* %3, i64 0, i32 1
	store i64 %8, i64* %12
	%13 = load {i32, i64}, {i32, i64}* %3, align 8
	ret {i32, i64} %13
}

define void @os.close(i32 %fd, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	store i32 %fd, i32* %0
	%1 = load i32, i32* %0, align 4
	call ccc void @close(i32 %1)
	ret void
}

define {i64, i64} @os.write(i32 %fd, {i8*, i64}* %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = alloca i64, align 16
	%3 = alloca {i64, i64}, align 16
	%4 = alloca {i64, i64}, align 16
	store i32 %fd, i32* %0
	%5 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%6 = load i32, i32* %0, align 4
	%7 = icmp ne i32 %6, -1
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	%10 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$90, i64 0, i32 0), i64 55}, i64 175, i64 2, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$91, i64 0, i32 0), i64 5}}, %runtime.Source_Code_Location* %1
	%12 = call i8 @runtime.assert(i1 %9, %..string zeroinitializer, %runtime.Source_Code_Location* %1)
	; bytes_written
	%13 = load i32, i32* %0, align 4
	; IndexExpr
	%14 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%15 = extractvalue {i8*, i64} %14, 0
	%16 = extractvalue {i8*, i64} %14, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$92, i64 0, i32 0), i64 55}, i64 177, i64 41, i64 0, i64 %16)
	%17 = getelementptr inbounds i8, i8* %15, i64 0
	%18 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%19 = extractvalue {i8*, i64} %18, 1
	%20 = bitcast i8* %17 to %..rawptr
	%21 = call ccc i64 @write(i32 %13, %..rawptr %20, i64 %19)
	store i64 %21, i64* %2
	; IfStmt
	%22 = load i64, i64* %2, align 8
	%23 = icmp eq i64 %22, -1
	%24 = zext i1 %23 to i8
	%25 = trunc i8 %24 to i1
	br i1 %25, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%26 = bitcast {i64, i64}* %3 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %3
	%28 = getelementptr inbounds {i64, i64}, {i64, i64}* %3, i64 0, i32 0
	store i64 0, i64* %28
	%29 = getelementptr inbounds {i64, i64}, {i64, i64}* %3, i64 0, i32 1
	store i64 1, i64* %29
	%30 = load {i64, i64}, {i64, i64}* %3, align 8
	ret {i64, i64} %30

if.done-2:
	; ReturnStmt
	%31 = load i64, i64* %2, align 8
	%32 = bitcast {i64, i64}* %4 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %4
	%34 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 0
	store i64 %31, i64* %34
	%35 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 1
	store i64 0, i64* %35
	%36 = load {i64, i64}, {i64, i64}* %4, align 8
	ret {i64, i64} %36
}

define {i64, i64} @os.read(i32 %fd, {i8*, i64}* %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = alloca i64, align 16
	%3 = alloca {i64, i64}, align 16
	%4 = alloca {i64, i64}, align 16
	store i32 %fd, i32* %0
	%5 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%6 = load i32, i32* %0, align 4
	%7 = icmp ne i32 %6, -1
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	%10 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$93, i64 0, i32 0), i64 55}, i64 185, i64 2, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$94, i64 0, i32 0), i64 4}}, %runtime.Source_Code_Location* %1
	%12 = call i8 @runtime.assert(i1 %9, %..string zeroinitializer, %runtime.Source_Code_Location* %1)
	; bytes_read
	%13 = load i32, i32* %0, align 4
	; IndexExpr
	%14 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%15 = extractvalue {i8*, i64} %14, 0
	%16 = extractvalue {i8*, i64} %14, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$95, i64 0, i32 0), i64 55}, i64 187, i64 37, i64 0, i64 %16)
	%17 = getelementptr inbounds i8, i8* %15, i64 0
	%18 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%19 = extractvalue {i8*, i64} %18, 1
	%20 = bitcast i8* %17 to %..rawptr
	%21 = call ccc i64 @read(i32 %13, %..rawptr %20, i64 %19)
	store i64 %21, i64* %2
	; IfStmt
	%22 = load i64, i64* %2, align 8
	%23 = icmp eq i64 %22, -1
	%24 = zext i1 %23 to i8
	%25 = trunc i8 %24 to i1
	br i1 %25, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%26 = bitcast {i64, i64}* %3 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %3
	%28 = getelementptr inbounds {i64, i64}, {i64, i64}* %3, i64 0, i32 0
	store i64 0, i64* %28
	%29 = getelementptr inbounds {i64, i64}, {i64, i64}* %3, i64 0, i32 1
	store i64 1, i64* %29
	%30 = load {i64, i64}, {i64, i64}* %3, align 8
	ret {i64, i64} %30

if.done-2:
	; ReturnStmt
	%31 = load i64, i64* %2, align 8
	%32 = bitcast {i64, i64}* %4 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %4
	%34 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 0
	store i64 %31, i64* %34
	%35 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 1
	store i64 0, i64* %35
	%36 = load {i64, i64}, {i64, i64}* %4, align 8
	ret {i64, i64} %36
}

define {i64, i64} @os.seek(i32 %fd, i64 %offset, i64 %whence, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca {i64, i64}, align 16
	%6 = alloca {i64, i64}, align 16
	store i32 %fd, i32* %0
	store i64 %offset, i64* %1
	store i64 %whence, i64* %2
	%7 = load i32, i32* %0, align 4
	%8 = icmp ne i32 %7, -1
	%9 = zext i1 %8 to i8
	%10 = trunc i8 %9 to i1
	%11 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$96, i64 0, i32 0), i64 55}, i64 195, i64 2, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$97, i64 0, i32 0), i64 4}}, %runtime.Source_Code_Location* %3
	%13 = call i8 @runtime.assert(i1 %10, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; final_offset
	%14 = load i32, i32* %0, align 4
	%15 = load i64, i64* %1, align 8
	%16 = bitcast i64 %15 to i64
	%17 = load i64, i64* %2, align 8
	%18 = call ccc i64 @lseek(i32 %14, i64 %16, i64 %17)
	%19 = bitcast i64 %18 to i64
	store i64 %19, i64* %4
	; IfStmt
	%20 = load i64, i64* %4, align 8
	%21 = icmp eq i64 %20, -1
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%24 = bitcast {i64, i64}* %5 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %5
	%26 = getelementptr inbounds {i64, i64}, {i64, i64}* %5, i64 0, i32 0
	store i64 0, i64* %26
	%27 = getelementptr inbounds {i64, i64}, {i64, i64}* %5, i64 0, i32 1
	store i64 1, i64* %27
	%28 = load {i64, i64}, {i64, i64}* %5, align 8
	ret {i64, i64} %28

if.done-2:
	; ReturnStmt
	%29 = load i64, i64* %4, align 8
	%30 = bitcast {i64, i64}* %6 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %6
	%32 = getelementptr inbounds {i64, i64}, {i64, i64}* %6, i64 0, i32 0
	store i64 %29, i64* %32
	%33 = getelementptr inbounds {i64, i64}, {i64, i64}* %6, i64 0, i32 1
	store i64 0, i64* %33
	%34 = load {i64, i64}, {i64, i64}* %6, align 8
	ret {i64, i64} %34
}

define {i64, i64} @os.file_size(i32 %fd, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca {i64, i64}, align 16
	store i32 %fd, i32* %0
	; prev
	%5 = load i32, i32* %0, align 4
	%6 = call {i64, i64} @os.seek(i32 %5, i64 0, i64 1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = extractvalue {i64, i64} %6, 0
	%8 = extractvalue {i64, i64} %6, 1
	store i64 %7, i64* %1
	; size
	; err
	%9 = load i32, i32* %0, align 4
	%10 = call {i64, i64} @os.seek(i32 %9, i64 0, i64 2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = extractvalue {i64, i64} %10, 0
	%12 = extractvalue {i64, i64} %10, 1
	store i64 %11, i64* %2
	store i64 %12, i64* %3
	%13 = load i32, i32* %0, align 4
	%14 = load i64, i64* %1, align 8
	%15 = call {i64, i64} @os.seek(i32 %13, i64 %14, i64 0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%16 = load i64, i64* %2, align 8
	%17 = load i64, i64* %3, align 8
	%18 = bitcast {i64, i64}* %4 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %4
	%20 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 0
	store i64 %16, i64* %20
	%21 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 1
	store i64 %17, i64* %21
	%22 = load {i64, i64}, {i64, i64}* %4, align 8
	ret {i64, i64} %22
}

define i64 @os.last_write_time_by_name(%..string %name, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	store %..string %name, %..string* %0
	; ReturnStmt
	ret i64 1
}

define %..rawptr @os.heap_alloc(i64 %size, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	store i64 %size, i64* %0
	%2 = load i64, i64* %0, align 8
	%3 = icmp sgt i64 %2, 0
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	%6 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$98, i64 0, i32 0), i64 55}, i64 238, i64 2, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$99, i64 0, i32 0), i64 10}}, %runtime.Source_Code_Location* %1
	%8 = call i8 @runtime.assert(i1 %5, %..string zeroinitializer, %runtime.Source_Code_Location* %1) alwaysinline
	; ReturnStmt
	%9 = load i64, i64* %0, align 8
	%10 = call ccc %..rawptr @calloc(i64 1, i64 %9) alwaysinline
	ret %..rawptr %10
}

define %..rawptr @os.heap_resize(%..rawptr %ptr, i64 %new_size, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i64, align 16
	store %..rawptr %ptr, %..rawptr* %0
	store i64 %new_size, i64* %1
	; ReturnStmt
	%2 = load %..rawptr, %..rawptr* %0, align 8
	%3 = load i64, i64* %1, align 8
	%4 = call ccc %..rawptr @realloc(%..rawptr %2, i64 %3) alwaysinline
	ret %..rawptr %4
}

define void @os.heap_free(%..rawptr %ptr, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..rawptr, align 16
	store %..rawptr %ptr, %..rawptr* %0
	%1 = load %..rawptr, %..rawptr* %0, align 8
	call ccc void @free(%..rawptr %1) alwaysinline
	ret void
}

define i64 @os.current_thread_id() #0 {
decls-0:
	; ReturnStmt
	ret i64 0
}

define {[4 x i8], i64} @utf8.encode_rune(i32 %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca [4 x i8], align 16
	%2 = alloca i32, align 16
	%3 = alloca {[4 x i8], i64}, align 16
	%4 = alloca {[4 x i8], i64}, align 16
	%5 = alloca {[4 x i8], i64}, align 16
	%6 = alloca {[4 x i8], i64}, align 16
	store i32 %r, i32* %0
	; buf
	%7 = bitcast [4 x i8]* %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 4) noinline
	store [4 x i8] zeroinitializer, [4 x i8]* %1
	; i
	%9 = load i32, i32* %0, align 4
	%10 = bitcast i32 %9 to i32
	store i32 %10, i32* %2
	; IfStmt
	%11 = load i32, i32* %2, align 4
	%12 = icmp ule i32 %11, 127
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; IndexExpr
	%15 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 0
	%16 = load i32, i32* %0, align 4
	%17 = trunc i32 %16 to i8
	store i8 %17, i8* %15
	; ReturnStmt
	%18 = load [4 x i8], [4 x i8]* %1, align 1
	%19 = bitcast {[4 x i8], i64}* %3 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 16) noinline
	store {[4 x i8], i64} zeroinitializer, {[4 x i8], i64}* %3
	%21 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %3, i64 0, i32 0
	store [4 x i8] %18, [4 x i8]* %21
	%22 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %3, i64 0, i32 1
	store i64 1, i64* %22
	%23 = load {[4 x i8], i64}, {[4 x i8], i64}* %3, align 8
	ret {[4 x i8], i64} %23

if.done-2:
	; IfStmt
	%24 = load i32, i32* %2, align 4
	%25 = icmp ule i32 %24, 2047
	%26 = zext i1 %25 to i8
	%27 = trunc i8 %26 to i1
	br i1 %27, label %if.then-3, label %if.done-4

if.then-3:
	; AssignStmt
	; IndexExpr
	%28 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 0
	%29 = load i32, i32* %0, align 4
	%30 = ashr i32 %29, 6
	%31 = trunc i32 %30 to i8
	%32 = or i8 192, %31
	store i8 %32, i8* %28
	; AssignStmt
	; IndexExpr
	%33 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 1
	%34 = load i32, i32* %0, align 4
	%35 = trunc i32 %34 to i8
	%36 = and i8 %35, 63
	%37 = or i8 128, %36
	store i8 %37, i8* %33
	; ReturnStmt
	%38 = load [4 x i8], [4 x i8]* %1, align 1
	%39 = bitcast {[4 x i8], i64}* %4 to %..rawptr
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 16) noinline
	store {[4 x i8], i64} zeroinitializer, {[4 x i8], i64}* %4
	%41 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %4, i64 0, i32 0
	store [4 x i8] %38, [4 x i8]* %41
	%42 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %4, i64 0, i32 1
	store i64 2, i64* %42
	%43 = load {[4 x i8], i64}, {[4 x i8], i64}* %4, align 8
	ret {[4 x i8], i64} %43

if.done-4:
	; IfStmt
	%44 = load i32, i32* %2, align 4
	%45 = icmp ugt i32 %44, 1114111
	%46 = zext i1 %45 to i8
	%47 = trunc i8 %46 to i1
	br i1 %47, label %if.then-7, label %cmp.or-5

cmp.or-5:
	%48 = load i32, i32* %2, align 4
	%49 = icmp ule i32 55296, %48
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%52 = load i32, i32* %2, align 4
	%53 = icmp ule i32 %52, 57343
	%54 = zext i1 %53 to i8
	%55 = trunc i8 %54 to i1
	br i1 %55, label %if.then-7, label %if.done-8

if.then-7:
	; AssignStmt
	store i32 65533, i32* %0
	br label %if.done-8

if.done-8:
	; IfStmt
	%56 = load i32, i32* %2, align 4
	%57 = icmp ule i32 %56, 65535
	%58 = zext i1 %57 to i8
	%59 = trunc i8 %58 to i1
	br i1 %59, label %if.then-9, label %if.done-10

if.then-9:
	; AssignStmt
	; IndexExpr
	%60 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 0
	%61 = load i32, i32* %0, align 4
	%62 = ashr i32 %61, 12
	%63 = trunc i32 %62 to i8
	%64 = or i8 224, %63
	store i8 %64, i8* %60
	; AssignStmt
	; IndexExpr
	%65 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 1
	%66 = load i32, i32* %0, align 4
	%67 = ashr i32 %66, 6
	%68 = trunc i32 %67 to i8
	%69 = and i8 %68, 63
	%70 = or i8 128, %69
	store i8 %70, i8* %65
	; AssignStmt
	; IndexExpr
	%71 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 2
	%72 = load i32, i32* %0, align 4
	%73 = trunc i32 %72 to i8
	%74 = and i8 %73, 63
	%75 = or i8 128, %74
	store i8 %75, i8* %71
	; ReturnStmt
	%76 = load [4 x i8], [4 x i8]* %1, align 1
	%77 = bitcast {[4 x i8], i64}* %5 to %..rawptr
	%78 = call %..rawptr @mem.zero(%..rawptr %77, i64 16) noinline
	store {[4 x i8], i64} zeroinitializer, {[4 x i8], i64}* %5
	%79 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %5, i64 0, i32 0
	store [4 x i8] %76, [4 x i8]* %79
	%80 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %5, i64 0, i32 1
	store i64 3, i64* %80
	%81 = load {[4 x i8], i64}, {[4 x i8], i64}* %5, align 8
	ret {[4 x i8], i64} %81

if.done-10:
	; AssignStmt
	; IndexExpr
	%82 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 0
	%83 = load i32, i32* %0, align 4
	%84 = ashr i32 %83, 18
	%85 = trunc i32 %84 to i8
	%86 = or i8 240, %85
	store i8 %86, i8* %82
	; AssignStmt
	; IndexExpr
	%87 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 1
	%88 = load i32, i32* %0, align 4
	%89 = ashr i32 %88, 12
	%90 = trunc i32 %89 to i8
	%91 = and i8 %90, 63
	%92 = or i8 128, %91
	store i8 %92, i8* %87
	; AssignStmt
	; IndexExpr
	%93 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 2
	%94 = load i32, i32* %0, align 4
	%95 = ashr i32 %94, 6
	%96 = trunc i32 %95 to i8
	%97 = and i8 %96, 63
	%98 = or i8 128, %97
	store i8 %98, i8* %93
	; AssignStmt
	; IndexExpr
	%99 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 3
	%100 = load i32, i32* %0, align 4
	%101 = trunc i32 %100 to i8
	%102 = and i8 %101, 63
	%103 = or i8 128, %102
	store i8 %103, i8* %99
	; ReturnStmt
	%104 = load [4 x i8], [4 x i8]* %1, align 1
	%105 = bitcast {[4 x i8], i64}* %6 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store {[4 x i8], i64} zeroinitializer, {[4 x i8], i64}* %6
	%107 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %6, i64 0, i32 0
	store [4 x i8] %104, [4 x i8]* %107
	%108 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %6, i64 0, i32 1
	store i64 4, i64* %108
	%109 = load {[4 x i8], i64}, {[4 x i8], i64}* %6, align 8
	ret {[4 x i8], i64} %109
}

define {i32, i64} @utf8.decode_rune_from_string(%..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i8*, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca {i8*, i64}, align 16
	%4 = alloca {i32, i64}, align 16
	store %..string %s, %..string* %0
	; ReturnStmt
	%5 = load %..string, %..string* %0, align 8
	%6 = extractvalue %..string %5, 0
	%7 = bitcast i8** %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 8) noinline
	store i8* zeroinitializer, i8** %1
	store i8* %6, i8** %1
	%9 = extractvalue %..string %5, 1
	%10 = sub i64 %9, 0
	%11 = load i8*, i8** %1, align 8
	%12 = getelementptr inbounds i8, i8* %11, i64 0
	%13 = bitcast {i8*, i64}* %2 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %2
	%15 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 0
	store i8* %12, i8** %15
	%16 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 1
	store i64 %10, i64* %16
	%17 = load {i8*, i64}, {i8*, i64}* %2, align 8
	%18 = bitcast {i8*, i64}* %3 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %3
	store {i8*, i64} %17, {i8*, i64}* %3
	%20 = call {i32, i64} @utf8.decode_rune({i8*, i64}* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%21 = extractvalue {i32, i64} %20, 0
	%22 = extractvalue {i32, i64} %20, 1
	%23 = bitcast {i32, i64}* %4 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %4
	%25 = getelementptr inbounds {i32, i64}, {i32, i64}* %4, i64 0, i32 0
	store i32 %21, i32* %25
	%26 = getelementptr inbounds {i32, i64}, {i32, i64}* %4, i64 0, i32 1
	store i64 %22, i64* %26
	%27 = load {i32, i64}, {i32, i64}* %4, align 8
	ret {i32, i64} %27
}

define {i32, i64} @utf8.decode_rune({i8*, i64}* %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca {i32, i64}, align 16
	%2 = alloca i8, align 16
	%3 = alloca i8, align 16
	%4 = alloca i32, align 16
	%5 = alloca {i32, i64}, align 16
	%6 = alloca i8, align 16
	%7 = alloca %utf8.Accept_Range, align 16
	%8 = alloca {i32, i64}, align 16
	%9 = alloca i8, align 16
	%10 = alloca {i32, i64}, align 16
	%11 = alloca {i32, i64}, align 16
	%12 = alloca i8, align 16
	%13 = alloca {i32, i64}, align 16
	%14 = alloca {i32, i64}, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i32, i64}, align 16
	%17 = alloca {i32, i64}, align 16
	%18 = load {i8*, i64}, {i8*, i64}* %s, align 8
	; n
	%19 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%20 = extractvalue {i8*, i64} %19, 1
	store i64 %20, i64* %0
	; IfStmt
	%21 = load i64, i64* %0, align 8
	%22 = icmp slt i64 %21, 1
	%23 = zext i1 %22 to i8
	%24 = trunc i8 %23 to i1
	br i1 %24, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%25 = bitcast {i32, i64}* %1 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %1
	%27 = getelementptr inbounds {i32, i64}, {i32, i64}* %1, i64 0, i32 0
	store i32 65533, i32* %27
	%28 = getelementptr inbounds {i32, i64}, {i32, i64}* %1, i64 0, i32 1
	store i64 0, i64* %28
	%29 = load {i32, i64}, {i32, i64}* %1, align 8
	ret {i32, i64} %29

if.done-2:
	; s0
	; IndexExpr
	%30 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%31 = extractvalue {i8*, i64} %30, 0
	%32 = extractvalue {i8*, i64} %30, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$9a, i64 0, i32 0), i64 63}, i64 103, i64 10, i64 0, i64 %32)
	%33 = getelementptr inbounds i8, i8* %31, i64 0
	%34 = load i8, i8* %33, align 1
	store i8 %34, i8* %2
	; x
	; IndexExpr
	%35 = load i8, i8* %2, align 1
	%36 = zext i8 %35 to i64
	%37 = trunc i64 %36 to i32
	%38 = getelementptr inbounds [256 x i8], [256 x i8]* @utf8.accept_sizes, i64 0, i32 %37
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$9b, i64 0, i32 0), i64 63}, i64 104, i64 20, i64 %36, i64 256)
	%39 = load i8, i8* %38, align 1
	store i8 %39, i8* %3
	; IfStmt
	%40 = load i8, i8* %3, align 1
	%41 = icmp uge i8 %40, 240
	%42 = zext i1 %41 to i8
	%43 = trunc i8 %42 to i1
	br i1 %43, label %if.then-3, label %if.done-4

if.then-3:
	; mask
	%44 = load i8, i8* %3, align 1
	%45 = zext i8 %44 to i32
	%46 = shl i32 %45, 31
	%47 = ashr i32 %46, 31
	store i32 %47, i32* %4
	; ReturnStmt
	; IndexExpr
	%48 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%49 = extractvalue {i8*, i64} %48, 0
	%50 = extractvalue {i8*, i64} %48, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$9c, i64 0, i32 0), i64 63}, i64 107, i64 17, i64 0, i64 %50)
	%51 = getelementptr inbounds i8, i8* %49, i64 0
	%52 = load i8, i8* %51, align 1
	%53 = zext i8 %52 to i32
	%54 = load i32, i32* %4, align 4
	%55 = xor i32 %54, -1
	%56 = and i32 %53, %55
	%57 = load i32, i32* %4, align 4
	%58 = and i32 65533, %57
	%59 = or i32 %56, %58
	%60 = bitcast {i32, i64}* %5 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %5
	%62 = getelementptr inbounds {i32, i64}, {i32, i64}* %5, i64 0, i32 0
	store i32 %59, i32* %62
	%63 = getelementptr inbounds {i32, i64}, {i32, i64}* %5, i64 0, i32 1
	store i64 1, i64* %63
	%64 = load {i32, i64}, {i32, i64}* %5, align 8
	ret {i32, i64} %64

if.done-4:
	; sz
	%65 = load i8, i8* %3, align 1
	%66 = and i8 %65, 7
	store i8 %66, i8* %6
	; accept
	; IndexExpr
	%67 = load i8, i8* %3, align 1
	%68 = lshr i8 %67, 4
	%69 = zext i8 %68 to i64
	%70 = trunc i64 %69 to i32
	%71 = getelementptr inbounds [5 x %utf8.Accept_Range], [5 x %utf8.Accept_Range]* @utf8.accept_ranges, i64 0, i32 %70
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$9d, i64 0, i32 0), i64 63}, i64 110, i64 26, i64 %69, i64 5)
	%72 = load %utf8.Accept_Range, %utf8.Accept_Range* %71, align 1
	store %utf8.Accept_Range %72, %utf8.Accept_Range* %7
	; IfStmt
	%73 = load i64, i64* %0, align 8
	%74 = load i8, i8* %6, align 1
	%75 = zext i8 %74 to i64
	%76 = icmp slt i64 %73, %75
	%77 = zext i1 %76 to i8
	%78 = trunc i8 %77 to i1
	br i1 %78, label %if.then-5, label %if.done-6

if.then-5:
	; ReturnStmt
	%79 = bitcast {i32, i64}* %8 to %..rawptr
	%80 = call %..rawptr @mem.zero(%..rawptr %79, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %8
	%81 = getelementptr inbounds {i32, i64}, {i32, i64}* %8, i64 0, i32 0
	store i32 65533, i32* %81
	%82 = getelementptr inbounds {i32, i64}, {i32, i64}* %8, i64 0, i32 1
	store i64 1, i64* %82
	%83 = load {i32, i64}, {i32, i64}* %8, align 8
	ret {i32, i64} %83

if.done-6:
	; b1
	; IndexExpr
	%84 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%85 = extractvalue {i8*, i64} %84, 0
	%86 = extractvalue {i8*, i64} %84, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$9e, i64 0, i32 0), i64 63}, i64 114, i64 10, i64 1, i64 %86)
	%87 = getelementptr inbounds i8, i8* %85, i64 1
	%88 = load i8, i8* %87, align 1
	store i8 %88, i8* %9
	; IfStmt
	%89 = load i8, i8* %9, align 1
	; SelectorExpr
	%90 = getelementptr inbounds %utf8.Accept_Range, %utf8.Accept_Range* %7, i64 0, i32 0
	%91 = load i8, i8* %90, align 1
	%92 = icmp ult i8 %89, %91
	%93 = zext i1 %92 to i8
	%94 = trunc i8 %93 to i1
	br i1 %94, label %if.then-8, label %cmp.or-7

cmp.or-7:
	; SelectorExpr
	%95 = getelementptr inbounds %utf8.Accept_Range, %utf8.Accept_Range* %7, i64 0, i32 1
	%96 = load i8, i8* %95, align 1
	%97 = load i8, i8* %9, align 1
	%98 = icmp ult i8 %96, %97
	%99 = zext i1 %98 to i8
	%100 = trunc i8 %99 to i1
	br i1 %100, label %if.then-8, label %if.done-9

if.then-8:
	; ReturnStmt
	%101 = bitcast {i32, i64}* %10 to %..rawptr
	%102 = call %..rawptr @mem.zero(%..rawptr %101, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %10
	%103 = getelementptr inbounds {i32, i64}, {i32, i64}* %10, i64 0, i32 0
	store i32 65533, i32* %103
	%104 = getelementptr inbounds {i32, i64}, {i32, i64}* %10, i64 0, i32 1
	store i64 1, i64* %104
	%105 = load {i32, i64}, {i32, i64}* %10, align 8
	ret {i32, i64} %105

if.done-9:
	; IfStmt
	%106 = load i8, i8* %6, align 1
	%107 = icmp eq i8 %106, 2
	%108 = zext i1 %107 to i8
	%109 = trunc i8 %108 to i1
	br i1 %109, label %if.then-10, label %if.done-11

if.then-10:
	; ReturnStmt
	%110 = load i8, i8* %2, align 1
	%111 = and i8 %110, 31
	%112 = zext i8 %111 to i32
	%113 = shl i32 %112, 6
	%114 = load i8, i8* %9, align 1
	%115 = and i8 %114, 63
	%116 = zext i8 %115 to i32
	%117 = or i32 %113, %116
	%118 = bitcast {i32, i64}* %11 to %..rawptr
	%119 = call %..rawptr @mem.zero(%..rawptr %118, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %11
	%120 = getelementptr inbounds {i32, i64}, {i32, i64}* %11, i64 0, i32 0
	store i32 %117, i32* %120
	%121 = getelementptr inbounds {i32, i64}, {i32, i64}* %11, i64 0, i32 1
	store i64 2, i64* %121
	%122 = load {i32, i64}, {i32, i64}* %11, align 8
	ret {i32, i64} %122

if.done-11:
	; b2
	; IndexExpr
	%123 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%124 = extractvalue {i8*, i64} %123, 0
	%125 = extractvalue {i8*, i64} %123, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$9f, i64 0, i32 0), i64 63}, i64 121, i64 10, i64 2, i64 %125)
	%126 = getelementptr inbounds i8, i8* %124, i64 2
	%127 = load i8, i8* %126, align 1
	store i8 %127, i8* %12
	; IfStmt
	%128 = load i8, i8* %12, align 1
	%129 = icmp ult i8 %128, 128
	%130 = zext i1 %129 to i8
	%131 = trunc i8 %130 to i1
	br i1 %131, label %if.then-13, label %cmp.or-12

cmp.or-12:
	%132 = load i8, i8* %12, align 1
	%133 = icmp ult i8 191, %132
	%134 = zext i1 %133 to i8
	%135 = trunc i8 %134 to i1
	br i1 %135, label %if.then-13, label %if.done-14

if.then-13:
	; ReturnStmt
	%136 = bitcast {i32, i64}* %13 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %13
	%138 = getelementptr inbounds {i32, i64}, {i32, i64}* %13, i64 0, i32 0
	store i32 65533, i32* %138
	%139 = getelementptr inbounds {i32, i64}, {i32, i64}* %13, i64 0, i32 1
	store i64 1, i64* %139
	%140 = load {i32, i64}, {i32, i64}* %13, align 8
	ret {i32, i64} %140

if.done-14:
	; IfStmt
	%141 = load i8, i8* %6, align 1
	%142 = icmp eq i8 %141, 3
	%143 = zext i1 %142 to i8
	%144 = trunc i8 %143 to i1
	br i1 %144, label %if.then-15, label %if.done-16

if.then-15:
	; ReturnStmt
	%145 = load i8, i8* %2, align 1
	%146 = and i8 %145, 15
	%147 = zext i8 %146 to i32
	%148 = shl i32 %147, 12
	%149 = load i8, i8* %9, align 1
	%150 = and i8 %149, 63
	%151 = zext i8 %150 to i32
	%152 = shl i32 %151, 6
	%153 = or i32 %148, %152
	%154 = load i8, i8* %12, align 1
	%155 = and i8 %154, 63
	%156 = zext i8 %155 to i32
	%157 = or i32 %153, %156
	%158 = bitcast {i32, i64}* %14 to %..rawptr
	%159 = call %..rawptr @mem.zero(%..rawptr %158, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %14
	%160 = getelementptr inbounds {i32, i64}, {i32, i64}* %14, i64 0, i32 0
	store i32 %157, i32* %160
	%161 = getelementptr inbounds {i32, i64}, {i32, i64}* %14, i64 0, i32 1
	store i64 3, i64* %161
	%162 = load {i32, i64}, {i32, i64}* %14, align 8
	ret {i32, i64} %162

if.done-16:
	; b3
	; IndexExpr
	%163 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%164 = extractvalue {i8*, i64} %163, 0
	%165 = extractvalue {i8*, i64} %163, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$a0, i64 0, i32 0), i64 63}, i64 128, i64 10, i64 3, i64 %165)
	%166 = getelementptr inbounds i8, i8* %164, i64 3
	%167 = load i8, i8* %166, align 1
	store i8 %167, i8* %15
	; IfStmt
	%168 = load i8, i8* %15, align 1
	%169 = icmp ult i8 %168, 128
	%170 = zext i1 %169 to i8
	%171 = trunc i8 %170 to i1
	br i1 %171, label %if.then-18, label %cmp.or-17

cmp.or-17:
	%172 = load i8, i8* %15, align 1
	%173 = icmp ult i8 191, %172
	%174 = zext i1 %173 to i8
	%175 = trunc i8 %174 to i1
	br i1 %175, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	%176 = bitcast {i32, i64}* %16 to %..rawptr
	%177 = call %..rawptr @mem.zero(%..rawptr %176, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %16
	%178 = getelementptr inbounds {i32, i64}, {i32, i64}* %16, i64 0, i32 0
	store i32 65533, i32* %178
	%179 = getelementptr inbounds {i32, i64}, {i32, i64}* %16, i64 0, i32 1
	store i64 1, i64* %179
	%180 = load {i32, i64}, {i32, i64}* %16, align 8
	ret {i32, i64} %180

if.done-19:
	; ReturnStmt
	%181 = load i8, i8* %2, align 1
	%182 = and i8 %181, 7
	%183 = zext i8 %182 to i32
	%184 = shl i32 %183, 18
	%185 = load i8, i8* %9, align 1
	%186 = and i8 %185, 63
	%187 = zext i8 %186 to i32
	%188 = shl i32 %187, 12
	%189 = or i32 %184, %188
	%190 = load i8, i8* %12, align 1
	%191 = and i8 %190, 63
	%192 = zext i8 %191 to i32
	%193 = shl i32 %192, 6
	%194 = or i32 %189, %193
	%195 = load i8, i8* %15, align 1
	%196 = and i8 %195, 63
	%197 = zext i8 %196 to i32
	%198 = or i32 %194, %197
	%199 = bitcast {i32, i64}* %17 to %..rawptr
	%200 = call %..rawptr @mem.zero(%..rawptr %199, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %17
	%201 = getelementptr inbounds {i32, i64}, {i32, i64}* %17, i64 0, i32 0
	store i32 %198, i32* %201
	%202 = getelementptr inbounds {i32, i64}, {i32, i64}* %17, i64 0, i32 1
	store i64 4, i64* %202
	%203 = load {i32, i64}, {i32, i64}* %17, align 8
	ret {i32, i64} %203
}

define i64 @utf8.rune_count_from_string(%..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i8*, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca {i8*, i64}, align 16
	store %..string %s, %..string* %0
	; ReturnStmt
	%4 = load %..string, %..string* %0, align 8
	%5 = extractvalue %..string %4, 0
	%6 = bitcast i8** %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 8) noinline
	store i8* zeroinitializer, i8** %1
	store i8* %5, i8** %1
	%8 = extractvalue %..string %4, 1
	%9 = sub i64 %8, 0
	%10 = load i8*, i8** %1, align 8
	%11 = getelementptr inbounds i8, i8* %10, i64 0
	%12 = bitcast {i8*, i64}* %2 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %2
	%14 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 0
	store i8* %11, i8** %14
	%15 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 1
	store i64 %9, i64* %15
	%16 = load {i8*, i64}, {i8*, i64}* %2, align 8
	%17 = bitcast {i8*, i64}* %3 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %3
	store {i8*, i64} %16, {i8*, i64}* %3
	%19 = call i64 @utf8.rune_count({i8*, i64}* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret i64 %19
}

define i64 @utf8.rune_count({i8*, i64}* %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i8, align 16
	%4 = alloca i8, align 16
	%5 = alloca i64, align 16
	%6 = alloca %utf8.Accept_Range, align 16
	%7 = alloca i8, align 16
	%8 = alloca i8, align 16
	%9 = alloca i8, align 16
	%10 = load {i8*, i64}, {i8*, i64}* %s, align 8
	; count
	store i64 0, i64* %0
	; n
	%11 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%12 = extractvalue {i8*, i64} %11, 1
	store i64 %12, i64* %1
	; ForStmt
	; i
	store i64 0, i64* %2
	br label %for.loop-1

for.loop-1:
	%13 = load i64, i64* %2, align 8
	%14 = load i64, i64* %1, align 8
	%15 = icmp slt i64 %13, %14
	%16 = zext i1 %15 to i8
	%17 = trunc i8 %16 to i1
	br i1 %17, label %for.body-2, label %for.done-26

for.body-2:
	; DeferStmt
	; si
	; IndexExpr
	%18 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%19 = extractvalue {i8*, i64} %18, 0
	%20 = load i64, i64* %2, align 8
	%21 = extractvalue {i8*, i64} %18, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$a1, i64 0, i32 0), i64 63}, i64 225, i64 11, i64 %20, i64 %21)
	%22 = getelementptr inbounds i8, i8* %19, i64 %20
	%23 = load i8, i8* %22, align 1
	store i8 %23, i8* %3
	; IfStmt
	%24 = load i8, i8* %3, align 1
	%25 = icmp ult i8 %24, 128
	%26 = zext i1 %25 to i8
	%27 = trunc i8 %26 to i1
	br i1 %27, label %if.then-3, label %if.done-4

if.then-3:
	; AssignStmt
	%28 = load i64, i64* %2, align 8
	%29 = add i64 %28, 1
	store i64 %29, i64* %2
	; defer
	; AssignStmt
	%30 = load i64, i64* %0, align 8
	%31 = add i64 %30, 1
	store i64 %31, i64* %0
	; continue
	br label %for.loop-1

if.done-4:
	; x
	; IndexExpr
	%32 = load i8, i8* %3, align 1
	%33 = zext i8 %32 to i64
	%34 = trunc i64 %33 to i32
	%35 = getelementptr inbounds [256 x i8], [256 x i8]* @utf8.accept_sizes, i64 0, i32 %34
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$a2, i64 0, i32 0), i64 63}, i64 230, i64 21, i64 %33, i64 256)
	%36 = load i8, i8* %35, align 1
	store i8 %36, i8* %4
	; IfStmt
	%37 = load i8, i8* %4, align 1
	%38 = icmp eq i8 %37, 241
	%39 = zext i1 %38 to i8
	%40 = trunc i8 %39 to i1
	br i1 %40, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	%41 = load i64, i64* %2, align 8
	%42 = add i64 %41, 1
	store i64 %42, i64* %2
	; defer
	; AssignStmt
	%43 = load i64, i64* %0, align 8
	%44 = add i64 %43, 1
	store i64 %44, i64* %0
	; continue
	br label %for.loop-1

if.done-6:
	; size
	%45 = load i8, i8* %4, align 1
	%46 = and i8 %45, 7
	%47 = zext i8 %46 to i64
	store i64 %47, i64* %5
	; IfStmt
	%48 = load i64, i64* %2, align 8
	%49 = load i64, i64* %5, align 8
	%50 = add i64 %48, %49
	%51 = load i64, i64* %1, align 8
	%52 = icmp sgt i64 %50, %51
	%53 = zext i1 %52 to i8
	%54 = trunc i8 %53 to i1
	br i1 %54, label %if.then-7, label %if.done-8

if.then-7:
	; AssignStmt
	%55 = load i64, i64* %2, align 8
	%56 = add i64 %55, 1
	store i64 %56, i64* %2
	; defer
	; AssignStmt
	%57 = load i64, i64* %0, align 8
	%58 = add i64 %57, 1
	store i64 %58, i64* %0
	; continue
	br label %for.loop-1

if.done-8:
	; ar
	; IndexExpr
	%59 = load i8, i8* %4, align 1
	%60 = lshr i8 %59, 4
	%61 = zext i8 %60 to i64
	%62 = trunc i64 %61 to i32
	%63 = getelementptr inbounds [5 x %utf8.Accept_Range], [5 x %utf8.Accept_Range]* @utf8.accept_ranges, i64 0, i32 %62
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$a3, i64 0, i32 0), i64 63}, i64 240, i64 23, i64 %61, i64 5)
	%64 = load %utf8.Accept_Range, %utf8.Accept_Range* %63, align 1
	store %utf8.Accept_Range %64, %utf8.Accept_Range* %6
	; IfStmt
	; b
	; IndexExpr
	%65 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%66 = extractvalue {i8*, i64} %65, 0
	%67 = load i64, i64* %2, align 8
	%68 = add i64 %67, 1
	%69 = extractvalue {i8*, i64} %65, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$a4, i64 0, i32 0), i64 63}, i64 241, i64 13, i64 %68, i64 %69)
	%70 = getelementptr inbounds i8, i8* %66, i64 %68
	%71 = load i8, i8* %70, align 1
	store i8 %71, i8* %7
	%72 = load i8, i8* %7, align 1
	; SelectorExpr
	%73 = getelementptr inbounds %utf8.Accept_Range, %utf8.Accept_Range* %6, i64 0, i32 0
	%74 = load i8, i8* %73, align 1
	%75 = icmp ult i8 %72, %74
	%76 = zext i1 %75 to i8
	%77 = trunc i8 %76 to i1
	br i1 %77, label %if.then-10, label %cmp.or-9

cmp.or-9:
	; SelectorExpr
	%78 = getelementptr inbounds %utf8.Accept_Range, %utf8.Accept_Range* %6, i64 0, i32 1
	%79 = load i8, i8* %78, align 1
	%80 = load i8, i8* %7, align 1
	%81 = icmp ult i8 %79, %80
	%82 = zext i1 %81 to i8
	%83 = trunc i8 %82 to i1
	br i1 %83, label %if.then-10, label %if.else-11

if.then-10:
	; AssignStmt
	store i64 1, i64* %5
	br label %if.done-25

if.else-11:
	; IfStmt
	%84 = load i64, i64* %5, align 8
	%85 = icmp eq i64 %84, 2
	%86 = zext i1 %85 to i8
	%87 = trunc i8 %86 to i1
	br i1 %87, label %if.then-12, label %if.else-13

if.then-12:
	br label %if.done-24

if.else-13:
	; IfStmt
	; b
	; IndexExpr
	%88 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%89 = extractvalue {i8*, i64} %88, 0
	%90 = load i64, i64* %2, align 8
	%91 = add i64 %90, 2
	%92 = extractvalue {i8*, i64} %88, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$a5, i64 0, i32 0), i64 63}, i64 245, i64 20, i64 %91, i64 %92)
	%93 = getelementptr inbounds i8, i8* %89, i64 %91
	%94 = load i8, i8* %93, align 1
	store i8 %94, i8* %8
	%95 = load i8, i8* %8, align 1
	%96 = icmp ult i8 %95, 128
	%97 = zext i1 %96 to i8
	%98 = trunc i8 %97 to i1
	br i1 %98, label %if.then-15, label %cmp.or-14

cmp.or-14:
	%99 = load i8, i8* %8, align 1
	%100 = icmp ult i8 191, %99
	%101 = zext i1 %100 to i8
	%102 = trunc i8 %101 to i1
	br i1 %102, label %if.then-15, label %if.else-16

if.then-15:
	; AssignStmt
	store i64 1, i64* %5
	br label %if.done-23

if.else-16:
	; IfStmt
	%103 = load i64, i64* %5, align 8
	%104 = icmp eq i64 %103, 3
	%105 = zext i1 %104 to i8
	%106 = trunc i8 %105 to i1
	br i1 %106, label %if.then-17, label %if.else-18

if.then-17:
	br label %if.done-22

if.else-18:
	; IfStmt
	; b
	; IndexExpr
	%107 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%108 = extractvalue {i8*, i64} %107, 0
	%109 = load i64, i64* %2, align 8
	%110 = add i64 %109, 3
	%111 = extractvalue {i8*, i64} %107, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$a6, i64 0, i32 0), i64 63}, i64 249, i64 20, i64 %110, i64 %111)
	%112 = getelementptr inbounds i8, i8* %108, i64 %110
	%113 = load i8, i8* %112, align 1
	store i8 %113, i8* %9
	%114 = load i8, i8* %9, align 1
	%115 = icmp ult i8 %114, 128
	%116 = zext i1 %115 to i8
	%117 = trunc i8 %116 to i1
	br i1 %117, label %if.then-20, label %cmp.or-19

cmp.or-19:
	%118 = load i8, i8* %9, align 1
	%119 = icmp ult i8 191, %118
	%120 = zext i1 %119 to i8
	%121 = trunc i8 %120 to i1
	br i1 %121, label %if.then-20, label %if.done-21

if.then-20:
	; AssignStmt
	store i64 1, i64* %5
	br label %if.done-21

if.done-21:
	br label %if.done-22

if.done-22:
	br label %if.done-23

if.done-23:
	br label %if.done-24

if.done-24:
	br label %if.done-25

if.done-25:
	; AssignStmt
	%122 = load i64, i64* %5, align 8
	%123 = load i64, i64* %2, align 8
	%124 = add i64 %123, %122
	store i64 %124, i64* %2
	; defer
	; AssignStmt
	%125 = load i64, i64* %0, align 8
	%126 = add i64 %125, 1
	store i64 %126, i64* %0
	br label %for.loop-1

for.done-26:
	; ReturnStmt
	%127 = load i64, i64* %0, align 8
	ret i64 %127
}

define void @log.nil_logger_proc(%..rawptr %data, i64 %level, %..string %ident, %..string %text, i8 %options, %runtime.Source_Code_Location* %location, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i64, align 16
	%2 = alloca %..string, align 16
	%3 = alloca %..string, align 16
	%4 = alloca i8, align 16
	store %..rawptr %data, %..rawptr* %0
	store i64 %level, i64* %1
	store %..string %ident, %..string* %2
	store %..string %text, %..string* %3
	store i8 %options, i8* %4
	%5 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, align 8
	ret void
}

define {i8*, i64, i64, %mem.Allocator} @fmt.string_buffer_from_slice({i8*, i64}* %backing, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Raw_Slice, align 16
	%1 = alloca %mem.Raw_Dynamic_Array, align 16
	%2 = alloca %mem.Raw_Dynamic_Array, align 16
	%3 = load {i8*, i64}, {i8*, i64}* %backing, align 8
	; s
	%4 = load {i8*, i64}, {i8*, i64}* %backing, align 8
	%5 = bitcast {i8*, i64}* %backing to %mem.Raw_Slice*
	%6 = load %mem.Raw_Slice, %mem.Raw_Slice* %5, align 8
	store %mem.Raw_Slice %6, %mem.Raw_Slice* %0
	; d
	; CompoundLit
	%7 = bitcast %mem.Raw_Dynamic_Array* %2 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 40) noinline
	store %mem.Raw_Dynamic_Array zeroinitializer, %mem.Raw_Dynamic_Array* %2
	store %mem.Raw_Dynamic_Array {%..rawptr zeroinitializer, i64 0, i64 zeroinitializer, %mem.Allocator zeroinitializer}, %mem.Raw_Dynamic_Array* %2
	; SelectorExpr
	%9 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %0, i64 0, i32 0
	%10 = load %..rawptr, %..rawptr* %9, align 8
	%11 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %2, i64 0, i32 0
	store %..rawptr %10, %..rawptr* %11
	; SelectorExpr
	%12 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %0, i64 0, i32 1
	%13 = load i64, i64* %12, align 8
	%14 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %2, i64 0, i32 2
	store i64 %13, i64* %14
	; SelectorExpr
	%15 = call %mem.Allocator @mem.nil_allocator(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%16 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %2, i64 0, i32 3
	store %mem.Allocator %15, %mem.Allocator* %16
	%17 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %2, align 8
	store %mem.Raw_Dynamic_Array %17, %mem.Raw_Dynamic_Array* %1
	; ReturnStmt
	%18 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %1, align 8
	%19 = bitcast %mem.Raw_Dynamic_Array* %1 to {i8*, i64, i64, %mem.Allocator}*
	%20 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %19, align 8
	ret {i8*, i64, i64, %mem.Allocator} %20
}

define %..string @fmt.to_string({i8*, i64, i64, %mem.Allocator}* %buf, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64}, align 16
	%1 = alloca %..string, align 16
	%2 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %buf, align 8
	; ReturnStmt
	; SliceExpr
	%3 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %buf, align 8
	%4 = extractvalue {i8*, i64, i64, %mem.Allocator} %3, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$a7, i64 0, i32 0), i64 53}, i64 49, i64 19, i64 0, i64 %4, i64 %4)
	%5 = extractvalue {i8*, i64, i64, %mem.Allocator} %3, 0
	%6 = getelementptr inbounds i8, i8* %5, i64 0
	%7 = sub i64 %4, 0
	%8 = bitcast {i8*, i64}* %0 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %0
	%10 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %0, i64 0, i32 0
	store i8* %6, i8** %10
	%11 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %0, i64 0, i32 1
	store i64 %7, i64* %11
	%12 = load {i8*, i64}, {i8*, i64}* %0, align 8
	%13 = extractvalue {i8*, i64} %12, 0
	%14 = extractvalue {i8*, i64} %12, 1
	%15 = bitcast %..string* %1 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 16) noinline
	store %..string zeroinitializer, %..string* %1
	%17 = getelementptr inbounds %..string, %..string* %1, i64 0, i32 0
	store i8* %13, i8** %17
	%18 = getelementptr inbounds %..string, %..string* %1, i64 0, i32 1
	store i64 %14, i64* %18
	%19 = load %..string, %..string* %1, align 8
	ret %..string %19
}

define void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %buf, %..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %..string, align 16
	%2 = alloca {%..string*, i64}, align 16
	%3 = alloca [1 x %..string], align 16
	%4 = alloca {%..string*, i64}, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store %..string %s, %..string* %1
	%6 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%7 = load %..string, %..string* %1, align 8
	; variadic call argument generation
	%8 = bitcast {%..string*, i64}* %2 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 16) noinline
	store {%..string*, i64} zeroinitializer, {%..string*, i64}* %2
	%10 = bitcast [1 x %..string]* %3 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 16) noinline
	store [1 x %..string] zeroinitializer, [1 x %..string]* %3
	%12 = getelementptr inbounds [1 x %..string], [1 x %..string]* %3, i64 0, i32 0
	store %..string %7, %..string* %12
	%13 = getelementptr inbounds [1 x %..string], [1 x %..string]* %3, i64 0, i32 0
	%14 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2, i64 0, i32 0
	store %..string* %13, %..string** %14
	%15 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2, i64 0, i32 1
	store i64 1, i64* %15
	%16 = load {%..string*, i64}, {%..string*, i64}* %2, align 8
	%17 = bitcast {%..string*, i64}* %4 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 16) noinline
	store {%..string*, i64} zeroinitializer, {%..string*, i64}* %4
	store {%..string*, i64} %16, {%..string*, i64}* %4
	%19 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$a8, i64 0, i32 0), i64 53}, i64 54, i64 2, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$a9, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %5
	%21 = call i64 @runtime.append_string-15135({i8*, i64, i64, %mem.Allocator}* %6, {%..string*, i64}* %4, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.write_bytes({i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64}* %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca {i8*, i64}, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	%3 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%4 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%5 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%6 = bitcast {i8*, i64}* %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %1
	store {i8*, i64} %5, {i8*, i64}* %1
	%8 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$aa, i64 0, i32 0), i64 53}, i64 57, i64 2, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$ab, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %2
	%10 = call i64 @runtime.append_elems-15148({i8*, i64, i64, %mem.Allocator}* %4, {i8*, i64}* %1, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %buf, i8 %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store i8 %data, i8* %1
	%3 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%4 = load i8, i8* %1, align 1
	%5 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%6 = call %..rawptr @mem.zero(%..rawptr %5, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$ac, i64 0, i32 0), i64 53}, i64 60, i64 2, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$ad, i64 0, i32 0), i64 10}}, %runtime.Source_Code_Location* %2
	%7 = call i64 @runtime.append_elem-15167({i8*, i64, i64, %mem.Allocator}* %3, i8 %4, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %buf, i32 %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i32, align 16
	%2 = alloca [4 x i8], align 16
	%3 = alloca i64, align 16
	%4 = alloca {i8*, i64}, align 16
	%5 = alloca {i8*, i64}, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store i32 %r, i32* %1
	; IfStmt
	%6 = load i32, i32* %1, align 4
	%7 = icmp slt i32 %6, 128
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	br i1 %9, label %if.then-1, label %if.done-2

if.then-1:
	%10 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = load i32, i32* %1, align 4
	%12 = trunc i32 %11 to i8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %10, i8 %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-2:
	; b
	; n
	; SelectorExpr
	%13 = load i32, i32* %1, align 4
	%14 = call {[4 x i8], i64} @utf8.encode_rune(i32 %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = extractvalue {[4 x i8], i64} %14, 0
	%16 = extractvalue {[4 x i8], i64} %14, 1
	store [4 x i8] %15, [4 x i8]* %2
	store i64 %16, i64* %3
	%17 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SliceExpr
	%18 = load i64, i64* %3, align 8
	%19 = load [4 x i8], [4 x i8]* %2, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$ae, i64 0, i32 0), i64 53}, i64 69, i64 20, i64 0, i64 %18, i64 4)
	%20 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i64 0, i32 0
	%21 = getelementptr inbounds i8, i8* %20, i64 0
	%22 = sub i64 %18, 0
	%23 = bitcast {i8*, i64}* %4 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %4
	%25 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4, i64 0, i32 0
	store i8* %21, i8** %25
	%26 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4, i64 0, i32 1
	store i64 %22, i64* %26
	%27 = load {i8*, i64}, {i8*, i64}* %4, align 8
	%28 = bitcast {i8*, i64}* %5 to %..rawptr
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	store {i8*, i64} %27, {i8*, i64}* %5
	call void @fmt.write_bytes({i8*, i64, i64, %mem.Allocator}* %17, {i8*, i64}* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.write_encoded_rune({i8*, i64, i64, %mem.Allocator}* %buf, i32 %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i32, align 16
	%2 = alloca [2 x i8], align 16
	%3 = alloca %..string, align 16
	%4 = alloca {i8*, i64}, align 16
	%5 = alloca {i8*, i64}, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store i32 %r, i32* %1
	%6 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %6, i8 39, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SwitchStmt
	%7 = load i32, i32* %1, align 4
	%8 = icmp eq i32 %7, 7
	br i1 %8, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%9 = icmp eq i32 %7, 8
	br i1 %9, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	%10 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %10, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$af, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-3:
	%11 = icmp eq i32 %7, 27
	br i1 %11, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	%12 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %12, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$b0, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-5:
	%13 = icmp eq i32 %7, 12
	br i1 %13, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	%14 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %14, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$b1, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-7:
	%15 = icmp eq i32 %7, 10
	br i1 %15, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	%16 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %16, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$b2, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-9:
	%17 = icmp eq i32 %7, 13
	br i1 %17, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	%18 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %18, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$b3, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-11:
	%19 = icmp eq i32 %7, 9
	br i1 %19, label %switch.fall.body-14, label %switch.case.next-13

switch.fall.body-12:
	%20 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %20, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$b4, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-13:
	%21 = icmp eq i32 %7, 11
	br i1 %21, label %switch.fall.body-16, label %switch.case.next-15

switch.fall.body-14:
	%22 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %22, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$b5, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-15:
	; IfStmt
	%23 = load i32, i32* %1, align 4
	%24 = icmp slt i32 %23, 32
	%25 = zext i1 %24 to i8
	%26 = trunc i8 %25 to i1
	br i1 %26, label %if.then-17, label %if.else-25

switch.fall.body-16:
	%27 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %27, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$b6, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

if.then-17:
	%28 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %28, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$b7, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; b
	%29 = bitcast [2 x i8]* %2 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 2) noinline
	store [2 x i8] zeroinitializer, [2 x i8]* %2
	; s
	; SelectorExpr
	; SliceExpr
	%31 = load [2 x i8], [2 x i8]* %2, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$b8, i64 0, i32 0), i64 53}, i64 86, i64 30, i64 0, i64 2, i64 2)
	%32 = getelementptr inbounds [2 x i8], [2 x i8]* %2, i64 0, i32 0
	%33 = getelementptr inbounds i8, i8* %32, i64 0
	%34 = sub i64 2, 0
	%35 = bitcast {i8*, i64}* %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %4
	%37 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4, i64 0, i32 0
	store i8* %33, i8** %37
	%38 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4, i64 0, i32 1
	store i64 %34, i64* %38
	%39 = load {i8*, i64}, {i8*, i64}* %4, align 8
	%40 = load i32, i32* %1, align 4
	%41 = sext i32 %40 to i64
	; SelectorExpr
	%42 = load %..string, %..string* @strconv.digits, align 8
	%43 = bitcast {i8*, i64}* %5 to %..rawptr
	%44 = call %..rawptr @mem.zero(%..rawptr %43, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	store {i8*, i64} %39, {i8*, i64}* %5
	%45 = call %..string @strconv.append_bits({i8*, i64}* %5, i64 %41, i64 16, i1 true, i64 64, %..string %42, i8 zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %45, %..string* %3
	; SwitchStmt
	%46 = load %..string, %..string* %3, align 8
	%47 = extractvalue %..string %46, 1
	%48 = icmp eq i64 %47, 0
	br i1 %48, label %switch.case.body-19, label %switch.case.next-18

switch.case.next-18:
	%49 = icmp eq i64 %47, 1
	br i1 %49, label %switch.fall.body-21, label %switch.case.next-20

switch.case.body-19:
	%50 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %50, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$b9, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-20:
	%51 = icmp eq i64 %47, 2
	br i1 %51, label %switch.fall.body-23, label %switch.case.next-22

switch.fall.body-21:
	%52 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %52, i32 48, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-22:
	br label %switch.done-24

switch.fall.body-23:
	%53 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%54 = load %..string, %..string* %3, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %53, %..string %54, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.done-24:
	br label %if.done-26

if.else-25:
	%55 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%56 = load i32, i32* %1, align 4
	call void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %55, i32 %56, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-26

if.done-26:
	br label %switch.done-27

switch.done-27:
	%57 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %57, i8 39, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.write_u64({i8*, i64, i64, %mem.Allocator}* %buf, i64 %i, i64 %base, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca [129 x i8], align 16
	%4 = alloca %..string, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca {i8*, i64}, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store i64 %i, i64* %1
	store i64 %base, i64* %2
	; b
	%7 = bitcast [129 x i8]* %3 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 129) noinline
	store [129 x i8] zeroinitializer, [129 x i8]* %3
	; s
	; SelectorExpr
	; SliceExpr
	%9 = load [129 x i8], [129 x i8]* %3, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$ba, i64 0, i32 0), i64 53}, i64 102, i64 28, i64 0, i64 129, i64 129)
	%10 = getelementptr inbounds [129 x i8], [129 x i8]* %3, i64 0, i32 0
	%11 = getelementptr inbounds i8, i8* %10, i64 0
	%12 = sub i64 129, 0
	%13 = bitcast {i8*, i64}* %5 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	%15 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 0
	store i8* %11, i8** %15
	%16 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 1
	store i64 %12, i64* %16
	%17 = load {i8*, i64}, {i8*, i64}* %5, align 8
	%18 = load i64, i64* %1, align 8
	%19 = load i64, i64* %2, align 8
	; SelectorExpr
	%20 = load %..string, %..string* @strconv.digits, align 8
	%21 = bitcast {i8*, i64}* %6 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	store {i8*, i64} %17, {i8*, i64}* %6
	%23 = call %..string @strconv.append_bits({i8*, i64}* %6, i64 %18, i64 %19, i1 false, i64 64, %..string %20, i8 zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %23, %..string* %4
	%24 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load %..string, %..string* %4, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %24, %..string %25, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %buf, i64 %i, i64 %base, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca [129 x i8], align 16
	%4 = alloca %..string, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca {i8*, i64}, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store i64 %i, i64* %1
	store i64 %base, i64* %2
	; b
	%7 = bitcast [129 x i8]* %3 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 129) noinline
	store [129 x i8] zeroinitializer, [129 x i8]* %3
	; s
	; SelectorExpr
	; SliceExpr
	%9 = load [129 x i8], [129 x i8]* %3, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$bb, i64 0, i32 0), i64 53}, i64 107, i64 28, i64 0, i64 129, i64 129)
	%10 = getelementptr inbounds [129 x i8], [129 x i8]* %3, i64 0, i32 0
	%11 = getelementptr inbounds i8, i8* %10, i64 0
	%12 = sub i64 129, 0
	%13 = bitcast {i8*, i64}* %5 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	%15 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 0
	store i8* %11, i8** %15
	%16 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 1
	store i64 %12, i64* %16
	%17 = load {i8*, i64}, {i8*, i64}* %5, align 8
	%18 = load i64, i64* %1, align 8
	%19 = bitcast i64 %18 to i64
	%20 = load i64, i64* %2, align 8
	; SelectorExpr
	%21 = load %..string, %..string* @strconv.digits, align 8
	%22 = bitcast {i8*, i64}* %6 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	store {i8*, i64} %17, {i8*, i64}* %6
	%24 = call %..string @strconv.append_bits({i8*, i64}* %6, i64 %19, i64 %20, i1 true, i64 64, %..string %21, i8 zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %24, %..string* %4
	%25 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%26 = load %..string, %..string* %4, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %25, %..string %26, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define i64 @fmt.fprint(i32 %fd, {%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca [4096 x i8], align 16
	%2 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%3 = alloca {i8*, i64}, align 16
	%4 = alloca {i8*, i64}, align 16
	%5 = alloca %..string, align 16
	%6 = alloca {%..any*, i64}, align 16
	store i32 %fd, i32* %0
	%7 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; data
	%8 = bitcast [4096 x i8]* %1 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 4096) noinline
	store [4096 x i8] zeroinitializer, [4096 x i8]* %1
	; buf
	; SliceExpr
	%10 = load [4096 x i8], [4096 x i8]* %1, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$bc, i64 0, i32 0), i64 53}, i64 113, i64 38, i64 0, i64 4096, i64 4096)
	%11 = getelementptr inbounds [4096 x i8], [4096 x i8]* %1, i64 0, i32 0
	%12 = getelementptr inbounds i8, i8* %11, i64 0
	%13 = sub i64 4096, 0
	%14 = bitcast {i8*, i64}* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %3
	%16 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3, i64 0, i32 0
	store i8* %12, i8** %16
	%17 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3, i64 0, i32 1
	store i64 %13, i64* %17
	%18 = load {i8*, i64}, {i8*, i64}* %3, align 8
	%19 = bitcast {i8*, i64}* %4 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %4
	store {i8*, i64} %18, {i8*, i64}* %4
	%21 = call {i8*, i64, i64, %mem.Allocator} @fmt.string_buffer_from_slice({i8*, i64}* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64, i64, %mem.Allocator} %21, {i8*, i64, i64, %mem.Allocator}* %2
	; res
	%22 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%23 = bitcast {%..any*, i64}* %6 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %6
	store {%..any*, i64} %22, {%..any*, i64}* %6
	%25 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* %2, {%..any*, i64}* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %25, %..string* %5
	; SelectorExpr
	%26 = load i32, i32* %0, align 4
	%27 = load %..string, %..string* %5, align 8
	%28 = call {i64, i64} @os.write_string(i32 %26, %..string %27, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%29 = load %..string, %..string* %5, align 8
	%30 = extractvalue %..string %29, 1
	ret i64 %30
}

define i64 @fmt.fprintf(i32 %fd, %..string %fmt, {%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %..string, align 16
	%2 = alloca [4096 x i8], align 16
	%3 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%4 = alloca {i8*, i64}, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca %..string, align 16
	%7 = alloca {%..any*, i64}, align 16
	store i32 %fd, i32* %0
	store %..string %fmt, %..string* %1
	%8 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; data
	%9 = bitcast [4096 x i8]* %2 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 4096) noinline
	store [4096 x i8] zeroinitializer, [4096 x i8]* %2
	; buf
	; SliceExpr
	%11 = load [4096 x i8], [4096 x i8]* %2, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$bd, i64 0, i32 0), i64 53}, i64 128, i64 38, i64 0, i64 4096, i64 4096)
	%12 = getelementptr inbounds [4096 x i8], [4096 x i8]* %2, i64 0, i32 0
	%13 = getelementptr inbounds i8, i8* %12, i64 0
	%14 = sub i64 4096, 0
	%15 = bitcast {i8*, i64}* %4 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %4
	%17 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4, i64 0, i32 0
	store i8* %13, i8** %17
	%18 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4, i64 0, i32 1
	store i64 %14, i64* %18
	%19 = load {i8*, i64}, {i8*, i64}* %4, align 8
	%20 = bitcast {i8*, i64}* %5 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	store {i8*, i64} %19, {i8*, i64}* %5
	%22 = call {i8*, i64, i64, %mem.Allocator} @fmt.string_buffer_from_slice({i8*, i64}* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64, i64, %mem.Allocator} %22, {i8*, i64, i64, %mem.Allocator}* %3
	; res
	%23 = load %..string, %..string* %1, align 8
	%24 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%25 = bitcast {%..any*, i64}* %7 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %7
	store {%..any*, i64} %24, {%..any*, i64}* %7
	%27 = call %..string @fmt.sbprintf({i8*, i64, i64, %mem.Allocator}* %3, %..string %23, {%..any*, i64}* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %27, %..string* %6
	; SelectorExpr
	%28 = load i32, i32* %0, align 4
	%29 = load %..string, %..string* %6, align 8
	%30 = call {i64, i64} @os.write_string(i32 %28, %..string %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%31 = load %..string, %..string* %6, align 8
	%32 = extractvalue %..string %31, 1
	ret i64 %32
}

define i64 @fmt.print({%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%..any*, i64}, align 16
	%1 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; ReturnStmt
	; SelectorExpr
	%2 = load i32, i32* @os.stdout, align 4
	%3 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%4 = bitcast {%..any*, i64}* %0 to %..rawptr
	%5 = call %..rawptr @mem.zero(%..rawptr %4, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %0
	store {%..any*, i64} %3, {%..any*, i64}* %0
	%6 = call i64 @fmt.fprint(i32 %2, {%..any*, i64}* %0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret i64 %6
}

define i64 @fmt.printf(%..string %fmt, {%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca {%..any*, i64}, align 16
	store %..string %fmt, %..string* %0
	%2 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; ReturnStmt
	; SelectorExpr
	%3 = load i32, i32* @os.stdout, align 4
	%4 = load %..string, %..string* %0, align 8
	%5 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%6 = bitcast {%..any*, i64}* %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %1
	store {%..any*, i64} %5, {%..any*, i64}* %1
	%8 = call i64 @fmt.fprintf(i32 %3, %..string %4, {%..any*, i64}* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret i64 %8
}

define i64 @fmt.printf_err(%..string %fmt, {%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca {%..any*, i64}, align 16
	store %..string %fmt, %..string* %0
	%2 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; ReturnStmt
	; SelectorExpr
	%3 = load i32, i32* @os.stderr, align 4
	%4 = load %..string, %..string* %0, align 8
	%5 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%6 = bitcast {%..any*, i64}* %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %1
	store {%..any*, i64} %5, {%..any*, i64}* %1
	%8 = call i64 @fmt.fprintf(i32 %3, %..string %4, {%..any*, i64}* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret i64 %8
}

define %..string @fmt.tprint({%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%1 = alloca %mem.Allocator, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%4 = alloca {%..any*, i64}, align 16
	%5 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%6 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; buf
	; SelectorExpr
	%7 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 1
	%8 = load %mem.Allocator, %mem.Allocator* %7, align 8
	%9 = bitcast %mem.Allocator* %1 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %1
	store %mem.Allocator %8, %mem.Allocator* %1
	%11 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$be, i64 0, i32 0), i64 53}, i64 165, i64 23, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$bf, i64 0, i32 0), i64 6}}, %runtime.Source_Code_Location* %2
	%13 = call {i8*, i64, i64, %mem.Allocator} @mem.make_dynamic_array-15214(%mem.Allocator* %1, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%14 = bitcast {i8*, i64, i64, %mem.Allocator}* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 40) noinline
	store {i8*, i64, i64, %mem.Allocator} zeroinitializer, {i8*, i64, i64, %mem.Allocator}* %3
	store {i8*, i64, i64, %mem.Allocator} %13, {i8*, i64, i64, %mem.Allocator}* %3
	%16 = bitcast {i8*, i64, i64, %mem.Allocator}* %3 to {i8*, i64, i64, %mem.Allocator}*
	%17 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %16, align 8
	store {i8*, i64, i64, %mem.Allocator} %17, {i8*, i64, i64, %mem.Allocator}* %0
	%18 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%19 = bitcast {%..any*, i64}* %4 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %4
	store {%..any*, i64} %18, {%..any*, i64}* %4
	%21 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* %0, {%..any*, i64}* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%22 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %0, align 8
	%23 = bitcast {i8*, i64, i64, %mem.Allocator}* %5 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 40) noinline
	store {i8*, i64, i64, %mem.Allocator} zeroinitializer, {i8*, i64, i64, %mem.Allocator}* %5
	store {i8*, i64, i64, %mem.Allocator} %22, {i8*, i64, i64, %mem.Allocator}* %5
	%25 = call %..string @fmt.to_string({i8*, i64, i64, %mem.Allocator}* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret %..string %25
}

define %..string @fmt.tprintf(%..string %fmt, {%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%2 = alloca %mem.Allocator, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%5 = alloca {%..any*, i64}, align 16
	%6 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	store %..string %fmt, %..string* %0
	%7 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; buf
	; SelectorExpr
	%8 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 1
	%9 = load %mem.Allocator, %mem.Allocator* %8, align 8
	%10 = bitcast %mem.Allocator* %2 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %2
	store %mem.Allocator %9, %mem.Allocator* %2
	%12 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$c0, i64 0, i32 0), i64 53}, i64 175, i64 23, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$c1, i64 0, i32 0), i64 7}}, %runtime.Source_Code_Location* %3
	%14 = call {i8*, i64, i64, %mem.Allocator} @mem.make_dynamic_array-15214(%mem.Allocator* %2, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = bitcast {i8*, i64, i64, %mem.Allocator}* %4 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 40) noinline
	store {i8*, i64, i64, %mem.Allocator} zeroinitializer, {i8*, i64, i64, %mem.Allocator}* %4
	store {i8*, i64, i64, %mem.Allocator} %14, {i8*, i64, i64, %mem.Allocator}* %4
	%17 = bitcast {i8*, i64, i64, %mem.Allocator}* %4 to {i8*, i64, i64, %mem.Allocator}*
	%18 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %17, align 8
	store {i8*, i64, i64, %mem.Allocator} %18, {i8*, i64, i64, %mem.Allocator}* %1
	%19 = load %..string, %..string* %0, align 8
	%20 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%21 = bitcast {%..any*, i64}* %5 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %5
	store {%..any*, i64} %20, {%..any*, i64}* %5
	%23 = call %..string @fmt.sbprintf({i8*, i64, i64, %mem.Allocator}* %1, %..string %19, {%..any*, i64}* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%24 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %1, align 8
	%25 = bitcast {i8*, i64, i64, %mem.Allocator}* %6 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 40) noinline
	store {i8*, i64, i64, %mem.Allocator} zeroinitializer, {i8*, i64, i64, %mem.Allocator}* %6
	store {i8*, i64, i64, %mem.Allocator} %24, {i8*, i64, i64, %mem.Allocator}* %6
	%27 = call %..string @fmt.to_string({i8*, i64, i64, %mem.Allocator}* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret %..string %27
}

define %..string @fmt.bprint({i8*, i64}* %buf, {%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%1 = alloca {i8*, i64}, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca {%..any*, i64}, align 16
	%4 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%5 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; sb
	; SliceExpr
	%6 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%7 = extractvalue {i8*, i64} %6, 1
	%8 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%9 = extractvalue {i8*, i64} %8, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$c2, i64 0, i32 0), i64 53}, i64 183, i64 36, i64 0, i64 %7, i64 %9)
	%10 = extractvalue {i8*, i64} %8, 0
	%11 = getelementptr inbounds i8, i8* %10, i64 0
	%12 = sub i64 %7, 0
	%13 = bitcast {i8*, i64}* %1 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %1
	%15 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1, i64 0, i32 0
	store i8* %11, i8** %15
	%16 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1, i64 0, i32 1
	store i64 %12, i64* %16
	%17 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%18 = bitcast {i8*, i64}* %2 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %2
	store {i8*, i64} %17, {i8*, i64}* %2
	%20 = call {i8*, i64, i64, %mem.Allocator} @fmt.string_buffer_from_slice({i8*, i64}* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64, i64, %mem.Allocator} %20, {i8*, i64, i64, %mem.Allocator}* %0
	; ReturnStmt
	%21 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%22 = bitcast {%..any*, i64}* %3 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %3
	store {%..any*, i64} %21, {%..any*, i64}* %3
	%24 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* %0, {%..any*, i64}* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret %..string %24
}

define %..string @fmt.bprintf({i8*, i64}* %buf, %..string %fmt, {%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca {i8*, i64}, align 16
	%4 = alloca {%..any*, i64}, align 16
	%5 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	store %..string %fmt, %..string* %0
	%6 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; sb
	; SliceExpr
	%7 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%8 = extractvalue {i8*, i64} %7, 1
	%9 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%10 = extractvalue {i8*, i64} %9, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$c3, i64 0, i32 0), i64 53}, i64 191, i64 36, i64 0, i64 %8, i64 %10)
	%11 = extractvalue {i8*, i64} %9, 0
	%12 = getelementptr inbounds i8, i8* %11, i64 0
	%13 = sub i64 %8, 0
	%14 = bitcast {i8*, i64}* %2 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %2
	%16 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 0
	store i8* %12, i8** %16
	%17 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 1
	store i64 %13, i64* %17
	%18 = load {i8*, i64}, {i8*, i64}* %2, align 8
	%19 = bitcast {i8*, i64}* %3 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %3
	store {i8*, i64} %18, {i8*, i64}* %3
	%21 = call {i8*, i64, i64, %mem.Allocator} @fmt.string_buffer_from_slice({i8*, i64}* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64, i64, %mem.Allocator} %21, {i8*, i64, i64, %mem.Allocator}* %1
	; ReturnStmt
	%22 = load %..string, %..string* %0, align 8
	%23 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%24 = bitcast {%..any*, i64}* %4 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %4
	store {%..any*, i64} %23, {%..any*, i64}* %4
	%26 = call %..string @fmt.sbprintf({i8*, i64, i64, %mem.Allocator}* %1, %..string %22, {%..any*, i64}* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret %..string %26
}

define void @fmt.write_typeid({i8*, i64, i64, %mem.Allocator}* %buf, %..typeid %id, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %..typeid, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store %..typeid %id, %..typeid* %1
	%2 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%3 = load %..typeid, %..typeid* %1, align 8
	%4 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %3)
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %2, %runtime.Type_Info* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %buf, %runtime.Type_Info* %ti, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	%2 = alloca %runtime.Type_Info_Named, align 16
	%3 = alloca %runtime.Type_Info_Integer, align 16
	%4 = alloca %runtime.Type_Info_Rune, align 16
	%5 = alloca %runtime.Type_Info_Float, align 16
	%6 = alloca %runtime.Type_Info_Complex, align 16
	%7 = alloca %runtime.Type_Info_String, align 16
	%8 = alloca %runtime.Type_Info_Boolean, align 16
	%9 = alloca %runtime.Type_Info_Any, align 16
	%10 = alloca %runtime.Type_Info_Type_Id, align 16
	%11 = alloca %runtime.Type_Info_Pointer, align 16
	%12 = alloca %runtime.Type_Info_Procedure, align 16
	%13 = alloca %runtime.Type_Info_Tuple, align 16
	%14 = alloca {%runtime.Type_Info_Tuple, i8}, align 16
	%15 = alloca %runtime.Type_Info*, align 16
	%16 = alloca i64, align 16
	%17 = alloca i64, align 16
	%18 = alloca i64, align 16
	%19 = alloca %runtime.Type_Info_Tuple, align 16
	%20 = alloca i64, align 16
	%21 = alloca %..string, align 16
	%22 = alloca i64, align 16
	%23 = alloca i64, align 16
	%24 = alloca i64, align 16
	%25 = alloca %runtime.Type_Info*, align 16
	%26 = alloca %runtime.Type_Info_Array, align 16
	%27 = alloca %runtime.Type_Info_Dynamic_Array, align 16
	%28 = alloca %runtime.Type_Info_Slice, align 16
	%29 = alloca %runtime.Type_Info_Map, align 16
	%30 = alloca %runtime.Type_Info_Struct, align 16
	%31 = alloca %..string, align 16
	%32 = alloca i64, align 16
	%33 = alloca i64, align 16
	%34 = alloca i64, align 16
	%35 = alloca %runtime.Type_Info_Union, align 16
	%36 = alloca %runtime.Type_Info*, align 16
	%37 = alloca i64, align 16
	%38 = alloca i64, align 16
	%39 = alloca i64, align 16
	%40 = alloca %runtime.Type_Info_Enum, align 16
	%41 = alloca %..string, align 16
	%42 = alloca i64, align 16
	%43 = alloca i64, align 16
	%44 = alloca i64, align 16
	%45 = alloca %runtime.Type_Info_Bit_Field, align 16
	%46 = alloca %..string, align 16
	%47 = alloca i64, align 16
	%48 = alloca i64, align 16
	%49 = alloca i64, align 16
	%50 = alloca %runtime.Type_Info_Bit_Set, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store %runtime.Type_Info* %ti, %runtime.Type_Info** %1
	; IfStmt
	%51 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%52 = icmp eq %runtime.Type_Info* %51, zeroinitializer
	%53 = zext i1 %52 to i8
	%54 = trunc i8 %53 to i1
	br i1 %54, label %if.then-1, label %if.done-2

if.then-1:
	%55 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %55, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$c4, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-2:
	; TypeSwitchStmt
	; SelectorExpr
	%56 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%57 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %56, i64 0
	%58 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %57, i64 0, i32 3
	%59 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %58, align 8
	; get union's tag
	%60 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %58, i64 0, i32 2 ; UnionTagPtr
	%61 = load i8, i8* %60, align 1
	%62 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %58 to %..rawptr
	%63 = icmp eq i8 %61, 1
	br i1 %63, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.next-3:
	%64 = icmp eq i8 %61, 2
	br i1 %64, label %typeswitch.body-6, label %typeswitch.next-5

typeswitch.body-4:
	%65 = bitcast %..rawptr %62 to %runtime.Type_Info_Named*
	%66 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %65, align 8
	store %runtime.Type_Info_Named %66, %runtime.Type_Info_Named* %2
	%67 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%68 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2, i64 0, i32 0
	%69 = load %..string, %..string* %68, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %67, %..string %69, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-5:
	%70 = icmp eq i8 %61, 3
	br i1 %70, label %typeswitch.body-18, label %typeswitch.next-17

typeswitch.body-6:
	%71 = bitcast %..rawptr %62 to %runtime.Type_Info_Integer*
	%72 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %71, align 1
	store %runtime.Type_Info_Integer %72, %runtime.Type_Info_Integer* %3
	; SwitchStmt
	; SelectorExpr
	%73 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%74 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %73, i64 0
	%75 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %74, i64 0, i32 2
	%76 = load %..typeid, %..typeid* %75, align 8
	%77 = icmp eq %..typeid %76, 4683743612465315846
	br i1 %77, label %switch.case.body-8, label %switch.case.next-7

switch.case.next-7:
	%78 = icmp eq %..typeid %76, 72057594037928003
	br i1 %78, label %switch.fall.body-10, label %switch.case.next-9

switch.case.body-8:
	%79 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %79, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$c5, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

switch.case.next-9:
	%80 = icmp eq %..typeid %76, 72057594037927986
	br i1 %80, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	%81 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %81, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$c6, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

switch.case.next-11:
	%82 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; TernaryExpr
	; SelectorExpr
	%83 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %3, i64 0, i32 0
	%84 = load i8, i8* %83, align 1
	%85 = trunc i8 %84 to i1
	br i1 %85, label %if.then-13, label %if.else-14

switch.fall.body-12:
	%86 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %86, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$c7, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

if.then-13:
	br label %if.done-15

if.else-14:
	br label %if.done-15

if.done-15:
	%87 = phi i32 [ 105, %if.then-13 ], [ 117, %if.else-14 ]
	%88 = trunc i32 %87 to i8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %82, i8 %88, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%89 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%90 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%91 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %90, i64 0
	%92 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %91, i64 0, i32 0
	%93 = load i64, i64* %92, align 8
	%94 = mul i64 8, %93
	%95 = bitcast i64 %94 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %89, i64 %95, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

switch.done-16:
	br label %typeswitch.done-124

typeswitch.next-17:
	%96 = icmp eq i8 %61, 4
	br i1 %96, label %typeswitch.body-20, label %typeswitch.next-19

typeswitch.body-18:
	%97 = bitcast %..rawptr %62 to %runtime.Type_Info_Rune*
	%98 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %97, align 1
	store %runtime.Type_Info_Rune %98, %runtime.Type_Info_Rune* %4
	%99 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %99, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$c8, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-19:
	%100 = icmp eq i8 %61, 5
	br i1 %100, label %typeswitch.body-22, label %typeswitch.next-21

typeswitch.body-20:
	%101 = bitcast %..rawptr %62 to %runtime.Type_Info_Float*
	%102 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %101, align 1
	store %runtime.Type_Info_Float %102, %runtime.Type_Info_Float* %5
	%103 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %103, i8 102, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%104 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%105 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%106 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %105, i64 0
	%107 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %106, i64 0, i32 0
	%108 = load i64, i64* %107, align 8
	%109 = mul i64 8, %108
	%110 = bitcast i64 %109 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %104, i64 %110, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-21:
	%111 = icmp eq i8 %61, 6
	br i1 %111, label %typeswitch.body-24, label %typeswitch.next-23

typeswitch.body-22:
	%112 = bitcast %..rawptr %62 to %runtime.Type_Info_Complex*
	%113 = load %runtime.Type_Info_Complex, %runtime.Type_Info_Complex* %112, align 1
	store %runtime.Type_Info_Complex %113, %runtime.Type_Info_Complex* %6
	%114 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %114, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$c9, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%115 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%116 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%117 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %116, i64 0
	%118 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %117, i64 0, i32 0
	%119 = load i64, i64* %118, align 8
	%120 = mul i64 8, %119
	%121 = bitcast i64 %120 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %115, i64 %121, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-23:
	%122 = icmp eq i8 %61, 7
	br i1 %122, label %typeswitch.body-29, label %typeswitch.next-28

typeswitch.body-24:
	%123 = bitcast %..rawptr %62 to %runtime.Type_Info_String*
	%124 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %123, align 1
	store %runtime.Type_Info_String %124, %runtime.Type_Info_String* %7
	; IfStmt
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_String, %runtime.Type_Info_String* %7, i64 0, i32 0
	%126 = load i8, i8* %125, align 1
	%127 = trunc i8 %126 to i1
	br i1 %127, label %if.then-25, label %if.else-26

if.then-25:
	%128 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %128, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$ca, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-27

if.else-26:
	%129 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %129, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$cb, i64 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-27

if.done-27:
	br label %typeswitch.done-124

typeswitch.next-28:
	%130 = icmp eq i8 %61, 8
	br i1 %130, label %typeswitch.body-34, label %typeswitch.next-33

typeswitch.body-29:
	%131 = bitcast %..rawptr %62 to %runtime.Type_Info_Boolean*
	%132 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %131, align 1
	store %runtime.Type_Info_Boolean %132, %runtime.Type_Info_Boolean* %8
	; SwitchStmt
	; SelectorExpr
	%133 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%134 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %133, i64 0
	%135 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %134, i64 0, i32 2
	%136 = load %..typeid, %..typeid* %135, align 8
	%137 = icmp eq %..typeid %136, 432345564227567636
	br i1 %137, label %switch.case.body-31, label %switch.case.next-30

switch.case.next-30:
	%138 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %138, i8 98, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%139 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%140 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%141 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %140, i64 0
	%142 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %141, i64 0, i32 0
	%143 = load i64, i64* %142, align 8
	%144 = mul i64 8, %143
	%145 = bitcast i64 %144 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %139, i64 %145, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-32

switch.case.body-31:
	%146 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %146, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$cc, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-32

switch.done-32:
	br label %typeswitch.done-124

typeswitch.next-33:
	%147 = icmp eq i8 %61, 9
	br i1 %147, label %typeswitch.body-36, label %typeswitch.next-35

typeswitch.body-34:
	%148 = bitcast %..rawptr %62 to %runtime.Type_Info_Any*
	%149 = load %runtime.Type_Info_Any, %runtime.Type_Info_Any* %148, align 1
	store %runtime.Type_Info_Any %149, %runtime.Type_Info_Any* %9
	%150 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %150, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$cd, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-35:
	%151 = icmp eq i8 %61, 10
	br i1 %151, label %typeswitch.body-38, label %typeswitch.next-37

typeswitch.body-36:
	%152 = bitcast %..rawptr %62 to %runtime.Type_Info_Type_Id*
	%153 = load %runtime.Type_Info_Type_Id, %runtime.Type_Info_Type_Id* %152, align 1
	store %runtime.Type_Info_Type_Id %153, %runtime.Type_Info_Type_Id* %10
	%154 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %154, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$ce, i64 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-37:
	%155 = icmp eq i8 %61, 11
	br i1 %155, label %typeswitch.body-43, label %typeswitch.next-42

typeswitch.body-38:
	%156 = bitcast %..rawptr %62 to %runtime.Type_Info_Pointer*
	%157 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %156, align 8
	store %runtime.Type_Info_Pointer %157, %runtime.Type_Info_Pointer* %11
	; IfStmt
	; SelectorExpr
	%158 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %11, i64 0, i32 0
	%159 = load %runtime.Type_Info*, %runtime.Type_Info** %158, align 8
	%160 = icmp eq %runtime.Type_Info* %159, zeroinitializer
	%161 = zext i1 %160 to i8
	%162 = trunc i8 %161 to i1
	br i1 %162, label %if.then-39, label %if.else-40

if.then-39:
	%163 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %163, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$cf, i64 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-41

if.else-40:
	%164 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %164, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$d0, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%165 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%166 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %11, i64 0, i32 0
	%167 = load %runtime.Type_Info*, %runtime.Type_Info** %166, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %165, %runtime.Type_Info* %167, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-41

if.done-41:
	br label %typeswitch.done-124

typeswitch.next-42:
	%168 = icmp eq i8 %61, 15
	br i1 %168, label %typeswitch.body-57, label %typeswitch.next-56

typeswitch.body-43:
	%169 = bitcast %..rawptr %62 to %runtime.Type_Info_Procedure*
	%170 = load %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %169, align 8
	store %runtime.Type_Info_Procedure %170, %runtime.Type_Info_Procedure* %12
	%171 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %171, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$d1, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%172 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 0
	%173 = load %runtime.Type_Info*, %runtime.Type_Info** %172, align 8
	%174 = icmp eq %runtime.Type_Info* %173, zeroinitializer
	%175 = zext i1 %174 to i8
	%176 = trunc i8 %175 to i1
	br i1 %176, label %if.then-44, label %if.else-45

if.then-44:
	%177 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %177, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$d2, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-53

if.else-45:
	; t
	; SelectorExpr
	; SelectorExpr
	%178 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 0
	%179 = load %runtime.Type_Info*, %runtime.Type_Info** %178, align 8
	%180 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %179, i64 0
	%181 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %180, i64 0, i32 3
	%182 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %181, align 8
	; cast - union_cast
	%183 = bitcast {%runtime.Type_Info_Tuple, i8}* %14 to %..rawptr
	%184 = call %..rawptr @mem.zero(%..rawptr %183, i64 40) noinline
	store {%runtime.Type_Info_Tuple, i8} zeroinitializer, {%runtime.Type_Info_Tuple, i8}* %14
	%185 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %181, i64 0, i32 2 ; UnionTagPtr
	%186 = load i8, i8* %185, align 1
	%187 = icmp eq i8 %186, 15
	br i1 %187, label %union_cast.ok-46, label %union_cast.end-47

union_cast.ok-46:
	%188 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 0
	%189 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 1
	%190 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %181 to %runtime.Type_Info_Tuple*
	%191 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %190, align 8
	store %runtime.Type_Info_Tuple %191, %runtime.Type_Info_Tuple* %188
	store i8 1, i8* %189
	br label %union_cast.end-47

union_cast.end-47:
	%192 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 1
	%193 = load i8, i8* %192, align 1
	%194 = trunc i8 %193 to i1
	call void @runtime.type_assertion_check(i1 %194, %..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$d3, i64 0, i32 0), i64 53}, i64 289, i64 21, %..typeid 1152921504606846991, %..typeid 3386706919782613033)
	%195 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 0
	%196 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %195, align 8
	store %runtime.Type_Info_Tuple %196, %runtime.Type_Info_Tuple* %13
	%197 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %197, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$d4, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; t
	%198 = bitcast %runtime.Type_Info** %15 to %..rawptr
	%199 = call %..rawptr @mem.zero(%..rawptr %198, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %15
	; i
	%200 = bitcast i64* %16 to %..rawptr
	%201 = call %..rawptr @mem.zero(%..rawptr %200, i64 8) noinline
	store i64 zeroinitializer, i64* %16
	; SelectorExpr
	%202 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %13, i64 0, i32 0
	%203 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %202, align 8
	%204 = bitcast i64* %17 to %..rawptr
	%205 = call %..rawptr @mem.zero(%..rawptr %204, i64 8) noinline
	store i64 zeroinitializer, i64* %17
	%206 = extractvalue {%runtime.Type_Info**, i64} %203, 1
	store i64 %206, i64* %17
	%207 = bitcast i64* %18 to %..rawptr
	%208 = call %..rawptr @mem.zero(%..rawptr %207, i64 8) noinline
	store i64 zeroinitializer, i64* %18
	store i64 -1, i64* %18
	br label %for.index.loop-48

for.index.loop-48:
	%209 = load i64, i64* %18, align 8
	%210 = add i64 %209, 1
	store i64 %210, i64* %18
	%211 = load i64, i64* %17, align 8
	%212 = icmp slt i64 %210, %211
	br i1 %212, label %for.index.body-49, label %for.index.done-52

for.index.body-49:
	%213 = load i64, i64* %18, align 8
	%214 = extractvalue {%runtime.Type_Info**, i64} %203, 0
	%215 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %214, i64 %213
	%216 = load %runtime.Type_Info*, %runtime.Type_Info** %215, align 8
	store %runtime.Type_Info* %216, %runtime.Type_Info** %15
	store i64 %213, i64* %16
	; IfStmt
	%217 = load i64, i64* %16, align 8
	%218 = icmp sgt i64 %217, 0
	%219 = zext i1 %218 to i8
	%220 = trunc i8 %219 to i1
	br i1 %220, label %if.then-50, label %if.done-51

if.then-50:
	%221 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %221, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$d5, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-51

if.done-51:
	%222 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%223 = load %runtime.Type_Info*, %runtime.Type_Info** %15, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %222, %runtime.Type_Info* %223, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-48

for.index.done-52:
	%224 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %224, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$d6, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-53

if.done-53:
	; IfStmt
	; SelectorExpr
	%225 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 1
	%226 = load %runtime.Type_Info*, %runtime.Type_Info** %225, align 8
	%227 = icmp ne %runtime.Type_Info* %226, zeroinitializer
	%228 = zext i1 %227 to i8
	%229 = trunc i8 %228 to i1
	br i1 %229, label %if.then-54, label %if.done-55

if.then-54:
	%230 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %230, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$d7, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%231 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%232 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 1
	%233 = load %runtime.Type_Info*, %runtime.Type_Info** %232, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %231, %runtime.Type_Info* %233, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-55

if.done-55:
	br label %typeswitch.done-124

typeswitch.next-56:
	%234 = icmp eq i8 %61, 12
	br i1 %234, label %typeswitch.body-70, label %typeswitch.next-69

typeswitch.body-57:
	%235 = bitcast %..rawptr %62 to %runtime.Type_Info_Tuple*
	%236 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %235, align 8
	store %runtime.Type_Info_Tuple %236, %runtime.Type_Info_Tuple* %19
	; count
	; SelectorExpr
	%237 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %19, i64 0, i32 1
	%238 = load {%..string*, i64}, {%..string*, i64}* %237, align 8
	%239 = extractvalue {%..string*, i64} %238, 1
	store i64 %239, i64* %20
	; IfStmt
	%240 = load i64, i64* %20, align 8
	%241 = icmp ne i64 %240, 1
	%242 = zext i1 %241 to i8
	%243 = trunc i8 %242 to i1
	br i1 %243, label %if.then-58, label %if.done-59

if.then-58:
	%244 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %244, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$d8, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-59

if.done-59:
	; RangeStmt
	; name
	%245 = bitcast %..string* %21 to %..rawptr
	%246 = call %..rawptr @mem.zero(%..rawptr %245, i64 16) noinline
	store %..string zeroinitializer, %..string* %21
	; i
	%247 = bitcast i64* %22 to %..rawptr
	%248 = call %..rawptr @mem.zero(%..rawptr %247, i64 8) noinline
	store i64 zeroinitializer, i64* %22
	; SelectorExpr
	%249 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %19, i64 0, i32 1
	%250 = load {%..string*, i64}, {%..string*, i64}* %249, align 8
	%251 = bitcast i64* %23 to %..rawptr
	%252 = call %..rawptr @mem.zero(%..rawptr %251, i64 8) noinline
	store i64 zeroinitializer, i64* %23
	%253 = extractvalue {%..string*, i64} %250, 1
	store i64 %253, i64* %23
	%254 = bitcast i64* %24 to %..rawptr
	%255 = call %..rawptr @mem.zero(%..rawptr %254, i64 8) noinline
	store i64 zeroinitializer, i64* %24
	store i64 -1, i64* %24
	br label %for.index.loop-60

for.index.loop-60:
	%256 = load i64, i64* %24, align 8
	%257 = add i64 %256, 1
	store i64 %257, i64* %24
	%258 = load i64, i64* %23, align 8
	%259 = icmp slt i64 %257, %258
	br i1 %259, label %for.index.body-61, label %for.index.done-66

for.index.body-61:
	%260 = load i64, i64* %24, align 8
	%261 = extractvalue {%..string*, i64} %250, 0
	%262 = getelementptr inbounds %..string, %..string* %261, i64 %260
	%263 = load %..string, %..string* %262, align 8
	store %..string %263, %..string* %21
	store i64 %260, i64* %22
	; IfStmt
	%264 = load i64, i64* %22, align 8
	%265 = icmp sgt i64 %264, 0
	%266 = zext i1 %265 to i8
	%267 = trunc i8 %266 to i1
	br i1 %267, label %if.then-62, label %if.done-63

if.then-62:
	%268 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %268, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$d9, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-63

if.done-63:
	; t
	; IndexExpr
	; SelectorExpr
	%269 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %19, i64 0, i32 0
	%270 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %269, align 8
	%271 = extractvalue {%runtime.Type_Info**, i64} %270, 0
	%272 = load i64, i64* %22, align 8
	%273 = extractvalue {%runtime.Type_Info**, i64} %270, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$da, i64 0, i32 0), i64 53}, i64 307, i64 20, i64 %272, i64 %273)
	%274 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %271, i64 %272
	%275 = load %runtime.Type_Info*, %runtime.Type_Info** %274, align 8
	store %runtime.Type_Info* %275, %runtime.Type_Info** %25
	; IfStmt
	%276 = load %..string, %..string* %21, align 8
	%277 = extractvalue %..string %276, 1
	%278 = icmp sgt i64 %277, 0
	%279 = zext i1 %278 to i8
	%280 = trunc i8 %279 to i1
	br i1 %280, label %if.then-64, label %if.done-65

if.then-64:
	%281 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%282 = load %..string, %..string* %21, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %281, %..string %282, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%283 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %283, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$db, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-65

if.done-65:
	%284 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%285 = load %runtime.Type_Info*, %runtime.Type_Info** %25, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %284, %runtime.Type_Info* %285, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-60

for.index.done-66:
	; IfStmt
	%286 = load i64, i64* %20, align 8
	%287 = icmp ne i64 %286, 1
	%288 = zext i1 %287 to i8
	%289 = trunc i8 %288 to i1
	br i1 %289, label %if.then-67, label %if.done-68

if.then-67:
	%290 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %290, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$dc, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-68

if.done-68:
	br label %typeswitch.done-124

typeswitch.next-69:
	%291 = icmp eq i8 %61, 13
	br i1 %291, label %typeswitch.body-72, label %typeswitch.next-71

typeswitch.body-70:
	%292 = bitcast %..rawptr %62 to %runtime.Type_Info_Array*
	%293 = load %runtime.Type_Info_Array, %runtime.Type_Info_Array* %292, align 8
	store %runtime.Type_Info_Array %293, %runtime.Type_Info_Array* %26
	%294 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %294, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$dd, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%295 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%296 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %26, i64 0, i32 2
	%297 = load i64, i64* %296, align 8
	%298 = bitcast i64 %297 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %295, i64 %298, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%299 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %299, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$de, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%300 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%301 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %26, i64 0, i32 0
	%302 = load %runtime.Type_Info*, %runtime.Type_Info** %301, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %300, %runtime.Type_Info* %302, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-71:
	%303 = icmp eq i8 %61, 14
	br i1 %303, label %typeswitch.body-74, label %typeswitch.next-73

typeswitch.body-72:
	%304 = bitcast %..rawptr %62 to %runtime.Type_Info_Dynamic_Array*
	%305 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %304, align 8
	store %runtime.Type_Info_Dynamic_Array %305, %runtime.Type_Info_Dynamic_Array* %27
	%306 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %306, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$df, i64 0, i32 0), i64 9}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%307 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%308 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %27, i64 0, i32 0
	%309 = load %runtime.Type_Info*, %runtime.Type_Info** %308, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %307, %runtime.Type_Info* %309, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-73:
	%310 = icmp eq i8 %61, 19
	br i1 %310, label %typeswitch.body-76, label %typeswitch.next-75

typeswitch.body-74:
	%311 = bitcast %..rawptr %62 to %runtime.Type_Info_Slice*
	%312 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %311, align 8
	store %runtime.Type_Info_Slice %312, %runtime.Type_Info_Slice* %28
	%313 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %313, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$e0, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%314 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%315 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %28, i64 0, i32 0
	%316 = load %runtime.Type_Info*, %runtime.Type_Info** %315, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %314, %runtime.Type_Info* %316, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-75:
	%317 = icmp eq i8 %61, 16
	br i1 %317, label %typeswitch.body-78, label %typeswitch.next-77

typeswitch.body-76:
	%318 = bitcast %..rawptr %62 to %runtime.Type_Info_Map*
	%319 = load %runtime.Type_Info_Map, %runtime.Type_Info_Map* %318, align 8
	store %runtime.Type_Info_Map %319, %runtime.Type_Info_Map* %29
	%320 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %320, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$e1, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%321 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%322 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %29, i64 0, i32 0
	%323 = load %runtime.Type_Info*, %runtime.Type_Info** %322, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %321, %runtime.Type_Info* %323, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%324 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %324, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%325 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%326 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %29, i64 0, i32 1
	%327 = load %runtime.Type_Info*, %runtime.Type_Info** %326, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %325, %runtime.Type_Info* %327, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-77:
	%328 = icmp eq i8 %61, 17
	br i1 %328, label %typeswitch.body-91, label %typeswitch.next-90

typeswitch.body-78:
	%329 = bitcast %..rawptr %62 to %runtime.Type_Info_Struct*
	%330 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %329, align 8
	store %runtime.Type_Info_Struct %330, %runtime.Type_Info_Struct* %30
	%331 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %331, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$e2, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%332 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 4
	%333 = load i8, i8* %332, align 1
	%334 = trunc i8 %333 to i1
	br i1 %334, label %if.then-79, label %if.done-80

if.then-79:
	%335 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %335, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$e3, i64 0, i32 0), i64 8}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-80

if.done-80:
	; IfStmt
	; SelectorExpr
	%336 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 5
	%337 = load i8, i8* %336, align 1
	%338 = trunc i8 %337 to i1
	br i1 %338, label %if.then-81, label %if.done-82

if.then-81:
	%339 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %339, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$e4, i64 0, i32 0), i64 11}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-82

if.done-82:
	; IfStmt
	; SelectorExpr
	%340 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 6
	%341 = load i8, i8* %340, align 1
	%342 = trunc i8 %341 to i1
	br i1 %342, label %if.then-83, label %if.done-84

if.then-83:
	%343 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %343, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$e5, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%344 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%345 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%346 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %345, i64 0
	%347 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %346, i64 0, i32 1
	%348 = load i64, i64* %347, align 8
	%349 = bitcast i64 %348 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %344, i64 %349, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%350 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %350, i8 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-84

if.done-84:
	%351 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %351, i8 123, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; name
	%352 = bitcast %..string* %31 to %..rawptr
	%353 = call %..rawptr @mem.zero(%..rawptr %352, i64 16) noinline
	store %..string zeroinitializer, %..string* %31
	; i
	%354 = bitcast i64* %32 to %..rawptr
	%355 = call %..rawptr @mem.zero(%..rawptr %354, i64 8) noinline
	store i64 zeroinitializer, i64* %32
	; SelectorExpr
	%356 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 1
	%357 = load {%..string*, i64}, {%..string*, i64}* %356, align 8
	%358 = bitcast i64* %33 to %..rawptr
	%359 = call %..rawptr @mem.zero(%..rawptr %358, i64 8) noinline
	store i64 zeroinitializer, i64* %33
	%360 = extractvalue {%..string*, i64} %357, 1
	store i64 %360, i64* %33
	%361 = bitcast i64* %34 to %..rawptr
	%362 = call %..rawptr @mem.zero(%..rawptr %361, i64 8) noinline
	store i64 zeroinitializer, i64* %34
	store i64 -1, i64* %34
	br label %for.index.loop-85

for.index.loop-85:
	%363 = load i64, i64* %34, align 8
	%364 = add i64 %363, 1
	store i64 %364, i64* %34
	%365 = load i64, i64* %33, align 8
	%366 = icmp slt i64 %364, %365
	br i1 %366, label %for.index.body-86, label %for.index.done-89

for.index.body-86:
	%367 = load i64, i64* %34, align 8
	%368 = extractvalue {%..string*, i64} %357, 0
	%369 = getelementptr inbounds %..string, %..string* %368, i64 %367
	%370 = load %..string, %..string* %369, align 8
	store %..string %370, %..string* %31
	store i64 %367, i64* %32
	; IfStmt
	%371 = load i64, i64* %32, align 8
	%372 = icmp sgt i64 %371, 0
	%373 = zext i1 %372 to i8
	%374 = trunc i8 %373 to i1
	br i1 %374, label %if.then-87, label %if.done-88

if.then-87:
	%375 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %375, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$e6, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-88

if.done-88:
	%376 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%377 = load %..string, %..string* %31, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %376, %..string %377, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%378 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %378, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$e7, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%379 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; IndexExpr
	; SelectorExpr
	%380 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 0
	%381 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %380, align 8
	%382 = extractvalue {%runtime.Type_Info**, i64} %381, 0
	%383 = load i64, i64* %32, align 8
	%384 = extractvalue {%runtime.Type_Info**, i64} %381, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$e8, i64 0, i32 0), i64 53}, i64 349, i64 31, i64 %383, i64 %384)
	%385 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %382, i64 %383
	%386 = load %runtime.Type_Info*, %runtime.Type_Info** %385, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %379, %runtime.Type_Info* %386, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-85

for.index.done-89:
	%387 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %387, i8 125, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-90:
	%388 = icmp eq i8 %61, 18
	br i1 %388, label %typeswitch.body-100, label %typeswitch.next-99

typeswitch.body-91:
	%389 = bitcast %..rawptr %62 to %runtime.Type_Info_Union*
	%390 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %389, align 8
	store %runtime.Type_Info_Union %390, %runtime.Type_Info_Union* %35
	%391 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %391, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$e9, i64 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%392 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %35, i64 0, i32 3
	%393 = load i8, i8* %392, align 1
	%394 = trunc i8 %393 to i1
	br i1 %394, label %if.then-92, label %if.done-93

if.then-92:
	%395 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %395, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$ea, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%396 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%397 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%398 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %397, i64 0
	%399 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %398, i64 0, i32 1
	%400 = load i64, i64* %399, align 8
	%401 = bitcast i64 %400 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %396, i64 %401, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%402 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %402, i8 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-93

if.done-93:
	%403 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %403, i8 123, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; variant
	%404 = bitcast %runtime.Type_Info** %36 to %..rawptr
	%405 = call %..rawptr @mem.zero(%..rawptr %404, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %36
	; i
	%406 = bitcast i64* %37 to %..rawptr
	%407 = call %..rawptr @mem.zero(%..rawptr %406, i64 8) noinline
	store i64 zeroinitializer, i64* %37
	; SelectorExpr
	%408 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %35, i64 0, i32 0
	%409 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %408, align 8
	%410 = bitcast i64* %38 to %..rawptr
	%411 = call %..rawptr @mem.zero(%..rawptr %410, i64 8) noinline
	store i64 zeroinitializer, i64* %38
	%412 = extractvalue {%runtime.Type_Info**, i64} %409, 1
	store i64 %412, i64* %38
	%413 = bitcast i64* %39 to %..rawptr
	%414 = call %..rawptr @mem.zero(%..rawptr %413, i64 8) noinline
	store i64 zeroinitializer, i64* %39
	store i64 -1, i64* %39
	br label %for.index.loop-94

for.index.loop-94:
	%415 = load i64, i64* %39, align 8
	%416 = add i64 %415, 1
	store i64 %416, i64* %39
	%417 = load i64, i64* %38, align 8
	%418 = icmp slt i64 %416, %417
	br i1 %418, label %for.index.body-95, label %for.index.done-98

for.index.body-95:
	%419 = load i64, i64* %39, align 8
	%420 = extractvalue {%runtime.Type_Info**, i64} %409, 0
	%421 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %420, i64 %419
	%422 = load %runtime.Type_Info*, %runtime.Type_Info** %421, align 8
	store %runtime.Type_Info* %422, %runtime.Type_Info** %36
	store i64 %419, i64* %37
	; IfStmt
	%423 = load i64, i64* %37, align 8
	%424 = icmp sgt i64 %423, 0
	%425 = zext i1 %424 to i8
	%426 = trunc i8 %425 to i1
	br i1 %426, label %if.then-96, label %if.done-97

if.then-96:
	%427 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %427, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$eb, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-97

if.done-97:
	%428 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%429 = load %runtime.Type_Info*, %runtime.Type_Info** %36, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %428, %runtime.Type_Info* %429, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-94

for.index.done-98:
	%430 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %430, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$ec, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-99:
	%431 = icmp eq i8 %61, 20
	br i1 %431, label %typeswitch.body-107, label %typeswitch.next-106

typeswitch.body-100:
	%432 = bitcast %..rawptr %62 to %runtime.Type_Info_Enum*
	%433 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %432, align 8
	store %runtime.Type_Info_Enum %433, %runtime.Type_Info_Enum* %40
	%434 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %434, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$ed, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%435 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%436 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %40, i64 0, i32 0
	%437 = load %runtime.Type_Info*, %runtime.Type_Info** %436, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %435, %runtime.Type_Info* %437, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%438 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %438, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$ee, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; name
	%439 = bitcast %..string* %41 to %..rawptr
	%440 = call %..rawptr @mem.zero(%..rawptr %439, i64 16) noinline
	store %..string zeroinitializer, %..string* %41
	; i
	%441 = bitcast i64* %42 to %..rawptr
	%442 = call %..rawptr @mem.zero(%..rawptr %441, i64 8) noinline
	store i64 zeroinitializer, i64* %42
	; SelectorExpr
	%443 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %40, i64 0, i32 1
	%444 = load {%..string*, i64}, {%..string*, i64}* %443, align 8
	%445 = bitcast i64* %43 to %..rawptr
	%446 = call %..rawptr @mem.zero(%..rawptr %445, i64 8) noinline
	store i64 zeroinitializer, i64* %43
	%447 = extractvalue {%..string*, i64} %444, 1
	store i64 %447, i64* %43
	%448 = bitcast i64* %44 to %..rawptr
	%449 = call %..rawptr @mem.zero(%..rawptr %448, i64 8) noinline
	store i64 zeroinitializer, i64* %44
	store i64 -1, i64* %44
	br label %for.index.loop-101

for.index.loop-101:
	%450 = load i64, i64* %44, align 8
	%451 = add i64 %450, 1
	store i64 %451, i64* %44
	%452 = load i64, i64* %43, align 8
	%453 = icmp slt i64 %451, %452
	br i1 %453, label %for.index.body-102, label %for.index.done-105

for.index.body-102:
	%454 = load i64, i64* %44, align 8
	%455 = extractvalue {%..string*, i64} %444, 0
	%456 = getelementptr inbounds %..string, %..string* %455, i64 %454
	%457 = load %..string, %..string* %456, align 8
	store %..string %457, %..string* %41
	store i64 %454, i64* %42
	; IfStmt
	%458 = load i64, i64* %42, align 8
	%459 = icmp sgt i64 %458, 0
	%460 = zext i1 %459 to i8
	%461 = trunc i8 %460 to i1
	br i1 %461, label %if.then-103, label %if.done-104

if.then-103:
	%462 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %462, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$ef, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-104

if.done-104:
	%463 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%464 = load %..string, %..string* %41, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %463, %..string %464, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-101

for.index.done-105:
	%465 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %465, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$f0, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-106:
	%466 = icmp eq i8 %61, 21
	br i1 %466, label %typeswitch.body-116, label %typeswitch.next-115

typeswitch.body-107:
	%467 = bitcast %..rawptr %62 to %runtime.Type_Info_Bit_Field*
	%468 = load %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %467, align 8
	store %runtime.Type_Info_Bit_Field %468, %runtime.Type_Info_Bit_Field* %45
	%469 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %469, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$f1, i64 0, i32 0), i64 10}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%470 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%471 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %470, i64 0
	%472 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %471, i64 0, i32 1
	%473 = load i64, i64* %472, align 8
	%474 = icmp ne i64 %473, 1
	%475 = zext i1 %474 to i8
	%476 = trunc i8 %475 to i1
	br i1 %476, label %if.then-108, label %if.done-109

if.then-108:
	%477 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %477, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$f2, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%478 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%479 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%480 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %479, i64 0
	%481 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %480, i64 0, i32 1
	%482 = load i64, i64* %481, align 8
	%483 = bitcast i64 %482 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %478, i64 %483, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%484 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %484, i32 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-109

if.done-109:
	%485 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %485, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$f3, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; name
	%486 = bitcast %..string* %46 to %..rawptr
	%487 = call %..rawptr @mem.zero(%..rawptr %486, i64 16) noinline
	store %..string zeroinitializer, %..string* %46
	; i
	%488 = bitcast i64* %47 to %..rawptr
	%489 = call %..rawptr @mem.zero(%..rawptr %488, i64 8) noinline
	store i64 zeroinitializer, i64* %47
	; SelectorExpr
	%490 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %45, i64 0, i32 0
	%491 = load {%..string*, i64}, {%..string*, i64}* %490, align 8
	%492 = bitcast i64* %48 to %..rawptr
	%493 = call %..rawptr @mem.zero(%..rawptr %492, i64 8) noinline
	store i64 zeroinitializer, i64* %48
	%494 = extractvalue {%..string*, i64} %491, 1
	store i64 %494, i64* %48
	%495 = bitcast i64* %49 to %..rawptr
	%496 = call %..rawptr @mem.zero(%..rawptr %495, i64 8) noinline
	store i64 zeroinitializer, i64* %49
	store i64 -1, i64* %49
	br label %for.index.loop-110

for.index.loop-110:
	%497 = load i64, i64* %49, align 8
	%498 = add i64 %497, 1
	store i64 %498, i64* %49
	%499 = load i64, i64* %48, align 8
	%500 = icmp slt i64 %498, %499
	br i1 %500, label %for.index.body-111, label %for.index.done-114

for.index.body-111:
	%501 = load i64, i64* %49, align 8
	%502 = extractvalue {%..string*, i64} %491, 0
	%503 = getelementptr inbounds %..string, %..string* %502, i64 %501
	%504 = load %..string, %..string* %503, align 8
	store %..string %504, %..string* %46
	store i64 %501, i64* %47
	; IfStmt
	%505 = load i64, i64* %47, align 8
	%506 = icmp sgt i64 %505, 0
	%507 = zext i1 %506 to i8
	%508 = trunc i8 %507 to i1
	br i1 %508, label %if.then-112, label %if.done-113

if.then-112:
	%509 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %509, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$f4, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-113

if.done-113:
	%510 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%511 = load %..string, %..string* %46, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %510, %..string %511, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%512 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %512, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$f5, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%513 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; IndexExpr
	; SelectorExpr
	%514 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %45, i64 0, i32 1
	%515 = load {i32*, i64}, {i32*, i64}* %514, align 8
	%516 = extractvalue {i32*, i64} %515, 0
	%517 = load i64, i64* %47, align 8
	%518 = extractvalue {i32*, i64} %515, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$f6, i64 0, i32 0), i64 53}, i64 389, i64 33, i64 %517, i64 %518)
	%519 = getelementptr inbounds i32, i32* %516, i64 %517
	%520 = load i32, i32* %519, align 4
	%521 = sext i32 %520 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %513, i64 %521, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-110

for.index.done-114:
	%522 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %522, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$f7, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-115:
	br label %typeswitch.done-124

typeswitch.body-116:
	%523 = bitcast %..rawptr %62 to %runtime.Type_Info_Bit_Set*
	%524 = load %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %523, align 8
	store %runtime.Type_Info_Bit_Set %524, %runtime.Type_Info_Bit_Set* %50
	%525 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %525, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$f8, i64 0, i32 0), i64 8}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SwitchStmt
	; SelectorExpr
	; SelectorExpr
	%526 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 0
	%527 = load %runtime.Type_Info*, %runtime.Type_Info** %526, align 8
	%528 = call i8 @types.is_enum(%runtime.Type_Info* %527, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%529 = icmp eq i8 1, %528
	br i1 %529, label %switch.case.body-118, label %switch.case.next-117

switch.case.next-117:
	; SelectorExpr
	; SelectorExpr
	%530 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 0
	%531 = load %runtime.Type_Info*, %runtime.Type_Info** %530, align 8
	%532 = call i8 @types.is_rune(%runtime.Type_Info* %531, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%533 = icmp eq i8 1, %532
	br i1 %533, label %switch.fall.body-120, label %switch.case.next-119

switch.case.body-118:
	%534 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%535 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 0
	%536 = load %runtime.Type_Info*, %runtime.Type_Info** %535, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %534, %runtime.Type_Info* %536, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-121

switch.case.next-119:
	%537 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%538 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 2
	%539 = load i64, i64* %538, align 8
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %537, i64 %539, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%540 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %540, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$f9, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%541 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%542 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 3
	%543 = load i64, i64* %542, align 8
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %541, i64 %543, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-121

switch.fall.body-120:
	%544 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%545 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 2
	%546 = load i64, i64* %545, align 8
	%547 = trunc i64 %546 to i32
	call void @fmt.write_encoded_rune({i8*, i64, i64, %mem.Allocator}* %544, i32 %547, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%548 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %548, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$fa, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%549 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%550 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 3
	%551 = load i64, i64* %550, align 8
	%552 = trunc i64 %551 to i32
	call void @fmt.write_encoded_rune({i8*, i64, i64, %mem.Allocator}* %549, i32 %552, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-121

switch.done-121:
	; IfStmt
	; SelectorExpr
	%553 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 1
	%554 = load %runtime.Type_Info*, %runtime.Type_Info** %553, align 8
	%555 = icmp ne %runtime.Type_Info* %554, zeroinitializer
	%556 = zext i1 %555 to i8
	%557 = trunc i8 %556 to i1
	br i1 %557, label %if.then-122, label %if.done-123

if.then-122:
	%558 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %558, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$fb, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%559 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%560 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 1
	%561 = load %runtime.Type_Info*, %runtime.Type_Info** %560, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %559, %runtime.Type_Info* %561, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-123

if.done-123:
	%562 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %562, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.done-124:
	ret void
}

define {i64, i64, i8} @fmt._parse_int(%..string %s, i64 %offset, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i8, align 16
	%5 = alloca i8, align 16
	%6 = alloca {i64, i64, i8}, align 16
	store %..string %s, %..string* %0
	store i64 %offset, i64* %1
	%7 = bitcast i64* %2 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	%9 = bitcast i64* %3 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%11 = bitcast i8* %4 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 1) noinline
	store i8 zeroinitializer, i8* %4
	; AssignStmt
	%13 = load i64, i64* %1, align 8
	store i64 %13, i64* %3
	; ForStmt
	br label %for.loop-1

for.loop-1:
	%14 = load i64, i64* %3, align 8
	%15 = load %..string, %..string* %0, align 8
	%16 = extractvalue %..string %15, 1
	%17 = icmp sle i64 %14, %16
	%18 = zext i1 %17 to i8
	%19 = trunc i8 %18 to i1
	br i1 %19, label %for.body-2, label %for.done-5

for.body-2:
	; c
	; IndexExpr
	%20 = load %..string, %..string* %0, align 8
	%21 = extractvalue %..string %20, 0
	%22 = extractvalue %..string %20, 1
	%23 = load i64, i64* %3, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$fc, i64 0, i32 0), i64 53}, i64 421, i64 10, i64 %23, i64 %22)
	%24 = getelementptr inbounds i8, i8* %21, i64 %23
	%25 = load i8, i8* %24, align 1
	store i8 %25, i8* %5
	; IfStmt
	%26 = load i8, i8* %5, align 1
	%27 = call i8 @fmt._parse_int.is_digit-0(i8 %26, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%28 = trunc i8 %27 to i1
	br i1 %28, label %if.done-4, label %if.then-3

if.then-3:
	; break
	br label %for.done-5

if.done-4:
	; AssignStmt
	%29 = load i64, i64* %3, align 8
	%30 = add i64 %29, 1
	store i64 %30, i64* %3
	; AssignStmt
	%31 = load i64, i64* %2, align 8
	%32 = mul i64 %31, 10
	store i64 %32, i64* %2
	; AssignStmt
	%33 = load i8, i8* %5, align 1
	%34 = zext i8 %33 to i64
	%35 = sub i64 %34, 48
	%36 = load i64, i64* %2, align 8
	%37 = add i64 %36, %35
	store i64 %37, i64* %2
	br label %for.loop-1

for.done-5:
	; AssignStmt
	%38 = load i64, i64* %3, align 8
	%39 = load i64, i64* %1, align 8
	%40 = icmp sgt i64 %38, %39
	%41 = zext i1 %40 to i8
	store i8 %41, i8* %4
	; ReturnStmt
	%42 = load i64, i64* %2, align 8
	%43 = load i64, i64* %3, align 8
	%44 = load i8, i8* %4, align 1
	%45 = bitcast {i64, i64, i8}* %6 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 24) noinline
	store {i64, i64, i8} zeroinitializer, {i64, i64, i8}* %6
	%47 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %6, i64 0, i32 0
	store i64 %42, i64* %47
	%48 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %6, i64 0, i32 1
	store i64 %43, i64* %48
	%49 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %6, i64 0, i32 2
	store i8 %44, i8* %49
	%50 = load {i64, i64, i8}, {i64, i64, i8}* %6, align 8
	ret {i64, i64, i8} %50
}

define i8 @fmt._parse_int.is_digit-0(i8 %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i8, align 16
	store i8 %r, i8* %0
	; ReturnStmt
	%1 = load i8, i8* %0, align 1
	%2 = icmp ule i8 48, %1
	%3 = zext i1 %2 to i8
	%4 = load i8, i8* %0, align 1
	%5 = icmp ule i8 48, %4
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %logical.cmp.rhs-1, label %logical.cmp.done-2

logical.cmp.rhs-1:
	%8 = load i8, i8* %0, align 1
	%9 = icmp ule i8 %8, 57
	%10 = zext i1 %9 to i8
	br label %logical.cmp.done-2

logical.cmp.done-2:
	%11 = phi i8 [ 0, %decls-0 ], [ %10, %logical.cmp.rhs-1 ]
	ret i8 %11
}

define {i64, i64, i8} @fmt._arg_number(%fmt.Fmt_Info* %fi, i64 %arg_index, %..string %format, i64 %offset, i64 %arg_count, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i8, align 16
	%8 = alloca {i64, i64, i8}, align 16
	%9 = alloca i64, align 16
	%10 = alloca %..string, align 16
	%11 = alloca {i64, i64, i8}, align 16
	%12 = alloca {i64, i64, i8}, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store i64 %arg_index, i64* %1
	store %..string %format, %..string* %2
	store i64 %offset, i64* %3
	store i64 %arg_count, i64* %4
	%13 = bitcast i64* %5 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	%15 = bitcast i64* %6 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 8) noinline
	store i64 zeroinitializer, i64* %6
	%17 = bitcast i8* %7 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 1) noinline
	store i8 zeroinitializer, i8* %7
	; IfStmt
	%19 = load %..string, %..string* %2, align 8
	%20 = extractvalue %..string %19, 1
	%21 = load i64, i64* %3, align 8
	%22 = icmp sle i64 %20, %21
	%23 = zext i1 %22 to i8
	%24 = trunc i8 %23 to i1
	br i1 %24, label %if.then-2, label %cmp.or-1

cmp.or-1:
	; IndexExpr
	%25 = load %..string, %..string* %2, align 8
	%26 = extractvalue %..string %25, 0
	%27 = extractvalue %..string %25, 1
	%28 = load i64, i64* %3, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$fd, i64 0, i32 0), i64 53}, i64 450, i64 37, i64 %28, i64 %27)
	%29 = getelementptr inbounds i8, i8* %26, i64 %28
	%30 = load i8, i8* %29, align 1
	%31 = icmp ne i8 %30, 91
	%32 = zext i1 %31 to i8
	%33 = trunc i8 %32 to i1
	br i1 %33, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	%34 = load i64, i64* %1, align 8
	%35 = load i64, i64* %3, align 8
	%36 = bitcast {i64, i64, i8}* %8 to %..rawptr
	%37 = call %..rawptr @mem.zero(%..rawptr %36, i64 24) noinline
	store {i64, i64, i8} zeroinitializer, {i64, i64, i8}* %8
	%38 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %8, i64 0, i32 0
	store i64 %34, i64* %38
	%39 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %8, i64 0, i32 1
	store i64 %35, i64* %39
	%40 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %8, i64 0, i32 2
	store i8 0, i8* %40
	%41 = load {i64, i64, i8}, {i64, i64, i8}* %8, align 8
	ret {i64, i64, i8} %41

if.done-3:
	; AssignStmt
	; SelectorExpr
	%42 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%43 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %42, i64 0
	%44 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %43, i64 0, i32 10
	store i8 1, i8* %44
	; width
	%45 = bitcast i64* %9 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 8) noinline
	store i64 zeroinitializer, i64* %9
	; AssignStmt
	; SliceExpr
	%47 = load i64, i64* %3, align 8
	%48 = load %..string, %..string* %2, align 8
	%49 = extractvalue %..string %48, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$fe, i64 0, i32 0), i64 53}, i64 456, i64 44, i64 %47, i64 %49, i64 %49)
	%50 = extractvalue %..string %48, 0
	%51 = getelementptr inbounds i8, i8* %50, i64 %47
	%52 = sub i64 %49, %47
	%53 = bitcast %..string* %10 to %..rawptr
	%54 = call %..rawptr @mem.zero(%..rawptr %53, i64 16) noinline
	store %..string zeroinitializer, %..string* %10
	%55 = getelementptr inbounds %..string, %..string* %10, i64 0, i32 0
	store i8* %51, i8** %55
	%56 = getelementptr inbounds %..string, %..string* %10, i64 0, i32 1
	store i64 %52, i64* %56
	%57 = load %..string, %..string* %10, align 8
	%58 = call {i64, i64, i8} @fmt._arg_number.parse_arg_number-0(%..string %57, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%59 = extractvalue {i64, i64, i8} %58, 0
	%60 = extractvalue {i64, i64, i8} %58, 1
	%61 = extractvalue {i64, i64, i8} %58, 2
	store i64 %59, i64* %5
	store i64 %60, i64* %9
	store i8 %61, i8* %7
	; IfStmt
	%62 = load i8, i8* %7, align 1
	%63 = trunc i8 %62 to i1
	br i1 %63, label %cmp.and-4, label %if.done-7

cmp.and-4:
	%64 = load i64, i64* %5, align 8
	%65 = icmp sle i64 0, %64
	%66 = zext i1 %65 to i8
	%67 = trunc i8 %66 to i1
	br i1 %67, label %cmp.and-5, label %if.done-7

cmp.and-5:
	%68 = load i64, i64* %5, align 8
	%69 = load i64, i64* %4, align 8
	%70 = icmp slt i64 %68, %69
	%71 = zext i1 %70 to i8
	%72 = trunc i8 %71 to i1
	br i1 %72, label %if.then-6, label %if.done-7

if.then-6:
	; ReturnStmt
	%73 = load i64, i64* %5, align 8
	%74 = load i64, i64* %3, align 8
	%75 = load i64, i64* %9, align 8
	%76 = add i64 %74, %75
	%77 = bitcast {i64, i64, i8}* %11 to %..rawptr
	%78 = call %..rawptr @mem.zero(%..rawptr %77, i64 24) noinline
	store {i64, i64, i8} zeroinitializer, {i64, i64, i8}* %11
	%79 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %11, i64 0, i32 0
	store i64 %73, i64* %79
	%80 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %11, i64 0, i32 1
	store i64 %76, i64* %80
	%81 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %11, i64 0, i32 2
	store i8 1, i8* %81
	%82 = load {i64, i64, i8}, {i64, i64, i8}* %11, align 8
	ret {i64, i64, i8} %82

if.done-7:
	; AssignStmt
	; SelectorExpr
	%83 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%84 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %83, i64 0
	%85 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %84, i64 0, i32 11
	store i8 0, i8* %85
	; ReturnStmt
	%86 = load i64, i64* %1, align 8
	%87 = load i64, i64* %3, align 8
	%88 = load i64, i64* %9, align 8
	%89 = add i64 %87, %88
	%90 = bitcast {i64, i64, i8}* %12 to %..rawptr
	%91 = call %..rawptr @mem.zero(%..rawptr %90, i64 24) noinline
	store {i64, i64, i8} zeroinitializer, {i64, i64, i8}* %12
	%92 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %12, i64 0, i32 0
	store i64 %86, i64* %92
	%93 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %12, i64 0, i32 1
	store i64 %89, i64* %93
	%94 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %12, i64 0, i32 2
	store i8 0, i8* %94
	%95 = load {i64, i64, i8}, {i64, i64, i8}* %12, align 8
	ret {i64, i64, i8} %95
}

define {i64, i64, i8} @fmt._arg_number.parse_arg_number-0(%..string %format, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca {i64, i64, i8}, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i8, align 16
	%8 = alloca {i64, i64, i8}, align 16
	%9 = alloca {i64, i64, i8}, align 16
	%10 = alloca {i64, i64, i8}, align 16
	store %..string %format, %..string* %0
	; IfStmt
	%11 = load %..string, %..string* %0, align 8
	%12 = extractvalue %..string %11, 1
	%13 = icmp slt i64 %12, 3
	%14 = zext i1 %13 to i8
	%15 = trunc i8 %14 to i1
	br i1 %15, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%16 = bitcast {i64, i64, i8}* %1 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 24) noinline
	store {i64, i64, i8} zeroinitializer, {i64, i64, i8}* %1
	%18 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %1, i64 0, i32 0
	store i64 0, i64* %18
	%19 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %1, i64 0, i32 1
	store i64 1, i64* %19
	%20 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %1, i64 0, i32 2
	store i8 0, i8* %20
	%21 = load {i64, i64, i8}, {i64, i64, i8}* %1, align 8
	ret {i64, i64, i8} %21

if.done-2:
	; RangeStmt
	; i
	%22 = bitcast i64* %2 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	%24 = bitcast i64* %3 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	store i64 1, i64* %3
	%26 = bitcast i64* %4 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 0, i64* %4
	br label %for.interval.loop-3

for.interval.loop-3:
	%28 = load %..string, %..string* %0, align 8
	%29 = extractvalue %..string %28, 1
	%30 = sub i64 %29, 1
	%31 = load i64, i64* %3, align 8
	%32 = icmp sle i64 %31, %30
	br i1 %32, label %for.interval.body-4, label %for.interval.done-10

for.interval.body-4:
	%33 = load i64, i64* %3, align 8
	%34 = load i64, i64* %4, align 8
	%35 = load i64, i64* %3, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %3
	%37 = load i64, i64* %4, align 8
	%38 = add i64 %37, 1
	store i64 %38, i64* %4
	store i64 %33, i64* %2
	; IfStmt
	; IndexExpr
	%39 = load %..string, %..string* %0, align 8
	%40 = extractvalue %..string %39, 0
	%41 = extractvalue %..string %39, 1
	%42 = load i64, i64* %2, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$ff, i64 0, i32 0), i64 53}, i64 437, i64 14, i64 %42, i64 %41)
	%43 = getelementptr inbounds i8, i8* %40, i64 %42
	%44 = load i8, i8* %43, align 1
	%45 = icmp eq i8 %44, 93
	%46 = zext i1 %45 to i8
	%47 = trunc i8 %46 to i1
	br i1 %47, label %if.then-5, label %if.done-9

if.then-5:
	; width
	; new_index
	; ok
	%48 = load %..string, %..string* %0, align 8
	%49 = call {i64, i64, i8} @fmt._parse_int(%..string %48, i64 1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%50 = extractvalue {i64, i64, i8} %49, 0
	%51 = extractvalue {i64, i64, i8} %49, 1
	%52 = extractvalue {i64, i64, i8} %49, 2
	store i64 %50, i64* %5
	store i64 %51, i64* %6
	store i8 %52, i8* %7
	; IfStmt
	%53 = load i8, i8* %7, align 1
	%54 = trunc i8 %53 to i1
	br i1 %54, label %cmp.or-6, label %if.then-7

cmp.or-6:
	%55 = load i64, i64* %6, align 8
	%56 = load i64, i64* %2, align 8
	%57 = icmp ne i64 %55, %56
	%58 = zext i1 %57 to i8
	%59 = trunc i8 %58 to i1
	br i1 %59, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	%60 = load i64, i64* %2, align 8
	%61 = add i64 %60, 1
	%62 = bitcast {i64, i64, i8}* %8 to %..rawptr
	%63 = call %..rawptr @mem.zero(%..rawptr %62, i64 24) noinline
	store {i64, i64, i8} zeroinitializer, {i64, i64, i8}* %8
	%64 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %8, i64 0, i32 0
	store i64 0, i64* %64
	%65 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %8, i64 0, i32 1
	store i64 %61, i64* %65
	%66 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %8, i64 0, i32 2
	store i8 0, i8* %66
	%67 = load {i64, i64, i8}, {i64, i64, i8}* %8, align 8
	ret {i64, i64, i8} %67

if.done-8:
	; ReturnStmt
	%68 = load i64, i64* %5, align 8
	%69 = sub i64 %68, 1
	%70 = load i64, i64* %2, align 8
	%71 = add i64 %70, 1
	%72 = bitcast {i64, i64, i8}* %9 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 24) noinline
	store {i64, i64, i8} zeroinitializer, {i64, i64, i8}* %9
	%74 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %9, i64 0, i32 0
	store i64 %69, i64* %74
	%75 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %9, i64 0, i32 1
	store i64 %71, i64* %75
	%76 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %9, i64 0, i32 2
	store i8 1, i8* %76
	%77 = load {i64, i64, i8}, {i64, i64, i8}* %9, align 8
	ret {i64, i64, i8} %77

if.done-9:
	br label %for.interval.loop-3

for.interval.done-10:
	; ReturnStmt
	%78 = bitcast {i64, i64, i8}* %10 to %..rawptr
	%79 = call %..rawptr @mem.zero(%..rawptr %78, i64 24) noinline
	store {i64, i64, i8} zeroinitializer, {i64, i64, i8}* %10
	%80 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %10, i64 0, i32 0
	store i64 0, i64* %80
	%81 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %10, i64 0, i32 1
	store i64 1, i64* %81
	%82 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %10, i64 0, i32 2
	store i8 0, i8* %82
	%83 = load {i64, i64, i8}, {i64, i64, i8}* %10, align 8
	ret {i64, i64, i8} %83
}

define {i64, i64, i8} @fmt.int_from_arg({%..any*, i64}* %args, i64 %arg_index, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i8, align 16
	%4 = alloca %..any, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca i16, align 16
	%8 = alloca i32, align 16
	%9 = alloca i64, align 16
	%10 = alloca i8, align 16
	%11 = alloca i16, align 16
	%12 = alloca i32, align 16
	%13 = alloca i64, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {i64, i64, i8}, align 16
	%16 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	store i64 %arg_index, i64* %0
	; num
	store i64 0, i64* %1
	; new_arg_index
	%17 = load i64, i64* %0, align 8
	store i64 %17, i64* %2
	; ok
	store i8 1, i8* %3
	; IfStmt
	%18 = load i64, i64* %0, align 8
	%19 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%20 = extractvalue {%..any*, i64} %19, 1
	%21 = icmp slt i64 %18, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.done-21

if.then-1:
	; arg
	; IndexExpr
	%24 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%25 = extractvalue {%..any*, i64} %24, 0
	%26 = load i64, i64* %0, align 8
	%27 = extractvalue {%..any*, i64} %24, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$100, i64 0, i32 0), i64 53}, i64 469, i64 15, i64 %26, i64 %27)
	%28 = getelementptr inbounds %..any, %..any* %25, i64 %26
	%29 = load %..any, %..any* %28, align 8
	store %..any %29, %..any* %4
	; AssignStmt
	; SelectorExpr
	%30 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	; SelectorExpr
	; SelectorExpr
	%31 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	%32 = load %..typeid, %..typeid* %31, align 8
	%33 = call %..typeid @runtime.typeid_base(%..typeid %32)
	store %..typeid %33, %..typeid* %30
	; TypeSwitchStmt
	%34 = load %..any, %..any* %4, align 8
	%35 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	%36 = load %..typeid, %..typeid* %35, align 8
	%37 = icmp eq %..typeid %36, 4683743612465315846
	br i1 %37, label %typeswitch.body-3, label %typeswitch.next-2

typeswitch.next-2:
	%38 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	%39 = load %..typeid, %..typeid* %38, align 8
	%40 = icmp eq %..typeid %39, 4683743612465315902
	br i1 %40, label %typeswitch.body-5, label %typeswitch.next-4

typeswitch.body-3:
	%41 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	%42 = load %..rawptr, %..rawptr* %41, align 8
	%43 = bitcast %..rawptr %42 to i64*
	%44 = load i64, i64* %43, align 8
	store i64 %44, i64* %5
	; AssignStmt
	%45 = load i64, i64* %5, align 8
	store i64 %45, i64* %1
	br label %typeswitch.done-20

typeswitch.next-4:
	%46 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	%47 = load %..typeid, %..typeid* %46, align 8
	%48 = icmp eq %..typeid %47, 4683743612465315903
	br i1 %48, label %typeswitch.body-7, label %typeswitch.next-6

typeswitch.body-5:
	%49 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	%50 = load %..rawptr, %..rawptr* %49, align 8
	%51 = bitcast %..rawptr %50 to i8*
	%52 = load i8, i8* %51, align 1
	store i8 %52, i8* %6
	; AssignStmt
	%53 = load i8, i8* %6, align 1
	%54 = sext i8 %53 to i64
	store i64 %54, i64* %1
	br label %typeswitch.done-20

typeswitch.next-6:
	%55 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	%56 = load %..typeid, %..typeid* %55, align 8
	%57 = icmp eq %..typeid %56, 4683743612465315848
	br i1 %57, label %typeswitch.body-9, label %typeswitch.next-8

typeswitch.body-7:
	%58 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	%59 = load %..rawptr, %..rawptr* %58, align 8
	%60 = bitcast %..rawptr %59 to i16*
	%61 = load i16, i16* %60, align 2
	store i16 %61, i16* %7
	; AssignStmt
	%62 = load i16, i16* %7, align 2
	%63 = sext i16 %62 to i64
	store i64 %63, i64* %1
	br label %typeswitch.done-20

typeswitch.next-8:
	%64 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	%65 = load %..typeid, %..typeid* %64, align 8
	%66 = icmp eq %..typeid %65, 4683743612465315904
	br i1 %66, label %typeswitch.body-11, label %typeswitch.next-10

typeswitch.body-9:
	%67 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	%68 = load %..rawptr, %..rawptr* %67, align 8
	%69 = bitcast %..rawptr %68 to i32*
	%70 = load i32, i32* %69, align 4
	store i32 %70, i32* %8
	; AssignStmt
	%71 = load i32, i32* %8, align 4
	%72 = sext i32 %71 to i64
	store i64 %72, i64* %1
	br label %typeswitch.done-20

typeswitch.next-10:
	%73 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	%74 = load %..typeid, %..typeid* %73, align 8
	%75 = icmp eq %..typeid %74, 72057594037927939
	br i1 %75, label %typeswitch.body-13, label %typeswitch.next-12

typeswitch.body-11:
	%76 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	%77 = load %..rawptr, %..rawptr* %76, align 8
	%78 = bitcast %..rawptr %77 to i64*
	%79 = load i64, i64* %78, align 8
	store i64 %79, i64* %9
	; AssignStmt
	%80 = load i64, i64* %9, align 8
	%81 = bitcast i64 %80 to i64
	store i64 %81, i64* %1
	br label %typeswitch.done-20

typeswitch.next-12:
	%82 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	%83 = load %..typeid, %..typeid* %82, align 8
	%84 = icmp eq %..typeid %83, 72057594037928001
	br i1 %84, label %typeswitch.body-15, label %typeswitch.next-14

typeswitch.body-13:
	%85 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	%86 = load %..rawptr, %..rawptr* %85, align 8
	%87 = bitcast %..rawptr %86 to i8*
	%88 = load i8, i8* %87, align 1
	store i8 %88, i8* %10
	; AssignStmt
	%89 = load i8, i8* %10, align 1
	%90 = zext i8 %89 to i64
	store i64 %90, i64* %1
	br label %typeswitch.done-20

typeswitch.next-14:
	%91 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	%92 = load %..typeid, %..typeid* %91, align 8
	%93 = icmp eq %..typeid %92, 72057594037928002
	br i1 %93, label %typeswitch.body-17, label %typeswitch.next-16

typeswitch.body-15:
	%94 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	%95 = load %..rawptr, %..rawptr* %94, align 8
	%96 = bitcast %..rawptr %95 to i16*
	%97 = load i16, i16* %96, align 2
	store i16 %97, i16* %11
	; AssignStmt
	%98 = load i16, i16* %11, align 2
	%99 = zext i16 %98 to i64
	store i64 %99, i64* %1
	br label %typeswitch.done-20

typeswitch.next-16:
	%100 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	%101 = load %..typeid, %..typeid* %100, align 8
	%102 = icmp eq %..typeid %101, 72057594037927943
	br i1 %102, label %typeswitch.body-19, label %typeswitch.next-18

typeswitch.body-17:
	%103 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	%104 = load %..rawptr, %..rawptr* %103, align 8
	%105 = bitcast %..rawptr %104 to i32*
	%106 = load i32, i32* %105, align 4
	store i32 %106, i32* %12
	; AssignStmt
	%107 = load i32, i32* %12, align 4
	%108 = zext i32 %107 to i64
	store i64 %108, i64* %1
	br label %typeswitch.done-20

typeswitch.next-18:
	store %..any %34, %..any* %14
	; AssignStmt
	store i8 0, i8* %3
	br label %typeswitch.done-20

typeswitch.body-19:
	%109 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	%110 = load %..rawptr, %..rawptr* %109, align 8
	%111 = bitcast %..rawptr %110 to i64*
	%112 = load i64, i64* %111, align 8
	store i64 %112, i64* %13
	; AssignStmt
	%113 = load i64, i64* %13, align 8
	%114 = bitcast i64 %113 to i64
	store i64 %114, i64* %1
	br label %typeswitch.done-20

typeswitch.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%115 = load i64, i64* %1, align 8
	%116 = load i64, i64* %2, align 8
	%117 = load i8, i8* %3, align 1
	%118 = bitcast {i64, i64, i8}* %15 to %..rawptr
	%119 = call %..rawptr @mem.zero(%..rawptr %118, i64 24) noinline
	store {i64, i64, i8} zeroinitializer, {i64, i64, i8}* %15
	%120 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %15, i64 0, i32 0
	store i64 %115, i64* %120
	%121 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %15, i64 0, i32 1
	store i64 %116, i64* %121
	%122 = getelementptr inbounds {i64, i64, i8}, {i64, i64, i8}* %15, i64 0, i32 2
	store i8 %117, i8* %122
	%123 = load {i64, i64, i8}, {i64, i64, i8}* %15, align 8
	ret {i64, i64, i8} %123
}

define void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %fi, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i32, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store i32 %verb, i32* %1
	%2 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%3 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0
	%4 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %3, i64 0, i32 12
	%5 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %4, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %5, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$101, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%6 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%7 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %6, i64 0
	%8 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %7, i64 0, i32 12
	%9 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %8, align 8
	%10 = load i32, i32* %1, align 4
	call void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %9, i32 %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%12 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %11, i64 0
	%13 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %12, i64 0, i32 12
	%14 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %13, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %14, i8 40, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%15 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%16 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %15, i64 0
	%17 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %16, i64 0, i32 13
	%18 = getelementptr inbounds %..any, %..any* %17, i64 0, i32 1
	%19 = load %..typeid, %..typeid* %18, align 8
	%20 = icmp ne %..typeid %19, 0
	%21 = zext i1 %20 to i8
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.else-2

if.then-1:
	%23 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%24 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %23, i64 0
	%25 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %24, i64 0, i32 12
	%26 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %25, align 8
	; SelectorExpr
	%27 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%28 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %27, i64 0
	%29 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %28, i64 0, i32 13
	%30 = getelementptr inbounds %..any, %..any* %29, i64 0, i32 1
	%31 = load %..typeid, %..typeid* %30, align 8
	call void @fmt.write_typeid({i8*, i64, i64, %mem.Allocator}* %26, %..typeid %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%32 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%33 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %32, i64 0
	%34 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %33, i64 0, i32 12
	%35 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %34, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %35, i8 61, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%36 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%37 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%38 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %37, i64 0
	%39 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %38, i64 0, i32 13
	%40 = load %..any, %..any* %39, align 8
	call void @fmt.fmt_value(%fmt.Fmt_Info* %36, %..any %40, i32 118, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-3

if.else-2:
	%41 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%42 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %41, i64 0
	%43 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %42, i64 0, i32 12
	%44 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %43, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %44, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$102, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-3

if.done-3:
	%45 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%46 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %45, i64 0
	%47 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %46, i64 0, i32 12
	%48 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %47, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %48, i8 41, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.fmt_bool(%fmt.Fmt_Info* %fi, i1 %b, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i8, align 16
	%2 = alloca i32, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	%3 = zext i1 %b to i8
	store i8 %3, i8* %1
	store i32 %verb, i32* %2
	; SwitchStmt
	%4 = load i32, i32* %2, align 4
	%5 = icmp eq i32 %4, 116
	br i1 %5, label %switch.case.body-3, label %switch.case.next-1

switch.case.next-1:
	%6 = icmp eq i32 %4, 118
	br i1 %6, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%7 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%8 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %7, i32 %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-7

switch.case.body-3:
	%9 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%10 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %9, i64 0
	%11 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %10, i64 0, i32 12
	%12 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %11, align 8
	; TernaryExpr
	%13 = load i8, i8* %1, align 1
	%14 = trunc i8 %13 to i1
	br i1 %14, label %if.then-4, label %if.else-5

if.then-4:
	br label %if.done-6

if.else-5:
	br label %if.done-6

if.done-6:
	%15 = phi %..string [ {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$103, i64 0, i32 0), i64 4}, %if.then-4 ], [ {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$104, i64 0, i32 0), i64 5}, %if.else-5 ]
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %12, %..string %15, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-7

switch.done-7:
	ret void
}

define void @fmt.fmt_write_padding(%fmt.Fmt_Info* %fi, i64 %width, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store i64 %width, i64* %1
	; IfStmt
	%5 = load i64, i64* %1, align 8
	%6 = icmp sle i64 %5, 0
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	br i1 %8, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; pad_byte
	store i8 48, i8* %2
	; IfStmt
	; SelectorExpr
	%9 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%10 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %9, i64 0
	%11 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %10, i64 0, i32 2
	%12 = load i8, i8* %11, align 1
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-3, label %if.done-4

if.then-3:
	; AssignStmt
	store i8 32, i8* %2
	br label %if.done-4

if.done-4:
	; RangeStmt
	%14 = bitcast i64* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	store i64 0, i64* %3
	%16 = bitcast i64* %4 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 0, i64* %4
	br label %for.interval.loop-5

for.interval.loop-5:
	%18 = load i64, i64* %1, align 8
	%19 = sub i64 %18, 1
	%20 = load i64, i64* %3, align 8
	%21 = icmp sle i64 %20, %19
	br i1 %21, label %for.interval.body-6, label %for.interval.done-7

for.interval.body-6:
	%22 = load i64, i64* %3, align 8
	%23 = load i64, i64* %4, align 8
	%24 = load i64, i64* %3, align 8
	%25 = add i64 %24, 1
	store i64 %25, i64* %3
	%26 = load i64, i64* %4, align 8
	%27 = add i64 %26, 1
	store i64 %27, i64* %4
	; SelectorExpr
	%28 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%29 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %28, i64 0
	%30 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %29, i64 0, i32 12
	%31 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %30, align 8
	%32 = load i8, i8* %2, align 1
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %31, i8 %32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-5

for.interval.done-7:
	ret void
}

define void @fmt._fmt_int(%fmt.Fmt_Info* %fi, i64 %u, i64 %base, i1 %is_signed, i64 %bit_size, %..string %digits, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i8, align 16
	%4 = alloca i64, align 16
	%5 = alloca %..string, align 16
	%6 = alloca i8, align 16
	%7 = alloca i64, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	%9 = alloca i64, align 16
	%10 = alloca i8, align 16
	%11 = alloca %runtime.Source_Code_Location, align 16
	%12 = alloca [256 x i8], align 16
	%13 = alloca i64, align 16
	%14 = alloca i8, align 16
	%15 = alloca %..string, align 16
	%16 = alloca {i8*, i64}, align 16
	%17 = alloca {i8*, i64}, align 16
	%18 = alloca i8, align 16
	%19 = alloca i8, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store i64 %u, i64* %1
	store i64 %base, i64* %2
	%20 = zext i1 %is_signed to i8
	store i8 %20, i8* %3
	store i64 %bit_size, i64* %4
	store %..string %digits, %..string* %5
	; neg
	; SelectorExpr
	%21 = load i64, i64* %1, align 8
	%22 = load i8, i8* %3, align 1
	%23 = load i64, i64* %4, align 8
	%24 = trunc i8 %22 to i1
	%25 = call {i64, i8} @strconv.is_integer_negative(i64 %21, i1 %24, i64 %23, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%26 = extractvalue {i64, i8} %25, 0
	%27 = extractvalue {i64, i8} %25, 1
	store i8 %27, i8* %6
	; IfStmt
	; SelectorExpr
	%28 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%29 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %28, i64 0
	%30 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %29, i64 0, i32 5
	%31 = load i8, i8* %30, align 1
	%32 = trunc i8 %31 to i1
	br i1 %32, label %if.then-2, label %cmp.or-1

cmp.or-1:
	; SelectorExpr
	%33 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%34 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %33, i64 0
	%35 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %34, i64 0, i32 6
	%36 = load i8, i8* %35, align 1
	%37 = trunc i8 %36 to i1
	br i1 %37, label %if.then-2, label %if.done-5

if.then-2:
	; width
	; SelectorExpr
	%38 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%39 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %38, i64 0
	%40 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %39, i64 0, i32 7
	%41 = load i64, i64* %40, align 8
	; SelectorExpr
	%42 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%43 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %42, i64 0
	%44 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %43, i64 0, i32 8
	%45 = load i64, i64* %44, align 8
	%46 = add i64 %41, %45
	%47 = add i64 %46, 3
	store i64 %47, i64* %7
	; IfStmt
	%48 = load i64, i64* %7, align 8
	%49 = icmp sgt i64 %48, 256
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-3, label %if.done-4

if.then-3:
	%52 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$105, i64 0, i32 0), i64 53}, i64 533, i64 4, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$106, i64 0, i32 0), i64 8}}, %runtime.Source_Code_Location* %8
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$107, i64 0, i32 0), i64 53}, %runtime.Source_Code_Location* %8) noreturn
	br label %if.done-4

if.done-4:
	br label %if.done-5

if.done-5:
	; prec
	store i64 0, i64* %9
	; IfStmt
	; SelectorExpr
	%54 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%55 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %54, i64 0
	%56 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %55, i64 0, i32 6
	%57 = load i8, i8* %56, align 1
	%58 = trunc i8 %57 to i1
	br i1 %58, label %if.then-6, label %if.else-10

if.then-6:
	; AssignStmt
	; SelectorExpr
	%59 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%60 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %59, i64 0
	%61 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %60, i64 0, i32 8
	%62 = load i64, i64* %61, align 8
	store i64 %62, i64* %9
	; IfStmt
	%63 = load i64, i64* %9, align 8
	%64 = icmp eq i64 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %cmp.and-7, label %if.done-9

cmp.and-7:
	%67 = load i64, i64* %1, align 8
	%68 = icmp eq i64 %67, 0
	%69 = zext i1 %68 to i8
	%70 = trunc i8 %69 to i1
	br i1 %70, label %if.then-8, label %if.done-9

if.then-8:
	; prev_zero
	; SelectorExpr
	%71 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%72 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %71, i64 0
	%73 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %72, i64 0, i32 3
	%74 = load i8, i8* %73, align 1
	store i8 %74, i8* %10
	; AssignStmt
	; SelectorExpr
	%75 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%76 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %75, i64 0
	%77 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %76, i64 0, i32 3
	store i8 0, i8* %77
	%78 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; SelectorExpr
	%79 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%80 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %79, i64 0
	%81 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %80, i64 0, i32 7
	%82 = load i64, i64* %81, align 8
	call void @fmt.fmt_write_padding(%fmt.Fmt_Info* %78, i64 %82, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	; SelectorExpr
	%83 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%84 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %83, i64 0
	%85 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %84, i64 0, i32 3
	%86 = load i8, i8* %10, align 1
	store i8 %86, i8* %85
	; ReturnStmt
	ret void

if.done-9:
	br label %if.done-18

if.else-10:
	; IfStmt
	; SelectorExpr
	%87 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%88 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %87, i64 0
	%89 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %88, i64 0, i32 3
	%90 = load i8, i8* %89, align 1
	%91 = trunc i8 %90 to i1
	br i1 %91, label %cmp.and-11, label %if.done-17

cmp.and-11:
	; SelectorExpr
	%92 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%93 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %92, i64 0
	%94 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %93, i64 0, i32 5
	%95 = load i8, i8* %94, align 1
	%96 = trunc i8 %95 to i1
	br i1 %96, label %if.then-12, label %if.done-17

if.then-12:
	; AssignStmt
	; SelectorExpr
	%97 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%98 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %97, i64 0
	%99 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %98, i64 0, i32 7
	%100 = load i64, i64* %99, align 8
	store i64 %100, i64* %9
	; IfStmt
	%101 = load i8, i8* %6, align 1
	%102 = trunc i8 %101 to i1
	br i1 %102, label %if.then-15, label %cmp.or-13

cmp.or-13:
	; SelectorExpr
	%103 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%104 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %103, i64 0
	%105 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %104, i64 0, i32 1
	%106 = load i8, i8* %105, align 1
	%107 = trunc i8 %106 to i1
	br i1 %107, label %if.then-15, label %cmp.or-14

cmp.or-14:
	; SelectorExpr
	%108 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%109 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %108, i64 0
	%110 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %109, i64 0, i32 2
	%111 = load i8, i8* %110, align 1
	%112 = trunc i8 %111 to i1
	br i1 %112, label %if.then-15, label %if.done-16

if.then-15:
	; AssignStmt
	%113 = load i64, i64* %9, align 8
	%114 = sub i64 %113, 1
	store i64 %114, i64* %9
	br label %if.done-16

if.done-16:
	br label %if.done-17

if.done-17:
	br label %if.done-18

if.done-18:
	; SwitchStmt
	%115 = load i64, i64* %2, align 8
	%116 = icmp eq i64 %115, 2
	br i1 %116, label %switch.case.body-24, label %switch.case.next-19

switch.case.next-19:
	%117 = icmp eq i64 %115, 8
	br i1 %117, label %switch.case.body-24, label %switch.case.next-20

switch.case.next-20:
	%118 = icmp eq i64 %115, 10
	br i1 %118, label %switch.case.body-24, label %switch.case.next-21

switch.case.next-21:
	%119 = icmp eq i64 %115, 12
	br i1 %119, label %switch.case.body-24, label %switch.case.next-22

switch.case.next-22:
	%120 = icmp eq i64 %115, 16
	br i1 %120, label %switch.case.body-24, label %switch.case.next-23

switch.case.next-23:
	%121 = bitcast %runtime.Source_Code_Location* %11 to %..rawptr
	%122 = call %..rawptr @mem.zero(%..rawptr %121, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %11
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$108, i64 0, i32 0), i64 53}, i64 559, i64 3, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$109, i64 0, i32 0), i64 8}}, %runtime.Source_Code_Location* %11
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([31 x i8], [31 x i8]* @str$10a, i64 0, i32 0), i64 30}, %runtime.Source_Code_Location* %11) noreturn
	br label %switch.done-25

switch.case.body-24:
	; break
	br label %switch.done-25

switch.done-25:
	; buf
	%123 = bitcast [256 x i8]* %12 to %..rawptr
	%124 = call %..rawptr @mem.zero(%..rawptr %123, i64 256) noinline
	store [256 x i8] zeroinitializer, [256 x i8]* %12
	; start
	store i64 0, i64* %13
	; flags
	%125 = bitcast i8* %14 to %..rawptr
	%126 = call %..rawptr @mem.zero(%..rawptr %125, i64 1) noinline
	store i8 zeroinitializer, i8* %14
	; IfStmt
	; SelectorExpr
	%127 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%128 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %127, i64 0
	%129 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %128, i64 0, i32 4
	%130 = load i8, i8* %129, align 1
	%131 = trunc i8 %130 to i1
	br i1 %131, label %cmp.and-26, label %if.done-28

cmp.and-26:
	; SelectorExpr
	%132 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%133 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %132, i64 0
	%134 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %133, i64 0, i32 3
	%135 = load i8, i8* %134, align 1
	%136 = trunc i8 %135 to i1
	br i1 %136, label %if.done-28, label %if.then-27

if.then-27:
	; AssignStmt
	%137 = load i8, i8* %14, align 1
	%138 = or i8 %137, 1
	store i8 %138, i8* %14
	br label %if.done-28

if.done-28:
	; IfStmt
	; SelectorExpr
	%139 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%140 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %139, i64 0
	%141 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %140, i64 0, i32 1
	%142 = load i8, i8* %141, align 1
	%143 = trunc i8 %142 to i1
	br i1 %143, label %if.then-29, label %if.done-30

if.then-29:
	; AssignStmt
	%144 = load i8, i8* %14, align 1
	%145 = or i8 %144, 2
	store i8 %145, i8* %14
	br label %if.done-30

if.done-30:
	; IfStmt
	; SelectorExpr
	%146 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%147 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %146, i64 0
	%148 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %147, i64 0, i32 2
	%149 = load i8, i8* %148, align 1
	%150 = trunc i8 %149 to i1
	br i1 %150, label %if.then-31, label %if.done-32

if.then-31:
	; AssignStmt
	%151 = load i8, i8* %14, align 1
	%152 = or i8 %151, 4
	store i8 %152, i8* %14
	br label %if.done-32

if.done-32:
	; s
	; SelectorExpr
	; SliceExpr
	%153 = load i64, i64* %13, align 8
	%154 = load [256 x i8], [256 x i8]* %12, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$10b, i64 0, i32 0), i64 53}, i64 570, i64 30, i64 %153, i64 256, i64 256)
	%155 = getelementptr inbounds [256 x i8], [256 x i8]* %12, i64 0, i32 0
	%156 = getelementptr inbounds i8, i8* %155, i64 %153
	%157 = sub i64 256, %153
	%158 = bitcast {i8*, i64}* %16 to %..rawptr
	%159 = call %..rawptr @mem.zero(%..rawptr %158, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %16
	%160 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i64 0, i32 0
	store i8* %156, i8** %160
	%161 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i64 0, i32 1
	store i64 %157, i64* %161
	%162 = load {i8*, i64}, {i8*, i64}* %16, align 8
	%163 = load i64, i64* %1, align 8
	%164 = load i64, i64* %2, align 8
	%165 = load i8, i8* %3, align 1
	%166 = load i64, i64* %4, align 8
	%167 = load %..string, %..string* %5, align 8
	%168 = load i8, i8* %14, align 1
	%169 = bitcast {i8*, i64}* %17 to %..rawptr
	%170 = call %..rawptr @mem.zero(%..rawptr %169, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %17
	store {i8*, i64} %162, {i8*, i64}* %17
	%171 = trunc i8 %165 to i1
	%172 = call %..string @strconv.append_bits({i8*, i64}* %17, i64 %163, i64 %164, i1 %171, i64 %166, %..string %167, i8 %168, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %172, %..string* %15
	; IfStmt
	; SelectorExpr
	%173 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%174 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %173, i64 0
	%175 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %174, i64 0, i32 4
	%176 = load i8, i8* %175, align 1
	%177 = trunc i8 %176 to i1
	br i1 %177, label %cmp.and-33, label %if.done-46

cmp.and-33:
	; SelectorExpr
	%178 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%179 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %178, i64 0
	%180 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %179, i64 0, i32 3
	%181 = load i8, i8* %180, align 1
	%182 = trunc i8 %181 to i1
	br i1 %182, label %if.then-34, label %if.done-46

if.then-34:
	; c
	store i8 0, i8* %18
	; SwitchStmt
	%183 = load i64, i64* %2, align 8
	%184 = icmp eq i64 %183, 2
	br i1 %184, label %switch.case.body-36, label %switch.case.next-35

switch.case.next-35:
	%185 = icmp eq i64 %183, 8
	br i1 %185, label %switch.fall.body-38, label %switch.case.next-37

switch.case.body-36:
	; AssignStmt
	store i8 98, i8* %18
	br label %switch.done-43

switch.case.next-37:
	%186 = icmp eq i64 %183, 12
	br i1 %186, label %switch.fall.body-40, label %switch.case.next-39

switch.fall.body-38:
	; AssignStmt
	store i8 111, i8* %18
	br label %switch.done-43

switch.case.next-39:
	%187 = icmp eq i64 %183, 16
	br i1 %187, label %switch.fall.body-42, label %switch.case.next-41

switch.fall.body-40:
	; AssignStmt
	store i8 122, i8* %18
	br label %switch.done-43

switch.case.next-41:
	br label %switch.done-43

switch.fall.body-42:
	; AssignStmt
	store i8 120, i8* %18
	br label %switch.done-43

switch.done-43:
	; IfStmt
	%188 = load i8, i8* %18, align 1
	%189 = icmp ne i8 %188, 0
	%190 = zext i1 %189 to i8
	%191 = trunc i8 %190 to i1
	br i1 %191, label %if.then-44, label %if.done-45

if.then-44:
	; SelectorExpr
	%192 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%193 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %192, i64 0
	%194 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %193, i64 0, i32 12
	%195 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %194, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %195, i8 48, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%196 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%197 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %196, i64 0
	%198 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %197, i64 0, i32 12
	%199 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %198, align 8
	%200 = load i8, i8* %18, align 1
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %199, i8 %200, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-45

if.done-45:
	br label %if.done-46

if.done-46:
	; prev_zero
	; SelectorExpr
	%201 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%202 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %201, i64 0
	%203 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %202, i64 0, i32 3
	%204 = load i8, i8* %203, align 1
	store i8 %204, i8* %19
	; DeferStmt
	; AssignStmt
	; SelectorExpr
	%205 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%206 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %205, i64 0
	%207 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %206, i64 0, i32 3
	store i8 0, i8* %207
	%208 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%209 = load %..string, %..string* %15, align 8
	call void @fmt._pad(%fmt.Fmt_Info* %208, %..string %209, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; defer
	; AssignStmt
	; SelectorExpr
	%210 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%211 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %210, i64 0
	%212 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %211, i64 0, i32 3
	%213 = load i8, i8* %19, align 1
	store i8 %213, i8* %212
	ret void
}

define void @fmt.fmt_rune(%fmt.Fmt_Info* %fi, i32 %r, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i32, align 16
	%2 = alloca i32, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store i32 %r, i32* %1
	store i32 %verb, i32* %2
	; SwitchStmt
	%3 = load i32, i32* %2, align 4
	%4 = icmp eq i32 %3, 99
	br i1 %4, label %switch.case.body-4, label %switch.case.next-1

switch.case.next-1:
	%5 = icmp eq i32 %3, 114
	br i1 %5, label %switch.case.body-4, label %switch.case.next-2

switch.case.next-2:
	%6 = icmp eq i32 %3, 118
	br i1 %6, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%7 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%8 = load i32, i32* %1, align 4
	%9 = sext i32 %8 to i64
	%10 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %7, i64 %9, i1 false, i64 32, i32 %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-5

switch.case.body-4:
	; SelectorExpr
	%11 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%12 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %11, i64 0
	%13 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %12, i64 0, i32 12
	%14 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %13, align 8
	%15 = load i32, i32* %1, align 4
	call void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %14, i32 %15, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-5

switch.done-5:
	ret void
}

define void @fmt.fmt_int(%fmt.Fmt_Info* %fi, i64 %u, i1 %is_signed, i64 %bit_size, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8, align 16
	%3 = alloca i64, align 16
	%4 = alloca i32, align 16
	%5 = alloca i32, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store i64 %u, i64* %1
	%6 = zext i1 %is_signed to i8
	store i8 %6, i8* %2
	store i64 %bit_size, i64* %3
	store i32 %verb, i32* %4
	; SwitchStmt
	%7 = load i32, i32* %4, align 4
	%8 = icmp eq i32 %7, 118
	br i1 %8, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%9 = icmp eq i32 %7, 98
	br i1 %9, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	%10 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%11 = load i64, i64* %1, align 8
	%12 = load i8, i8* %2, align 1
	%13 = load i64, i64* %3, align 8
	%14 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%15 = trunc i8 %12 to i1
	call void @fmt._fmt_int(%fmt.Fmt_Info* %10, i64 %11, i64 10, i1 %15, i64 %13, %..string %14, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-3:
	%16 = icmp eq i32 %7, 111
	br i1 %16, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	%17 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%18 = load i64, i64* %1, align 8
	%19 = load i8, i8* %2, align 1
	%20 = load i64, i64* %3, align 8
	%21 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%22 = trunc i8 %19 to i1
	call void @fmt._fmt_int(%fmt.Fmt_Info* %17, i64 %18, i64 2, i1 %22, i64 %20, %..string %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-5:
	%23 = icmp eq i32 %7, 100
	br i1 %23, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	%24 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%25 = load i64, i64* %1, align 8
	%26 = load i8, i8* %2, align 1
	%27 = load i64, i64* %3, align 8
	%28 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%29 = trunc i8 %26 to i1
	call void @fmt._fmt_int(%fmt.Fmt_Info* %24, i64 %25, i64 8, i1 %29, i64 %27, %..string %28, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-7:
	%30 = icmp eq i32 %7, 122
	br i1 %30, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	%31 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%32 = load i64, i64* %1, align 8
	%33 = load i8, i8* %2, align 1
	%34 = load i64, i64* %3, align 8
	%35 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%36 = trunc i8 %33 to i1
	call void @fmt._fmt_int(%fmt.Fmt_Info* %31, i64 %32, i64 10, i1 %36, i64 %34, %..string %35, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-9:
	%37 = icmp eq i32 %7, 120
	br i1 %37, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	%38 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%39 = load i64, i64* %1, align 8
	%40 = load i8, i8* %2, align 1
	%41 = load i64, i64* %3, align 8
	%42 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%43 = trunc i8 %40 to i1
	call void @fmt._fmt_int(%fmt.Fmt_Info* %38, i64 %39, i64 12, i1 %43, i64 %41, %..string %42, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-11:
	%44 = icmp eq i32 %7, 88
	br i1 %44, label %switch.fall.body-14, label %switch.case.next-13

switch.fall.body-12:
	%45 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%46 = load i64, i64* %1, align 8
	%47 = load i8, i8* %2, align 1
	%48 = load i64, i64* %3, align 8
	%49 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%50 = trunc i8 %47 to i1
	call void @fmt._fmt_int(%fmt.Fmt_Info* %45, i64 %46, i64 16, i1 %50, i64 %48, %..string %49, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-13:
	%51 = icmp eq i32 %7, 99
	br i1 %51, label %switch.fall.body-17, label %switch.case.next-15

switch.fall.body-14:
	%52 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%53 = load i64, i64* %1, align 8
	%54 = load i8, i8* %2, align 1
	%55 = load i64, i64* %3, align 8
	%56 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	%57 = trunc i8 %54 to i1
	call void @fmt._fmt_int(%fmt.Fmt_Info* %52, i64 %53, i64 16, i1 %57, i64 %55, %..string %56, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-15:
	%58 = icmp eq i32 %7, 114
	br i1 %58, label %switch.fall.body-17, label %switch.case.next-16

switch.case.next-16:
	%59 = icmp eq i32 %7, 85
	br i1 %59, label %switch.fall.body-19, label %switch.case.next-18

switch.fall.body-17:
	%60 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%61 = load i64, i64* %1, align 8
	%62 = trunc i64 %61 to i32
	%63 = load i32, i32* %4, align 4
	call void @fmt.fmt_rune(%fmt.Fmt_Info* %60, i32 %62, i32 %63, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-18:
	%64 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%65 = load i32, i32* %4, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %64, i32 %65, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.fall.body-19:
	; r
	%66 = load i64, i64* %1, align 8
	%67 = trunc i64 %66 to i32
	store i32 %67, i32* %5
	; IfStmt
	%68 = load i32, i32* %5, align 4
	%69 = icmp slt i32 %68, 0
	%70 = zext i1 %69 to i8
	%71 = trunc i8 %70 to i1
	br i1 %71, label %if.then-21, label %cmp.or-20

cmp.or-20:
	%72 = load i32, i32* %5, align 4
	%73 = icmp sgt i32 %72, 1114111
	%74 = zext i1 %73 to i8
	%75 = trunc i8 %74 to i1
	br i1 %75, label %if.then-21, label %if.else-22

if.then-21:
	%76 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%77 = load i32, i32* %4, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %76, i32 %77, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-23

if.else-22:
	; SelectorExpr
	%78 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%79 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %78, i64 0
	%80 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %79, i64 0, i32 12
	%81 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %80, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %81, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$10c, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%82 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%83 = load i64, i64* %1, align 8
	%84 = load i64, i64* %3, align 8
	%85 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	call void @fmt._fmt_int(%fmt.Fmt_Info* %82, i64 %83, i64 16, i1 false, i64 %84, %..string %85, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-23

if.done-23:
	br label %switch.done-24

switch.done-24:
	ret void
}

define void @fmt._pad(%fmt.Fmt_Info* %fi, %..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i64, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..string %s, %..string* %1
	; IfStmt
	; SelectorExpr
	%3 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%4 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %3, i64 0
	%5 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %4, i64 0, i32 5
	%6 = load i8, i8* %5, align 1
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.done-2, label %if.then-1

if.then-1:
	; SelectorExpr
	%8 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%9 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %8, i64 0
	%10 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %9, i64 0, i32 12
	%11 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %10, align 8
	%12 = load %..string, %..string* %1, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %11, %..string %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-2:
	; width
	; SelectorExpr
	%13 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%14 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %13, i64 0
	%15 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %14, i64 0, i32 7
	%16 = load i64, i64* %15, align 8
	; SelectorExpr
	%17 = load %..string, %..string* %1, align 8
	%18 = call i64 @utf8.rune_count_from_string(%..string %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = sub i64 %16, %18
	store i64 %19, i64* %2
	; IfStmt
	; SelectorExpr
	%20 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%21 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %20, i64 0
	%22 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %21, i64 0, i32 0
	%23 = load i8, i8* %22, align 1
	%24 = trunc i8 %23 to i1
	br i1 %24, label %if.then-3, label %if.else-4

if.then-3:
	; SelectorExpr
	%25 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%26 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %25, i64 0
	%27 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %26, i64 0, i32 12
	%28 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %27, align 8
	%29 = load %..string, %..string* %1, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %28, %..string %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%30 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%31 = load i64, i64* %2, align 8
	call void @fmt.fmt_write_padding(%fmt.Fmt_Info* %30, i64 %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-5

if.else-4:
	%32 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%33 = load i64, i64* %2, align 8
	call void @fmt.fmt_write_padding(%fmt.Fmt_Info* %32, i64 %33, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%34 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%35 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %34, i64 0
	%36 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %35, i64 0, i32 12
	%37 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %36, align 8
	%38 = load %..string, %..string* %1, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %37, %..string %38, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-5

if.done-5:
	ret void
}

define void @fmt.fmt_float(%fmt.Fmt_Info* %fi, double %v, i64 %bit_size, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca double, align 16
	%2 = alloca i64, align 16
	%3 = alloca i32, align 16
	%4 = alloca i64, align 16
	%5 = alloca [386 x i8], align 16
	%6 = alloca %..string, align 16
	%7 = alloca {i8*, i64}, align 16
	%8 = alloca {i8*, i64}, align 16
	%9 = alloca {i8*, i64}, align 16
	%10 = alloca %..string, align 16
	%11 = alloca %..string, align 16
	%12 = alloca %..string, align 16
	%13 = alloca %..string, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store double %v, double* %1
	store i64 %bit_size, i64* %2
	store i32 %verb, i32* %3
	; SwitchStmt
	%14 = load i32, i32* %3, align 4
	%15 = icmp eq i32 %14, 102
	br i1 %15, label %switch.case.body-4, label %switch.case.next-1

switch.case.next-1:
	%16 = icmp eq i32 %14, 70
	br i1 %16, label %switch.case.body-4, label %switch.case.next-2

switch.case.next-2:
	%17 = icmp eq i32 %14, 118
	br i1 %17, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%18 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%19 = load i32, i32* %3, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %18, i32 %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-28

switch.case.body-4:
	; prec
	store i64 3, i64* %4
	; IfStmt
	; SelectorExpr
	%20 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%21 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %20, i64 0
	%22 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %21, i64 0, i32 6
	%23 = load i8, i8* %22, align 1
	%24 = trunc i8 %23 to i1
	br i1 %24, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%25 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%26 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %25, i64 0
	%27 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %26, i64 0, i32 8
	%28 = load i64, i64* %27, align 8
	store i64 %28, i64* %4
	br label %if.done-6

if.done-6:
	; buf
	%29 = bitcast [386 x i8]* %5 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 386) noinline
	store [386 x i8] zeroinitializer, [386 x i8]* %5
	; str
	; SelectorExpr
	; SliceExpr
	%31 = load [386 x i8], [386 x i8]* %5, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$10d, i64 0, i32 0), i64 53}, i64 657, i64 34, i64 1, i64 386, i64 386)
	%32 = getelementptr inbounds [386 x i8], [386 x i8]* %5, i64 0, i32 0
	%33 = getelementptr inbounds i8, i8* %32, i64 1
	%34 = sub i64 386, 1
	%35 = bitcast {i8*, i64}* %7 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %7
	%37 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i64 0, i32 0
	store i8* %33, i8** %37
	%38 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i64 0, i32 1
	store i64 %34, i64* %38
	%39 = load {i8*, i64}, {i8*, i64}* %7, align 8
	%40 = load double, double* %1, align 8
	%41 = load i64, i64* %4, align 8
	%42 = load i64, i64* %2, align 8
	%43 = bitcast {i8*, i64}* %8 to %..rawptr
	%44 = call %..rawptr @mem.zero(%..rawptr %43, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %8
	store {i8*, i64} %39, {i8*, i64}* %8
	%45 = call %..string @strconv.append_float({i8*, i64}* %8, double %40, i8 102, i64 %41, i64 %42, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %45, %..string* %6
	; AssignStmt
	; SliceExpr
	%46 = load %..string, %..string* %6, align 8
	%47 = extractvalue %..string %46, 1
	%48 = add i64 %47, 1
	%49 = load [386 x i8], [386 x i8]* %5, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$10e, i64 0, i32 0), i64 53}, i64 658, i64 19, i64 0, i64 %48, i64 386)
	%50 = getelementptr inbounds [386 x i8], [386 x i8]* %5, i64 0, i32 0
	%51 = getelementptr inbounds i8, i8* %50, i64 0
	%52 = sub i64 %48, 0
	%53 = bitcast {i8*, i64}* %9 to %..rawptr
	%54 = call %..rawptr @mem.zero(%..rawptr %53, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %9
	%55 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %9, i64 0, i32 0
	store i8* %51, i8** %55
	%56 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %9, i64 0, i32 1
	store i64 %52, i64* %56
	%57 = load {i8*, i64}, {i8*, i64}* %9, align 8
	%58 = extractvalue {i8*, i64} %57, 0
	%59 = extractvalue {i8*, i64} %57, 1
	%60 = bitcast %..string* %10 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store %..string zeroinitializer, %..string* %10
	%62 = getelementptr inbounds %..string, %..string* %10, i64 0, i32 0
	store i8* %58, i8** %62
	%63 = getelementptr inbounds %..string, %..string* %10, i64 0, i32 1
	store i64 %59, i64* %63
	%64 = load %..string, %..string* %10, align 8
	store %..string %64, %..string* %6
	; IfStmt
	; IndexExpr
	%65 = load %..string, %..string* %6, align 8
	%66 = extractvalue %..string %65, 0
	%67 = extractvalue %..string %65, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$10f, i64 0, i32 0), i64 53}, i64 659, i64 10, i64 1, i64 %67)
	%68 = getelementptr inbounds i8, i8* %66, i64 1
	%69 = load i8, i8* %68, align 1
	%70 = icmp eq i8 %69, 43
	%71 = zext i1 %70 to i8
	%72 = trunc i8 %71 to i1
	br i1 %72, label %if.then-8, label %cmp.or-7

cmp.or-7:
	; IndexExpr
	%73 = load %..string, %..string* %6, align 8
	%74 = extractvalue %..string %73, 0
	%75 = extractvalue %..string %73, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$110, i64 0, i32 0), i64 53}, i64 659, i64 27, i64 1, i64 %75)
	%76 = getelementptr inbounds i8, i8* %74, i64 1
	%77 = load i8, i8* %76, align 1
	%78 = icmp eq i8 %77, 45
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-8, label %if.else-9

if.then-8:
	; AssignStmt
	; SliceExpr
	%81 = load %..string, %..string* %6, align 8
	%82 = extractvalue %..string %81, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$111, i64 0, i32 0), i64 53}, i64 660, i64 13, i64 1, i64 %82, i64 %82)
	%83 = extractvalue %..string %81, 0
	%84 = getelementptr inbounds i8, i8* %83, i64 1
	%85 = sub i64 %82, 1
	%86 = bitcast %..string* %11 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %..string zeroinitializer, %..string* %11
	%88 = getelementptr inbounds %..string, %..string* %11, i64 0, i32 0
	store i8* %84, i8** %88
	%89 = getelementptr inbounds %..string, %..string* %11, i64 0, i32 1
	store i64 %85, i64* %89
	%90 = load %..string, %..string* %11, align 8
	store %..string %90, %..string* %6
	br label %if.done-10

if.else-9:
	; AssignStmt
	; IndexExpr
	%91 = load %..string, %..string* %6, align 8
	%92 = extractvalue %..string %91, 0
	%93 = extractvalue %..string %91, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$112, i64 0, i32 0), i64 53}, i64 662, i64 8, i64 0, i64 %93)
	%94 = getelementptr inbounds i8, i8* %92, i64 0
	store i8 43, i8* %94
	br label %if.done-10

if.done-10:
	; IfStmt
	; SelectorExpr
	%95 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%96 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %95, i64 0
	%97 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %96, i64 0, i32 2
	%98 = load i8, i8* %97, align 1
	%99 = trunc i8 %98 to i1
	br i1 %99, label %cmp.and-11, label %if.done-14

cmp.and-11:
	; SelectorExpr
	%100 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%101 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %100, i64 0
	%102 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %101, i64 0, i32 1
	%103 = load i8, i8* %102, align 1
	%104 = trunc i8 %103 to i1
	br i1 %104, label %if.done-14, label %cmp.and-12

cmp.and-12:
	; IndexExpr
	%105 = load %..string, %..string* %6, align 8
	%106 = extractvalue %..string %105, 0
	%107 = extractvalue %..string %105, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$113, i64 0, i32 0), i64 53}, i64 665, i64 34, i64 0, i64 %107)
	%108 = getelementptr inbounds i8, i8* %106, i64 0
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 43
	%111 = zext i1 %110 to i8
	%112 = trunc i8 %111 to i1
	br i1 %112, label %if.then-13, label %if.done-14

if.then-13:
	; AssignStmt
	; IndexExpr
	%113 = load %..string, %..string* %6, align 8
	%114 = extractvalue %..string %113, 0
	%115 = extractvalue %..string %113, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$114, i64 0, i32 0), i64 53}, i64 666, i64 8, i64 0, i64 %115)
	%116 = getelementptr inbounds i8, i8* %114, i64 0
	store i8 32, i8* %116
	br label %if.done-14

if.done-14:
	; IfStmt
	%117 = load %..string, %..string* %6, align 8
	%118 = extractvalue %..string %117, 1
	%119 = icmp sgt i64 %118, 1
	%120 = zext i1 %119 to i8
	%121 = trunc i8 %120 to i1
	br i1 %121, label %cmp.and-15, label %if.done-18

cmp.and-15:
	; IndexExpr
	%122 = load %..string, %..string* %6, align 8
	%123 = extractvalue %..string %122, 0
	%124 = extractvalue %..string %122, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$115, i64 0, i32 0), i64 53}, i64 669, i64 26, i64 1, i64 %124)
	%125 = getelementptr inbounds i8, i8* %123, i64 1
	%126 = load i8, i8* %125, align 1
	%127 = icmp eq i8 %126, 78
	%128 = zext i1 %127 to i8
	%129 = trunc i8 %128 to i1
	br i1 %129, label %cmp.and-16, label %if.done-18

cmp.and-16:
	; IndexExpr
	%130 = load %..string, %..string* %6, align 8
	%131 = extractvalue %..string %130, 0
	%132 = extractvalue %..string %130, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$116, i64 0, i32 0), i64 53}, i64 669, i64 43, i64 1, i64 %132)
	%133 = getelementptr inbounds i8, i8* %131, i64 1
	%134 = load i8, i8* %133, align 1
	%135 = icmp eq i8 %134, 73
	%136 = zext i1 %135 to i8
	%137 = trunc i8 %136 to i1
	br i1 %137, label %if.then-17, label %if.done-18

if.then-17:
	; SelectorExpr
	%138 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%139 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %138, i64 0
	%140 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %139, i64 0, i32 12
	%141 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %140, align 8
	%142 = load %..string, %..string* %6, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %141, %..string %142, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-18:
	; IfStmt
	; SelectorExpr
	%143 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%144 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %143, i64 0
	%145 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %144, i64 0, i32 1
	%146 = load i8, i8* %145, align 1
	%147 = trunc i8 %146 to i1
	br i1 %147, label %if.then-20, label %cmp.or-19

cmp.or-19:
	; IndexExpr
	%148 = load %..string, %..string* %6, align 8
	%149 = extractvalue %..string %148, 0
	%150 = extractvalue %..string %148, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$117, i64 0, i32 0), i64 53}, i64 674, i64 21, i64 0, i64 %150)
	%151 = getelementptr inbounds i8, i8* %149, i64 0
	%152 = load i8, i8* %151, align 1
	%153 = icmp ne i8 %152, 43
	%154 = zext i1 %153 to i8
	%155 = trunc i8 %154 to i1
	br i1 %155, label %if.then-20, label %if.else-26

if.then-20:
	; IfStmt
	; SelectorExpr
	%156 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%157 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %156, i64 0
	%158 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %157, i64 0, i32 3
	%159 = load i8, i8* %158, align 1
	%160 = trunc i8 %159 to i1
	br i1 %160, label %cmp.and-21, label %if.else-24

cmp.and-21:
	; SelectorExpr
	%161 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%162 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %161, i64 0
	%163 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %162, i64 0, i32 5
	%164 = load i8, i8* %163, align 1
	%165 = trunc i8 %164 to i1
	br i1 %165, label %cmp.and-22, label %if.else-24

cmp.and-22:
	; SelectorExpr
	%166 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%167 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %166, i64 0
	%168 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %167, i64 0, i32 7
	%169 = load i64, i64* %168, align 8
	%170 = load %..string, %..string* %6, align 8
	%171 = extractvalue %..string %170, 1
	%172 = icmp sgt i64 %169, %171
	%173 = zext i1 %172 to i8
	%174 = trunc i8 %173 to i1
	br i1 %174, label %if.then-23, label %if.else-24

if.then-23:
	; SelectorExpr
	%175 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%176 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %175, i64 0
	%177 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %176, i64 0, i32 12
	%178 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %177, align 8
	; IndexExpr
	%179 = load %..string, %..string* %6, align 8
	%180 = extractvalue %..string %179, 0
	%181 = extractvalue %..string %179, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$118, i64 0, i32 0), i64 53}, i64 676, i64 28, i64 0, i64 %181)
	%182 = getelementptr inbounds i8, i8* %180, i64 0
	%183 = load i8, i8* %182, align 1
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %178, i8 %183, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%184 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; SelectorExpr
	%185 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%186 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %185, i64 0
	%187 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %186, i64 0, i32 7
	%188 = load i64, i64* %187, align 8
	%189 = load %..string, %..string* %6, align 8
	%190 = extractvalue %..string %189, 1
	%191 = sub i64 %188, %190
	call void @fmt.fmt_write_padding(%fmt.Fmt_Info* %184, i64 %191, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%192 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%193 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %192, i64 0
	%194 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %193, i64 0, i32 12
	%195 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %194, align 8
	; SliceExpr
	%196 = load %..string, %..string* %6, align 8
	%197 = extractvalue %..string %196, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$119, i64 0, i32 0), i64 53}, i64 678, i64 29, i64 1, i64 %197, i64 %197)
	%198 = extractvalue %..string %196, 0
	%199 = getelementptr inbounds i8, i8* %198, i64 1
	%200 = sub i64 %197, 1
	%201 = bitcast %..string* %12 to %..rawptr
	%202 = call %..rawptr @mem.zero(%..rawptr %201, i64 16) noinline
	store %..string zeroinitializer, %..string* %12
	%203 = getelementptr inbounds %..string, %..string* %12, i64 0, i32 0
	store i8* %199, i8** %203
	%204 = getelementptr inbounds %..string, %..string* %12, i64 0, i32 1
	store i64 %200, i64* %204
	%205 = load %..string, %..string* %12, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %195, %..string %205, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-25

if.else-24:
	%206 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%207 = load %..string, %..string* %6, align 8
	call void @fmt._pad(%fmt.Fmt_Info* %206, %..string %207, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-25

if.done-25:
	br label %if.done-27

if.else-26:
	%208 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; SliceExpr
	%209 = load %..string, %..string* %6, align 8
	%210 = extractvalue %..string %209, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$11a, i64 0, i32 0), i64 53}, i64 683, i64 16, i64 1, i64 %210, i64 %210)
	%211 = extractvalue %..string %209, 0
	%212 = getelementptr inbounds i8, i8* %211, i64 1
	%213 = sub i64 %210, 1
	%214 = bitcast %..string* %13 to %..rawptr
	%215 = call %..rawptr @mem.zero(%..rawptr %214, i64 16) noinline
	store %..string zeroinitializer, %..string* %13
	%216 = getelementptr inbounds %..string, %..string* %13, i64 0, i32 0
	store i8* %212, i8** %216
	%217 = getelementptr inbounds %..string, %..string* %13, i64 0, i32 1
	store i64 %213, i64* %217
	%218 = load %..string, %..string* %13, align 8
	call void @fmt._pad(%fmt.Fmt_Info* %208, %..string %218, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-27

if.done-27:
	br label %switch.done-28

switch.done-28:
	ret void
}

define void @fmt.fmt_string(%fmt.Fmt_Info* %fi, %..string %s, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i32, align 16
	%3 = alloca i8, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca %..string, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..string %s, %..string* %1
	store i32 %verb, i32* %2
	; SwitchStmt
	%8 = load i32, i32* %2, align 4
	%9 = icmp eq i32 %8, 115
	br i1 %9, label %switch.case.body-3, label %switch.case.next-1

switch.case.next-1:
	%10 = icmp eq i32 %8, 118
	br i1 %10, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%11 = icmp eq i32 %8, 120
	br i1 %11, label %switch.fall.body-6, label %switch.case.next-4

switch.case.body-3:
	; SelectorExpr
	%12 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%13 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %12, i64 0
	%14 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %13, i64 0, i32 12
	%15 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %14, align 8
	%16 = load %..string, %..string* %1, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %15, %..string %16, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-15

switch.case.next-4:
	%17 = icmp eq i32 %8, 88
	br i1 %17, label %switch.fall.body-6, label %switch.case.next-5

switch.case.next-5:
	%18 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%19 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %18, i32 %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-15

switch.fall.body-6:
	; space
	; SelectorExpr
	%20 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%21 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %20, i64 0
	%22 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %21, i64 0, i32 2
	%23 = load i8, i8* %22, align 1
	store i8 %23, i8* %3
	; AssignStmt
	; SelectorExpr
	%24 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%25 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %24, i64 0
	%26 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %25, i64 0, i32 2
	store i8 0, i8* %26
	; DeferStmt
	; RangeStmt
	; i
	%27 = bitcast i64* %4 to %..rawptr
	%28 = call %..rawptr @mem.zero(%..rawptr %27, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	%29 = bitcast i64* %5 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	store i64 0, i64* %5
	%31 = bitcast i64* %6 to %..rawptr
	%32 = call %..rawptr @mem.zero(%..rawptr %31, i64 8) noinline
	store i64 zeroinitializer, i64* %6
	store i64 0, i64* %6
	br label %for.interval.loop-7

for.interval.loop-7:
	%33 = load %..string, %..string* %1, align 8
	%34 = extractvalue %..string %33, 1
	%35 = sub i64 %34, 1
	%36 = load i64, i64* %5, align 8
	%37 = icmp sle i64 %36, %35
	br i1 %37, label %for.interval.body-8, label %for.interval.done-14

for.interval.body-8:
	%38 = load i64, i64* %5, align 8
	%39 = load i64, i64* %6, align 8
	%40 = load i64, i64* %5, align 8
	%41 = add i64 %40, 1
	store i64 %41, i64* %5
	%42 = load i64, i64* %6, align 8
	%43 = add i64 %42, 1
	store i64 %43, i64* %6
	store i64 %38, i64* %4
	; IfStmt
	%44 = load i64, i64* %4, align 8
	%45 = icmp sgt i64 %44, 0
	%46 = zext i1 %45 to i8
	%47 = trunc i8 %46 to i1
	br i1 %47, label %cmp.and-9, label %if.done-11

cmp.and-9:
	%48 = load i8, i8* %3, align 1
	%49 = trunc i8 %48 to i1
	br i1 %49, label %if.then-10, label %if.done-11

if.then-10:
	; SelectorExpr
	%50 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%51 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %50, i64 0
	%52 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %51, i64 0, i32 12
	%53 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %52, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %53, i8 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-11

if.done-11:
	; char_set
	%54 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	store %..string %54, %..string* %7
	; IfStmt
	%55 = load i32, i32* %2, align 4
	%56 = icmp eq i32 %55, 120
	%57 = zext i1 %56 to i8
	%58 = trunc i8 %57 to i1
	br i1 %58, label %if.then-12, label %if.done-13

if.then-12:
	; AssignStmt
	%59 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	store %..string %59, %..string* %7
	br label %if.done-13

if.done-13:
	%60 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; IndexExpr
	%61 = load %..string, %..string* %1, align 8
	%62 = extractvalue %..string %61, 0
	%63 = extractvalue %..string %61, 1
	%64 = load i64, i64* %4, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$11b, i64 0, i32 0), i64 53}, i64 704, i64 23, i64 %64, i64 %63)
	%65 = getelementptr inbounds i8, i8* %62, i64 %64
	%66 = load i8, i8* %65, align 1
	%67 = zext i8 %66 to i64
	%68 = load %..string, %..string* %7, align 8
	call void @fmt._fmt_int(%fmt.Fmt_Info* %60, i64 %67, i64 16, i1 false, i64 8, %..string %68, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-7

for.interval.done-14:
	; defer
	; AssignStmt
	; SelectorExpr
	%69 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%70 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %69, i64 0
	%71 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %70, i64 0, i32 2
	%72 = load i8, i8* %3, align 1
	store i8 %72, i8* %71
	br label %switch.done-15

switch.done-15:
	ret void
}

define void @fmt.fmt_cstring(%fmt.Fmt_Info* %fi, i8* %s, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i8*, align 16
	%2 = alloca i32, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store i8* %s, i8** %1
	store i32 %verb, i32* %2
	%3 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%4 = load i8*, i8** %1, align 8
	%5 = call %..string @runtime.cstring_to_string(i8* %4)
	%6 = load i32, i32* %2, align 4
	call void @fmt.fmt_string(%fmt.Fmt_Info* %3, %..string %5, i32 %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.fmt_pointer(%fmt.Fmt_Info* %fi, %..rawptr %p, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca i32, align 16
	%3 = alloca i64, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..rawptr %p, %..rawptr* %1
	store i32 %verb, i32* %2
	; SwitchStmt
	%4 = load i32, i32* %2, align 4
	%5 = icmp eq i32 %4, 112
	br i1 %5, label %switch.case.body-3, label %switch.case.next-1

switch.case.next-1:
	%6 = icmp eq i32 %4, 118
	br i1 %6, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%7 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%8 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %7, i32 %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-7

switch.case.body-3:
	; u
	%9 = load %..rawptr, %..rawptr* %1, align 8
	%10 = ptrtoint %..rawptr %9 to i64
	%11 = bitcast i64 %10 to i64
	store i64 %11, i64* %3
	; IfStmt
	; SelectorExpr
	%12 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%13 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %12, i64 0
	%14 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %13, i64 0, i32 4
	%15 = load i8, i8* %14, align 1
	%16 = trunc i8 %15 to i1
	br i1 %16, label %cmp.or-4, label %if.then-5

cmp.or-4:
	%17 = load i32, i32* %2, align 4
	%18 = icmp eq i32 %17, 118
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-5, label %if.done-6

if.then-5:
	; SelectorExpr
	%21 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%22 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %21, i64 0
	%23 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %22, i64 0, i32 12
	%24 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %23, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %24, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$11c, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-6

if.done-6:
	%25 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%26 = load i64, i64* %3, align 8
	%27 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	call void @fmt._fmt_int(%fmt.Fmt_Info* %25, i64 %26, i64 16, i1 false, i64 64, %..string %27, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-7

switch.done-7:
	ret void
}

define {%..string, i8} @fmt.enum_value_to_string(%..any %v, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..any, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	%2 = alloca %runtime.Type_Info_Enum, align 16
	%3 = alloca %..any, align 16
	%4 = alloca %..any, align 16
	%5 = alloca %runtime.Type_Info*, align 16
	%6 = alloca i32, align 16
	%7 = alloca %runtime.Type_Info_Enum, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca i8, align 16
	%10 = alloca %runtime.Type_Info_Enum, align 16
	%11 = alloca {%..string, i8}, align 16
	%12 = alloca i16, align 16
	%13 = alloca %runtime.Type_Info_Enum, align 16
	%14 = alloca {%..string, i8}, align 16
	%15 = alloca i32, align 16
	%16 = alloca %runtime.Type_Info_Enum, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca i64, align 16
	%19 = alloca %runtime.Type_Info_Enum, align 16
	%20 = alloca {%..string, i8}, align 16
	%21 = alloca i64, align 16
	%22 = alloca %runtime.Type_Info_Enum, align 16
	%23 = alloca {%..string, i8}, align 16
	%24 = alloca i8, align 16
	%25 = alloca %runtime.Type_Info_Enum, align 16
	%26 = alloca {%..string, i8}, align 16
	%27 = alloca i16, align 16
	%28 = alloca %runtime.Type_Info_Enum, align 16
	%29 = alloca {%..string, i8}, align 16
	%30 = alloca i32, align 16
	%31 = alloca %runtime.Type_Info_Enum, align 16
	%32 = alloca {%..string, i8}, align 16
	%33 = alloca i64, align 16
	%34 = alloca %runtime.Type_Info_Enum, align 16
	%35 = alloca {%..string, i8}, align 16
	%36 = alloca i64, align 16
	%37 = alloca %runtime.Type_Info_Enum, align 16
	%38 = alloca {%..string, i8}, align 16
	%39 = alloca i64, align 16
	%40 = alloca %runtime.Type_Info_Enum, align 16
	%41 = alloca {%..string, i8}, align 16
	%42 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	%43 = alloca {%..string, i8}, align 16
	%44 = alloca {%..string, i8}, align 16
	store %..any %v, %..any* %0
	; AssignStmt
	; SelectorExpr
	%45 = getelementptr inbounds %..any, %..any* %0, i64 0, i32 1
	; SelectorExpr
	; SelectorExpr
	%46 = getelementptr inbounds %..any, %..any* %0, i64 0, i32 1
	%47 = load %..typeid, %..typeid* %46, align 8
	%48 = call %..typeid @runtime.typeid_base(%..typeid %47)
	store %..typeid %48, %..typeid* %45
	; type_info
	; SelectorExpr
	%49 = getelementptr inbounds %..any, %..any* %0, i64 0, i32 1
	%50 = load %..typeid, %..typeid* %49, align 8
	%51 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %50)
	store %runtime.Type_Info* %51, %runtime.Type_Info** %1
	; TypeSwitchStmt
	; SelectorExpr
	%52 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%53 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %52, i64 0
	%54 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %53, i64 0, i32 3
	%55 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %54, align 8
	; get union's tag
	%56 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %54, i64 0, i32 2 ; UnionTagPtr
	%57 = load i8, i8* %56, align 1
	%58 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %54 to %..rawptr
	%59 = icmp eq i8 %57, 18
	br i1 %59, label %typeswitch.body-2, label %typeswitch.next-1

typeswitch.next-1:
	store {[0 x <8 x i8>], [72 x i8], i8} %55, {[0 x <8 x i8>], [72 x i8], i8}* %42
	; ReturnStmt
	%60 = bitcast {%..string, i8}* %43 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %43
	%62 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %43, i64 0, i32 0
	store %..string zeroinitializer, %..string* %62
	%63 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %43, i64 0, i32 1
	store i8 0, i8* %63
	%64 = load {%..string, i8}, {%..string, i8}* %43, align 8
	ret {%..string, i8} %64

typeswitch.body-2:
	%65 = bitcast %..rawptr %58 to %runtime.Type_Info_Enum*
	%66 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %65, align 8
	store %runtime.Type_Info_Enum %66, %runtime.Type_Info_Enum* %2
	; a
	; CompoundLit
	%67 = bitcast %..any* %4 to %..rawptr
	%68 = call %..rawptr @mem.zero(%..rawptr %67, i64 16) noinline
	store %..any zeroinitializer, %..any* %4
	store %..any zeroinitializer, %..any* %4
	; SelectorExpr
	%69 = getelementptr inbounds %..any, %..any* %0, i64 0, i32 0
	%70 = load %..rawptr, %..rawptr* %69, align 8
	%71 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	store %..rawptr %70, %..rawptr* %71
	; SelectorExpr
	; SelectorExpr
	; SelectorExpr
	%72 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, i64 0, i32 0
	%73 = load %runtime.Type_Info*, %runtime.Type_Info** %72, align 8
	%74 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %73)
	%75 = bitcast %runtime.Type_Info** %5 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %5
	store %runtime.Type_Info* %74, %runtime.Type_Info** %5
	%77 = load %runtime.Type_Info*, %runtime.Type_Info** %5, align 8
	%78 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %77, i64 0
	%79 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %78, i64 0, i32 2
	%80 = load %..typeid, %..typeid* %79, align 8
	%81 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	store %..typeid %80, %..typeid* %81
	%82 = load %..any, %..any* %4, align 8
	store %..any %82, %..any* %3
	; TypeSwitchStmt
	%83 = load %..any, %..any* %3, align 8
	%84 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%85 = load %..typeid, %..typeid* %84, align 8
	%86 = icmp eq %..typeid %85, 4755801206503243837
	br i1 %86, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.next-3:
	%87 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%88 = load %..typeid, %..typeid* %87, align 8
	%89 = icmp eq %..typeid %88, 4683743612465315902
	br i1 %89, label %typeswitch.body-6, label %typeswitch.next-5

typeswitch.body-4:
	%90 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%91 = load %..rawptr, %..rawptr* %90, align 8
	%92 = bitcast %..rawptr %91 to i32*
	%93 = load i32, i32* %92, align 4
	store i32 %93, i32* %6
	; ReturnStmt
	%94 = load i32, i32* %6, align 4
	%95 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%96 = bitcast %runtime.Type_Info_Enum* %7 to %..rawptr
	%97 = call %..rawptr @mem.zero(%..rawptr %96, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %7
	store %runtime.Type_Info_Enum %95, %runtime.Type_Info_Enum* %7
	%98 = call {%..string, i8} @fmt.enum_value_to_string.get_str-0(i32 %94, %runtime.Type_Info_Enum* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%99 = extractvalue {%..string, i8} %98, 0
	%100 = extractvalue {%..string, i8} %98, 1
	%101 = bitcast {%..string, i8}* %8 to %..rawptr
	%102 = call %..rawptr @mem.zero(%..rawptr %101, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%103 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %99, %..string* %103
	%104 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 %100, i8* %104
	%105 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %105

typeswitch.next-5:
	%106 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%107 = load %..typeid, %..typeid* %106, align 8
	%108 = icmp eq %..typeid %107, 4683743612465315903
	br i1 %108, label %typeswitch.body-8, label %typeswitch.next-7

typeswitch.body-6:
	%109 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%110 = load %..rawptr, %..rawptr* %109, align 8
	%111 = bitcast %..rawptr %110 to i8*
	%112 = load i8, i8* %111, align 1
	store i8 %112, i8* %9
	; ReturnStmt
	%113 = load i8, i8* %9, align 1
	%114 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%115 = bitcast %runtime.Type_Info_Enum* %10 to %..rawptr
	%116 = call %..rawptr @mem.zero(%..rawptr %115, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %10
	store %runtime.Type_Info_Enum %114, %runtime.Type_Info_Enum* %10
	%117 = call {%..string, i8} @fmt.enum_value_to_string.get_str-1(i8 %113, %runtime.Type_Info_Enum* %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%118 = extractvalue {%..string, i8} %117, 0
	%119 = extractvalue {%..string, i8} %117, 1
	%120 = bitcast {%..string, i8}* %11 to %..rawptr
	%121 = call %..rawptr @mem.zero(%..rawptr %120, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %11
	%122 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %11, i64 0, i32 0
	store %..string %118, %..string* %122
	%123 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %11, i64 0, i32 1
	store i8 %119, i8* %123
	%124 = load {%..string, i8}, {%..string, i8}* %11, align 8
	ret {%..string, i8} %124

typeswitch.next-7:
	%125 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%126 = load %..typeid, %..typeid* %125, align 8
	%127 = icmp eq %..typeid %126, 4683743612465315848
	br i1 %127, label %typeswitch.body-10, label %typeswitch.next-9

typeswitch.body-8:
	%128 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%129 = load %..rawptr, %..rawptr* %128, align 8
	%130 = bitcast %..rawptr %129 to i16*
	%131 = load i16, i16* %130, align 2
	store i16 %131, i16* %12
	; ReturnStmt
	%132 = load i16, i16* %12, align 2
	%133 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%134 = bitcast %runtime.Type_Info_Enum* %13 to %..rawptr
	%135 = call %..rawptr @mem.zero(%..rawptr %134, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %13
	store %runtime.Type_Info_Enum %133, %runtime.Type_Info_Enum* %13
	%136 = call {%..string, i8} @fmt.enum_value_to_string.get_str-2(i16 %132, %runtime.Type_Info_Enum* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%137 = extractvalue {%..string, i8} %136, 0
	%138 = extractvalue {%..string, i8} %136, 1
	%139 = bitcast {%..string, i8}* %14 to %..rawptr
	%140 = call %..rawptr @mem.zero(%..rawptr %139, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %14
	%141 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %14, i64 0, i32 0
	store %..string %137, %..string* %141
	%142 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %14, i64 0, i32 1
	store i8 %138, i8* %142
	%143 = load {%..string, i8}, {%..string, i8}* %14, align 8
	ret {%..string, i8} %143

typeswitch.next-9:
	%144 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%145 = load %..typeid, %..typeid* %144, align 8
	%146 = icmp eq %..typeid %145, 4683743612465315904
	br i1 %146, label %typeswitch.body-12, label %typeswitch.next-11

typeswitch.body-10:
	%147 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%148 = load %..rawptr, %..rawptr* %147, align 8
	%149 = bitcast %..rawptr %148 to i32*
	%150 = load i32, i32* %149, align 4
	store i32 %150, i32* %15
	; ReturnStmt
	%151 = load i32, i32* %15, align 4
	%152 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%153 = bitcast %runtime.Type_Info_Enum* %16 to %..rawptr
	%154 = call %..rawptr @mem.zero(%..rawptr %153, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %16
	store %runtime.Type_Info_Enum %152, %runtime.Type_Info_Enum* %16
	%155 = call {%..string, i8} @fmt.enum_value_to_string.get_str-3(i32 %151, %runtime.Type_Info_Enum* %16, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%156 = extractvalue {%..string, i8} %155, 0
	%157 = extractvalue {%..string, i8} %155, 1
	%158 = bitcast {%..string, i8}* %17 to %..rawptr
	%159 = call %..rawptr @mem.zero(%..rawptr %158, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%160 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %156, %..string* %160
	%161 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 %157, i8* %161
	%162 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %162

typeswitch.next-11:
	%163 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%164 = load %..typeid, %..typeid* %163, align 8
	%165 = icmp eq %..typeid %164, 4683743612465315846
	br i1 %165, label %typeswitch.body-14, label %typeswitch.next-13

typeswitch.body-12:
	%166 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%167 = load %..rawptr, %..rawptr* %166, align 8
	%168 = bitcast %..rawptr %167 to i64*
	%169 = load i64, i64* %168, align 8
	store i64 %169, i64* %18
	; ReturnStmt
	%170 = load i64, i64* %18, align 8
	%171 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%172 = bitcast %runtime.Type_Info_Enum* %19 to %..rawptr
	%173 = call %..rawptr @mem.zero(%..rawptr %172, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %19
	store %runtime.Type_Info_Enum %171, %runtime.Type_Info_Enum* %19
	%174 = call {%..string, i8} @fmt.enum_value_to_string.get_str-4(i64 %170, %runtime.Type_Info_Enum* %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%175 = extractvalue {%..string, i8} %174, 0
	%176 = extractvalue {%..string, i8} %174, 1
	%177 = bitcast {%..string, i8}* %20 to %..rawptr
	%178 = call %..rawptr @mem.zero(%..rawptr %177, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %20
	%179 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %20, i64 0, i32 0
	store %..string %175, %..string* %179
	%180 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %20, i64 0, i32 1
	store i8 %176, i8* %180
	%181 = load {%..string, i8}, {%..string, i8}* %20, align 8
	ret {%..string, i8} %181

typeswitch.next-13:
	%182 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%183 = load %..typeid, %..typeid* %182, align 8
	%184 = icmp eq %..typeid %183, 72057594037927939
	br i1 %184, label %typeswitch.body-16, label %typeswitch.next-15

typeswitch.body-14:
	%185 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%186 = load %..rawptr, %..rawptr* %185, align 8
	%187 = bitcast %..rawptr %186 to i64*
	%188 = load i64, i64* %187, align 8
	store i64 %188, i64* %21
	; ReturnStmt
	%189 = load i64, i64* %21, align 8
	%190 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%191 = bitcast %runtime.Type_Info_Enum* %22 to %..rawptr
	%192 = call %..rawptr @mem.zero(%..rawptr %191, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %22
	store %runtime.Type_Info_Enum %190, %runtime.Type_Info_Enum* %22
	%193 = call {%..string, i8} @fmt.enum_value_to_string.get_str-5(i64 %189, %runtime.Type_Info_Enum* %22, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%194 = extractvalue {%..string, i8} %193, 0
	%195 = extractvalue {%..string, i8} %193, 1
	%196 = bitcast {%..string, i8}* %23 to %..rawptr
	%197 = call %..rawptr @mem.zero(%..rawptr %196, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %23
	%198 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %23, i64 0, i32 0
	store %..string %194, %..string* %198
	%199 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %23, i64 0, i32 1
	store i8 %195, i8* %199
	%200 = load {%..string, i8}, {%..string, i8}* %23, align 8
	ret {%..string, i8} %200

typeswitch.next-15:
	%201 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%202 = load %..typeid, %..typeid* %201, align 8
	%203 = icmp eq %..typeid %202, 72057594037928001
	br i1 %203, label %typeswitch.body-18, label %typeswitch.next-17

typeswitch.body-16:
	%204 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%205 = load %..rawptr, %..rawptr* %204, align 8
	%206 = bitcast %..rawptr %205 to i8*
	%207 = load i8, i8* %206, align 1
	store i8 %207, i8* %24
	; ReturnStmt
	%208 = load i8, i8* %24, align 1
	%209 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%210 = bitcast %runtime.Type_Info_Enum* %25 to %..rawptr
	%211 = call %..rawptr @mem.zero(%..rawptr %210, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %25
	store %runtime.Type_Info_Enum %209, %runtime.Type_Info_Enum* %25
	%212 = call {%..string, i8} @fmt.enum_value_to_string.get_str-6(i8 %208, %runtime.Type_Info_Enum* %25, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%213 = extractvalue {%..string, i8} %212, 0
	%214 = extractvalue {%..string, i8} %212, 1
	%215 = bitcast {%..string, i8}* %26 to %..rawptr
	%216 = call %..rawptr @mem.zero(%..rawptr %215, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %26
	%217 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %26, i64 0, i32 0
	store %..string %213, %..string* %217
	%218 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %26, i64 0, i32 1
	store i8 %214, i8* %218
	%219 = load {%..string, i8}, {%..string, i8}* %26, align 8
	ret {%..string, i8} %219

typeswitch.next-17:
	%220 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%221 = load %..typeid, %..typeid* %220, align 8
	%222 = icmp eq %..typeid %221, 72057594037928002
	br i1 %222, label %typeswitch.body-20, label %typeswitch.next-19

typeswitch.body-18:
	%223 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%224 = load %..rawptr, %..rawptr* %223, align 8
	%225 = bitcast %..rawptr %224 to i16*
	%226 = load i16, i16* %225, align 2
	store i16 %226, i16* %27
	; ReturnStmt
	%227 = load i16, i16* %27, align 2
	%228 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%229 = bitcast %runtime.Type_Info_Enum* %28 to %..rawptr
	%230 = call %..rawptr @mem.zero(%..rawptr %229, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %28
	store %runtime.Type_Info_Enum %228, %runtime.Type_Info_Enum* %28
	%231 = call {%..string, i8} @fmt.enum_value_to_string.get_str-7(i16 %227, %runtime.Type_Info_Enum* %28, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%232 = extractvalue {%..string, i8} %231, 0
	%233 = extractvalue {%..string, i8} %231, 1
	%234 = bitcast {%..string, i8}* %29 to %..rawptr
	%235 = call %..rawptr @mem.zero(%..rawptr %234, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %29
	%236 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %29, i64 0, i32 0
	store %..string %232, %..string* %236
	%237 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %29, i64 0, i32 1
	store i8 %233, i8* %237
	%238 = load {%..string, i8}, {%..string, i8}* %29, align 8
	ret {%..string, i8} %238

typeswitch.next-19:
	%239 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%240 = load %..typeid, %..typeid* %239, align 8
	%241 = icmp eq %..typeid %240, 72057594037927943
	br i1 %241, label %typeswitch.body-22, label %typeswitch.next-21

typeswitch.body-20:
	%242 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%243 = load %..rawptr, %..rawptr* %242, align 8
	%244 = bitcast %..rawptr %243 to i32*
	%245 = load i32, i32* %244, align 4
	store i32 %245, i32* %30
	; ReturnStmt
	%246 = load i32, i32* %30, align 4
	%247 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%248 = bitcast %runtime.Type_Info_Enum* %31 to %..rawptr
	%249 = call %..rawptr @mem.zero(%..rawptr %248, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %31
	store %runtime.Type_Info_Enum %247, %runtime.Type_Info_Enum* %31
	%250 = call {%..string, i8} @fmt.enum_value_to_string.get_str-8(i32 %246, %runtime.Type_Info_Enum* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%251 = extractvalue {%..string, i8} %250, 0
	%252 = extractvalue {%..string, i8} %250, 1
	%253 = bitcast {%..string, i8}* %32 to %..rawptr
	%254 = call %..rawptr @mem.zero(%..rawptr %253, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %32
	%255 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %32, i64 0, i32 0
	store %..string %251, %..string* %255
	%256 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %32, i64 0, i32 1
	store i8 %252, i8* %256
	%257 = load {%..string, i8}, {%..string, i8}* %32, align 8
	ret {%..string, i8} %257

typeswitch.next-21:
	%258 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%259 = load %..typeid, %..typeid* %258, align 8
	%260 = icmp eq %..typeid %259, 72057594037928003
	br i1 %260, label %typeswitch.body-24, label %typeswitch.next-23

typeswitch.body-22:
	%261 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%262 = load %..rawptr, %..rawptr* %261, align 8
	%263 = bitcast %..rawptr %262 to i64*
	%264 = load i64, i64* %263, align 8
	store i64 %264, i64* %33
	; ReturnStmt
	%265 = load i64, i64* %33, align 8
	%266 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%267 = bitcast %runtime.Type_Info_Enum* %34 to %..rawptr
	%268 = call %..rawptr @mem.zero(%..rawptr %267, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %34
	store %runtime.Type_Info_Enum %266, %runtime.Type_Info_Enum* %34
	%269 = call {%..string, i8} @fmt.enum_value_to_string.get_str-9(i64 %265, %runtime.Type_Info_Enum* %34, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%270 = extractvalue {%..string, i8} %269, 0
	%271 = extractvalue {%..string, i8} %269, 1
	%272 = bitcast {%..string, i8}* %35 to %..rawptr
	%273 = call %..rawptr @mem.zero(%..rawptr %272, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %35
	%274 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %35, i64 0, i32 0
	store %..string %270, %..string* %274
	%275 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %35, i64 0, i32 1
	store i8 %271, i8* %275
	%276 = load {%..string, i8}, {%..string, i8}* %35, align 8
	ret {%..string, i8} %276

typeswitch.next-23:
	%277 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%278 = load %..typeid, %..typeid* %277, align 8
	%279 = icmp eq %..typeid %278, 72057594037927986
	br i1 %279, label %typeswitch.body-26, label %typeswitch.next-25

typeswitch.body-24:
	%280 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%281 = load %..rawptr, %..rawptr* %280, align 8
	%282 = bitcast %..rawptr %281 to i64*
	%283 = load i64, i64* %282, align 8
	store i64 %283, i64* %36
	; ReturnStmt
	%284 = load i64, i64* %36, align 8
	%285 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%286 = bitcast %runtime.Type_Info_Enum* %37 to %..rawptr
	%287 = call %..rawptr @mem.zero(%..rawptr %286, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %37
	store %runtime.Type_Info_Enum %285, %runtime.Type_Info_Enum* %37
	%288 = call {%..string, i8} @fmt.enum_value_to_string.get_str-10(i64 %284, %runtime.Type_Info_Enum* %37, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%289 = extractvalue {%..string, i8} %288, 0
	%290 = extractvalue {%..string, i8} %288, 1
	%291 = bitcast {%..string, i8}* %38 to %..rawptr
	%292 = call %..rawptr @mem.zero(%..rawptr %291, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %38
	%293 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %38, i64 0, i32 0
	store %..string %289, %..string* %293
	%294 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %38, i64 0, i32 1
	store i8 %290, i8* %294
	%295 = load {%..string, i8}, {%..string, i8}* %38, align 8
	ret {%..string, i8} %295

typeswitch.next-25:
	; ReturnStmt
	%296 = bitcast {%..string, i8}* %44 to %..rawptr
	%297 = call %..rawptr @mem.zero(%..rawptr %296, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %44
	%298 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %44, i64 0, i32 0
	store %..string zeroinitializer, %..string* %298
	%299 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %44, i64 0, i32 1
	store i8 0, i8* %299
	%300 = load {%..string, i8}, {%..string, i8}* %44, align 8
	ret {%..string, i8} %300

typeswitch.body-26:
	%301 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%302 = load %..rawptr, %..rawptr* %301, align 8
	%303 = bitcast %..rawptr %302 to i64*
	%304 = load i64, i64* %303, align 8
	store i64 %304, i64* %39
	; ReturnStmt
	%305 = load i64, i64* %39, align 8
	%306 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%307 = bitcast %runtime.Type_Info_Enum* %40 to %..rawptr
	%308 = call %..rawptr @mem.zero(%..rawptr %307, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %40
	store %runtime.Type_Info_Enum %306, %runtime.Type_Info_Enum* %40
	%309 = call {%..string, i8} @fmt.enum_value_to_string.get_str-11(i64 %305, %runtime.Type_Info_Enum* %40, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%310 = extractvalue {%..string, i8} %309, 0
	%311 = extractvalue {%..string, i8} %309, 1
	%312 = bitcast {%..string, i8}* %41 to %..rawptr
	%313 = call %..rawptr @mem.zero(%..rawptr %312, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %41
	%314 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %41, i64 0, i32 0
	store %..string %310, %..string* %314
	%315 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %41, i64 0, i32 1
	store i8 %311, i8* %315
	%316 = load {%..string, i8}, {%..string, i8}* %41, align 8
	ret {%..string, i8} %316
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-0(i32 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i32, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i32, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i32, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i32, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i32 %i, i32* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i32, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 1
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i32*
	%52 = load i32, i32* %51, align 4
	store i32 %52, i32* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i32, i8}, {i32, i8}* %7, align 4
	%54 = extractvalue {i32, i8} %53, 0
	%55 = extractvalue {i32, i8} %53, 1
	store i32 %54, i32* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i32, i32* %5, align 4
	%59 = load i32, i32* %0, align 4
	%60 = icmp eq i32 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$11d, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i32, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 1
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i32*
	%114 = load i32, i32* %113, align 4
	store i32 %114, i32* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i32, i8}, {i32, i8}* %16, align 4
	%116 = extractvalue {i32, i8} %115, 0
	%117 = extractvalue {i32, i8} %115, 1
	store i32 %116, i32* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i32, i32* %14, align 4
	%121 = load i32, i32* %0, align 4
	%122 = icmp eq i32 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$11e, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-1(i8 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i8, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i8, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i8, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i8, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i8 %i, i8* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i8, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 2) noinline
	store {i8, i8} zeroinitializer, {i8, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 2
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i8, i8}, {i8, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i8, i8}, {i8, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i8*
	%52 = load i8, i8* %51, align 1
	store i8 %52, i8* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i8, i8}, {i8, i8}* %7, align 1
	%54 = extractvalue {i8, i8} %53, 0
	%55 = extractvalue {i8, i8} %53, 1
	store i8 %54, i8* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i8, i8* %5, align 1
	%59 = load i8, i8* %0, align 1
	%60 = icmp eq i8 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$11f, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i8, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 2) noinline
	store {i8, i8} zeroinitializer, {i8, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 2
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i8, i8}, {i8, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i8, i8}, {i8, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i8*
	%114 = load i8, i8* %113, align 1
	store i8 %114, i8* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i8, i8}, {i8, i8}* %16, align 1
	%116 = extractvalue {i8, i8} %115, 0
	%117 = extractvalue {i8, i8} %115, 1
	store i8 %116, i8* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i8, i8* %14, align 1
	%121 = load i8, i8* %0, align 1
	%122 = icmp eq i8 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$120, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-2(i16 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i16, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i16, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i16, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i16, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i16, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i16 %i, i16* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i16, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 4) noinline
	store {i16, i8} zeroinitializer, {i16, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 3
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i16, i8}, {i16, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i16, i8}, {i16, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i16*
	%52 = load i16, i16* %51, align 2
	store i16 %52, i16* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i16, i8}, {i16, i8}* %7, align 2
	%54 = extractvalue {i16, i8} %53, 0
	%55 = extractvalue {i16, i8} %53, 1
	store i16 %54, i16* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i16, i16* %5, align 2
	%59 = load i16, i16* %0, align 2
	%60 = icmp eq i16 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$121, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i16, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 4) noinline
	store {i16, i8} zeroinitializer, {i16, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 3
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i16, i8}, {i16, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i16, i8}, {i16, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i16*
	%114 = load i16, i16* %113, align 2
	store i16 %114, i16* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i16, i8}, {i16, i8}* %16, align 2
	%116 = extractvalue {i16, i8} %115, 0
	%117 = extractvalue {i16, i8} %115, 1
	store i16 %116, i16* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i16, i16* %14, align 2
	%121 = load i16, i16* %0, align 2
	%122 = icmp eq i16 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$122, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-3(i32 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i32, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i32, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i32, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i32, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i32 %i, i32* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i32, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 4
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i32*
	%52 = load i32, i32* %51, align 4
	store i32 %52, i32* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i32, i8}, {i32, i8}* %7, align 4
	%54 = extractvalue {i32, i8} %53, 0
	%55 = extractvalue {i32, i8} %53, 1
	store i32 %54, i32* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i32, i32* %5, align 4
	%59 = load i32, i32* %0, align 4
	%60 = icmp eq i32 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$123, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i32, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 4
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i32*
	%114 = load i32, i32* %113, align 4
	store i32 %114, i32* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i32, i8}, {i32, i8}* %16, align 4
	%116 = extractvalue {i32, i8} %115, 0
	%117 = extractvalue {i32, i8} %115, 1
	store i32 %116, i32* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i32, i32* %14, align 4
	%121 = load i32, i32* %0, align 4
	%122 = icmp eq i32 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$124, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-4(i64 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i64, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i64 %i, i64* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i64, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 5
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i64*
	%52 = load i64, i64* %51, align 8
	store i64 %52, i64* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i64, i8}, {i64, i8}* %7, align 8
	%54 = extractvalue {i64, i8} %53, 0
	%55 = extractvalue {i64, i8} %53, 1
	store i64 %54, i64* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i64, i64* %5, align 8
	%59 = load i64, i64* %0, align 8
	%60 = icmp eq i64 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$125, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i64, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 5
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i64*
	%114 = load i64, i64* %113, align 8
	store i64 %114, i64* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i64, i8}, {i64, i8}* %16, align 8
	%116 = extractvalue {i64, i8} %115, 0
	%117 = extractvalue {i64, i8} %115, 1
	store i64 %116, i64* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i64, i64* %14, align 8
	%121 = load i64, i64* %0, align 8
	%122 = icmp eq i64 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$126, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-5(i64 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i64, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i64 %i, i64* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i64, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 6
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i64*
	%52 = load i64, i64* %51, align 8
	store i64 %52, i64* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i64, i8}, {i64, i8}* %7, align 8
	%54 = extractvalue {i64, i8} %53, 0
	%55 = extractvalue {i64, i8} %53, 1
	store i64 %54, i64* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i64, i64* %5, align 8
	%59 = load i64, i64* %0, align 8
	%60 = icmp eq i64 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$127, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i64, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 6
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i64*
	%114 = load i64, i64* %113, align 8
	store i64 %114, i64* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i64, i8}, {i64, i8}* %16, align 8
	%116 = extractvalue {i64, i8} %115, 0
	%117 = extractvalue {i64, i8} %115, 1
	store i64 %116, i64* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i64, i64* %14, align 8
	%121 = load i64, i64* %0, align 8
	%122 = icmp eq i64 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$128, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-6(i8 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i8, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i8, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i8, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i8, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i8 %i, i8* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i8, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 2) noinline
	store {i8, i8} zeroinitializer, {i8, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 7
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i8, i8}, {i8, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i8, i8}, {i8, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i8*
	%52 = load i8, i8* %51, align 1
	store i8 %52, i8* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i8, i8}, {i8, i8}* %7, align 1
	%54 = extractvalue {i8, i8} %53, 0
	%55 = extractvalue {i8, i8} %53, 1
	store i8 %54, i8* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i8, i8* %5, align 1
	%59 = load i8, i8* %0, align 1
	%60 = icmp eq i8 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$129, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i8, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 2) noinline
	store {i8, i8} zeroinitializer, {i8, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 7
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i8, i8}, {i8, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i8, i8}, {i8, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i8*
	%114 = load i8, i8* %113, align 1
	store i8 %114, i8* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i8, i8}, {i8, i8}* %16, align 1
	%116 = extractvalue {i8, i8} %115, 0
	%117 = extractvalue {i8, i8} %115, 1
	store i8 %116, i8* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i8, i8* %14, align 1
	%121 = load i8, i8* %0, align 1
	%122 = icmp eq i8 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$12a, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-7(i16 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i16, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i16, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i16, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i16, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i16, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i16 %i, i16* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i16, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 4) noinline
	store {i16, i8} zeroinitializer, {i16, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 8
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i16, i8}, {i16, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i16, i8}, {i16, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i16*
	%52 = load i16, i16* %51, align 2
	store i16 %52, i16* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i16, i8}, {i16, i8}* %7, align 2
	%54 = extractvalue {i16, i8} %53, 0
	%55 = extractvalue {i16, i8} %53, 1
	store i16 %54, i16* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i16, i16* %5, align 2
	%59 = load i16, i16* %0, align 2
	%60 = icmp eq i16 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$12b, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i16, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 4) noinline
	store {i16, i8} zeroinitializer, {i16, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 8
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i16, i8}, {i16, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i16, i8}, {i16, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i16*
	%114 = load i16, i16* %113, align 2
	store i16 %114, i16* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i16, i8}, {i16, i8}* %16, align 2
	%116 = extractvalue {i16, i8} %115, 0
	%117 = extractvalue {i16, i8} %115, 1
	store i16 %116, i16* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i16, i16* %14, align 2
	%121 = load i16, i16* %0, align 2
	%122 = icmp eq i16 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$12c, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-8(i32 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i32, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i32, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i32, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i32, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i32 %i, i32* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i32, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 9
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i32*
	%52 = load i32, i32* %51, align 4
	store i32 %52, i32* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i32, i8}, {i32, i8}* %7, align 4
	%54 = extractvalue {i32, i8} %53, 0
	%55 = extractvalue {i32, i8} %53, 1
	store i32 %54, i32* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i32, i32* %5, align 4
	%59 = load i32, i32* %0, align 4
	%60 = icmp eq i32 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$12d, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i32, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 9
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i32*
	%114 = load i32, i32* %113, align 4
	store i32 %114, i32* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i32, i8}, {i32, i8}* %16, align 4
	%116 = extractvalue {i32, i8} %115, 0
	%117 = extractvalue {i32, i8} %115, 1
	store i32 %116, i32* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i32, i32* %14, align 4
	%121 = load i32, i32* %0, align 4
	%122 = icmp eq i32 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$12e, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-9(i64 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i64, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i64 %i, i64* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i64, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 10
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i64*
	%52 = load i64, i64* %51, align 8
	store i64 %52, i64* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i64, i8}, {i64, i8}* %7, align 8
	%54 = extractvalue {i64, i8} %53, 0
	%55 = extractvalue {i64, i8} %53, 1
	store i64 %54, i64* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i64, i64* %5, align 8
	%59 = load i64, i64* %0, align 8
	%60 = icmp eq i64 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$12f, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i64, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 10
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i64*
	%114 = load i64, i64* %113, align 8
	store i64 %114, i64* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i64, i8}, {i64, i8}* %16, align 8
	%116 = extractvalue {i64, i8} %115, 0
	%117 = extractvalue {i64, i8} %115, 1
	store i64 %116, i64* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i64, i64* %14, align 8
	%121 = load i64, i64* %0, align 8
	%122 = icmp eq i64 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$130, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-10(i64 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i64, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i64 %i, i64* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i64, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 11
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i64*
	%52 = load i64, i64* %51, align 8
	store i64 %52, i64* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i64, i8}, {i64, i8}* %7, align 8
	%54 = extractvalue {i64, i8} %53, 0
	%55 = extractvalue {i64, i8} %53, 1
	store i64 %54, i64* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i64, i64* %5, align 8
	%59 = load i64, i64* %0, align 8
	%60 = icmp eq i64 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$131, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i64, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 11
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i64*
	%114 = load i64, i64* %113, align 8
	store i64 %114, i64* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i64, i8}, {i64, i8}* %16, align 8
	%116 = extractvalue {i64, i8} %115, 0
	%117 = extractvalue {i64, i8} %115, 1
	store i64 %116, i64* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i64, i64* %14, align 8
	%121 = load i64, i64* %0, align 8
	%122 = icmp eq i64 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$132, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-11(i64 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i64, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i64 %i, i64* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i64, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 12
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i64*
	%52 = load i64, i64* %51, align 8
	store i64 %52, i64* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i64, i8}, {i64, i8}* %7, align 8
	%54 = extractvalue {i64, i8} %53, 0
	%55 = extractvalue {i64, i8} %53, 1
	store i64 %54, i64* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i64, i64* %5, align 8
	%59 = load i64, i64* %0, align 8
	%60 = icmp eq i64 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$133, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i64, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 12
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i64*
	%114 = load i64, i64* %113, align 8
	store i64 %114, i64* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i64, i8}, {i64, i8}* %16, align 8
	%116 = extractvalue {i64, i8} %115, 0
	%117 = extractvalue {i64, i8} %115, 1
	store i64 %116, i64* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i64, i64* %14, align 8
	%121 = load i64, i64* %0, align 8
	%122 = icmp eq i64 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$134, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define void @fmt.fmt_enum(%fmt.Fmt_Info* %fi, %..any %v, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca i32, align 16
	%3 = alloca %runtime.Type_Info*, align 16
	%4 = alloca %runtime.Type_Info_Enum, align 16
	%5 = alloca %..any, align 16
	%6 = alloca %runtime.Type_Info*, align 16
	%7 = alloca %..string, align 16
	%8 = alloca i8, align 16
	%9 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..any %v, %..any* %1
	store i32 %verb, i32* %2
	; IfStmt
	; SelectorExpr
	%10 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%11 = load %..typeid, %..typeid* %10, align 8
	%12 = icmp eq %..typeid %11, 0
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %if.then-2, label %cmp.or-1

cmp.or-1:
	; SelectorExpr
	%15 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%16 = load %..rawptr, %..rawptr* %15, align 8
	%17 = icmp eq %..rawptr %16, zeroinitializer
	%18 = zext i1 %17 to i8
	%19 = trunc i8 %18 to i1
	br i1 %19, label %if.then-2, label %if.done-3

if.then-2:
	; SelectorExpr
	%20 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%21 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %20, i64 0
	%22 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %21, i64 0, i32 12
	%23 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %22, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %23, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$135, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-3:
	; type_info
	; SelectorExpr
	%24 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%25 = load %..typeid, %..typeid* %24, align 8
	%26 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %25)
	store %runtime.Type_Info* %26, %runtime.Type_Info** %3
	; TypeSwitchStmt
	; SelectorExpr
	%27 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%28 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %27, i64 0
	%29 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %28, i64 0, i32 3
	%30 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %29, align 8
	; get union's tag
	%31 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %29, i64 0, i32 2 ; UnionTagPtr
	%32 = load i8, i8* %31, align 1
	%33 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %29 to %..rawptr
	%34 = icmp eq i8 %32, 18
	br i1 %34, label %typeswitch.body-5, label %typeswitch.next-4

typeswitch.next-4:
	store {[0 x <8 x i8>], [72 x i8], i8} %30, {[0 x <8 x i8>], [72 x i8], i8}* %9
	%35 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%36 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %35, i32 %36, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-15

typeswitch.body-5:
	%37 = bitcast %..rawptr %33 to %runtime.Type_Info_Enum*
	%38 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %37, align 8
	store %runtime.Type_Info_Enum %38, %runtime.Type_Info_Enum* %4
	; SwitchStmt
	%39 = load i32, i32* %2, align 4
	%40 = icmp eq i32 %39, 100
	br i1 %40, label %switch.fall.body-8, label %switch.case.next-6

switch.case.next-6:
	%41 = icmp eq i32 %39, 102
	br i1 %41, label %switch.fall.body-8, label %switch.case.next-7

switch.case.next-7:
	%42 = icmp eq i32 %39, 115
	br i1 %42, label %switch.fall.body-11, label %switch.case.next-9

switch.fall.body-8:
	%43 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%44 = bitcast %..any* %5 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 16) noinline
	store %..any zeroinitializer, %..any* %5
	store %..any zeroinitializer, %..any* %5
	; SelectorExpr
	%46 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%47 = load %..rawptr, %..rawptr* %46, align 8
	%48 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	store %..rawptr %47, %..rawptr* %48
	; SelectorExpr
	; SelectorExpr
	; SelectorExpr
	%49 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %4, i64 0, i32 0
	%50 = load %runtime.Type_Info*, %runtime.Type_Info** %49, align 8
	%51 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %50)
	%52 = bitcast %runtime.Type_Info** %6 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %6
	store %runtime.Type_Info* %51, %runtime.Type_Info** %6
	%54 = load %runtime.Type_Info*, %runtime.Type_Info** %6, align 8
	%55 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %54, i64 0
	%56 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %55, i64 0, i32 2
	%57 = load %..typeid, %..typeid* %56, align 8
	%58 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	store %..typeid %57, %..typeid* %58
	%59 = load %..any, %..any* %5, align 8
	%60 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %43, %..any %59, i32 %60, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-14

switch.case.next-9:
	%61 = icmp eq i32 %39, 118
	br i1 %61, label %switch.fall.body-11, label %switch.case.next-10

switch.case.next-10:
	%62 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%63 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %62, i32 %63, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-14

switch.fall.body-11:
	; str
	; ok
	%64 = load %..any, %..any* %1, align 8
	%65 = call {%..string, i8} @fmt.enum_value_to_string(%..any %64, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%66 = extractvalue {%..string, i8} %65, 0
	%67 = extractvalue {%..string, i8} %65, 1
	store %..string %66, %..string* %7
	store i8 %67, i8* %8
	; IfStmt
	%68 = load i8, i8* %8, align 1
	%69 = trunc i8 %68 to i1
	br i1 %69, label %if.done-13, label %if.then-12

if.then-12:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$136, i64 0, i32 0), i64 18}, %..string* %7
	br label %if.done-13

if.done-13:
	; SelectorExpr
	%70 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%71 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %70, i64 0
	%72 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %71, i64 0, i32 12
	%73 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %72, align 8
	%74 = load %..string, %..string* %7, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %73, %..string %74, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-14

switch.done-14:
	br label %typeswitch.done-15

typeswitch.done-15:
	ret void
}

define i64 @fmt.enum_value_to_u64(%runtime.Type_Info_Enum_Value* %ev, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i8, align 16
	%2 = alloca i16, align 16
	%3 = alloca i32, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca i16, align 16
	%8 = alloca i32, align 16
	%9 = alloca i64, align 16
	%10 = alloca i64, align 16
	%11 = alloca i64, align 16
	%12 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %ev, align 8
	; TypeSwitchStmt
	%13 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %ev, align 8
	; get union's tag
	%14 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %ev, i64 0, i32 2 ; UnionTagPtr
	%15 = load i8, i8* %14, align 1
	%16 = bitcast %runtime.Type_Info_Enum_Value* %ev to %..rawptr
	%17 = icmp eq i8 %15, 1
	br i1 %17, label %typeswitch.body-2, label %typeswitch.next-1

typeswitch.next-1:
	%18 = icmp eq i8 %15, 2
	br i1 %18, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.body-2:
	%19 = bitcast %..rawptr %16 to i32*
	%20 = load i32, i32* %19, align 4
	store i32 %20, i32* %0
	; ReturnStmt
	%21 = load i32, i32* %0, align 4
	%22 = sext i32 %21 to i64
	ret i64 %22

typeswitch.next-3:
	%23 = icmp eq i8 %15, 3
	br i1 %23, label %typeswitch.body-6, label %typeswitch.next-5

typeswitch.body-4:
	%24 = bitcast %..rawptr %16 to i8*
	%25 = load i8, i8* %24, align 1
	store i8 %25, i8* %1
	; ReturnStmt
	%26 = load i8, i8* %1, align 1
	%27 = sext i8 %26 to i64
	ret i64 %27

typeswitch.next-5:
	%28 = icmp eq i8 %15, 4
	br i1 %28, label %typeswitch.body-8, label %typeswitch.next-7

typeswitch.body-6:
	%29 = bitcast %..rawptr %16 to i16*
	%30 = load i16, i16* %29, align 2
	store i16 %30, i16* %2
	; ReturnStmt
	%31 = load i16, i16* %2, align 2
	%32 = sext i16 %31 to i64
	ret i64 %32

typeswitch.next-7:
	%33 = icmp eq i8 %15, 5
	br i1 %33, label %typeswitch.body-10, label %typeswitch.next-9

typeswitch.body-8:
	%34 = bitcast %..rawptr %16 to i32*
	%35 = load i32, i32* %34, align 4
	store i32 %35, i32* %3
	; ReturnStmt
	%36 = load i32, i32* %3, align 4
	%37 = sext i32 %36 to i64
	ret i64 %37

typeswitch.next-9:
	%38 = icmp eq i8 %15, 6
	br i1 %38, label %typeswitch.body-12, label %typeswitch.next-11

typeswitch.body-10:
	%39 = bitcast %..rawptr %16 to i64*
	%40 = load i64, i64* %39, align 8
	store i64 %40, i64* %4
	; ReturnStmt
	%41 = load i64, i64* %4, align 8
	%42 = bitcast i64 %41 to i64
	ret i64 %42

typeswitch.next-11:
	%43 = icmp eq i8 %15, 7
	br i1 %43, label %typeswitch.body-14, label %typeswitch.next-13

typeswitch.body-12:
	%44 = bitcast %..rawptr %16 to i64*
	%45 = load i64, i64* %44, align 8
	store i64 %45, i64* %5
	; ReturnStmt
	%46 = load i64, i64* %5, align 8
	%47 = bitcast i64 %46 to i64
	ret i64 %47

typeswitch.next-13:
	%48 = icmp eq i8 %15, 8
	br i1 %48, label %typeswitch.body-16, label %typeswitch.next-15

typeswitch.body-14:
	%49 = bitcast %..rawptr %16 to i8*
	%50 = load i8, i8* %49, align 1
	store i8 %50, i8* %6
	; ReturnStmt
	%51 = load i8, i8* %6, align 1
	%52 = zext i8 %51 to i64
	ret i64 %52

typeswitch.next-15:
	%53 = icmp eq i8 %15, 9
	br i1 %53, label %typeswitch.body-18, label %typeswitch.next-17

typeswitch.body-16:
	%54 = bitcast %..rawptr %16 to i16*
	%55 = load i16, i16* %54, align 2
	store i16 %55, i16* %7
	; ReturnStmt
	%56 = load i16, i16* %7, align 2
	%57 = zext i16 %56 to i64
	ret i64 %57

typeswitch.next-17:
	%58 = icmp eq i8 %15, 10
	br i1 %58, label %typeswitch.body-20, label %typeswitch.next-19

typeswitch.body-18:
	%59 = bitcast %..rawptr %16 to i32*
	%60 = load i32, i32* %59, align 4
	store i32 %60, i32* %8
	; ReturnStmt
	%61 = load i32, i32* %8, align 4
	%62 = zext i32 %61 to i64
	ret i64 %62

typeswitch.next-19:
	%63 = icmp eq i8 %15, 11
	br i1 %63, label %typeswitch.body-22, label %typeswitch.next-21

typeswitch.body-20:
	%64 = bitcast %..rawptr %16 to i64*
	%65 = load i64, i64* %64, align 8
	store i64 %65, i64* %9
	; ReturnStmt
	%66 = load i64, i64* %9, align 8
	ret i64 %66

typeswitch.next-21:
	%67 = icmp eq i8 %15, 12
	br i1 %67, label %typeswitch.body-24, label %typeswitch.next-23

typeswitch.body-22:
	%68 = bitcast %..rawptr %16 to i64*
	%69 = load i64, i64* %68, align 8
	store i64 %69, i64* %10
	; ReturnStmt
	%70 = load i64, i64* %10, align 8
	%71 = bitcast i64 %70 to i64
	ret i64 %71

typeswitch.next-23:
	; ReturnStmt
	ret i64 0

typeswitch.body-24:
	%72 = bitcast %..rawptr %16 to i64*
	%73 = load i64, i64* %72, align 8
	store i64 %73, i64* %11
	; ReturnStmt
	%74 = load i64, i64* %11, align 8
	%75 = bitcast i64 %74 to i64
	ret i64 %75
}

define void @fmt.fmt_bit_set(%fmt.Fmt_Info* %fi, %..any %v, %..string %name, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca %..string, align 16
	%3 = alloca %runtime.Type_Info*, align 16
	%4 = alloca %runtime.Type_Info_Named, align 16
	%5 = alloca %..any, align 16
	%6 = alloca %runtime.Type_Info_Bit_Set, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca i32, align 16
	%10 = alloca %runtime.Source_Code_Location, align 16
	%11 = alloca %runtime.Type_Info*, align 16
	%12 = alloca %runtime.Type_Info_Enum, align 16
	%13 = alloca i8, align 16
	%14 = alloca {%runtime.Type_Info_Enum, i8}, align 16
	%15 = alloca i64, align 16
	%16 = alloca i64, align 16
	%17 = alloca i64, align 16
	%18 = alloca i64, align 16
	%19 = alloca %runtime.Type_Info_Enum_Value, align 16
	%20 = alloca i64, align 16
	%21 = alloca i64, align 16
	%22 = alloca i64, align 16
	%23 = alloca i64, align 16
	%24 = alloca %runtime.Type_Info_Enum_Value, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..any %v, %..any* %1
	store %..string %name, %..string* %2
	; type_info
	; SelectorExpr
	%25 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%26 = load %..typeid, %..typeid* %25, align 8
	%27 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %26)
	store %runtime.Type_Info* %27, %runtime.Type_Info** %3
	; TypeSwitchStmt
	; SelectorExpr
	%28 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%29 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %28, i64 0
	%30 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %29, i64 0, i32 3
	%31 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %30, align 8
	; get union's tag
	%32 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %30, i64 0, i32 2 ; UnionTagPtr
	%33 = load i8, i8* %32, align 1
	%34 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %30 to %..rawptr
	%35 = icmp eq i8 %33, 1
	br i1 %35, label %typeswitch.body-2, label %typeswitch.next-1

typeswitch.next-1:
	%36 = icmp eq i8 %33, 21
	br i1 %36, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.body-2:
	%37 = bitcast %..rawptr %34 to %runtime.Type_Info_Named*
	%38 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %37, align 8
	store %runtime.Type_Info_Named %38, %runtime.Type_Info_Named* %4
	; val
	%39 = load %..any, %..any* %1, align 8
	store %..any %39, %..any* %5
	; AssignStmt
	; SelectorExpr
	%40 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	; SelectorExpr
	; SelectorExpr
	%41 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 1
	%42 = load %runtime.Type_Info*, %runtime.Type_Info** %41, align 8
	%43 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %42, i64 0
	%44 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %43, i64 0, i32 2
	%45 = load %..typeid, %..typeid* %44, align 8
	store %..typeid %45, %..typeid* %40
	%46 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%47 = load %..any, %..any* %5, align 8
	; SelectorExpr
	%48 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 0
	%49 = load %..string, %..string* %48, align 8
	call void @fmt.fmt_bit_set(%fmt.Fmt_Info* %46, %..any %47, %..string %49, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-35

typeswitch.next-3:
	br label %typeswitch.done-35

typeswitch.body-4:
	%50 = bitcast %..rawptr %34 to %runtime.Type_Info_Bit_Set*
	%51 = load %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, align 8
	store %runtime.Type_Info_Bit_Set %51, %runtime.Type_Info_Bit_Set* %6
	; bits
	%52 = bitcast i64* %7 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 8) noinline
	store i64 zeroinitializer, i64* %7
	; bit_size
	; SelectorExpr
	%54 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%55 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %54, i64 0
	%56 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %55, i64 0, i32 0
	%57 = load i64, i64* %56, align 8
	%58 = mul i64 8, %57
	%59 = bitcast i64 %58 to i64
	store i64 %59, i64* %8
	; verb
	store i32 98, i32* %9
	; SwitchStmt
	%60 = load i64, i64* %8, align 8
	%61 = icmp eq i64 %60, 0
	br i1 %61, label %switch.case.body-6, label %switch.case.next-5

switch.case.next-5:
	%62 = icmp eq i64 %60, 8
	br i1 %62, label %switch.fall.body-8, label %switch.case.next-7

switch.case.body-6:
	; AssignStmt
	store i64 0, i64* %7
	br label %switch.done-15

switch.case.next-7:
	%63 = icmp eq i64 %60, 16
	br i1 %63, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	; AssignStmt
	; SelectorExpr
	%64 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%65 = load %..rawptr, %..rawptr* %64, align 8
	%66 = bitcast %..rawptr %65 to i8*
	%67 = getelementptr inbounds i8, i8* %66, i64 0
	%68 = load i8, i8* %67, align 1
	%69 = zext i8 %68 to i64
	store i64 %69, i64* %7
	br label %switch.done-15

switch.case.next-9:
	%70 = icmp eq i64 %60, 32
	br i1 %70, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	; AssignStmt
	; SelectorExpr
	%71 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%72 = load %..rawptr, %..rawptr* %71, align 8
	%73 = bitcast %..rawptr %72 to i16*
	%74 = getelementptr inbounds i16, i16* %73, i64 0
	%75 = load i16, i16* %74, align 2
	%76 = zext i16 %75 to i64
	store i64 %76, i64* %7
	br label %switch.done-15

switch.case.next-11:
	%77 = icmp eq i64 %60, 64
	br i1 %77, label %switch.fall.body-14, label %switch.case.next-13

switch.fall.body-12:
	; AssignStmt
	; SelectorExpr
	%78 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%79 = load %..rawptr, %..rawptr* %78, align 8
	%80 = bitcast %..rawptr %79 to i32*
	%81 = getelementptr inbounds i32, i32* %80, i64 0
	%82 = load i32, i32* %81, align 4
	%83 = zext i32 %82 to i64
	store i64 %83, i64* %7
	br label %switch.done-15

switch.case.next-13:
	%84 = bitcast %runtime.Source_Code_Location* %10 to %..rawptr
	%85 = call %..rawptr @mem.zero(%..rawptr %84, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %10
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$137, i64 0, i32 0), i64 53}, i64 849, i64 9, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$138, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %10
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$139, i64 0, i32 0), i64 21}, %runtime.Source_Code_Location* %10) noreturn
	br label %switch.done-15

switch.fall.body-14:
	; AssignStmt
	; SelectorExpr
	%86 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%87 = load %..rawptr, %..rawptr* %86, align 8
	%88 = bitcast %..rawptr %87 to i64*
	%89 = getelementptr inbounds i64, i64* %88, i64 0
	%90 = load i64, i64* %89, align 8
	store i64 %90, i64* %7
	br label %switch.done-15

switch.done-15:
	; et
	; SelectorExpr
	; SelectorExpr
	%91 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %6, i64 0, i32 0
	%92 = load %runtime.Type_Info*, %runtime.Type_Info** %91, align 8
	%93 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %92)
	store %runtime.Type_Info* %93, %runtime.Type_Info** %11
	; IfStmt
	%94 = load %..string, %..string* %2, align 8
	%95 = call i8 @runtime.string_ne(%..string %94, %..string zeroinitializer)
	%96 = trunc i8 %95 to i1
	br i1 %96, label %if.then-16, label %if.else-17

if.then-16:
	; SelectorExpr
	%97 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%98 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %97, i64 0
	%99 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %98, i64 0, i32 12
	%100 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %99, align 8
	%101 = load %..string, %..string* %2, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %100, %..string %101, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-18

if.else-17:
	; SelectorExpr
	%102 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%103 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %102, i64 0
	%104 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %103, i64 0, i32 12
	%105 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %104, align 8
	%106 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %105, %runtime.Type_Info* %106, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-18

if.done-18:
	; SelectorExpr
	%107 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%108 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %107, i64 0
	%109 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %108, i64 0, i32 12
	%110 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %109, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %110, i8 123, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	; e
	; is_enum
	; SelectorExpr
	%111 = load %runtime.Type_Info*, %runtime.Type_Info** %11, align 8
	%112 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %111, i64 0
	%113 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %112, i64 0, i32 3
	%114 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %113, align 8
	; cast - union_cast
	%115 = bitcast {%runtime.Type_Info_Enum, i8}* %14 to %..rawptr
	%116 = call %..rawptr @mem.zero(%..rawptr %115, i64 48) noinline
	store {%runtime.Type_Info_Enum, i8} zeroinitializer, {%runtime.Type_Info_Enum, i8}* %14
	%117 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %113, i64 0, i32 2 ; UnionTagPtr
	%118 = load i8, i8* %117, align 1
	%119 = icmp eq i8 %118, 18
	br i1 %119, label %union_cast.ok-19, label %union_cast.end-20

union_cast.ok-19:
	%120 = getelementptr inbounds {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %14, i64 0, i32 0
	%121 = getelementptr inbounds {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %14, i64 0, i32 1
	%122 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %113 to %runtime.Type_Info_Enum*
	%123 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %122, align 8
	store %runtime.Type_Info_Enum %123, %runtime.Type_Info_Enum* %120
	store i8 1, i8* %121
	br label %union_cast.end-20

union_cast.end-20:
	%124 = load {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %14, align 8
	%125 = extractvalue {%runtime.Type_Info_Enum, i8} %124, 0
	%126 = extractvalue {%runtime.Type_Info_Enum, i8} %124, 1
	store %runtime.Type_Info_Enum %125, %runtime.Type_Info_Enum* %12
	store i8 %126, i8* %13
	; commas
	store i64 0, i64* %15
	; RangeStmt
	; i
	%127 = bitcast i64* %16 to %..rawptr
	%128 = call %..rawptr @mem.zero(%..rawptr %127, i64 8) noinline
	store i64 zeroinitializer, i64* %16
	%129 = bitcast i64* %17 to %..rawptr
	%130 = call %..rawptr @mem.zero(%..rawptr %129, i64 8) noinline
	store i64 zeroinitializer, i64* %17
	store i64 0, i64* %17
	%131 = bitcast i64* %18 to %..rawptr
	%132 = call %..rawptr @mem.zero(%..rawptr %131, i64 8) noinline
	store i64 zeroinitializer, i64* %18
	store i64 0, i64* %18
	br label %for.interval.loop-21

for.interval.loop-21:
	%133 = load i64, i64* %8, align 8
	%134 = sub i64 %133, 1
	%135 = load i64, i64* %17, align 8
	%136 = icmp ule i64 %135, %134
	br i1 %136, label %for.interval.body-22, label %for.interval.done-34

for.interval.body-22:
	%137 = load i64, i64* %17, align 8
	%138 = load i64, i64* %18, align 8
	%139 = load i64, i64* %17, align 8
	%140 = add i64 %139, 1
	store i64 %140, i64* %17
	%141 = load i64, i64* %18, align 8
	%142 = add i64 %141, 1
	store i64 %142, i64* %18
	store i64 %137, i64* %16
	; IfStmt
	%143 = load i64, i64* %7, align 8
	%144 = load i64, i64* %16, align 8
	%145 = shl i64 1, %144
	%146 = and i64 %143, %145
	%147 = icmp eq i64 %146, 0
	%148 = zext i1 %147 to i8
	%149 = trunc i8 %148 to i1
	br i1 %149, label %if.then-23, label %if.done-24

if.then-23:
	; continue
	br label %for.interval.loop-21

if.done-24:
	; IfStmt
	%150 = load i64, i64* %15, align 8
	%151 = icmp sgt i64 %150, 0
	%152 = zext i1 %151 to i8
	%153 = trunc i8 %152 to i1
	br i1 %153, label %if.then-25, label %if.done-26

if.then-25:
	; SelectorExpr
	%154 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%155 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %154, i64 0
	%156 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %155, i64 0, i32 12
	%157 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %156, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %157, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$13a, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-26

if.done-26:
	; DeferStmt
	; IfStmt
	%158 = load i8, i8* %13, align 1
	%159 = trunc i8 %158 to i1
	br i1 %159, label %if.then-27, label %if.done-33

if.then-27:
	; RangeStmt
	; ev
	%160 = bitcast %runtime.Type_Info_Enum_Value* %19 to %..rawptr
	%161 = call %..rawptr @mem.zero(%..rawptr %160, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %19
	; evi
	%162 = bitcast i64* %20 to %..rawptr
	%163 = call %..rawptr @mem.zero(%..rawptr %162, i64 8) noinline
	store i64 zeroinitializer, i64* %20
	; SelectorExpr
	%164 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %12, i64 0, i32 2
	%165 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %164, align 8
	%166 = bitcast i64* %21 to %..rawptr
	%167 = call %..rawptr @mem.zero(%..rawptr %166, i64 8) noinline
	store i64 zeroinitializer, i64* %21
	%168 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %165, 1
	store i64 %168, i64* %21
	%169 = bitcast i64* %22 to %..rawptr
	%170 = call %..rawptr @mem.zero(%..rawptr %169, i64 8) noinline
	store i64 zeroinitializer, i64* %22
	store i64 -1, i64* %22
	br label %for.index.loop-28

for.index.loop-28:
	%171 = load i64, i64* %22, align 8
	%172 = add i64 %171, 1
	store i64 %172, i64* %22
	%173 = load i64, i64* %21, align 8
	%174 = icmp slt i64 %172, %173
	br i1 %174, label %for.index.body-29, label %for.index.done-32

for.index.body-29:
	%175 = load i64, i64* %22, align 8
	%176 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %165, 0
	%177 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %176, i64 %175
	%178 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %177, align 8
	store %runtime.Type_Info_Enum_Value %178, %runtime.Type_Info_Enum_Value* %19
	store i64 %175, i64* %20
	; v
	%179 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %19, align 8
	%180 = bitcast %runtime.Type_Info_Enum_Value* %24 to %..rawptr
	%181 = call %..rawptr @mem.zero(%..rawptr %180, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %24
	store %runtime.Type_Info_Enum_Value %179, %runtime.Type_Info_Enum_Value* %24
	%182 = call i64 @fmt.enum_value_to_u64(%runtime.Type_Info_Enum_Value* %24, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %182, i64* %23
	; IfStmt
	%183 = load i64, i64* %23, align 8
	%184 = load i64, i64* %16, align 8
	%185 = icmp eq i64 %183, %184
	%186 = zext i1 %185 to i8
	%187 = trunc i8 %186 to i1
	br i1 %187, label %if.then-30, label %if.done-31

if.then-30:
	; SelectorExpr
	%188 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%189 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %188, i64 0
	%190 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %189, i64 0, i32 12
	%191 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %190, align 8
	; IndexExpr
	; SelectorExpr
	%192 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %12, i64 0, i32 1
	%193 = load {%..string*, i64}, {%..string*, i64}* %192, align 8
	%194 = extractvalue {%..string*, i64} %193, 0
	%195 = load i64, i64* %20, align 8
	%196 = extractvalue {%..string*, i64} %193, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$13b, i64 0, i32 0), i64 53}, i64 876, i64 35, i64 %195, i64 %196)
	%197 = getelementptr inbounds %..string, %..string* %194, i64 %195
	%198 = load %..string, %..string* %197, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %191, %..string %198, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; defer
	; AssignStmt
	%199 = load i64, i64* %15, align 8
	%200 = add i64 %199, 1
	store i64 %200, i64* %15
	; continue
	br label %for.interval.loop-21

if.done-31:
	br label %for.index.loop-28

for.index.done-32:
	br label %if.done-33

if.done-33:
	; SelectorExpr
	%201 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%202 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %201, i64 0
	%203 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %202, i64 0, i32 12
	%204 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %203, align 8
	%205 = load i64, i64* %16, align 8
	%206 = bitcast i64 %205 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %204, i64 %206, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; defer
	; AssignStmt
	%207 = load i64, i64* %15, align 8
	%208 = add i64 %207, 1
	store i64 %208, i64* %15
	br label %for.interval.loop-21

for.interval.done-34:
	; defer
	; SelectorExpr
	%209 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%210 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %209, i64 0
	%211 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %210, i64 0, i32 12
	%212 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %211, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %212, i8 125, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-35

typeswitch.done-35:
	ret void
}

define void @fmt.fmt_bit_field(%fmt.Fmt_Info* %fi, %..any %v, %..string %name, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca %..string, align 16
	%3 = alloca %runtime.Type_Info*, align 16
	%4 = alloca %runtime.Type_Info_Named, align 16
	%5 = alloca %..any, align 16
	%6 = alloca %runtime.Type_Info_Bit_Field, align 16
	%7 = alloca i64, align 16
	%8 = alloca %..string, align 16
	%9 = alloca i64, align 16
	%10 = alloca i64, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i64, align 16
	%16 = alloca i64, align 16
	%17 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..any %v, %..any* %1
	store %..string %name, %..string* %2
	; type_info
	; SelectorExpr
	%18 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%19 = load %..typeid, %..typeid* %18, align 8
	%20 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %19)
	store %runtime.Type_Info* %20, %runtime.Type_Info** %3
	; TypeSwitchStmt
	; SelectorExpr
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%22 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %21, i64 0
	%23 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %22, i64 0, i32 3
	%24 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %23, align 8
	; get union's tag
	%25 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %23, i64 0, i32 2 ; UnionTagPtr
	%26 = load i8, i8* %25, align 1
	%27 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %23 to %..rawptr
	%28 = icmp eq i8 %26, 1
	br i1 %28, label %typeswitch.body-2, label %typeswitch.next-1

typeswitch.next-1:
	%29 = icmp eq i8 %26, 20
	br i1 %29, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.body-2:
	%30 = bitcast %..rawptr %27 to %runtime.Type_Info_Named*
	%31 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %30, align 8
	store %runtime.Type_Info_Named %31, %runtime.Type_Info_Named* %4
	; val
	%32 = load %..any, %..any* %1, align 8
	store %..any %32, %..any* %5
	; AssignStmt
	; SelectorExpr
	%33 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	; SelectorExpr
	; SelectorExpr
	%34 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 1
	%35 = load %runtime.Type_Info*, %runtime.Type_Info** %34, align 8
	%36 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %35, i64 0
	%37 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %36, i64 0, i32 2
	%38 = load %..typeid, %..typeid* %37, align 8
	store %..typeid %38, %..typeid* %33
	%39 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%40 = load %..any, %..any* %5, align 8
	; SelectorExpr
	%41 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 0
	%42 = load %..string, %..string* %41, align 8
	call void @fmt.fmt_bit_field(%fmt.Fmt_Info* %39, %..any %40, %..string %42, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-22

typeswitch.next-3:
	store {[0 x <8 x i8>], [72 x i8], i8} %24, {[0 x <8 x i8>], [72 x i8], i8}* %17
	; SelectorExpr
	%43 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%44 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %43, i64 0
	%45 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %44, i64 0, i32 12
	%46 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %45, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %46, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$13c, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-22

typeswitch.body-4:
	%47 = bitcast %..rawptr %27 to %runtime.Type_Info_Bit_Field*
	%48 = load %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %47, align 8
	store %runtime.Type_Info_Bit_Field %48, %runtime.Type_Info_Bit_Field* %6
	; data
	store i64 0, i64* %7
	; SwitchStmt
	; SelectorExpr
	%49 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%50 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %49, i64 0
	%51 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %50, i64 0, i32 0
	%52 = load i64, i64* %51, align 8
	%53 = icmp eq i64 %52, 1
	br i1 %53, label %switch.case.body-6, label %switch.case.next-5

switch.case.next-5:
	%54 = icmp eq i64 %52, 2
	br i1 %54, label %switch.fall.body-8, label %switch.case.next-7

switch.case.body-6:
	; AssignStmt
	; SelectorExpr
	%55 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%56 = load %..rawptr, %..rawptr* %55, align 8
	%57 = bitcast %..rawptr %56 to i8*
	%58 = getelementptr inbounds i8, i8* %57, i64 0
	%59 = load i8, i8* %58, align 1
	%60 = zext i8 %59 to i64
	store i64 %60, i64* %7
	br label %switch.done-13

switch.case.next-7:
	%61 = icmp eq i64 %52, 4
	br i1 %61, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	; AssignStmt
	; SelectorExpr
	%62 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%63 = load %..rawptr, %..rawptr* %62, align 8
	%64 = bitcast %..rawptr %63 to i16*
	%65 = getelementptr inbounds i16, i16* %64, i64 0
	%66 = load i16, i16* %65, align 2
	%67 = zext i16 %66 to i64
	store i64 %67, i64* %7
	br label %switch.done-13

switch.case.next-9:
	%68 = icmp eq i64 %52, 8
	br i1 %68, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	; AssignStmt
	; SelectorExpr
	%69 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%70 = load %..rawptr, %..rawptr* %69, align 8
	%71 = bitcast %..rawptr %70 to i32*
	%72 = getelementptr inbounds i32, i32* %71, i64 0
	%73 = load i32, i32* %72, align 4
	%74 = zext i32 %73 to i64
	store i64 %74, i64* %7
	br label %switch.done-13

switch.case.next-11:
	br label %switch.done-13

switch.fall.body-12:
	; AssignStmt
	; SelectorExpr
	%75 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%76 = load %..rawptr, %..rawptr* %75, align 8
	%77 = bitcast %..rawptr %76 to i64*
	%78 = getelementptr inbounds i64, i64* %77, i64 0
	%79 = load i64, i64* %78, align 8
	store i64 %79, i64* %7
	br label %switch.done-13

switch.done-13:
	; IfStmt
	%80 = load %..string, %..string* %2, align 8
	%81 = call i8 @runtime.string_ne(%..string %80, %..string zeroinitializer)
	%82 = trunc i8 %81 to i1
	br i1 %82, label %if.then-14, label %if.else-15

if.then-14:
	; SelectorExpr
	%83 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%84 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %83, i64 0
	%85 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %84, i64 0, i32 12
	%86 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %85, align 8
	%87 = load %..string, %..string* %2, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %86, %..string %87, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%88 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%89 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %88, i64 0
	%90 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %89, i64 0, i32 12
	%91 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %90, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %91, i8 123, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-16

if.else-15:
	; SelectorExpr
	%92 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%93 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %92, i64 0
	%94 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %93, i64 0, i32 12
	%95 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %94, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %95, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$13d, i64 0, i32 0), i64 10}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-16

if.done-16:
	; RangeStmt
	; name
	%96 = bitcast %..string* %8 to %..rawptr
	%97 = call %..rawptr @mem.zero(%..rawptr %96, i64 16) noinline
	store %..string zeroinitializer, %..string* %8
	; i
	%98 = bitcast i64* %9 to %..rawptr
	%99 = call %..rawptr @mem.zero(%..rawptr %98, i64 8) noinline
	store i64 zeroinitializer, i64* %9
	; SelectorExpr
	%100 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %6, i64 0, i32 0
	%101 = load {%..string*, i64}, {%..string*, i64}* %100, align 8
	%102 = bitcast i64* %10 to %..rawptr
	%103 = call %..rawptr @mem.zero(%..rawptr %102, i64 8) noinline
	store i64 zeroinitializer, i64* %10
	%104 = extractvalue {%..string*, i64} %101, 1
	store i64 %104, i64* %10
	%105 = bitcast i64* %11 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	store i64 -1, i64* %11
	br label %for.index.loop-17

for.index.loop-17:
	%107 = load i64, i64* %11, align 8
	%108 = add i64 %107, 1
	store i64 %108, i64* %11
	%109 = load i64, i64* %10, align 8
	%110 = icmp slt i64 %108, %109
	br i1 %110, label %for.index.body-18, label %for.index.done-21

for.index.body-18:
	%111 = load i64, i64* %11, align 8
	%112 = extractvalue {%..string*, i64} %101, 0
	%113 = getelementptr inbounds %..string, %..string* %112, i64 %111
	%114 = load %..string, %..string* %113, align 8
	store %..string %114, %..string* %8
	store i64 %111, i64* %9
	; IfStmt
	%115 = load i64, i64* %9, align 8
	%116 = icmp sgt i64 %115, 0
	%117 = zext i1 %116 to i8
	%118 = trunc i8 %117 to i1
	br i1 %118, label %if.then-19, label %if.done-20

if.then-19:
	; SelectorExpr
	%119 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%120 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %119, i64 0
	%121 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %120, i64 0, i32 12
	%122 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %121, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %122, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$13e, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-20

if.done-20:
	; bits
	; IndexExpr
	; SelectorExpr
	%123 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %6, i64 0, i32 1
	%124 = load {i32*, i64}, {i32*, i64}* %123, align 8
	%125 = extractvalue {i32*, i64} %124, 0
	%126 = load i64, i64* %9, align 8
	%127 = extractvalue {i32*, i64} %124, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$13f, i64 0, i32 0), i64 53}, i64 910, i64 26, i64 %126, i64 %127)
	%128 = getelementptr inbounds i32, i32* %125, i64 %126
	%129 = load i32, i32* %128, align 4
	%130 = sext i32 %129 to i64
	store i64 %130, i64* %12
	; offset
	; IndexExpr
	; SelectorExpr
	%131 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %6, i64 0, i32 2
	%132 = load {i32*, i64}, {i32*, i64}* %131, align 8
	%133 = extractvalue {i32*, i64} %132, 0
	%134 = load i64, i64* %9, align 8
	%135 = extractvalue {i32*, i64} %132, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$140, i64 0, i32 0), i64 53}, i64 911, i64 31, i64 %134, i64 %135)
	%136 = getelementptr inbounds i32, i32* %133, i64 %134
	%137 = load i32, i32* %136, align 4
	%138 = sext i32 %137 to i64
	store i64 %138, i64* %13
	; SelectorExpr
	%139 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%140 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %139, i64 0
	%141 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %140, i64 0, i32 12
	%142 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %141, align 8
	%143 = load %..string, %..string* %8, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %142, %..string %143, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%144 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%145 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %144, i64 0
	%146 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %145, i64 0, i32 12
	%147 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %146, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %147, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$141, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; n
	store i64 64, i64* %14
	; sa
	%148 = load i64, i64* %14, align 8
	%149 = load i64, i64* %12, align 8
	%150 = sub i64 %148, %149
	store i64 %150, i64* %15
	; u
	%151 = load i64, i64* %7, align 8
	%152 = load i64, i64* %13, align 8
	%153 = lshr i64 %151, %152
	store i64 %153, i64* %16
	; AssignStmt
	%154 = load i64, i64* %15, align 8
	%155 = load i64, i64* %16, align 8
	%156 = shl i64 %155, %154
	store i64 %156, i64* %16
	; AssignStmt
	%157 = load i64, i64* %15, align 8
	%158 = load i64, i64* %16, align 8
	%159 = lshr i64 %158, %157
	store i64 %159, i64* %16
	; SelectorExpr
	%160 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%161 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %160, i64 0
	%162 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %161, i64 0, i32 12
	%163 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %162, align 8
	%164 = load i64, i64* %16, align 8
	call void @fmt.write_u64({i8*, i64, i64, %mem.Allocator}* %163, i64 %164, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-17

for.index.done-21:
	; SelectorExpr
	%165 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%166 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %165, i64 0
	%167 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %166, i64 0, i32 12
	%168 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %167, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %168, i8 125, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-22

typeswitch.done-22:
	ret void
}

define void @fmt.fmt_value(%fmt.Fmt_Info* %fi, %..any %v, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca i32, align 16
	%3 = alloca %runtime.Type_Info*, align 16
	%4 = alloca %runtime.Type_Info_Named, align 16
	%5 = alloca %runtime.Type_Info_Struct, align 16
	%6 = alloca i8, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	%10 = alloca i64, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca %runtime.Type_Info*, align 16
	%14 = alloca %..rawptr, align 16
	%15 = alloca %..any, align 16
	%16 = alloca i64, align 16
	%17 = alloca i64, align 16
	%18 = alloca %runtime.Type_Info_Bit_Set, align 16
	%19 = alloca %runtime.Type_Info_Bit_Field, align 16
	%20 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	%21 = alloca %..any, align 16
	%22 = alloca %runtime.Type_Info_Boolean, align 16
	%23 = alloca %runtime.Type_Info_Integer, align 16
	%24 = alloca %runtime.Type_Info_Rune, align 16
	%25 = alloca %runtime.Type_Info_Float, align 16
	%26 = alloca %runtime.Type_Info_Complex, align 16
	%27 = alloca %runtime.Type_Info_String, align 16
	%28 = alloca %runtime.Type_Info_Pointer, align 16
	%29 = alloca %runtime.Type_Info_Array, align 16
	%30 = alloca i64, align 16
	%31 = alloca i64, align 16
	%32 = alloca i64, align 16
	%33 = alloca i64, align 16
	%34 = alloca %..any, align 16
	%35 = alloca %runtime.Type_Info_Dynamic_Array, align 16
	%36 = alloca %mem.Raw_Dynamic_Array*, align 16
	%37 = alloca i64, align 16
	%38 = alloca i64, align 16
	%39 = alloca i64, align 16
	%40 = alloca i64, align 16
	%41 = alloca %..any, align 16
	%42 = alloca %runtime.Type_Info_Slice, align 16
	%43 = alloca %mem.Raw_Slice*, align 16
	%44 = alloca i64, align 16
	%45 = alloca i64, align 16
	%46 = alloca i64, align 16
	%47 = alloca i64, align 16
	%48 = alloca %..any, align 16
	%49 = alloca %runtime.Type_Info_Map, align 16
	%50 = alloca %mem.Raw_Map*, align 16
	%51 = alloca %mem.Raw_Dynamic_Array*, align 16
	%52 = alloca %runtime.Type_Info_Struct, align 16
	%53 = alloca %runtime.Type_Info*, align 16
	%54 = alloca {%runtime.Type_Info_Struct, i8}, align 16
	%55 = alloca %runtime.Type_Info_Dynamic_Array, align 16
	%56 = alloca %runtime.Type_Info*, align 16
	%57 = alloca {%runtime.Type_Info_Dynamic_Array, i8}, align 16
	%58 = alloca %runtime.Type_Info_Struct, align 16
	%59 = alloca {%runtime.Type_Info_Struct, i8}, align 16
	%60 = alloca i64, align 16
	%61 = alloca i64, align 16
	%62 = alloca i64, align 16
	%63 = alloca i64, align 16
	%64 = alloca i64, align 16
	%65 = alloca %runtime.Map_Entry_Header*, align 16
	%66 = alloca %fmt.Fmt_Info, align 16
	%67 = alloca %fmt.Fmt_Info, align 16
	%68 = alloca %..any, align 16
	%69 = alloca i64, align 16
	%70 = alloca %..any, align 16
	%71 = alloca %runtime.Type_Info_Struct, align 16
	%72 = alloca i8, align 16
	%73 = alloca i64, align 16
	%74 = alloca i64, align 16
	%75 = alloca i64, align 16
	%76 = alloca i64, align 16
	%77 = alloca i64, align 16
	%78 = alloca %runtime.Type_Info*, align 16
	%79 = alloca i64, align 16
	%80 = alloca %..any, align 16
	%81 = alloca %runtime.Type_Info_Union, align 16
	%82 = alloca i64, align 16
	%83 = alloca %..any, align 16
	%84 = alloca %..any, align 16
	%85 = alloca i64, align 16
	%86 = alloca i8, align 16
	%87 = alloca i8, align 16
	%88 = alloca i16, align 16
	%89 = alloca i16, align 16
	%90 = alloca i32, align 16
	%91 = alloca i32, align 16
	%92 = alloca i64, align 16
	%93 = alloca i64, align 16
	%94 = alloca %..any, align 16
	%95 = alloca %runtime.Source_Code_Location, align 16
	%96 = alloca %..typeid, align 16
	%97 = alloca %..any, align 16
	%98 = alloca %runtime.Type_Info_Enum, align 16
	%99 = alloca %runtime.Type_Info_Procedure, align 16
	%100 = alloca %..rawptr, align 16
	%101 = alloca %runtime.Type_Info_Type_Id, align 16
	%102 = alloca %..typeid, align 16
	%103 = alloca %runtime.Type_Info_Bit_Field, align 16
	%104 = alloca %runtime.Type_Info_Bit_Set, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..any %v, %..any* %1
	store i32 %verb, i32* %2
	; IfStmt
	; SelectorExpr
	%105 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%106 = load %..rawptr, %..rawptr* %105, align 8
	%107 = icmp eq %..rawptr %106, zeroinitializer
	%108 = zext i1 %107 to i8
	%109 = trunc i8 %108 to i1
	br i1 %109, label %if.then-2, label %cmp.or-1

cmp.or-1:
	; SelectorExpr
	%110 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%111 = load %..typeid, %..typeid* %110, align 8
	%112 = icmp eq %..typeid %111, 0
	%113 = zext i1 %112 to i8
	%114 = trunc i8 %113 to i1
	br i1 %114, label %if.then-2, label %if.done-3

if.then-2:
	; SelectorExpr
	%115 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%116 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %115, i64 0
	%117 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %116, i64 0, i32 12
	%118 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %117, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %118, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$142, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-3:
	; type_info
	; SelectorExpr
	%119 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%120 = load %..typeid, %..typeid* %119, align 8
	%121 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %120)
	store %runtime.Type_Info* %121, %runtime.Type_Info** %3
	; TypeSwitchStmt
	; SelectorExpr
	%122 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%123 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %122, i64 0
	%124 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %123, i64 0, i32 3
	%125 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %124, align 8
	; get union's tag
	%126 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %124, i64 0, i32 2 ; UnionTagPtr
	%127 = load i8, i8* %126, align 1
	%128 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %124 to %..rawptr
	%129 = icmp eq i8 %127, 1
	br i1 %129, label %typeswitch.body-5, label %typeswitch.next-4

typeswitch.next-4:
	%130 = icmp eq i8 %127, 7
	br i1 %130, label %typeswitch.body-41, label %typeswitch.next-40

typeswitch.body-5:
	%131 = bitcast %..rawptr %128 to %runtime.Type_Info_Named*
	%132 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %131, align 8
	store %runtime.Type_Info_Named %132, %runtime.Type_Info_Named* %4
	; TypeSwitchStmt
	; SelectorExpr
	; SelectorExpr
	%133 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 1
	%134 = load %runtime.Type_Info*, %runtime.Type_Info** %133, align 8
	%135 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %134, i64 0
	%136 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %135, i64 0, i32 3
	%137 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %136, align 8
	; get union's tag
	%138 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %136, i64 0, i32 2 ; UnionTagPtr
	%139 = load i8, i8* %138, align 1
	%140 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %136 to %..rawptr
	%141 = icmp eq i8 %139, 16
	br i1 %141, label %typeswitch.body-7, label %typeswitch.next-6

typeswitch.next-6:
	%142 = icmp eq i8 %139, 21
	br i1 %142, label %typeswitch.body-36, label %typeswitch.next-35

typeswitch.body-7:
	%143 = bitcast %..rawptr %140 to %runtime.Type_Info_Struct*
	%144 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %143, align 8
	store %runtime.Type_Info_Struct %144, %runtime.Type_Info_Struct* %5
	; IfStmt
	%145 = load i32, i32* %2, align 4
	%146 = icmp ne i32 %145, 118
	%147 = zext i1 %146 to i8
	%148 = trunc i8 %147 to i1
	br i1 %148, label %if.then-8, label %if.done-9

if.then-8:
	%149 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%150 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %149, i32 %150, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-9:
	; IfStmt
	; SelectorExpr
	%151 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %5, i64 0, i32 5
	%152 = load i8, i8* %151, align 1
	%153 = trunc i8 %152 to i1
	br i1 %153, label %if.then-10, label %if.done-11

if.then-10:
	; SelectorExpr
	%154 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%155 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %154, i64 0
	%156 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %155, i64 0, i32 12
	%157 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %156, align 8
	; SelectorExpr
	%158 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 0
	%159 = load %..string, %..string* %158, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %157, %..string %159, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%160 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%161 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %160, i64 0
	%162 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %161, i64 0, i32 12
	%163 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %162, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %163, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$143, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-11:
	; SelectorExpr
	%164 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%165 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %164, i64 0
	%166 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %165, i64 0, i32 12
	%167 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %166, align 8
	; SelectorExpr
	%168 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 0
	%169 = load %..string, %..string* %168, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %167, %..string %169, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%170 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%171 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %170, i64 0
	%172 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %171, i64 0, i32 12
	%173 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %172, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %173, i8 123, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; hash
	; SelectorExpr
	%174 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%175 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %174, i64 0
	%176 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %175, i64 0, i32 4
	%177 = load i8, i8* %176, align 1
	store i8 %177, i8* %6
	; DeferStmt
	; indent
	; SelectorExpr
	%178 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%179 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %178, i64 0
	%180 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %179, i64 0, i32 9
	%181 = load i64, i64* %180, align 8
	store i64 %181, i64* %7
	; DeferStmt
	; AssignStmt
	; SelectorExpr
	%182 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%183 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %182, i64 0
	%184 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %183, i64 0, i32 4
	store i8 0, i8* %184
	; AssignStmt
	; SelectorExpr
	%185 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%186 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %185, i64 0
	%187 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %186, i64 0, i32 9
	%188 = load i64, i64* %187, align 8
	%189 = add i64 %188, 1
	store i64 %189, i64* %187
	; IfStmt
	%190 = load i8, i8* %6, align 1
	%191 = trunc i8 %190 to i1
	br i1 %191, label %if.then-12, label %if.done-13

if.then-12:
	; SelectorExpr
	%192 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%193 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %192, i64 0
	%194 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %193, i64 0, i32 12
	%195 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %194, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %195, i8 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-13

if.done-13:
	; RangeStmt
	; i
	%196 = bitcast i64* %8 to %..rawptr
	%197 = call %..rawptr @mem.zero(%..rawptr %196, i64 8) noinline
	store i64 zeroinitializer, i64* %8
	; SelectorExpr
	%198 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %5, i64 0, i32 1
	%199 = load {%..string*, i64}, {%..string*, i64}* %198, align 8
	%200 = bitcast i64* %9 to %..rawptr
	%201 = call %..rawptr @mem.zero(%..rawptr %200, i64 8) noinline
	store i64 zeroinitializer, i64* %9
	%202 = extractvalue {%..string*, i64} %199, 1
	store i64 %202, i64* %9
	%203 = bitcast i64* %10 to %..rawptr
	%204 = call %..rawptr @mem.zero(%..rawptr %203, i64 8) noinline
	store i64 zeroinitializer, i64* %10
	store i64 -1, i64* %10
	br label %for.index.loop-14

for.index.loop-14:
	%205 = load i64, i64* %10, align 8
	%206 = add i64 %205, 1
	store i64 %206, i64* %10
	%207 = load i64, i64* %9, align 8
	%208 = icmp slt i64 %206, %207
	br i1 %208, label %for.index.body-15, label %for.index.done-29

for.index.body-15:
	%209 = load i64, i64* %10, align 8
	store i64 %209, i64* %8
	; IfStmt
	%210 = load i8, i8* %6, align 1
	%211 = trunc i8 %210 to i1
	br i1 %211, label %if.done-18, label %cmp.and-16

cmp.and-16:
	%212 = load i64, i64* %8, align 8
	%213 = icmp sgt i64 %212, 0
	%214 = zext i1 %213 to i8
	%215 = trunc i8 %214 to i1
	br i1 %215, label %if.then-17, label %if.done-18

if.then-17:
	; SelectorExpr
	%216 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%217 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %216, i64 0
	%218 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %217, i64 0, i32 12
	%219 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %218, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %219, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$144, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-18

if.done-18:
	; IfStmt
	%220 = load i8, i8* %6, align 1
	%221 = trunc i8 %220 to i1
	br i1 %221, label %if.then-19, label %if.done-23

if.then-19:
	; RangeStmt
	%222 = bitcast i64* %11 to %..rawptr
	%223 = call %..rawptr @mem.zero(%..rawptr %222, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	store i64 0, i64* %11
	%224 = bitcast i64* %12 to %..rawptr
	%225 = call %..rawptr @mem.zero(%..rawptr %224, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	store i64 0, i64* %12
	br label %for.interval.loop-20

for.interval.loop-20:
	; SelectorExpr
	%226 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%227 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %226, i64 0
	%228 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %227, i64 0, i32 9
	%229 = load i64, i64* %228, align 8
	%230 = sub i64 %229, 1
	%231 = load i64, i64* %11, align 8
	%232 = icmp sle i64 %231, %230
	br i1 %232, label %for.interval.body-21, label %for.interval.done-22

for.interval.body-21:
	%233 = load i64, i64* %11, align 8
	%234 = load i64, i64* %12, align 8
	%235 = load i64, i64* %11, align 8
	%236 = add i64 %235, 1
	store i64 %236, i64* %11
	%237 = load i64, i64* %12, align 8
	%238 = add i64 %237, 1
	store i64 %238, i64* %12
	; SelectorExpr
	%239 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%240 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %239, i64 0
	%241 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %240, i64 0, i32 12
	%242 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %241, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %242, i8 9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-20

for.interval.done-22:
	br label %if.done-23

if.done-23:
	; SelectorExpr
	%243 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%244 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %243, i64 0
	%245 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %244, i64 0, i32 12
	%246 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %245, align 8
	; IndexExpr
	; SelectorExpr
	%247 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %5, i64 0, i32 1
	%248 = load {%..string*, i64}, {%..string*, i64}* %247, align 8
	%249 = extractvalue {%..string*, i64} %248, 0
	%250 = load i64, i64* %8, align 8
	%251 = extractvalue {%..string*, i64} %248, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$145, i64 0, i32 0), i64 53}, i64 965, i64 34, i64 %250, i64 %251)
	%252 = getelementptr inbounds %..string, %..string* %249, i64 %250
	%253 = load %..string, %..string* %252, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %246, %..string %253, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%254 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%255 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %254, i64 0
	%256 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %255, i64 0, i32 12
	%257 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %256, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %257, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$146, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; t
	; IndexExpr
	; SelectorExpr
	%258 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %5, i64 0, i32 0
	%259 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %258, align 8
	%260 = extractvalue {%runtime.Type_Info**, i64} %259, 0
	%261 = load i64, i64* %8, align 8
	%262 = extractvalue {%runtime.Type_Info**, i64} %259, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$147, i64 0, i32 0), i64 53}, i64 968, i64 21, i64 %261, i64 %262)
	%263 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %260, i64 %261
	%264 = load %runtime.Type_Info*, %runtime.Type_Info** %263, align 8
	store %runtime.Type_Info* %264, %runtime.Type_Info** %13
	; SelectorExpr
	%265 = load %runtime.Type_Info*, %runtime.Type_Info** %13, align 8
	%266 = call i8 @types.is_any(%runtime.Type_Info* %265, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%267 = trunc i8 %266 to i1
	br i1 %267, label %if.then-24, label %if.else-25

if.then-24:
	; SelectorExpr
	%268 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%269 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %268, i64 0
	%270 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %269, i64 0, i32 12
	%271 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %270, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %271, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$148, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-26

if.else-25:
	; data
	; SelectorExpr
	%272 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%273 = load %..rawptr, %..rawptr* %272, align 8
	%274 = ptrtoint %..rawptr %273 to i64
	; IndexExpr
	; SelectorExpr
	%275 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %5, i64 0, i32 2
	%276 = load {i64*, i64}, {i64*, i64}* %275, align 8
	%277 = extractvalue {i64*, i64} %276, 0
	%278 = load i64, i64* %8, align 8
	%279 = extractvalue {i64*, i64} %276, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$149, i64 0, i32 0), i64 53}, i64 971, i64 49, i64 %278, i64 %279)
	%280 = getelementptr inbounds i64, i64* %277, i64 %278
	%281 = load i64, i64* %280, align 8
	%282 = add i64 %274, %281
	%283 = inttoptr i64 %282 to %..rawptr
	store %..rawptr %283, %..rawptr* %14
	%284 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%285 = bitcast %..any* %15 to %..rawptr
	%286 = call %..rawptr @mem.zero(%..rawptr %285, i64 16) noinline
	store %..any zeroinitializer, %..any* %15
	store %..any zeroinitializer, %..any* %15
	%287 = load %..rawptr, %..rawptr* %14, align 8
	%288 = getelementptr inbounds %..any, %..any* %15, i64 0, i32 0
	store %..rawptr %287, %..rawptr* %288
	; SelectorExpr
	%289 = load %runtime.Type_Info*, %runtime.Type_Info** %13, align 8
	%290 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %289, i64 0
	%291 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %290, i64 0, i32 2
	%292 = load %..typeid, %..typeid* %291, align 8
	%293 = getelementptr inbounds %..any, %..any* %15, i64 0, i32 1
	store %..typeid %292, %..typeid* %293
	%294 = load %..any, %..any* %15, align 8
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %284, %..any %294, i32 118, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-26

if.done-26:
	; IfStmt
	%295 = load i8, i8* %6, align 1
	%296 = trunc i8 %295 to i1
	br i1 %296, label %if.then-27, label %if.done-28

if.then-27:
	; SelectorExpr
	%297 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%298 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %297, i64 0
	%299 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %298, i64 0, i32 12
	%300 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %299, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %300, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$14a, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-28

if.done-28:
	br label %for.index.loop-14

for.index.done-29:
	; IfStmt
	%301 = load i8, i8* %6, align 1
	%302 = trunc i8 %301 to i1
	br i1 %302, label %if.then-30, label %if.done-34

if.then-30:
	; RangeStmt
	%303 = bitcast i64* %16 to %..rawptr
	%304 = call %..rawptr @mem.zero(%..rawptr %303, i64 8) noinline
	store i64 zeroinitializer, i64* %16
	store i64 0, i64* %16
	%305 = bitcast i64* %17 to %..rawptr
	%306 = call %..rawptr @mem.zero(%..rawptr %305, i64 8) noinline
	store i64 zeroinitializer, i64* %17
	store i64 0, i64* %17
	br label %for.interval.loop-31

for.interval.loop-31:
	%307 = load i64, i64* %7, align 8
	%308 = sub i64 %307, 1
	%309 = load i64, i64* %16, align 8
	%310 = icmp sle i64 %309, %308
	br i1 %310, label %for.interval.body-32, label %for.interval.done-33

for.interval.body-32:
	%311 = load i64, i64* %16, align 8
	%312 = load i64, i64* %17, align 8
	%313 = load i64, i64* %16, align 8
	%314 = add i64 %313, 1
	store i64 %314, i64* %16
	%315 = load i64, i64* %17, align 8
	%316 = add i64 %315, 1
	store i64 %316, i64* %17
	; SelectorExpr
	%317 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%318 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %317, i64 0
	%319 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %318, i64 0, i32 12
	%320 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %319, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %320, i8 9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-31

for.interval.done-33:
	br label %if.done-34

if.done-34:
	; SelectorExpr
	%321 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%322 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %321, i64 0
	%323 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %322, i64 0, i32 12
	%324 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %323, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %324, i8 125, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; defer
	; AssignStmt
	; SelectorExpr
	%325 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%326 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %325, i64 0
	%327 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %326, i64 0, i32 9
	%328 = load i64, i64* %327, align 8
	%329 = sub i64 %328, 1
	store i64 %329, i64* %327
	; defer
	; AssignStmt
	; SelectorExpr
	%330 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%331 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %330, i64 0
	%332 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %331, i64 0, i32 4
	%333 = load i8, i8* %6, align 1
	store i8 %333, i8* %332
	br label %typeswitch.done-39

typeswitch.next-35:
	%334 = icmp eq i8 %139, 20
	br i1 %334, label %typeswitch.body-38, label %typeswitch.next-37

typeswitch.body-36:
	%335 = bitcast %..rawptr %140 to %runtime.Type_Info_Bit_Set*
	%336 = load %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %335, align 8
	store %runtime.Type_Info_Bit_Set %336, %runtime.Type_Info_Bit_Set* %18
	%337 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%338 = load %..any, %..any* %1, align 8
	call void @fmt.fmt_bit_set(%fmt.Fmt_Info* %337, %..any %338, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-39

typeswitch.next-37:
	store {[0 x <8 x i8>], [72 x i8], i8} %137, {[0 x <8 x i8>], [72 x i8], i8}* %20
	%339 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%340 = bitcast %..any* %21 to %..rawptr
	%341 = call %..rawptr @mem.zero(%..rawptr %340, i64 16) noinline
	store %..any zeroinitializer, %..any* %21
	store %..any zeroinitializer, %..any* %21
	; SelectorExpr
	%342 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%343 = load %..rawptr, %..rawptr* %342, align 8
	%344 = getelementptr inbounds %..any, %..any* %21, i64 0, i32 0
	store %..rawptr %343, %..rawptr* %344
	; SelectorExpr
	; SelectorExpr
	%345 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 1
	%346 = load %runtime.Type_Info*, %runtime.Type_Info** %345, align 8
	%347 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %346, i64 0
	%348 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %347, i64 0, i32 2
	%349 = load %..typeid, %..typeid* %348, align 8
	%350 = getelementptr inbounds %..any, %..any* %21, i64 0, i32 1
	store %..typeid %349, %..typeid* %350
	%351 = load %..any, %..any* %21, align 8
	%352 = load i32, i32* %2, align 4
	call void @fmt.fmt_value(%fmt.Fmt_Info* %339, %..any %351, i32 %352, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-39

typeswitch.body-38:
	%353 = bitcast %..rawptr %140 to %runtime.Type_Info_Bit_Field*
	%354 = load %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %353, align 8
	store %runtime.Type_Info_Bit_Field %354, %runtime.Type_Info_Bit_Field* %19
	%355 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%356 = load %..any, %..any* %1, align 8
	call void @fmt.fmt_bit_field(%fmt.Fmt_Info* %355, %..any %356, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-39

typeswitch.done-39:
	br label %typeswitch.done-158

typeswitch.next-40:
	%357 = icmp eq i8 %127, 2
	br i1 %357, label %typeswitch.body-43, label %typeswitch.next-42

typeswitch.body-41:
	%358 = bitcast %..rawptr %128 to %runtime.Type_Info_Boolean*
	%359 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %358, align 1
	store %runtime.Type_Info_Boolean %359, %runtime.Type_Info_Boolean* %22
	%360 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%361 = load %..any, %..any* %1, align 8
	%362 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %360, %..any %361, i32 %362, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-42:
	%363 = icmp eq i8 %127, 3
	br i1 %363, label %typeswitch.body-45, label %typeswitch.next-44

typeswitch.body-43:
	%364 = bitcast %..rawptr %128 to %runtime.Type_Info_Integer*
	%365 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %364, align 1
	store %runtime.Type_Info_Integer %365, %runtime.Type_Info_Integer* %23
	%366 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%367 = load %..any, %..any* %1, align 8
	%368 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %366, %..any %367, i32 %368, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-44:
	%369 = icmp eq i8 %127, 4
	br i1 %369, label %typeswitch.body-47, label %typeswitch.next-46

typeswitch.body-45:
	%370 = bitcast %..rawptr %128 to %runtime.Type_Info_Rune*
	%371 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %370, align 1
	store %runtime.Type_Info_Rune %371, %runtime.Type_Info_Rune* %24
	%372 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%373 = load %..any, %..any* %1, align 8
	%374 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %372, %..any %373, i32 %374, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-46:
	%375 = icmp eq i8 %127, 5
	br i1 %375, label %typeswitch.body-49, label %typeswitch.next-48

typeswitch.body-47:
	%376 = bitcast %..rawptr %128 to %runtime.Type_Info_Float*
	%377 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %376, align 1
	store %runtime.Type_Info_Float %377, %runtime.Type_Info_Float* %25
	%378 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%379 = load %..any, %..any* %1, align 8
	%380 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %378, %..any %379, i32 %380, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-48:
	%381 = icmp eq i8 %127, 6
	br i1 %381, label %typeswitch.body-51, label %typeswitch.next-50

typeswitch.body-49:
	%382 = bitcast %..rawptr %128 to %runtime.Type_Info_Complex*
	%383 = load %runtime.Type_Info_Complex, %runtime.Type_Info_Complex* %382, align 1
	store %runtime.Type_Info_Complex %383, %runtime.Type_Info_Complex* %26
	%384 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%385 = load %..any, %..any* %1, align 8
	%386 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %384, %..any %385, i32 %386, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-50:
	%387 = icmp eq i8 %127, 10
	br i1 %387, label %typeswitch.body-53, label %typeswitch.next-52

typeswitch.body-51:
	%388 = bitcast %..rawptr %128 to %runtime.Type_Info_String*
	%389 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %388, align 1
	store %runtime.Type_Info_String %389, %runtime.Type_Info_String* %27
	%390 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%391 = load %..any, %..any* %1, align 8
	%392 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %390, %..any %391, i32 %392, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-52:
	%393 = icmp eq i8 %127, 12
	br i1 %393, label %typeswitch.body-58, label %typeswitch.next-57

typeswitch.body-53:
	%394 = bitcast %..rawptr %128 to %runtime.Type_Info_Pointer*
	%395 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %394, align 8
	store %runtime.Type_Info_Pointer %395, %runtime.Type_Info_Pointer* %28
	; IfStmt
	; SelectorExpr
	%396 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%397 = load %..typeid, %..typeid* %396, align 8
	%398 = icmp eq %..typeid %397, 648518346341351435
	%399 = zext i1 %398 to i8
	%400 = trunc i8 %399 to i1
	br i1 %400, label %if.then-54, label %if.else-55

if.then-54:
	; SelectorExpr
	%401 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%402 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %401, i64 0
	%403 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %402, i64 0, i32 12
	%404 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %403, align 8
	; SelectorExpr
	%405 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%406 = load %..rawptr, %..rawptr* %405, align 8
	%407 = bitcast %..rawptr %406 to %runtime.Type_Info**
	%408 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %407, i64 0
	%409 = load %runtime.Type_Info*, %runtime.Type_Info** %408, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %404, %runtime.Type_Info* %409, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-56

if.else-55:
	%410 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; SelectorExpr
	%411 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%412 = load %..rawptr, %..rawptr* %411, align 8
	%413 = bitcast %..rawptr %412 to %..rawptr*
	%414 = getelementptr inbounds %..rawptr, %..rawptr* %413, i64 0
	%415 = load %..rawptr, %..rawptr* %414, align 8
	%416 = load i32, i32* %2, align 4
	call void @fmt.fmt_pointer(%fmt.Fmt_Info* %410, %..rawptr %415, i32 %416, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-56

if.done-56:
	br label %typeswitch.done-158

typeswitch.next-57:
	%417 = icmp eq i8 %127, 13
	br i1 %417, label %typeswitch.body-65, label %typeswitch.next-64

typeswitch.body-58:
	%418 = bitcast %..rawptr %128 to %runtime.Type_Info_Array*
	%419 = load %runtime.Type_Info_Array, %runtime.Type_Info_Array* %418, align 8
	store %runtime.Type_Info_Array %419, %runtime.Type_Info_Array* %29
	; SelectorExpr
	%420 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%421 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %420, i64 0
	%422 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %421, i64 0, i32 12
	%423 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %422, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %423, i8 91, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	; RangeStmt
	; i
	%424 = bitcast i64* %30 to %..rawptr
	%425 = call %..rawptr @mem.zero(%..rawptr %424, i64 8) noinline
	store i64 zeroinitializer, i64* %30
	%426 = bitcast i64* %31 to %..rawptr
	%427 = call %..rawptr @mem.zero(%..rawptr %426, i64 8) noinline
	store i64 zeroinitializer, i64* %31
	store i64 0, i64* %31
	%428 = bitcast i64* %32 to %..rawptr
	%429 = call %..rawptr @mem.zero(%..rawptr %428, i64 8) noinline
	store i64 zeroinitializer, i64* %32
	store i64 0, i64* %32
	br label %for.interval.loop-59

for.interval.loop-59:
	; SelectorExpr
	%430 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %29, i64 0, i32 2
	%431 = load i64, i64* %430, align 8
	%432 = sub i64 %431, 1
	%433 = load i64, i64* %31, align 8
	%434 = icmp sle i64 %433, %432
	br i1 %434, label %for.interval.body-60, label %for.interval.done-63

for.interval.body-60:
	%435 = load i64, i64* %31, align 8
	%436 = load i64, i64* %32, align 8
	%437 = load i64, i64* %31, align 8
	%438 = add i64 %437, 1
	store i64 %438, i64* %31
	%439 = load i64, i64* %32, align 8
	%440 = add i64 %439, 1
	store i64 %440, i64* %32
	store i64 %435, i64* %30
	; IfStmt
	%441 = load i64, i64* %30, align 8
	%442 = icmp sgt i64 %441, 0
	%443 = zext i1 %442 to i8
	%444 = trunc i8 %443 to i1
	br i1 %444, label %if.then-61, label %if.done-62

if.then-61:
	; SelectorExpr
	%445 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%446 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %445, i64 0
	%447 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %446, i64 0, i32 12
	%448 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %447, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %448, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$14b, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-62

if.done-62:
	; data
	; SelectorExpr
	%449 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%450 = load %..rawptr, %..rawptr* %449, align 8
	%451 = ptrtoint %..rawptr %450 to i64
	%452 = load i64, i64* %30, align 8
	; SelectorExpr
	%453 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %29, i64 0, i32 1
	%454 = load i64, i64* %453, align 8
	%455 = mul i64 %452, %454
	%456 = bitcast i64 %455 to i64
	%457 = add i64 %451, %456
	store i64 %457, i64* %33
	%458 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%459 = bitcast %..any* %34 to %..rawptr
	%460 = call %..rawptr @mem.zero(%..rawptr %459, i64 16) noinline
	store %..any zeroinitializer, %..any* %34
	store %..any zeroinitializer, %..any* %34
	%461 = load i64, i64* %33, align 8
	%462 = inttoptr i64 %461 to %..rawptr
	%463 = getelementptr inbounds %..any, %..any* %34, i64 0, i32 0
	store %..rawptr %462, %..rawptr* %463
	; SelectorExpr
	; SelectorExpr
	%464 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %29, i64 0, i32 0
	%465 = load %runtime.Type_Info*, %runtime.Type_Info** %464, align 8
	%466 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %465, i64 0
	%467 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %466, i64 0, i32 2
	%468 = load %..typeid, %..typeid* %467, align 8
	%469 = getelementptr inbounds %..any, %..any* %34, i64 0, i32 1
	store %..typeid %468, %..typeid* %469
	%470 = load %..any, %..any* %34, align 8
	%471 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %458, %..any %470, i32 %471, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-59

for.interval.done-63:
	; defer
	; SelectorExpr
	%472 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%473 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %472, i64 0
	%474 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %473, i64 0, i32 12
	%475 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %474, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %475, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-64:
	%476 = icmp eq i8 %127, 14
	br i1 %476, label %typeswitch.body-72, label %typeswitch.next-71

typeswitch.body-65:
	%477 = bitcast %..rawptr %128 to %runtime.Type_Info_Dynamic_Array*
	%478 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %477, align 8
	store %runtime.Type_Info_Dynamic_Array %478, %runtime.Type_Info_Dynamic_Array* %35
	; SelectorExpr
	%479 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%480 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %479, i64 0
	%481 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %480, i64 0, i32 12
	%482 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %481, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %482, i8 91, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	; array
	; SelectorExpr
	%483 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%484 = load %..rawptr, %..rawptr* %483, align 8
	%485 = bitcast %..rawptr %484 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %485, %mem.Raw_Dynamic_Array** %36
	; RangeStmt
	; i
	%486 = bitcast i64* %37 to %..rawptr
	%487 = call %..rawptr @mem.zero(%..rawptr %486, i64 8) noinline
	store i64 zeroinitializer, i64* %37
	%488 = bitcast i64* %38 to %..rawptr
	%489 = call %..rawptr @mem.zero(%..rawptr %488, i64 8) noinline
	store i64 zeroinitializer, i64* %38
	store i64 0, i64* %38
	%490 = bitcast i64* %39 to %..rawptr
	%491 = call %..rawptr @mem.zero(%..rawptr %490, i64 8) noinline
	store i64 zeroinitializer, i64* %39
	store i64 0, i64* %39
	br label %for.interval.loop-66

for.interval.loop-66:
	; SelectorExpr
	%492 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %36, align 8
	%493 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %492, i64 0
	%494 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %493, i64 0, i32 1
	%495 = load i64, i64* %494, align 8
	%496 = sub i64 %495, 1
	%497 = load i64, i64* %38, align 8
	%498 = icmp sle i64 %497, %496
	br i1 %498, label %for.interval.body-67, label %for.interval.done-70

for.interval.body-67:
	%499 = load i64, i64* %38, align 8
	%500 = load i64, i64* %39, align 8
	%501 = load i64, i64* %38, align 8
	%502 = add i64 %501, 1
	store i64 %502, i64* %38
	%503 = load i64, i64* %39, align 8
	%504 = add i64 %503, 1
	store i64 %504, i64* %39
	store i64 %499, i64* %37
	; IfStmt
	%505 = load i64, i64* %37, align 8
	%506 = icmp sgt i64 %505, 0
	%507 = zext i1 %506 to i8
	%508 = trunc i8 %507 to i1
	br i1 %508, label %if.then-68, label %if.done-69

if.then-68:
	; SelectorExpr
	%509 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%510 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %509, i64 0
	%511 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %510, i64 0, i32 12
	%512 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %511, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %512, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$14c, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-69

if.done-69:
	; data
	; SelectorExpr
	%513 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %36, align 8
	%514 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %513, i64 0
	%515 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %514, i64 0, i32 0
	%516 = load %..rawptr, %..rawptr* %515, align 8
	%517 = ptrtoint %..rawptr %516 to i64
	%518 = load i64, i64* %37, align 8
	; SelectorExpr
	%519 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %35, i64 0, i32 1
	%520 = load i64, i64* %519, align 8
	%521 = mul i64 %518, %520
	%522 = bitcast i64 %521 to i64
	%523 = add i64 %517, %522
	store i64 %523, i64* %40
	%524 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%525 = bitcast %..any* %41 to %..rawptr
	%526 = call %..rawptr @mem.zero(%..rawptr %525, i64 16) noinline
	store %..any zeroinitializer, %..any* %41
	store %..any zeroinitializer, %..any* %41
	%527 = load i64, i64* %40, align 8
	%528 = inttoptr i64 %527 to %..rawptr
	%529 = getelementptr inbounds %..any, %..any* %41, i64 0, i32 0
	store %..rawptr %528, %..rawptr* %529
	; SelectorExpr
	; SelectorExpr
	%530 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %35, i64 0, i32 0
	%531 = load %runtime.Type_Info*, %runtime.Type_Info** %530, align 8
	%532 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %531, i64 0
	%533 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %532, i64 0, i32 2
	%534 = load %..typeid, %..typeid* %533, align 8
	%535 = getelementptr inbounds %..any, %..any* %41, i64 0, i32 1
	store %..typeid %534, %..typeid* %535
	%536 = load %..any, %..any* %41, align 8
	%537 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %524, %..any %536, i32 %537, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-66

for.interval.done-70:
	; defer
	; SelectorExpr
	%538 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%539 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %538, i64 0
	%540 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %539, i64 0, i32 12
	%541 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %540, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %541, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-71:
	%542 = icmp eq i8 %127, 19
	br i1 %542, label %typeswitch.body-79, label %typeswitch.next-78

typeswitch.body-72:
	%543 = bitcast %..rawptr %128 to %runtime.Type_Info_Slice*
	%544 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %543, align 8
	store %runtime.Type_Info_Slice %544, %runtime.Type_Info_Slice* %42
	; SelectorExpr
	%545 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%546 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %545, i64 0
	%547 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %546, i64 0, i32 12
	%548 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %547, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %548, i8 91, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	; slice
	; SelectorExpr
	%549 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%550 = load %..rawptr, %..rawptr* %549, align 8
	%551 = bitcast %..rawptr %550 to %mem.Raw_Slice*
	store %mem.Raw_Slice* %551, %mem.Raw_Slice** %43
	; RangeStmt
	; i
	%552 = bitcast i64* %44 to %..rawptr
	%553 = call %..rawptr @mem.zero(%..rawptr %552, i64 8) noinline
	store i64 zeroinitializer, i64* %44
	%554 = bitcast i64* %45 to %..rawptr
	%555 = call %..rawptr @mem.zero(%..rawptr %554, i64 8) noinline
	store i64 zeroinitializer, i64* %45
	store i64 0, i64* %45
	%556 = bitcast i64* %46 to %..rawptr
	%557 = call %..rawptr @mem.zero(%..rawptr %556, i64 8) noinline
	store i64 zeroinitializer, i64* %46
	store i64 0, i64* %46
	br label %for.interval.loop-73

for.interval.loop-73:
	; SelectorExpr
	%558 = load %mem.Raw_Slice*, %mem.Raw_Slice** %43, align 8
	%559 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %558, i64 0
	%560 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %559, i64 0, i32 1
	%561 = load i64, i64* %560, align 8
	%562 = sub i64 %561, 1
	%563 = load i64, i64* %45, align 8
	%564 = icmp sle i64 %563, %562
	br i1 %564, label %for.interval.body-74, label %for.interval.done-77

for.interval.body-74:
	%565 = load i64, i64* %45, align 8
	%566 = load i64, i64* %46, align 8
	%567 = load i64, i64* %45, align 8
	%568 = add i64 %567, 1
	store i64 %568, i64* %45
	%569 = load i64, i64* %46, align 8
	%570 = add i64 %569, 1
	store i64 %570, i64* %46
	store i64 %565, i64* %44
	; IfStmt
	%571 = load i64, i64* %44, align 8
	%572 = icmp sgt i64 %571, 0
	%573 = zext i1 %572 to i8
	%574 = trunc i8 %573 to i1
	br i1 %574, label %if.then-75, label %if.done-76

if.then-75:
	; SelectorExpr
	%575 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%576 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %575, i64 0
	%577 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %576, i64 0, i32 12
	%578 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %577, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %578, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$14d, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-76

if.done-76:
	; data
	; SelectorExpr
	%579 = load %mem.Raw_Slice*, %mem.Raw_Slice** %43, align 8
	%580 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %579, i64 0
	%581 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %580, i64 0, i32 0
	%582 = load %..rawptr, %..rawptr* %581, align 8
	%583 = ptrtoint %..rawptr %582 to i64
	%584 = load i64, i64* %44, align 8
	; SelectorExpr
	%585 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %42, i64 0, i32 1
	%586 = load i64, i64* %585, align 8
	%587 = mul i64 %584, %586
	%588 = bitcast i64 %587 to i64
	%589 = add i64 %583, %588
	store i64 %589, i64* %47
	%590 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%591 = bitcast %..any* %48 to %..rawptr
	%592 = call %..rawptr @mem.zero(%..rawptr %591, i64 16) noinline
	store %..any zeroinitializer, %..any* %48
	store %..any zeroinitializer, %..any* %48
	%593 = load i64, i64* %47, align 8
	%594 = inttoptr i64 %593 to %..rawptr
	%595 = getelementptr inbounds %..any, %..any* %48, i64 0, i32 0
	store %..rawptr %594, %..rawptr* %595
	; SelectorExpr
	; SelectorExpr
	%596 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %42, i64 0, i32 0
	%597 = load %runtime.Type_Info*, %runtime.Type_Info** %596, align 8
	%598 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %597, i64 0
	%599 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %598, i64 0, i32 2
	%600 = load %..typeid, %..typeid* %599, align 8
	%601 = getelementptr inbounds %..any, %..any* %48, i64 0, i32 1
	store %..typeid %600, %..typeid* %601
	%602 = load %..any, %..any* %48, align 8
	%603 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %590, %..any %602, i32 %603, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-73

for.interval.done-77:
	; defer
	; SelectorExpr
	%604 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%605 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %604, i64 0
	%606 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %605, i64 0, i32 12
	%607 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %606, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %607, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-78:
	%608 = icmp eq i8 %127, 16
	br i1 %608, label %typeswitch.body-101, label %typeswitch.next-100

typeswitch.body-79:
	%609 = bitcast %..rawptr %128 to %runtime.Type_Info_Map*
	%610 = load %runtime.Type_Info_Map, %runtime.Type_Info_Map* %609, align 8
	store %runtime.Type_Info_Map %610, %runtime.Type_Info_Map* %49
	; IfStmt
	%611 = load i32, i32* %2, align 4
	%612 = icmp ne i32 %611, 118
	%613 = zext i1 %612 to i8
	%614 = trunc i8 %613 to i1
	br i1 %614, label %if.then-80, label %if.done-81

if.then-80:
	%615 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%616 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %615, i32 %616, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-81:
	; SelectorExpr
	%617 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%618 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %617, i64 0
	%619 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %618, i64 0, i32 12
	%620 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %619, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %620, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$14e, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	; m
	; SelectorExpr
	%621 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%622 = load %..rawptr, %..rawptr* %621, align 8
	%623 = bitcast %..rawptr %622 to %mem.Raw_Map*
	store %mem.Raw_Map* %623, %mem.Raw_Map** %50
	; IfStmt
	%624 = load %mem.Raw_Map*, %mem.Raw_Map** %50, align 8
	%625 = icmp ne %mem.Raw_Map* %624, zeroinitializer
	%626 = zext i1 %625 to i8
	%627 = trunc i8 %626 to i1
	br i1 %627, label %if.then-82, label %if.done-99

if.then-82:
	; IfStmt
	; SelectorExpr
	%628 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %49, i64 0, i32 2
	%629 = load %runtime.Type_Info*, %runtime.Type_Info** %628, align 8
	%630 = icmp eq %runtime.Type_Info* %629, zeroinitializer
	%631 = zext i1 %630 to i8
	%632 = trunc i8 %631 to i1
	br i1 %632, label %if.then-83, label %if.done-84

if.then-83:
	; ReturnStmt
	; defer
	; SelectorExpr
	%633 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%634 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %633, i64 0
	%635 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %634, i64 0, i32 12
	%636 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %635, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %636, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void

if.done-84:
	; entries
	; SelectorExpr
	%637 = load %mem.Raw_Map*, %mem.Raw_Map** %50, align 8
	%638 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %637, i64 0
	%639 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %638, i64 0, i32 1
	store %mem.Raw_Dynamic_Array* %639, %mem.Raw_Dynamic_Array** %51
	; gs
	; SelectorExpr
	; SelectorExpr
	; SelectorExpr
	%640 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %49, i64 0, i32 2
	%641 = load %runtime.Type_Info*, %runtime.Type_Info** %640, align 8
	%642 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %641)
	%643 = bitcast %runtime.Type_Info** %53 to %..rawptr
	%644 = call %..rawptr @mem.zero(%..rawptr %643, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %53
	store %runtime.Type_Info* %642, %runtime.Type_Info** %53
	%645 = load %runtime.Type_Info*, %runtime.Type_Info** %53, align 8
	%646 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %645, i64 0
	%647 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %646, i64 0, i32 3
	%648 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %647, align 8
	; cast - union_cast
	%649 = bitcast {%runtime.Type_Info_Struct, i8}* %54 to %..rawptr
	%650 = call %..rawptr @mem.zero(%..rawptr %649, i64 80) noinline
	store {%runtime.Type_Info_Struct, i8} zeroinitializer, {%runtime.Type_Info_Struct, i8}* %54
	%651 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %647, i64 0, i32 2 ; UnionTagPtr
	%652 = load i8, i8* %651, align 1
	%653 = icmp eq i8 %652, 16
	br i1 %653, label %union_cast.ok-85, label %union_cast.end-86

union_cast.ok-85:
	%654 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %54, i64 0, i32 0
	%655 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %54, i64 0, i32 1
	%656 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %647 to %runtime.Type_Info_Struct*
	%657 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %656, align 8
	store %runtime.Type_Info_Struct %657, %runtime.Type_Info_Struct* %654
	store i8 1, i8* %655
	br label %union_cast.end-86

union_cast.end-86:
	%658 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %54, i64 0, i32 1
	%659 = load i8, i8* %658, align 1
	%660 = trunc i8 %659 to i1
	call void @runtime.type_assertion_check(i1 %660, %..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$14f, i64 0, i32 0), i64 53}, i64 1050, i64 64, %..typeid 1152921504606846991, %..typeid 3386706919782613039)
	%661 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %54, i64 0, i32 0
	%662 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %661, align 8
	store %runtime.Type_Info_Struct %662, %runtime.Type_Info_Struct* %52
	; ed
	; SelectorExpr
	; SelectorExpr
	; IndexExpr
	; SelectorExpr
	%663 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %52, i64 0, i32 0
	%664 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %663, align 8
	%665 = extractvalue {%runtime.Type_Info**, i64} %664, 0
	%666 = extractvalue {%runtime.Type_Info**, i64} %664, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$150, i64 0, i32 0), i64 53}, i64 1051, i64 50, i64 1, i64 %666)
	%667 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %665, i64 1
	%668 = load %runtime.Type_Info*, %runtime.Type_Info** %667, align 8
	%669 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %668)
	%670 = bitcast %runtime.Type_Info** %56 to %..rawptr
	%671 = call %..rawptr @mem.zero(%..rawptr %670, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %56
	store %runtime.Type_Info* %669, %runtime.Type_Info** %56
	%672 = load %runtime.Type_Info*, %runtime.Type_Info** %56, align 8
	%673 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %672, i64 0
	%674 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %673, i64 0, i32 3
	%675 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %674, align 8
	; cast - union_cast
	%676 = bitcast {%runtime.Type_Info_Dynamic_Array, i8}* %57 to %..rawptr
	%677 = call %..rawptr @mem.zero(%..rawptr %676, i64 24) noinline
	store {%runtime.Type_Info_Dynamic_Array, i8} zeroinitializer, {%runtime.Type_Info_Dynamic_Array, i8}* %57
	%678 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %674, i64 0, i32 2 ; UnionTagPtr
	%679 = load i8, i8* %678, align 1
	%680 = icmp eq i8 %679, 13
	br i1 %680, label %union_cast.ok-87, label %union_cast.end-88

union_cast.ok-87:
	%681 = getelementptr inbounds {%runtime.Type_Info_Dynamic_Array, i8}, {%runtime.Type_Info_Dynamic_Array, i8}* %57, i64 0, i32 0
	%682 = getelementptr inbounds {%runtime.Type_Info_Dynamic_Array, i8}, {%runtime.Type_Info_Dynamic_Array, i8}* %57, i64 0, i32 1
	%683 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %674 to %runtime.Type_Info_Dynamic_Array*
	%684 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %683, align 8
	store %runtime.Type_Info_Dynamic_Array %684, %runtime.Type_Info_Dynamic_Array* %681
	store i8 1, i8* %682
	br label %union_cast.end-88

union_cast.end-88:
	%685 = getelementptr inbounds {%runtime.Type_Info_Dynamic_Array, i8}, {%runtime.Type_Info_Dynamic_Array, i8}* %57, i64 0, i32 1
	%686 = load i8, i8* %685, align 1
	%687 = trunc i8 %686 to i1
	call void @runtime.type_assertion_check(i1 %687, %..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$151, i64 0, i32 0), i64 53}, i64 1051, i64 54, %..typeid 1152921504606846991, %..typeid 3386706919782613030)
	%688 = getelementptr inbounds {%runtime.Type_Info_Dynamic_Array, i8}, {%runtime.Type_Info_Dynamic_Array, i8}* %57, i64 0, i32 0
	%689 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %688, align 8
	store %runtime.Type_Info_Dynamic_Array %689, %runtime.Type_Info_Dynamic_Array* %55
	; entry_type
	; SelectorExpr
	; SelectorExpr
	%690 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %55, i64 0, i32 0
	%691 = load %runtime.Type_Info*, %runtime.Type_Info** %690, align 8
	%692 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %691, i64 0
	%693 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %692, i64 0, i32 3
	%694 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %693, align 8
	; cast - union_cast
	%695 = bitcast {%runtime.Type_Info_Struct, i8}* %59 to %..rawptr
	%696 = call %..rawptr @mem.zero(%..rawptr %695, i64 80) noinline
	store {%runtime.Type_Info_Struct, i8} zeroinitializer, {%runtime.Type_Info_Struct, i8}* %59
	%697 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %693, i64 0, i32 2 ; UnionTagPtr
	%698 = load i8, i8* %697, align 1
	%699 = icmp eq i8 %698, 16
	br i1 %699, label %union_cast.ok-89, label %union_cast.end-90

union_cast.ok-89:
	%700 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %59, i64 0, i32 0
	%701 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %59, i64 0, i32 1
	%702 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %693 to %runtime.Type_Info_Struct*
	%703 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %702, align 8
	store %runtime.Type_Info_Struct %703, %runtime.Type_Info_Struct* %700
	store i8 1, i8* %701
	br label %union_cast.end-90

union_cast.end-90:
	%704 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %59, i64 0, i32 1
	%705 = load i8, i8* %704, align 1
	%706 = trunc i8 %705 to i1
	call void @runtime.type_assertion_check(i1 %706, %..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$152, i64 0, i32 0), i64 53}, i64 1052, i64 26, %..typeid 1152921504606846991, %..typeid 3386706919782613039)
	%707 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %59, i64 0, i32 0
	%708 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %707, align 8
	store %runtime.Type_Info_Struct %708, %runtime.Type_Info_Struct* %58
	; entry_size
	; SelectorExpr
	%709 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %55, i64 0, i32 1
	%710 = load i64, i64* %709, align 8
	store i64 %710, i64* %60
	; RangeStmt
	; i
	%711 = bitcast i64* %61 to %..rawptr
	%712 = call %..rawptr @mem.zero(%..rawptr %711, i64 8) noinline
	store i64 zeroinitializer, i64* %61
	%713 = bitcast i64* %62 to %..rawptr
	%714 = call %..rawptr @mem.zero(%..rawptr %713, i64 8) noinline
	store i64 zeroinitializer, i64* %62
	store i64 0, i64* %62
	%715 = bitcast i64* %63 to %..rawptr
	%716 = call %..rawptr @mem.zero(%..rawptr %715, i64 8) noinline
	store i64 zeroinitializer, i64* %63
	store i64 0, i64* %63
	br label %for.interval.loop-91

for.interval.loop-91:
	; SelectorExpr
	%717 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %51, align 8
	%718 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %717, i64 0
	%719 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %718, i64 0, i32 1
	%720 = load i64, i64* %719, align 8
	%721 = sub i64 %720, 1
	%722 = load i64, i64* %62, align 8
	%723 = icmp sle i64 %722, %721
	br i1 %723, label %for.interval.body-92, label %for.interval.done-98

for.interval.body-92:
	%724 = load i64, i64* %62, align 8
	%725 = load i64, i64* %63, align 8
	%726 = load i64, i64* %62, align 8
	%727 = add i64 %726, 1
	store i64 %727, i64* %62
	%728 = load i64, i64* %63, align 8
	%729 = add i64 %728, 1
	store i64 %729, i64* %63
	store i64 %724, i64* %61
	; IfStmt
	%730 = load i64, i64* %61, align 8
	%731 = icmp sgt i64 %730, 0
	%732 = zext i1 %731 to i8
	%733 = trunc i8 %732 to i1
	br i1 %733, label %if.then-93, label %if.done-94

if.then-93:
	; SelectorExpr
	%734 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%735 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %734, i64 0
	%736 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %735, i64 0, i32 12
	%737 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %736, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %737, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$153, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-94

if.done-94:
	; data
	; SelectorExpr
	%738 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %51, align 8
	%739 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %738, i64 0
	%740 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %739, i64 0, i32 0
	%741 = load %..rawptr, %..rawptr* %740, align 8
	%742 = ptrtoint %..rawptr %741 to i64
	%743 = load i64, i64* %61, align 8
	%744 = load i64, i64* %60, align 8
	%745 = mul i64 %743, %744
	%746 = bitcast i64 %745 to i64
	%747 = add i64 %742, %746
	store i64 %747, i64* %64
	; header
	%748 = load i64, i64* %64, align 8
	%749 = inttoptr i64 %748 to %runtime.Map_Entry_Header*
	store %runtime.Map_Entry_Header* %749, %runtime.Map_Entry_Header** %65
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%750 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %49, i64 0, i32 0
	%751 = load %runtime.Type_Info*, %runtime.Type_Info** %750, align 8
	%752 = call i8 @types.is_string(%runtime.Type_Info* %751, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%753 = trunc i8 %752 to i1
	br i1 %753, label %if.then-95, label %if.else-96

if.then-95:
	; SelectorExpr
	%754 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%755 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %754, i64 0
	%756 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %755, i64 0, i32 12
	%757 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %756, align 8
	; SelectorExpr
	; SelectorExpr
	%758 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %65, align 8
	%759 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %758, i64 0
	%760 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %759, i64 0, i32 0
	%761 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %760, i64 0, i32 1
	%762 = load %..string, %..string* %761, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %757, %..string %762, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-97

if.else-96:
	; fi
	; CompoundLit
	%763 = bitcast %fmt.Fmt_Info* %67 to %..rawptr
	%764 = call %..rawptr @mem.zero(%..rawptr %763, i64 64) noinline
	store %fmt.Fmt_Info zeroinitializer, %fmt.Fmt_Info* %67
	store %fmt.Fmt_Info {i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, {i8*, i64, i64, %mem.Allocator}* zeroinitializer, %..any zeroinitializer}, %fmt.Fmt_Info* %67
	; SelectorExpr
	%765 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%766 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %765, i64 0
	%767 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %766, i64 0, i32 12
	%768 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %767, align 8
	%769 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %67, i64 0, i32 12
	store {i8*, i64, i64, %mem.Allocator}* %768, {i8*, i64, i64, %mem.Allocator}** %769
	%770 = load %fmt.Fmt_Info, %fmt.Fmt_Info* %67, align 8
	store %fmt.Fmt_Info %770, %fmt.Fmt_Info* %66
	; CompoundLit
	%771 = bitcast %..any* %68 to %..rawptr
	%772 = call %..rawptr @mem.zero(%..rawptr %771, i64 16) noinline
	store %..any zeroinitializer, %..any* %68
	store %..any zeroinitializer, %..any* %68
	; SelectorExpr
	; SelectorExpr
	%773 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %65, align 8
	%774 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %773, i64 0
	%775 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %774, i64 0, i32 0
	%776 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %775, i64 0, i32 0
	%777 = bitcast i64* %776 to %..rawptr
	%778 = getelementptr inbounds %..any, %..any* %68, i64 0, i32 0
	store %..rawptr %777, %..rawptr* %778
	; SelectorExpr
	; SelectorExpr
	%779 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %49, i64 0, i32 0
	%780 = load %runtime.Type_Info*, %runtime.Type_Info** %779, align 8
	%781 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %780, i64 0
	%782 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %781, i64 0, i32 2
	%783 = load %..typeid, %..typeid* %782, align 8
	%784 = getelementptr inbounds %..any, %..any* %68, i64 0, i32 1
	store %..typeid %783, %..typeid* %784
	%785 = load %..any, %..any* %68, align 8
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %66, %..any %785, i32 118, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-97

if.done-97:
	; SelectorExpr
	%786 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%787 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %786, i64 0
	%788 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %787, i64 0, i32 12
	%789 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %788, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %789, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$154, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; value
	%790 = load i64, i64* %64, align 8
	; IndexExpr
	; SelectorExpr
	%791 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %58, i64 0, i32 2
	%792 = load {i64*, i64}, {i64*, i64}* %791, align 8
	%793 = extractvalue {i64*, i64} %792, 0
	%794 = extractvalue {i64*, i64} %792, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$155, i64 0, i32 0), i64 53}, i64 1070, i64 40, i64 2, i64 %794)
	%795 = getelementptr inbounds i64, i64* %793, i64 2
	%796 = load i64, i64* %795, align 8
	%797 = add i64 %790, %796
	store i64 %797, i64* %69
	%798 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%799 = bitcast %..any* %70 to %..rawptr
	%800 = call %..rawptr @mem.zero(%..rawptr %799, i64 16) noinline
	store %..any zeroinitializer, %..any* %70
	store %..any zeroinitializer, %..any* %70
	%801 = load i64, i64* %69, align 8
	%802 = inttoptr i64 %801 to %..rawptr
	%803 = getelementptr inbounds %..any, %..any* %70, i64 0, i32 0
	store %..rawptr %802, %..rawptr* %803
	; SelectorExpr
	; SelectorExpr
	%804 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %49, i64 0, i32 1
	%805 = load %runtime.Type_Info*, %runtime.Type_Info** %804, align 8
	%806 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %805, i64 0
	%807 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %806, i64 0, i32 2
	%808 = load %..typeid, %..typeid* %807, align 8
	%809 = getelementptr inbounds %..any, %..any* %70, i64 0, i32 1
	store %..typeid %808, %..typeid* %809
	%810 = load %..any, %..any* %70, align 8
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %798, %..any %810, i32 118, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-91

for.interval.done-98:
	br label %if.done-99

if.done-99:
	; defer
	; SelectorExpr
	%811 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%812 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %811, i64 0
	%813 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %812, i64 0, i32 12
	%814 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %813, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %814, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-100:
	%815 = icmp eq i8 %127, 17
	br i1 %815, label %typeswitch.body-123, label %typeswitch.next-122

typeswitch.body-101:
	%816 = bitcast %..rawptr %128 to %runtime.Type_Info_Struct*
	%817 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %816, align 8
	store %runtime.Type_Info_Struct %817, %runtime.Type_Info_Struct* %71
	; IfStmt
	; SelectorExpr
	%818 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %71, i64 0, i32 5
	%819 = load i8, i8* %818, align 1
	%820 = trunc i8 %819 to i1
	br i1 %820, label %if.then-102, label %if.done-103

if.then-102:
	; SelectorExpr
	%821 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%822 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %821, i64 0
	%823 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %822, i64 0, i32 12
	%824 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %823, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %824, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$156, i64 0, i32 0), i64 11}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-103:
	; SelectorExpr
	%825 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%826 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %825, i64 0
	%827 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %826, i64 0, i32 12
	%828 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %827, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %828, i8 123, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	; AssignStmt
	; SelectorExpr
	%829 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%830 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %829, i64 0
	%831 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %830, i64 0, i32 9
	%832 = load i64, i64* %831, align 8
	%833 = add i64 %832, 1
	store i64 %833, i64* %831
	; DeferStmt
	; hash
	; SelectorExpr
	%834 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%835 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %834, i64 0
	%836 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %835, i64 0, i32 4
	%837 = load i8, i8* %836, align 1
	store i8 %837, i8* %72
	; DeferStmt
	; AssignStmt
	; SelectorExpr
	%838 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%839 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %838, i64 0
	%840 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %839, i64 0, i32 4
	store i8 0, i8* %840
	; IfStmt
	%841 = load i8, i8* %72, align 1
	%842 = trunc i8 %841 to i1
	br i1 %842, label %if.then-104, label %if.done-105

if.then-104:
	; SelectorExpr
	%843 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%844 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %843, i64 0
	%845 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %844, i64 0, i32 12
	%846 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %845, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %846, i8 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-105

if.done-105:
	; RangeStmt
	; i
	%847 = bitcast i64* %73 to %..rawptr
	%848 = call %..rawptr @mem.zero(%..rawptr %847, i64 8) noinline
	store i64 zeroinitializer, i64* %73
	; SelectorExpr
	%849 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %71, i64 0, i32 1
	%850 = load {%..string*, i64}, {%..string*, i64}* %849, align 8
	%851 = bitcast i64* %74 to %..rawptr
	%852 = call %..rawptr @mem.zero(%..rawptr %851, i64 8) noinline
	store i64 zeroinitializer, i64* %74
	%853 = extractvalue {%..string*, i64} %850, 1
	store i64 %853, i64* %74
	%854 = bitcast i64* %75 to %..rawptr
	%855 = call %..rawptr @mem.zero(%..rawptr %854, i64 8) noinline
	store i64 zeroinitializer, i64* %75
	store i64 -1, i64* %75
	br label %for.index.loop-106

for.index.loop-106:
	%856 = load i64, i64* %75, align 8
	%857 = add i64 %856, 1
	store i64 %857, i64* %75
	%858 = load i64, i64* %74, align 8
	%859 = icmp slt i64 %857, %858
	br i1 %859, label %for.index.body-107, label %for.index.done-121

for.index.body-107:
	%860 = load i64, i64* %75, align 8
	store i64 %860, i64* %73
	; IfStmt
	%861 = load i8, i8* %72, align 1
	%862 = trunc i8 %861 to i1
	br i1 %862, label %if.done-110, label %cmp.and-108

cmp.and-108:
	%863 = load i64, i64* %73, align 8
	%864 = icmp sgt i64 %863, 0
	%865 = zext i1 %864 to i8
	%866 = trunc i8 %865 to i1
	br i1 %866, label %if.then-109, label %if.done-110

if.then-109:
	; SelectorExpr
	%867 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%868 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %867, i64 0
	%869 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %868, i64 0, i32 12
	%870 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %869, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %870, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$157, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-110

if.done-110:
	; IfStmt
	%871 = load i8, i8* %72, align 1
	%872 = trunc i8 %871 to i1
	br i1 %872, label %if.then-111, label %if.done-115

if.then-111:
	; RangeStmt
	%873 = bitcast i64* %76 to %..rawptr
	%874 = call %..rawptr @mem.zero(%..rawptr %873, i64 8) noinline
	store i64 zeroinitializer, i64* %76
	store i64 0, i64* %76
	%875 = bitcast i64* %77 to %..rawptr
	%876 = call %..rawptr @mem.zero(%..rawptr %875, i64 8) noinline
	store i64 zeroinitializer, i64* %77
	store i64 0, i64* %77
	br label %for.interval.loop-112

for.interval.loop-112:
	; SelectorExpr
	%877 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%878 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %877, i64 0
	%879 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %878, i64 0, i32 9
	%880 = load i64, i64* %879, align 8
	%881 = sub i64 %880, 1
	%882 = load i64, i64* %76, align 8
	%883 = icmp sle i64 %882, %881
	br i1 %883, label %for.interval.body-113, label %for.interval.done-114

for.interval.body-113:
	%884 = load i64, i64* %76, align 8
	%885 = load i64, i64* %77, align 8
	%886 = load i64, i64* %76, align 8
	%887 = add i64 %886, 1
	store i64 %887, i64* %76
	%888 = load i64, i64* %77, align 8
	%889 = add i64 %888, 1
	store i64 %889, i64* %77
	; SelectorExpr
	%890 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%891 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %890, i64 0
	%892 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %891, i64 0, i32 12
	%893 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %892, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %893, i8 9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-112

for.interval.done-114:
	br label %if.done-115

if.done-115:
	; SelectorExpr
	%894 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%895 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %894, i64 0
	%896 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %895, i64 0, i32 12
	%897 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %896, align 8
	; IndexExpr
	; SelectorExpr
	%898 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %71, i64 0, i32 1
	%899 = load {%..string*, i64}, {%..string*, i64}* %898, align 8
	%900 = extractvalue {%..string*, i64} %899, 0
	%901 = load i64, i64* %73, align 8
	%902 = extractvalue {%..string*, i64} %899, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$158, i64 0, i32 0), i64 53}, i64 1099, i64 36, i64 %901, i64 %902)
	%903 = getelementptr inbounds %..string, %..string* %900, i64 %901
	%904 = load %..string, %..string* %903, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %897, %..string %904, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%905 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%906 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %905, i64 0
	%907 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %906, i64 0, i32 12
	%908 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %907, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %908, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$159, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; t
	; IndexExpr
	; SelectorExpr
	%909 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %71, i64 0, i32 0
	%910 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %909, align 8
	%911 = extractvalue {%runtime.Type_Info**, i64} %910, 0
	%912 = load i64, i64* %73, align 8
	%913 = extractvalue {%runtime.Type_Info**, i64} %910, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$15a, i64 0, i32 0), i64 53}, i64 1102, i64 23, i64 %912, i64 %913)
	%914 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %911, i64 %912
	%915 = load %runtime.Type_Info*, %runtime.Type_Info** %914, align 8
	store %runtime.Type_Info* %915, %runtime.Type_Info** %78
	; SelectorExpr
	%916 = load %runtime.Type_Info*, %runtime.Type_Info** %78, align 8
	%917 = call i8 @types.is_any(%runtime.Type_Info* %916, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%918 = trunc i8 %917 to i1
	br i1 %918, label %if.then-116, label %if.else-117

if.then-116:
	; SelectorExpr
	%919 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%920 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %919, i64 0
	%921 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %920, i64 0, i32 12
	%922 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %921, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %922, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$15b, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-118

if.else-117:
	; data
	; SelectorExpr
	%923 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%924 = load %..rawptr, %..rawptr* %923, align 8
	%925 = ptrtoint %..rawptr %924 to i64
	; IndexExpr
	; SelectorExpr
	%926 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %71, i64 0, i32 2
	%927 = load {i64*, i64}, {i64*, i64}* %926, align 8
	%928 = extractvalue {i64*, i64} %927, 0
	%929 = load i64, i64* %73, align 8
	%930 = extractvalue {i64*, i64} %927, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$15c, i64 0, i32 0), i64 53}, i64 1105, i64 44, i64 %929, i64 %930)
	%931 = getelementptr inbounds i64, i64* %928, i64 %929
	%932 = load i64, i64* %931, align 8
	%933 = add i64 %925, %932
	store i64 %933, i64* %79
	%934 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%935 = bitcast %..any* %80 to %..rawptr
	%936 = call %..rawptr @mem.zero(%..rawptr %935, i64 16) noinline
	store %..any zeroinitializer, %..any* %80
	store %..any zeroinitializer, %..any* %80
	%937 = load i64, i64* %79, align 8
	%938 = inttoptr i64 %937 to %..rawptr
	%939 = getelementptr inbounds %..any, %..any* %80, i64 0, i32 0
	store %..rawptr %938, %..rawptr* %939
	; SelectorExpr
	%940 = load %runtime.Type_Info*, %runtime.Type_Info** %78, align 8
	%941 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %940, i64 0
	%942 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %941, i64 0, i32 2
	%943 = load %..typeid, %..typeid* %942, align 8
	%944 = getelementptr inbounds %..any, %..any* %80, i64 0, i32 1
	store %..typeid %943, %..typeid* %944
	%945 = load %..any, %..any* %80, align 8
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %934, %..any %945, i32 118, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-118

if.done-118:
	; IfStmt
	%946 = load i8, i8* %72, align 1
	%947 = trunc i8 %946 to i1
	br i1 %947, label %if.then-119, label %if.done-120

if.then-119:
	; SelectorExpr
	%948 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%949 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %948, i64 0
	%950 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %949, i64 0, i32 12
	%951 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %950, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %951, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$15d, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-120

if.done-120:
	br label %for.index.loop-106

for.index.done-121:
	; defer
	; AssignStmt
	; SelectorExpr
	%952 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%953 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %952, i64 0
	%954 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %953, i64 0, i32 4
	%955 = load i8, i8* %72, align 1
	store i8 %955, i8* %954
	; defer
	; AssignStmt
	; SelectorExpr
	%956 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%957 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %956, i64 0
	%958 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %957, i64 0, i32 9
	%959 = load i64, i64* %958, align 8
	%960 = sub i64 %959, 1
	store i64 %960, i64* %958
	; defer
	; SelectorExpr
	%961 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%962 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %961, i64 0
	%963 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %962, i64 0, i32 12
	%964 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %963, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %964, i8 125, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-122:
	%965 = icmp eq i8 %127, 18
	br i1 %965, label %typeswitch.body-146, label %typeswitch.next-145

typeswitch.body-123:
	%966 = bitcast %..rawptr %128 to %runtime.Type_Info_Union*
	%967 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %966, align 8
	store %runtime.Type_Info_Union %967, %runtime.Type_Info_Union* %81
	; tag_ptr
	; SelectorExpr
	%968 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%969 = load %..rawptr, %..rawptr* %968, align 8
	%970 = ptrtoint %..rawptr %969 to i64
	; SelectorExpr
	%971 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %81, i64 0, i32 1
	%972 = load i64, i64* %971, align 8
	%973 = add i64 %970, %972
	store i64 %973, i64* %82
	; tag_any
	; CompoundLit
	%974 = bitcast %..any* %84 to %..rawptr
	%975 = call %..rawptr @mem.zero(%..rawptr %974, i64 16) noinline
	store %..any zeroinitializer, %..any* %84
	store %..any zeroinitializer, %..any* %84
	%976 = load i64, i64* %82, align 8
	%977 = inttoptr i64 %976 to %..rawptr
	%978 = getelementptr inbounds %..any, %..any* %84, i64 0, i32 0
	store %..rawptr %977, %..rawptr* %978
	; SelectorExpr
	; SelectorExpr
	%979 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %81, i64 0, i32 2
	%980 = load %runtime.Type_Info*, %runtime.Type_Info** %979, align 8
	%981 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %980, i64 0
	%982 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %981, i64 0, i32 2
	%983 = load %..typeid, %..typeid* %982, align 8
	%984 = getelementptr inbounds %..any, %..any* %84, i64 0, i32 1
	store %..typeid %983, %..typeid* %984
	%985 = load %..any, %..any* %84, align 8
	store %..any %985, %..any* %83
	; tag
	store i64 -1, i64* %85
	; TypeSwitchStmt
	%986 = load %..any, %..any* %83, align 8
	%987 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%988 = load %..typeid, %..typeid* %987, align 8
	%989 = icmp eq %..typeid %988, 72057594037927939
	br i1 %989, label %typeswitch.body-125, label %typeswitch.next-124

typeswitch.next-124:
	%990 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%991 = load %..typeid, %..typeid* %990, align 8
	%992 = icmp eq %..typeid %991, 4683743612465315902
	br i1 %992, label %typeswitch.body-127, label %typeswitch.next-126

typeswitch.body-125:
	%993 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%994 = load %..rawptr, %..rawptr* %993, align 8
	%995 = bitcast %..rawptr %994 to i8*
	%996 = load i8, i8* %995, align 1
	store i8 %996, i8* %86
	; AssignStmt
	%997 = load i8, i8* %86, align 1
	%998 = zext i8 %997 to i64
	store i64 %998, i64* %85
	br label %typeswitch.done-140

typeswitch.next-126:
	%999 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%1000 = load %..typeid, %..typeid* %999, align 8
	%1001 = icmp eq %..typeid %1000, 72057594037928001
	br i1 %1001, label %typeswitch.body-129, label %typeswitch.next-128

typeswitch.body-127:
	%1002 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%1003 = load %..rawptr, %..rawptr* %1002, align 8
	%1004 = bitcast %..rawptr %1003 to i8*
	%1005 = load i8, i8* %1004, align 1
	store i8 %1005, i8* %87
	; AssignStmt
	%1006 = load i8, i8* %87, align 1
	%1007 = sext i8 %1006 to i64
	store i64 %1007, i64* %85
	br label %typeswitch.done-140

typeswitch.next-128:
	%1008 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%1009 = load %..typeid, %..typeid* %1008, align 8
	%1010 = icmp eq %..typeid %1009, 4683743612465315903
	br i1 %1010, label %typeswitch.body-131, label %typeswitch.next-130

typeswitch.body-129:
	%1011 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%1012 = load %..rawptr, %..rawptr* %1011, align 8
	%1013 = bitcast %..rawptr %1012 to i16*
	%1014 = load i16, i16* %1013, align 2
	store i16 %1014, i16* %88
	; AssignStmt
	%1015 = load i16, i16* %88, align 2
	%1016 = zext i16 %1015 to i64
	store i64 %1016, i64* %85
	br label %typeswitch.done-140

typeswitch.next-130:
	%1017 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%1018 = load %..typeid, %..typeid* %1017, align 8
	%1019 = icmp eq %..typeid %1018, 72057594037928002
	br i1 %1019, label %typeswitch.body-133, label %typeswitch.next-132

typeswitch.body-131:
	%1020 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%1021 = load %..rawptr, %..rawptr* %1020, align 8
	%1022 = bitcast %..rawptr %1021 to i16*
	%1023 = load i16, i16* %1022, align 2
	store i16 %1023, i16* %89
	; AssignStmt
	%1024 = load i16, i16* %89, align 2
	%1025 = sext i16 %1024 to i64
	store i64 %1025, i64* %85
	br label %typeswitch.done-140

typeswitch.next-132:
	%1026 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%1027 = load %..typeid, %..typeid* %1026, align 8
	%1028 = icmp eq %..typeid %1027, 4683743612465315848
	br i1 %1028, label %typeswitch.body-135, label %typeswitch.next-134

typeswitch.body-133:
	%1029 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%1030 = load %..rawptr, %..rawptr* %1029, align 8
	%1031 = bitcast %..rawptr %1030 to i32*
	%1032 = load i32, i32* %1031, align 4
	store i32 %1032, i32* %90
	; AssignStmt
	%1033 = load i32, i32* %90, align 4
	%1034 = zext i32 %1033 to i64
	store i64 %1034, i64* %85
	br label %typeswitch.done-140

typeswitch.next-134:
	%1035 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%1036 = load %..typeid, %..typeid* %1035, align 8
	%1037 = icmp eq %..typeid %1036, 72057594037927943
	br i1 %1037, label %typeswitch.body-137, label %typeswitch.next-136

typeswitch.body-135:
	%1038 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%1039 = load %..rawptr, %..rawptr* %1038, align 8
	%1040 = bitcast %..rawptr %1039 to i32*
	%1041 = load i32, i32* %1040, align 4
	store i32 %1041, i32* %91
	; AssignStmt
	%1042 = load i32, i32* %91, align 4
	%1043 = sext i32 %1042 to i64
	store i64 %1043, i64* %85
	br label %typeswitch.done-140

typeswitch.next-136:
	%1044 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%1045 = load %..typeid, %..typeid* %1044, align 8
	%1046 = icmp eq %..typeid %1045, 4683743612465315904
	br i1 %1046, label %typeswitch.body-139, label %typeswitch.next-138

typeswitch.body-137:
	%1047 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%1048 = load %..rawptr, %..rawptr* %1047, align 8
	%1049 = bitcast %..rawptr %1048 to i64*
	%1050 = load i64, i64* %1049, align 8
	store i64 %1050, i64* %92
	; AssignStmt
	%1051 = load i64, i64* %92, align 8
	%1052 = bitcast i64 %1051 to i64
	store i64 %1052, i64* %85
	br label %typeswitch.done-140

typeswitch.next-138:
	store %..any %986, %..any* %94
	%1053 = bitcast %runtime.Source_Code_Location* %95 to %..rawptr
	%1054 = call %..rawptr @mem.zero(%..rawptr %1053, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %95
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$15e, i64 0, i32 0), i64 53}, i64 1125, i64 9, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$15f, i64 0, i32 0), i64 9}}, %runtime.Source_Code_Location* %95
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$160, i64 0, i32 0), i64 22}, %runtime.Source_Code_Location* %95) noreturn
	br label %typeswitch.done-140

typeswitch.body-139:
	%1055 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%1056 = load %..rawptr, %..rawptr* %1055, align 8
	%1057 = bitcast %..rawptr %1056 to i64*
	%1058 = load i64, i64* %1057, align 8
	store i64 %1058, i64* %93
	; AssignStmt
	%1059 = load i64, i64* %93, align 8
	store i64 %1059, i64* %85
	br label %typeswitch.done-140

typeswitch.done-140:
	; IfStmt
	; SelectorExpr
	%1060 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%1061 = load %..rawptr, %..rawptr* %1060, align 8
	%1062 = icmp eq %..rawptr %1061, zeroinitializer
	%1063 = zext i1 %1062 to i8
	%1064 = trunc i8 %1063 to i1
	br i1 %1064, label %if.then-142, label %cmp.or-141

cmp.or-141:
	%1065 = load i64, i64* %85, align 8
	%1066 = icmp eq i64 %1065, 0
	%1067 = zext i1 %1066 to i8
	%1068 = trunc i8 %1067 to i1
	br i1 %1068, label %if.then-142, label %if.else-143

if.then-142:
	; SelectorExpr
	%1069 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1070 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1069, i64 0
	%1071 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1070, i64 0, i32 12
	%1072 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %1071, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %1072, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$161, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-144

if.else-143:
	; id
	; SelectorExpr
	; IndexExpr
	; SelectorExpr
	%1073 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %81, i64 0, i32 0
	%1074 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1073, align 8
	%1075 = extractvalue {%runtime.Type_Info**, i64} %1074, 0
	%1076 = load i64, i64* %85, align 8
	%1077 = sub i64 %1076, 1
	%1078 = bitcast i64 %1077 to i64
	%1079 = extractvalue {%runtime.Type_Info**, i64} %1074, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$162, i64 0, i32 0), i64 53}, i64 1131, i64 24, i64 %1078, i64 %1079)
	%1080 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1075, i64 %1078
	%1081 = load %runtime.Type_Info*, %runtime.Type_Info** %1080, align 8
	%1082 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1081, i64 0
	%1083 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1082, i64 0, i32 2
	%1084 = load %..typeid, %..typeid* %1083, align 8
	store %..typeid %1084, %..typeid* %96
	%1085 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%1086 = bitcast %..any* %97 to %..rawptr
	%1087 = call %..rawptr @mem.zero(%..rawptr %1086, i64 16) noinline
	store %..any zeroinitializer, %..any* %97
	store %..any zeroinitializer, %..any* %97
	; SelectorExpr
	%1088 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%1089 = load %..rawptr, %..rawptr* %1088, align 8
	%1090 = getelementptr inbounds %..any, %..any* %97, i64 0, i32 0
	store %..rawptr %1089, %..rawptr* %1090
	%1091 = load %..typeid, %..typeid* %96, align 8
	%1092 = getelementptr inbounds %..any, %..any* %97, i64 0, i32 1
	store %..typeid %1091, %..typeid* %1092
	%1093 = load %..any, %..any* %97, align 8
	%1094 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %1085, %..any %1093, i32 %1094, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-144

if.done-144:
	br label %typeswitch.done-158

typeswitch.next-145:
	%1095 = icmp eq i8 %127, 11
	br i1 %1095, label %typeswitch.body-148, label %typeswitch.next-147

typeswitch.body-146:
	%1096 = bitcast %..rawptr %128 to %runtime.Type_Info_Enum*
	%1097 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %1096, align 8
	store %runtime.Type_Info_Enum %1097, %runtime.Type_Info_Enum* %98
	%1098 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1099 = load %..any, %..any* %1, align 8
	%1100 = load i32, i32* %2, align 4
	call void @fmt.fmt_enum(%fmt.Fmt_Info* %1098, %..any %1099, i32 %1100, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-147:
	%1101 = icmp eq i8 %127, 9
	br i1 %1101, label %typeswitch.body-153, label %typeswitch.next-152

typeswitch.body-148:
	%1102 = bitcast %..rawptr %128 to %runtime.Type_Info_Procedure*
	%1103 = load %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %1102, align 8
	store %runtime.Type_Info_Procedure %1103, %runtime.Type_Info_Procedure* %99
	; ptr
	; SelectorExpr
	%1104 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%1105 = load %..rawptr, %..rawptr* %1104, align 8
	%1106 = bitcast %..rawptr %1105 to %..rawptr*
	%1107 = getelementptr inbounds %..rawptr, %..rawptr* %1106, i64 0
	%1108 = load %..rawptr, %..rawptr* %1107, align 8
	store %..rawptr %1108, %..rawptr* %100
	; IfStmt
	%1109 = load %..rawptr, %..rawptr* %100, align 8
	%1110 = icmp eq %..rawptr %1109, zeroinitializer
	%1111 = zext i1 %1110 to i8
	%1112 = trunc i8 %1111 to i1
	br i1 %1112, label %if.then-149, label %if.else-150

if.then-149:
	; SelectorExpr
	%1113 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1114 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1113, i64 0
	%1115 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1114, i64 0, i32 12
	%1116 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %1115, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %1116, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$163, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-151

if.else-150:
	; SelectorExpr
	%1117 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1118 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1117, i64 0
	%1119 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1118, i64 0, i32 12
	%1120 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %1119, align 8
	; SelectorExpr
	%1121 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%1122 = load %..typeid, %..typeid* %1121, align 8
	call void @fmt.write_typeid({i8*, i64, i64, %mem.Allocator}* %1120, %..typeid %1122, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%1123 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1124 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1123, i64 0
	%1125 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1124, i64 0, i32 12
	%1126 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %1125, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %1126, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$164, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%1127 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1128 = load %..rawptr, %..rawptr* %100, align 8
	call void @fmt.fmt_pointer(%fmt.Fmt_Info* %1127, %..rawptr %1128, i32 112, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-151

if.done-151:
	br label %typeswitch.done-158

typeswitch.next-152:
	%1129 = icmp eq i8 %127, 20
	br i1 %1129, label %typeswitch.body-155, label %typeswitch.next-154

typeswitch.body-153:
	%1130 = bitcast %..rawptr %128 to %runtime.Type_Info_Type_Id*
	%1131 = load %runtime.Type_Info_Type_Id, %runtime.Type_Info_Type_Id* %1130, align 1
	store %runtime.Type_Info_Type_Id %1131, %runtime.Type_Info_Type_Id* %101
	; id
	; SelectorExpr
	%1132 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%1133 = load %..rawptr, %..rawptr* %1132, align 8
	%1134 = bitcast %..rawptr %1133 to %..typeid*
	%1135 = getelementptr inbounds %..typeid, %..typeid* %1134, i64 0
	%1136 = load %..typeid, %..typeid* %1135, align 8
	store %..typeid %1136, %..typeid* %102
	; SelectorExpr
	%1137 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1138 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1137, i64 0
	%1139 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1138, i64 0, i32 12
	%1140 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %1139, align 8
	%1141 = load %..typeid, %..typeid* %102, align 8
	call void @fmt.write_typeid({i8*, i64, i64, %mem.Allocator}* %1140, %..typeid %1141, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-154:
	%1142 = icmp eq i8 %127, 21
	br i1 %1142, label %typeswitch.body-157, label %typeswitch.next-156

typeswitch.body-155:
	%1143 = bitcast %..rawptr %128 to %runtime.Type_Info_Bit_Field*
	%1144 = load %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %1143, align 8
	store %runtime.Type_Info_Bit_Field %1144, %runtime.Type_Info_Bit_Field* %103
	%1145 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1146 = load %..any, %..any* %1, align 8
	call void @fmt.fmt_bit_field(%fmt.Fmt_Info* %1145, %..any %1146, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-156:
	br label %typeswitch.done-158

typeswitch.body-157:
	%1147 = bitcast %..rawptr %128 to %runtime.Type_Info_Bit_Set*
	%1148 = load %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %1147, align 8
	store %runtime.Type_Info_Bit_Set %1148, %runtime.Type_Info_Bit_Set* %104
	%1149 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1150 = load %..any, %..any* %1, align 8
	call void @fmt.fmt_bit_set(%fmt.Fmt_Info* %1149, %..any %1150, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.done-158:
	ret void
}

define void @fmt.fmt_complex(%fmt.Fmt_Info* %fi, %..complex128* %c, i64 %bits, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i32, align 16
	%3 = alloca double, align 16
	%4 = alloca double, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	%5 = load %..complex128, %..complex128* %c, align 8
	store i64 %bits, i64* %1
	store i32 %verb, i32* %2
	; SwitchStmt
	%6 = load i32, i32* %2, align 4
	%7 = icmp eq i32 %6, 102
	br i1 %7, label %switch.case.body-4, label %switch.case.next-1

switch.case.next-1:
	%8 = icmp eq i32 %6, 70
	br i1 %8, label %switch.case.body-4, label %switch.case.next-2

switch.case.next-2:
	%9 = icmp eq i32 %6, 118
	br i1 %9, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%10 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%11 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %10, i32 %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

switch.case.body-4:
	; r
	; i
	; real
	%12 = load %..complex128, %..complex128* %c, align 8
	%13 = extractvalue %..complex128 %12, 0
	; imag
	%14 = load %..complex128, %..complex128* %c, align 8
	%15 = extractvalue %..complex128 %14, 1
	store double %13, double* %3
	store double %15, double* %4
	%16 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%17 = load double, double* %3, align 8
	%18 = load i64, i64* %1, align 8
	%19 = sdiv i64 %18, 2
	%20 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Fmt_Info* %16, double %17, i64 %19, i32 %20, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%21 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%22 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %21, i64 0
	%23 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %22, i64 0, i32 1
	%24 = load i8, i8* %23, align 1
	%25 = trunc i8 %24 to i1
	br i1 %25, label %if.done-7, label %cmp.and-5

cmp.and-5:
	%26 = load double, double* %4, align 8
	%27 = fcmp oge double %26, 0x0000000000000000
	%28 = zext i1 %27 to i8
	%29 = trunc i8 %28 to i1
	br i1 %29, label %if.then-6, label %if.done-7

if.then-6:
	; SelectorExpr
	%30 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%31 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %30, i64 0
	%32 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %31, i64 0, i32 12
	%33 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %32, align 8
	call void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %33, i32 43, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-7

if.done-7:
	%34 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%35 = load double, double* %4, align 8
	%36 = load i64, i64* %1, align 8
	%37 = sdiv i64 %36, 2
	%38 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Fmt_Info* %34, double %35, i64 %37, i32 %38, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%39 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%40 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %39, i64 0
	%41 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %40, i64 0, i32 12
	%42 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %41, align 8
	call void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %42, i32 105, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.fmt_arg(%fmt.Fmt_Info* %fi, %..any %arg, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca i32, align 16
	%3 = alloca %runtime.Type_Info*, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca %..any, align 16
	%6 = alloca i8, align 16
	%7 = alloca i8, align 16
	%8 = alloca i16, align 16
	%9 = alloca i32, align 16
	%10 = alloca i64, align 16
	%11 = alloca %..any, align 16
	%12 = alloca i32, align 16
	%13 = alloca float, align 16
	%14 = alloca double, align 16
	%15 = alloca %..complex64, align 16
	%16 = alloca %..complex128, align 16
	%17 = alloca %..complex128, align 16
	%18 = alloca %..complex128, align 16
	%19 = alloca %..complex128, align 16
	%20 = alloca i8, align 16
	%21 = alloca i8, align 16
	%22 = alloca i16, align 16
	%23 = alloca i16, align 16
	%24 = alloca i32, align 16
	%25 = alloca i32, align 16
	%26 = alloca i64, align 16
	%27 = alloca i64, align 16
	%28 = alloca i64, align 16
	%29 = alloca i64, align 16
	%30 = alloca i64, align 16
	%31 = alloca %..string, align 16
	%32 = alloca i8*, align 16
	%33 = alloca %..typeid, align 16
	%34 = alloca %..any, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..any %arg, %..any* %1
	store i32 %verb, i32* %2
	; IfStmt
	%35 = load %..any, %..any* %1, align 8
	%36 = extractvalue %..any %35, 0
	%37 = extractvalue %..any %35, 1
	%38 = icmp eq %..rawptr %36, null
	%39 = icmp eq %..typeid %37, 0
	%40 = zext i1 %38 to i8
	%41 = zext i1 %39 to i8
	%42 = or i8 %40, %41
	%43 = trunc i8 %42 to i1
	br i1 %43, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	%44 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%45 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %44, i64 0
	%46 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %45, i64 0, i32 12
	%47 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %46, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %47, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$165, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-2:
	; AssignStmt
	; SelectorExpr
	%48 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%49 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %48, i64 0
	%50 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %49, i64 0, i32 13
	%51 = load %..any, %..any* %1, align 8
	store %..any %51, %..any* %50
	; IfStmt
	%52 = load i32, i32* %2, align 4
	%53 = icmp eq i32 %52, 84
	%54 = zext i1 %53 to i8
	%55 = trunc i8 %54 to i1
	br i1 %55, label %if.then-3, label %if.done-7

if.then-3:
	; ti
	; SelectorExpr
	%56 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%57 = load %..typeid, %..typeid* %56, align 8
	%58 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %57)
	store %runtime.Type_Info* %58, %runtime.Type_Info** %3
	; TypeSwitchStmt
	%59 = load %..any, %..any* %1, align 8
	%60 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%61 = load %..typeid, %..typeid* %60, align 8
	%62 = icmp eq %..typeid %61, 648518346341351435
	br i1 %62, label %typeswitch.body-5, label %typeswitch.next-4

typeswitch.next-4:
	br label %typeswitch.done-6

typeswitch.body-5:
	%63 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%64 = load %..rawptr, %..rawptr* %63, align 8
	%65 = bitcast %..rawptr %64 to %runtime.Type_Info**
	%66 = load %runtime.Type_Info*, %runtime.Type_Info** %65, align 8
	store %runtime.Type_Info* %66, %runtime.Type_Info** %4
	; AssignStmt
	%67 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	store %runtime.Type_Info* %67, %runtime.Type_Info** %3
	br label %typeswitch.done-6

typeswitch.done-6:
	; SelectorExpr
	%68 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%69 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %68, i64 0
	%70 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %69, i64 0, i32 12
	%71 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %70, align 8
	%72 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %71, %runtime.Type_Info* %72, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-7:
	; base_arg
	%73 = load %..any, %..any* %1, align 8
	store %..any %73, %..any* %5
	; AssignStmt
	; SelectorExpr
	%74 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	; SelectorExpr
	; SelectorExpr
	%75 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%76 = load %..typeid, %..typeid* %75, align 8
	%77 = call %..typeid @runtime.typeid_base(%..typeid %76)
	store %..typeid %77, %..typeid* %74
	; TypeSwitchStmt
	%78 = load %..any, %..any* %5, align 8
	%79 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%80 = load %..typeid, %..typeid* %79, align 8
	%81 = icmp eq %..typeid %80, 432345564227567636
	br i1 %81, label %typeswitch.body-9, label %typeswitch.next-8

typeswitch.next-8:
	%82 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%83 = load %..typeid, %..typeid* %82, align 8
	%84 = icmp eq %..typeid %83, 432345564227567695
	br i1 %84, label %typeswitch.body-11, label %typeswitch.next-10

typeswitch.body-9:
	%85 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%86 = load %..rawptr, %..rawptr* %85, align 8
	%87 = bitcast %..rawptr %86 to i8*
	%88 = load i8, i8* %87, align 1
	store i8 %88, i8* %6
	%89 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%90 = load i8, i8* %6, align 1
	%91 = load i32, i32* %2, align 4
	%92 = trunc i8 %90 to i1
	call void @fmt.fmt_bool(%fmt.Fmt_Info* %89, i1 %92, i32 %91, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-10:
	%93 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%94 = load %..typeid, %..typeid* %93, align 8
	%95 = icmp eq %..typeid %94, 432345564227567696
	br i1 %95, label %typeswitch.body-13, label %typeswitch.next-12

typeswitch.body-11:
	%96 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%97 = load %..rawptr, %..rawptr* %96, align 8
	%98 = bitcast %..rawptr %97 to i8*
	%99 = load i8, i8* %98, align 1
	store i8 %99, i8* %7
	%100 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%101 = load i8, i8* %7, align 1
	%102 = icmp ne i8 %101, 0
	%103 = zext i1 %102 to i8
	%104 = load i32, i32* %2, align 4
	%105 = trunc i8 %103 to i1
	call void @fmt.fmt_bool(%fmt.Fmt_Info* %100, i1 %105, i32 %104, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-12:
	%106 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%107 = load %..typeid, %..typeid* %106, align 8
	%108 = icmp eq %..typeid %107, 432345564227567697
	br i1 %108, label %typeswitch.body-15, label %typeswitch.next-14

typeswitch.body-13:
	%109 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%110 = load %..rawptr, %..rawptr* %109, align 8
	%111 = bitcast %..rawptr %110 to i16*
	%112 = load i16, i16* %111, align 2
	store i16 %112, i16* %8
	%113 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%114 = load i16, i16* %8, align 2
	%115 = icmp ne i16 %114, 0
	%116 = zext i1 %115 to i8
	%117 = load i32, i32* %2, align 4
	%118 = trunc i8 %116 to i1
	call void @fmt.fmt_bool(%fmt.Fmt_Info* %113, i1 %118, i32 %117, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-14:
	%119 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%120 = load %..typeid, %..typeid* %119, align 8
	%121 = icmp eq %..typeid %120, 432345564227567698
	br i1 %121, label %typeswitch.body-17, label %typeswitch.next-16

typeswitch.body-15:
	%122 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%123 = load %..rawptr, %..rawptr* %122, align 8
	%124 = bitcast %..rawptr %123 to i32*
	%125 = load i32, i32* %124, align 4
	store i32 %125, i32* %9
	%126 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%127 = load i32, i32* %9, align 4
	%128 = icmp ne i32 %127, 0
	%129 = zext i1 %128 to i8
	%130 = load i32, i32* %2, align 4
	%131 = trunc i8 %129 to i1
	call void @fmt.fmt_bool(%fmt.Fmt_Info* %126, i1 %131, i32 %130, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-16:
	%132 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%133 = load %..typeid, %..typeid* %132, align 8
	%134 = icmp eq %..typeid %133, 10
	br i1 %134, label %typeswitch.body-19, label %typeswitch.next-18

typeswitch.body-17:
	%135 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%136 = load %..rawptr, %..rawptr* %135, align 8
	%137 = bitcast %..rawptr %136 to i64*
	%138 = load i64, i64* %137, align 8
	store i64 %138, i64* %10
	%139 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%140 = load i64, i64* %10, align 8
	%141 = icmp ne i64 %140, 0
	%142 = zext i1 %141 to i8
	%143 = load i32, i32* %2, align 4
	%144 = trunc i8 %142 to i1
	call void @fmt.fmt_bool(%fmt.Fmt_Info* %139, i1 %144, i32 %143, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-18:
	%145 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%146 = load %..typeid, %..typeid* %145, align 8
	%147 = icmp eq %..typeid %146, 4755801206503243837
	br i1 %147, label %typeswitch.body-21, label %typeswitch.next-20

typeswitch.body-19:
	%148 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%149 = load %..rawptr, %..rawptr* %148, align 8
	%150 = bitcast %..rawptr %149 to %..any*
	%151 = load %..any, %..any* %150, align 8
	store %..any %151, %..any* %11
	%152 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%153 = load %..any, %..any* %11, align 8
	%154 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %152, %..any %153, i32 %154, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-20:
	%155 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%156 = load %..typeid, %..typeid* %155, align 8
	%157 = icmp eq %..typeid %156, 216172782113783891
	br i1 %157, label %typeswitch.body-23, label %typeswitch.next-22

typeswitch.body-21:
	%158 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%159 = load %..rawptr, %..rawptr* %158, align 8
	%160 = bitcast %..rawptr %159 to i32*
	%161 = load i32, i32* %160, align 4
	store i32 %161, i32* %12
	%162 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%163 = load i32, i32* %12, align 4
	%164 = load i32, i32* %2, align 4
	call void @fmt.fmt_rune(%fmt.Fmt_Info* %162, i32 %163, i32 %164, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-22:
	%165 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%166 = load %..typeid, %..typeid* %165, align 8
	%167 = icmp eq %..typeid %166, 216172782113783892
	br i1 %167, label %typeswitch.body-25, label %typeswitch.next-24

typeswitch.body-23:
	%168 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%169 = load %..rawptr, %..rawptr* %168, align 8
	%170 = bitcast %..rawptr %169 to float*
	%171 = load float, float* %170, align 4
	store float %171, float* %13
	%172 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%173 = load float, float* %13, align 4
	%174 = fpext float %173 to double
	%175 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Fmt_Info* %172, double %174, i64 32, i32 %175, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-24:
	%176 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%177 = load %..typeid, %..typeid* %176, align 8
	%178 = icmp eq %..typeid %177, 288230376151711829
	br i1 %178, label %typeswitch.body-27, label %typeswitch.next-26

typeswitch.body-25:
	%179 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%180 = load %..rawptr, %..rawptr* %179, align 8
	%181 = bitcast %..rawptr %180 to double*
	%182 = load double, double* %181, align 8
	store double %182, double* %14
	%183 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%184 = load double, double* %14, align 8
	%185 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Fmt_Info* %183, double %184, i64 64, i32 %185, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-26:
	%186 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%187 = load %..typeid, %..typeid* %186, align 8
	%188 = icmp eq %..typeid %187, 288230376151711830
	br i1 %188, label %typeswitch.body-29, label %typeswitch.next-28

typeswitch.body-27:
	%189 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%190 = load %..rawptr, %..rawptr* %189, align 8
	%191 = bitcast %..rawptr %190 to %..complex64*
	%192 = load %..complex64, %..complex64* %191, align 4
	store %..complex64 %192, %..complex64* %15
	%193 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%194 = load %..complex64, %..complex64* %15, align 4
	%195 = bitcast %..complex128* %16 to %..rawptr
	%196 = call %..rawptr @mem.zero(%..rawptr %195, i64 16) noinline
	store %..complex128 zeroinitializer, %..complex128* %16
	%197 = extractvalue %..complex64 %194, 0
	%198 = fpext float %197 to double
	%199 = extractvalue %..complex64 %194, 1
	%200 = fpext float %199 to double
	%201 = getelementptr inbounds %..complex128, %..complex128* %16, i64 0, i32 0
	store double %198, double* %201
	%202 = getelementptr inbounds %..complex128, %..complex128* %16, i64 0, i32 1
	store double %200, double* %202
	%203 = load %..complex128, %..complex128* %16, align 8
	%204 = load i32, i32* %2, align 4
	%205 = bitcast %..complex128* %17 to %..rawptr
	%206 = call %..rawptr @mem.zero(%..rawptr %205, i64 16) noinline
	store %..complex128 zeroinitializer, %..complex128* %17
	store %..complex128 %203, %..complex128* %17
	call void @fmt.fmt_complex(%fmt.Fmt_Info* %193, %..complex128* %17, i64 64, i32 %204, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-28:
	%207 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%208 = load %..typeid, %..typeid* %207, align 8
	%209 = icmp eq %..typeid %208, 4683743612465315902
	br i1 %209, label %typeswitch.body-31, label %typeswitch.next-30

typeswitch.body-29:
	%210 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%211 = load %..rawptr, %..rawptr* %210, align 8
	%212 = bitcast %..rawptr %211 to %..complex128*
	%213 = load %..complex128, %..complex128* %212, align 8
	store %..complex128 %213, %..complex128* %18
	%214 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%215 = load %..complex128, %..complex128* %18, align 8
	%216 = load i32, i32* %2, align 4
	%217 = bitcast %..complex128* %19 to %..rawptr
	%218 = call %..rawptr @mem.zero(%..rawptr %217, i64 16) noinline
	store %..complex128 zeroinitializer, %..complex128* %19
	store %..complex128 %215, %..complex128* %19
	call void @fmt.fmt_complex(%fmt.Fmt_Info* %214, %..complex128* %19, i64 128, i32 %216, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-30:
	%219 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%220 = load %..typeid, %..typeid* %219, align 8
	%221 = icmp eq %..typeid %220, 72057594037927939
	br i1 %221, label %typeswitch.body-33, label %typeswitch.next-32

typeswitch.body-31:
	%222 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%223 = load %..rawptr, %..rawptr* %222, align 8
	%224 = bitcast %..rawptr %223 to i8*
	%225 = load i8, i8* %224, align 1
	store i8 %225, i8* %20
	%226 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%227 = load i8, i8* %20, align 1
	%228 = sext i8 %227 to i64
	%229 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %226, i64 %228, i1 true, i64 8, i32 %229, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-32:
	%230 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%231 = load %..typeid, %..typeid* %230, align 8
	%232 = icmp eq %..typeid %231, 4683743612465315903
	br i1 %232, label %typeswitch.body-35, label %typeswitch.next-34

typeswitch.body-33:
	%233 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%234 = load %..rawptr, %..rawptr* %233, align 8
	%235 = bitcast %..rawptr %234 to i8*
	%236 = load i8, i8* %235, align 1
	store i8 %236, i8* %21
	%237 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%238 = load i8, i8* %21, align 1
	%239 = zext i8 %238 to i64
	%240 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %237, i64 %239, i1 false, i64 8, i32 %240, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-34:
	%241 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%242 = load %..typeid, %..typeid* %241, align 8
	%243 = icmp eq %..typeid %242, 72057594037928001
	br i1 %243, label %typeswitch.body-37, label %typeswitch.next-36

typeswitch.body-35:
	%244 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%245 = load %..rawptr, %..rawptr* %244, align 8
	%246 = bitcast %..rawptr %245 to i16*
	%247 = load i16, i16* %246, align 2
	store i16 %247, i16* %22
	%248 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%249 = load i16, i16* %22, align 2
	%250 = sext i16 %249 to i64
	%251 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %248, i64 %250, i1 true, i64 16, i32 %251, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-36:
	%252 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%253 = load %..typeid, %..typeid* %252, align 8
	%254 = icmp eq %..typeid %253, 4683743612465315848
	br i1 %254, label %typeswitch.body-39, label %typeswitch.next-38

typeswitch.body-37:
	%255 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%256 = load %..rawptr, %..rawptr* %255, align 8
	%257 = bitcast %..rawptr %256 to i16*
	%258 = load i16, i16* %257, align 2
	store i16 %258, i16* %23
	%259 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%260 = load i16, i16* %23, align 2
	%261 = zext i16 %260 to i64
	%262 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %259, i64 %261, i1 false, i64 16, i32 %262, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-38:
	%263 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%264 = load %..typeid, %..typeid* %263, align 8
	%265 = icmp eq %..typeid %264, 72057594037928002
	br i1 %265, label %typeswitch.body-41, label %typeswitch.next-40

typeswitch.body-39:
	%266 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%267 = load %..rawptr, %..rawptr* %266, align 8
	%268 = bitcast %..rawptr %267 to i32*
	%269 = load i32, i32* %268, align 4
	store i32 %269, i32* %24
	%270 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%271 = load i32, i32* %24, align 4
	%272 = sext i32 %271 to i64
	%273 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %270, i64 %272, i1 true, i64 32, i32 %273, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-40:
	%274 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%275 = load %..typeid, %..typeid* %274, align 8
	%276 = icmp eq %..typeid %275, 4683743612465315904
	br i1 %276, label %typeswitch.body-43, label %typeswitch.next-42

typeswitch.body-41:
	%277 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%278 = load %..rawptr, %..rawptr* %277, align 8
	%279 = bitcast %..rawptr %278 to i32*
	%280 = load i32, i32* %279, align 4
	store i32 %280, i32* %25
	%281 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%282 = load i32, i32* %25, align 4
	%283 = zext i32 %282 to i64
	%284 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %281, i64 %283, i1 false, i64 32, i32 %284, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-42:
	%285 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%286 = load %..typeid, %..typeid* %285, align 8
	%287 = icmp eq %..typeid %286, 72057594037927943
	br i1 %287, label %typeswitch.body-45, label %typeswitch.next-44

typeswitch.body-43:
	%288 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%289 = load %..rawptr, %..rawptr* %288, align 8
	%290 = bitcast %..rawptr %289 to i64*
	%291 = load i64, i64* %290, align 8
	store i64 %291, i64* %26
	%292 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%293 = load i64, i64* %26, align 8
	%294 = bitcast i64 %293 to i64
	%295 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %292, i64 %294, i1 true, i64 64, i32 %295, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-44:
	%296 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%297 = load %..typeid, %..typeid* %296, align 8
	%298 = icmp eq %..typeid %297, 4683743612465315846
	br i1 %298, label %typeswitch.body-47, label %typeswitch.next-46

typeswitch.body-45:
	%299 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%300 = load %..rawptr, %..rawptr* %299, align 8
	%301 = bitcast %..rawptr %300 to i64*
	%302 = load i64, i64* %301, align 8
	store i64 %302, i64* %27
	%303 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%304 = load i64, i64* %27, align 8
	%305 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %303, i64 %304, i1 false, i64 64, i32 %305, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-46:
	%306 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%307 = load %..typeid, %..typeid* %306, align 8
	%308 = icmp eq %..typeid %307, 72057594037928003
	br i1 %308, label %typeswitch.body-49, label %typeswitch.next-48

typeswitch.body-47:
	%309 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%310 = load %..rawptr, %..rawptr* %309, align 8
	%311 = bitcast %..rawptr %310 to i64*
	%312 = load i64, i64* %311, align 8
	store i64 %312, i64* %28
	%313 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%314 = load i64, i64* %28, align 8
	%315 = bitcast i64 %314 to i64
	%316 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %313, i64 %315, i1 true, i64 64, i32 %316, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-48:
	%317 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%318 = load %..typeid, %..typeid* %317, align 8
	%319 = icmp eq %..typeid %318, 72057594037927986
	br i1 %319, label %typeswitch.body-51, label %typeswitch.next-50

typeswitch.body-49:
	%320 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%321 = load %..rawptr, %..rawptr* %320, align 8
	%322 = bitcast %..rawptr %321 to i64*
	%323 = load i64, i64* %322, align 8
	store i64 %323, i64* %29
	%324 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%325 = load i64, i64* %29, align 8
	%326 = bitcast i64 %325 to i64
	%327 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %324, i64 %326, i1 false, i64 64, i32 %327, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-50:
	%328 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%329 = load %..typeid, %..typeid* %328, align 8
	%330 = icmp eq %..typeid %329, 360287970189639684
	br i1 %330, label %typeswitch.body-53, label %typeswitch.next-52

typeswitch.body-51:
	%331 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%332 = load %..rawptr, %..rawptr* %331, align 8
	%333 = bitcast %..rawptr %332 to i64*
	%334 = load i64, i64* %333, align 8
	store i64 %334, i64* %30
	%335 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%336 = load i64, i64* %30, align 8
	%337 = bitcast i64 %336 to i64
	%338 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %335, i64 %337, i1 false, i64 64, i32 %338, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-52:
	%339 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%340 = load %..typeid, %..typeid* %339, align 8
	%341 = icmp eq %..typeid %340, 4971973988617027671
	br i1 %341, label %typeswitch.body-55, label %typeswitch.next-54

typeswitch.body-53:
	%342 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%343 = load %..rawptr, %..rawptr* %342, align 8
	%344 = bitcast %..rawptr %343 to %..string*
	%345 = load %..string, %..string* %344, align 8
	store %..string %345, %..string* %31
	%346 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%347 = load %..string, %..string* %31, align 8
	%348 = load i32, i32* %2, align 4
	call void @fmt.fmt_string(%fmt.Fmt_Info* %346, %..string %347, i32 %348, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-54:
	%349 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%350 = load %..typeid, %..typeid* %349, align 8
	%351 = icmp eq %..typeid %350, 14
	br i1 %351, label %typeswitch.body-57, label %typeswitch.next-56

typeswitch.body-55:
	%352 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%353 = load %..rawptr, %..rawptr* %352, align 8
	%354 = bitcast %..rawptr %353 to i8**
	%355 = load i8*, i8** %354, align 8
	store i8* %355, i8** %32
	%356 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%357 = load i8*, i8** %32, align 8
	%358 = load i32, i32* %2, align 4
	call void @fmt.fmt_cstring(%fmt.Fmt_Info* %356, i8* %357, i32 %358, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-56:
	store %..any %78, %..any* %34
	%359 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%360 = load %..any, %..any* %1, align 8
	%361 = load i32, i32* %2, align 4
	call void @fmt.fmt_value(%fmt.Fmt_Info* %359, %..any %360, i32 %361, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.body-57:
	%362 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%363 = load %..rawptr, %..rawptr* %362, align 8
	%364 = bitcast %..rawptr %363 to %..typeid*
	%365 = load %..typeid, %..typeid* %364, align 8
	store %..typeid %365, %..typeid* %33
	; SelectorExpr
	%366 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%367 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %366, i64 0
	%368 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %367, i64 0, i32 12
	%369 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %368, align 8
	%370 = load %..typeid, %..typeid* %33, align 8
	call void @fmt.write_typeid({i8*, i64, i64, %mem.Allocator}* %369, %..typeid %370, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.done-58:
	ret void
}

define %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* %buf, {%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %fmt.Fmt_Info, align 16
	%2 = alloca i8, align 16
	%3 = alloca %..any, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i8, align 16
	%8 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	%9 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; fi
	%10 = bitcast %fmt.Fmt_Info* %1 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 64) noinline
	store %fmt.Fmt_Info zeroinitializer, %fmt.Fmt_Info* %1
	; prev_string
	store i8 0, i8* %2
	; AssignStmt
	; SelectorExpr
	%12 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1, i64 0, i32 12
	%13 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	store {i8*, i64, i64, %mem.Allocator}* %13, {i8*, i64, i64, %mem.Allocator}** %12
	; RangeStmt
	; arg
	%14 = bitcast %..any* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 16) noinline
	store %..any zeroinitializer, %..any* %3
	; i
	%16 = bitcast i64* %4 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	%18 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%19 = bitcast i64* %5 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	%21 = extractvalue {%..any*, i64} %18, 1
	store i64 %21, i64* %5
	%22 = bitcast i64* %6 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 8) noinline
	store i64 zeroinitializer, i64* %6
	store i64 -1, i64* %6
	br label %for.index.loop-1

for.index.loop-1:
	%24 = load i64, i64* %6, align 8
	%25 = add i64 %24, 1
	store i64 %25, i64* %6
	%26 = load i64, i64* %5, align 8
	%27 = icmp slt i64 %25, %26
	br i1 %27, label %for.index.body-2, label %for.index.done-9

for.index.body-2:
	%28 = load i64, i64* %6, align 8
	%29 = extractvalue {%..any*, i64} %18, 0
	%30 = getelementptr inbounds %..any, %..any* %29, i64 %28
	%31 = load %..any, %..any* %30, align 8
	store %..any %31, %..any* %3
	store i64 %28, i64* %4
	; is_string
	%32 = load %..any, %..any* %3, align 8
	%33 = extractvalue %..any %32, 0
	%34 = extractvalue %..any %32, 1
	%35 = icmp ne %..rawptr %33, null
	%36 = icmp ne %..typeid %34, 0
	%37 = zext i1 %35 to i8
	%38 = zext i1 %36 to i8
	%39 = and i8 %37, %38
	%40 = load %..any, %..any* %3, align 8
	%41 = extractvalue %..any %40, 0
	%42 = extractvalue %..any %40, 1
	%43 = icmp ne %..rawptr %41, null
	%44 = icmp ne %..typeid %42, 0
	%45 = zext i1 %43 to i8
	%46 = zext i1 %44 to i8
	%47 = and i8 %45, %46
	%48 = trunc i8 %47 to i1
	br i1 %48, label %logical.cmp.rhs-3, label %logical.cmp.done-4

logical.cmp.rhs-3:
	; SelectorExpr
	; SelectorExpr
	%49 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%50 = load %..typeid, %..typeid* %49, align 8
	%51 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %50)
	%52 = call i8 @types.is_string(%runtime.Type_Info* %51, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %logical.cmp.done-4

logical.cmp.done-4:
	%53 = phi i8 [ 0, %for.index.body-2 ], [ %52, %logical.cmp.rhs-3 ]
	store i8 %53, i8* %7
	; IfStmt
	%54 = load i64, i64* %4, align 8
	%55 = icmp sgt i64 %54, 0
	%56 = zext i1 %55 to i8
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-5, label %if.done-8

cmp.and-5:
	%58 = load i8, i8* %7, align 1
	%59 = trunc i8 %58 to i1
	br i1 %59, label %if.done-8, label %cmp.and-6

cmp.and-6:
	%60 = load i8, i8* %2, align 1
	%61 = trunc i8 %60 to i1
	br i1 %61, label %if.done-8, label %if.then-7

if.then-7:
	%62 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %62, i8 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-8

if.done-8:
	; IndexExpr
	%63 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%64 = extractvalue {%..any*, i64} %63, 0
	%65 = load i64, i64* %4, align 8
	%66 = extractvalue {%..any*, i64} %63, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$166, i64 0, i32 0), i64 53}, i64 1246, i64 23, i64 %65, i64 %66)
	%67 = getelementptr inbounds %..any, %..any* %64, i64 %65
	%68 = load %..any, %..any* %67, align 8
	call void @fmt.fmt_value(%fmt.Fmt_Info* %1, %..any %68, i32 118, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	%69 = load i8, i8* %7, align 1
	store i8 %69, i8* %2
	br label %for.index.loop-1

for.index.done-9:
	; ReturnStmt
	%70 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%71 = getelementptr inbounds {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %70, i64 0
	%72 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %71, align 8
	%73 = bitcast {i8*, i64, i64, %mem.Allocator}* %8 to %..rawptr
	%74 = call %..rawptr @mem.zero(%..rawptr %73, i64 40) noinline
	store {i8*, i64, i64, %mem.Allocator} zeroinitializer, {i8*, i64, i64, %mem.Allocator}* %8
	store {i8*, i64, i64, %mem.Allocator} %72, {i8*, i64, i64, %mem.Allocator}* %8
	%75 = call %..string @fmt.to_string({i8*, i64, i64, %mem.Allocator}* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret %..string %75
}

define %..string @fmt.sbprintf({i8*, i64, i64, %mem.Allocator}* %b, %..string %fmt, {%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %..string, align 16
	%2 = alloca %fmt.Fmt_Info, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i8, align 16
	%6 = alloca i64, align 16
	%7 = alloca %fmt.Fmt_Info, align 16
	%8 = alloca i64, align 16
	%9 = alloca %..string, align 16
	%10 = alloca {%..any*, i64}, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca i32, align 16
	%13 = alloca i64, align 16
	%14 = alloca %..string, align 16
	%15 = alloca %..any, align 16
	%16 = alloca i64, align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca i64, align 16
	%19 = alloca i64, align 16
	%20 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	store {i8*, i64, i64, %mem.Allocator}* %b, {i8*, i64, i64, %mem.Allocator}** %0
	store %..string %fmt, %..string* %1
	%21 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; fi
	%22 = bitcast %fmt.Fmt_Info* %2 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 64) noinline
	store %fmt.Fmt_Info zeroinitializer, %fmt.Fmt_Info* %2
	; arg_index
	store i64 0, i64* %3
	; end
	%24 = load %..string, %..string* %1, align 8
	%25 = extractvalue %..string %24, 1
	store i64 %25, i64* %4
	; was_prev_index
	store i8 0, i8* %5
	; ForStmt
	; i
	store i64 0, i64* %6
	br label %for.loop-1

for.loop-1:
	%26 = load i64, i64* %6, align 8
	%27 = load i64, i64* %4, align 8
	%28 = icmp slt i64 %26, %27
	%29 = zext i1 %28 to i8
	%30 = trunc i8 %29 to i1
	br i1 %30, label %for.body-2, label %for.done-62

for.body-2:
	; AssignStmt
	; CompoundLit
	%31 = bitcast %fmt.Fmt_Info* %7 to %..rawptr
	%32 = call %..rawptr @mem.zero(%..rawptr %31, i64 64) noinline
	store %fmt.Fmt_Info zeroinitializer, %fmt.Fmt_Info* %7
	store %fmt.Fmt_Info {i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i8 zeroinitializer, i8 1, {i8*, i64, i64, %mem.Allocator}* zeroinitializer, %..any zeroinitializer}, %fmt.Fmt_Info* %7
	%33 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%34 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %7, i64 0, i32 12
	store {i8*, i64, i64, %mem.Allocator}* %33, {i8*, i64, i64, %mem.Allocator}** %34
	%35 = load %fmt.Fmt_Info, %fmt.Fmt_Info* %7, align 8
	store %fmt.Fmt_Info %35, %fmt.Fmt_Info* %2
	; prev_i
	%36 = load i64, i64* %6, align 8
	store i64 %36, i64* %8
	; ForStmt
	br label %for.loop-3

for.loop-3:
	%37 = load i64, i64* %6, align 8
	%38 = load i64, i64* %4, align 8
	%39 = icmp slt i64 %37, %38
	%40 = zext i1 %39 to i8
	%41 = trunc i8 %40 to i1
	br i1 %41, label %cmp.and-4, label %for.done-6

cmp.and-4:
	; IndexExpr
	%42 = load %..string, %..string* %1, align 8
	%43 = extractvalue %..string %42, 0
	%44 = extractvalue %..string %42, 1
	%45 = load i64, i64* %6, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$167, i64 0, i32 0), i64 53}, i64 1276, i64 22, i64 %45, i64 %44)
	%46 = getelementptr inbounds i8, i8* %43, i64 %45
	%47 = load i8, i8* %46, align 1
	%48 = icmp ne i8 %47, 37
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %for.body-5, label %for.done-6

for.body-5:
	; AssignStmt
	%51 = load i64, i64* %6, align 8
	%52 = add i64 %51, 1
	store i64 %52, i64* %6
	br label %for.loop-3

for.done-6:
	; IfStmt
	%53 = load i64, i64* %6, align 8
	%54 = load i64, i64* %8, align 8
	%55 = icmp sgt i64 %53, %54
	%56 = zext i1 %55 to i8
	%57 = trunc i8 %56 to i1
	br i1 %57, label %if.then-7, label %if.done-8

if.then-7:
	%58 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SliceExpr
	%59 = load i64, i64* %8, align 8
	%60 = load i64, i64* %6, align 8
	%61 = load %..string, %..string* %1, align 8
	%62 = extractvalue %..string %61, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$168, i64 0, i32 0), i64 53}, i64 1280, i64 23, i64 %59, i64 %60, i64 %62)
	%63 = extractvalue %..string %61, 0
	%64 = getelementptr inbounds i8, i8* %63, i64 %59
	%65 = sub i64 %60, %59
	%66 = bitcast %..string* %9 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	%68 = getelementptr inbounds %..string, %..string* %9, i64 0, i32 0
	store i8* %64, i8** %68
	%69 = getelementptr inbounds %..string, %..string* %9, i64 0, i32 1
	store i64 %65, i64* %69
	%70 = load %..string, %..string* %9, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %58, %..string %70, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-8

if.done-8:
	; IfStmt
	%71 = load i64, i64* %6, align 8
	%72 = load i64, i64* %4, align 8
	%73 = icmp sge i64 %71, %72
	%74 = zext i1 %73 to i8
	%75 = trunc i8 %74 to i1
	br i1 %75, label %if.then-9, label %if.done-10

if.then-9:
	; break
	br label %for.done-62

if.done-10:
	; AssignStmt
	%76 = load i64, i64* %6, align 8
	%77 = add i64 %76, 1
	store i64 %77, i64* %6
	; ForStmt
	br label %for.loop-11

for.loop-11:
	%78 = load i64, i64* %6, align 8
	%79 = load i64, i64* %4, align 8
	%80 = icmp slt i64 %78, %79
	%81 = zext i1 %80 to i8
	%82 = trunc i8 %81 to i1
	br i1 %82, label %for.body-12, label %for.done-24

for.body-12:
	; SwitchStmt
	; IndexExpr
	%83 = load %..string, %..string* %1, align 8
	%84 = extractvalue %..string %83, 0
	%85 = extractvalue %..string %83, 1
	%86 = load i64, i64* %6, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$169, i64 0, i32 0), i64 53}, i64 1290, i64 15, i64 %86, i64 %85)
	%87 = getelementptr inbounds i8, i8* %84, i64 %86
	%88 = load i8, i8* %87, align 1
	%89 = icmp eq i8 %88, 43
	br i1 %89, label %switch.case.body-14, label %switch.case.next-13

switch.case.next-13:
	%90 = icmp eq i8 %88, 45
	br i1 %90, label %switch.fall.body-16, label %switch.case.next-15

switch.case.body-14:
	; AssignStmt
	; SelectorExpr
	%91 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 1
	store i8 1, i8* %91
	br label %switch.done-23

switch.case.next-15:
	%92 = icmp eq i8 %88, 32
	br i1 %92, label %switch.fall.body-18, label %switch.case.next-17

switch.fall.body-16:
	; AssignStmt
	; SelectorExpr
	%93 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 0
	store i8 1, i8* %93
	; AssignStmt
	; SelectorExpr
	%94 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 3
	store i8 0, i8* %94
	br label %switch.done-23

switch.case.next-17:
	%95 = icmp eq i8 %88, 35
	br i1 %95, label %switch.fall.body-20, label %switch.case.next-19

switch.fall.body-18:
	; AssignStmt
	; SelectorExpr
	%96 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 2
	store i8 1, i8* %96
	br label %switch.done-23

switch.case.next-19:
	%97 = icmp eq i8 %88, 48
	br i1 %97, label %switch.fall.body-22, label %switch.case.next-21

switch.fall.body-20:
	; AssignStmt
	; SelectorExpr
	%98 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 4
	store i8 1, i8* %98
	br label %switch.done-23

switch.case.next-21:
	; break
	br label %for.done-24

switch.fall.body-22:
	; AssignStmt
	; SelectorExpr
	%99 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 3
	; SelectorExpr
	%100 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 0
	%101 = load i8, i8* %100, align 1
	%102 = icmp eq i8 %101, 0
	%103 = zext i1 %102 to i8
	store i8 %103, i8* %99
	br label %switch.done-23

switch.done-23:
	; AssignStmt
	%104 = load i64, i64* %6, align 8
	%105 = add i64 %104, 1
	store i64 %105, i64* %6
	br label %for.loop-11

for.done-24:
	; AssignStmt
	%106 = load i64, i64* %3, align 8
	%107 = load %..string, %..string* %1, align 8
	%108 = load i64, i64* %6, align 8
	%109 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%110 = extractvalue {%..any*, i64} %109, 1
	%111 = call {i64, i64, i8} @fmt._arg_number(%fmt.Fmt_Info* %2, i64 %106, %..string %107, i64 %108, i64 %110, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%112 = extractvalue {i64, i64, i8} %111, 0
	%113 = extractvalue {i64, i64, i8} %111, 1
	%114 = extractvalue {i64, i64, i8} %111, 2
	store i64 %112, i64* %3
	store i64 %113, i64* %6
	store i8 %114, i8* %5
	; IfStmt
	%115 = load i64, i64* %6, align 8
	%116 = load i64, i64* %4, align 8
	%117 = icmp slt i64 %115, %116
	%118 = zext i1 %117 to i8
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-25, label %if.else-31

cmp.and-25:
	; IndexExpr
	%120 = load %..string, %..string* %1, align 8
	%121 = extractvalue %..string %120, 0
	%122 = extractvalue %..string %120, 1
	%123 = load i64, i64* %6, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$16a, i64 0, i32 0), i64 53}, i64 1310, i64 21, i64 %123, i64 %122)
	%124 = getelementptr inbounds i8, i8* %121, i64 %123
	%125 = load i8, i8* %124, align 1
	%126 = icmp eq i8 %125, 42
	%127 = zext i1 %126 to i8
	%128 = trunc i8 %127 to i1
	br i1 %128, label %if.then-26, label %if.else-31

if.then-26:
	; AssignStmt
	%129 = load i64, i64* %6, align 8
	%130 = add i64 %129, 1
	store i64 %130, i64* %6
	; AssignStmt
	; SelectorExpr
	%131 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 7
	; SelectorExpr
	%132 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 5
	%133 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%134 = load i64, i64* %3, align 8
	%135 = bitcast {%..any*, i64}* %10 to %..rawptr
	%136 = call %..rawptr @mem.zero(%..rawptr %135, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %10
	store {%..any*, i64} %133, {%..any*, i64}* %10
	%137 = call {i64, i64, i8} @fmt.int_from_arg({%..any*, i64}* %10, i64 %134, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%138 = extractvalue {i64, i64, i8} %137, 0
	%139 = extractvalue {i64, i64, i8} %137, 1
	%140 = extractvalue {i64, i64, i8} %137, 2
	store i64 %138, i64* %131
	store i64 %139, i64* %3
	store i8 %140, i8* %132
	; IfStmt
	; SelectorExpr
	%141 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 5
	%142 = load i8, i8* %141, align 1
	%143 = trunc i8 %142 to i1
	br i1 %143, label %if.done-28, label %if.then-27

if.then-27:
	%144 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %144, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$16b, i64 0, i32 0), i64 13}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-28

if.done-28:
	; IfStmt
	; SelectorExpr
	%145 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 7
	%146 = load i64, i64* %145, align 8
	%147 = icmp slt i64 %146, 0
	%148 = zext i1 %147 to i8
	%149 = trunc i8 %148 to i1
	br i1 %149, label %if.then-29, label %if.done-30

if.then-29:
	; AssignStmt
	; SelectorExpr
	%150 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 7
	; SelectorExpr
	%151 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 7
	%152 = load i64, i64* %151, align 8
	%153 = sub i64 0, %152
	store i64 %153, i64* %150
	; AssignStmt
	; SelectorExpr
	%154 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 0
	store i8 1, i8* %154
	; AssignStmt
	; SelectorExpr
	%155 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 3
	store i8 0, i8* %155
	br label %if.done-30

if.done-30:
	; AssignStmt
	store i8 0, i8* %5
	br label %if.done-35

if.else-31:
	; AssignStmt
	; SelectorExpr
	%156 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 7
	; SelectorExpr
	%157 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 5
	%158 = load %..string, %..string* %1, align 8
	%159 = load i64, i64* %6, align 8
	%160 = call {i64, i64, i8} @fmt._parse_int(%..string %158, i64 %159, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%161 = extractvalue {i64, i64, i8} %160, 0
	%162 = extractvalue {i64, i64, i8} %160, 1
	%163 = extractvalue {i64, i64, i8} %160, 2
	store i64 %161, i64* %156
	store i64 %162, i64* %6
	store i8 %163, i8* %157
	; IfStmt
	%164 = load i8, i8* %5, align 1
	%165 = trunc i8 %164 to i1
	br i1 %165, label %cmp.and-32, label %if.done-34

cmp.and-32:
	; SelectorExpr
	%166 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 5
	%167 = load i8, i8* %166, align 1
	%168 = trunc i8 %167 to i1
	br i1 %168, label %if.then-33, label %if.done-34

if.then-33:
	; AssignStmt
	; SelectorExpr
	%169 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 11
	store i8 0, i8* %169
	br label %if.done-34

if.done-34:
	br label %if.done-35

if.done-35:
	; IfStmt
	%170 = load i64, i64* %6, align 8
	%171 = load i64, i64* %4, align 8
	%172 = icmp slt i64 %170, %171
	%173 = zext i1 %172 to i8
	%174 = trunc i8 %173 to i1
	br i1 %174, label %cmp.and-36, label %if.done-50

cmp.and-36:
	; IndexExpr
	%175 = load %..string, %..string* %1, align 8
	%176 = extractvalue %..string %175, 0
	%177 = extractvalue %..string %175, 1
	%178 = load i64, i64* %6, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$16c, i64 0, i32 0), i64 53}, i64 1331, i64 21, i64 %178, i64 %177)
	%179 = getelementptr inbounds i8, i8* %176, i64 %178
	%180 = load i8, i8* %179, align 1
	%181 = icmp eq i8 %180, 46
	%182 = zext i1 %181 to i8
	%183 = trunc i8 %182 to i1
	br i1 %183, label %if.then-37, label %if.done-50

if.then-37:
	; AssignStmt
	%184 = load i64, i64* %6, align 8
	%185 = add i64 %184, 1
	store i64 %185, i64* %6
	; IfStmt
	%186 = load i8, i8* %5, align 1
	%187 = trunc i8 %186 to i1
	br i1 %187, label %if.then-38, label %if.done-39

if.then-38:
	; AssignStmt
	; SelectorExpr
	%188 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 11
	store i8 0, i8* %188
	br label %if.done-39

if.done-39:
	; IfStmt
	%189 = load i64, i64* %6, align 8
	%190 = load i64, i64* %4, align 8
	%191 = icmp slt i64 %189, %190
	%192 = zext i1 %191 to i8
	%193 = trunc i8 %192 to i1
	br i1 %193, label %cmp.and-40, label %if.else-46

cmp.and-40:
	; IndexExpr
	%194 = load %..string, %..string* %1, align 8
	%195 = extractvalue %..string %194, 0
	%196 = extractvalue %..string %194, 1
	%197 = load i64, i64* %6, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$16d, i64 0, i32 0), i64 53}, i64 1336, i64 22, i64 %197, i64 %196)
	%198 = getelementptr inbounds i8, i8* %195, i64 %197
	%199 = load i8, i8* %198, align 1
	%200 = icmp eq i8 %199, 42
	%201 = zext i1 %200 to i8
	%202 = trunc i8 %201 to i1
	br i1 %202, label %if.then-41, label %if.else-46

if.then-41:
	; AssignStmt
	%203 = load i64, i64* %3, align 8
	%204 = load %..string, %..string* %1, align 8
	%205 = load i64, i64* %6, align 8
	%206 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%207 = extractvalue {%..any*, i64} %206, 1
	%208 = call {i64, i64, i8} @fmt._arg_number(%fmt.Fmt_Info* %2, i64 %203, %..string %204, i64 %205, i64 %207, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%209 = extractvalue {i64, i64, i8} %208, 0
	%210 = extractvalue {i64, i64, i8} %208, 1
	%211 = extractvalue {i64, i64, i8} %208, 2
	store i64 %209, i64* %3
	store i64 %210, i64* %6
	store i8 %211, i8* %5
	; AssignStmt
	%212 = load i64, i64* %6, align 8
	%213 = add i64 %212, 1
	store i64 %213, i64* %6
	; AssignStmt
	; SelectorExpr
	%214 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 8
	; SelectorExpr
	%215 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 6
	%216 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%217 = load i64, i64* %3, align 8
	%218 = bitcast {%..any*, i64}* %11 to %..rawptr
	%219 = call %..rawptr @mem.zero(%..rawptr %218, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	store {%..any*, i64} %216, {%..any*, i64}* %11
	%220 = call {i64, i64, i8} @fmt.int_from_arg({%..any*, i64}* %11, i64 %217, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%221 = extractvalue {i64, i64, i8} %220, 0
	%222 = extractvalue {i64, i64, i8} %220, 1
	%223 = extractvalue {i64, i64, i8} %220, 2
	store i64 %221, i64* %214
	store i64 %222, i64* %3
	store i8 %223, i8* %215
	; IfStmt
	; SelectorExpr
	%224 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 8
	%225 = load i64, i64* %224, align 8
	%226 = icmp slt i64 %225, 0
	%227 = zext i1 %226 to i8
	%228 = trunc i8 %227 to i1
	br i1 %228, label %if.then-42, label %if.done-43

if.then-42:
	; AssignStmt
	; SelectorExpr
	%229 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 8
	store i64 0, i64* %229
	; AssignStmt
	; SelectorExpr
	%230 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 6
	store i8 0, i8* %230
	br label %if.done-43

if.done-43:
	; IfStmt
	; SelectorExpr
	%231 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 6
	%232 = load i8, i8* %231, align 1
	%233 = trunc i8 %232 to i1
	br i1 %233, label %if.done-45, label %if.then-44

if.then-44:
	; SelectorExpr
	%234 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 12
	%235 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %234, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %235, %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$16e, i64 0, i32 0), i64 17}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-45

if.done-45:
	; AssignStmt
	store i8 0, i8* %5
	br label %if.done-49

if.else-46:
	; AssignStmt
	; SelectorExpr
	%236 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 8
	; SelectorExpr
	%237 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 6
	%238 = load %..string, %..string* %1, align 8
	%239 = load i64, i64* %6, align 8
	%240 = call {i64, i64, i8} @fmt._parse_int(%..string %238, i64 %239, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%241 = extractvalue {i64, i64, i8} %240, 0
	%242 = extractvalue {i64, i64, i8} %240, 1
	%243 = extractvalue {i64, i64, i8} %240, 2
	store i64 %241, i64* %236
	store i64 %242, i64* %6
	store i8 %243, i8* %237
	; IfStmt
	; SelectorExpr
	%244 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 6
	%245 = load i8, i8* %244, align 1
	%246 = trunc i8 %245 to i1
	br i1 %246, label %if.done-48, label %if.then-47

if.then-47:
	br label %if.done-48

if.done-48:
	br label %if.done-49

if.done-49:
	br label %if.done-50

if.done-50:
	; IfStmt
	%247 = load i8, i8* %5, align 1
	%248 = trunc i8 %247 to i1
	br i1 %248, label %if.done-52, label %if.then-51

if.then-51:
	; AssignStmt
	%249 = load i64, i64* %3, align 8
	%250 = load %..string, %..string* %1, align 8
	%251 = load i64, i64* %6, align 8
	%252 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%253 = extractvalue {%..any*, i64} %252, 1
	%254 = call {i64, i64, i8} @fmt._arg_number(%fmt.Fmt_Info* %2, i64 %249, %..string %250, i64 %251, i64 %253, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%255 = extractvalue {i64, i64, i8} %254, 0
	%256 = extractvalue {i64, i64, i8} %254, 1
	%257 = extractvalue {i64, i64, i8} %254, 2
	store i64 %255, i64* %3
	store i64 %256, i64* %6
	store i8 %257, i8* %5
	br label %if.done-52

if.done-52:
	; IfStmt
	%258 = load i64, i64* %6, align 8
	%259 = load i64, i64* %4, align 8
	%260 = icmp sge i64 %258, %259
	%261 = zext i1 %260 to i8
	%262 = trunc i8 %261 to i1
	br i1 %262, label %if.then-53, label %if.done-54

if.then-53:
	%263 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %263, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$16f, i64 0, i32 0), i64 11}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; break
	br label %for.done-62

if.done-54:
	; verb
	; w
	; SelectorExpr
	; SliceExpr
	%264 = load i64, i64* %6, align 8
	%265 = load %..string, %..string* %1, align 8
	%266 = extractvalue %..string %265, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$170, i64 0, i32 0), i64 53}, i64 1366, i64 46, i64 %264, i64 %266, i64 %266)
	%267 = extractvalue %..string %265, 0
	%268 = getelementptr inbounds i8, i8* %267, i64 %264
	%269 = sub i64 %266, %264
	%270 = bitcast %..string* %14 to %..rawptr
	%271 = call %..rawptr @mem.zero(%..rawptr %270, i64 16) noinline
	store %..string zeroinitializer, %..string* %14
	%272 = getelementptr inbounds %..string, %..string* %14, i64 0, i32 0
	store i8* %268, i8** %272
	%273 = getelementptr inbounds %..string, %..string* %14, i64 0, i32 1
	store i64 %269, i64* %273
	%274 = load %..string, %..string* %14, align 8
	%275 = call {i32, i64} @utf8.decode_rune_from_string(%..string %274, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%276 = extractvalue {i32, i64} %275, 0
	%277 = extractvalue {i32, i64} %275, 1
	store i32 %276, i32* %12
	store i64 %277, i64* %13
	; AssignStmt
	%278 = load i64, i64* %13, align 8
	%279 = load i64, i64* %6, align 8
	%280 = add i64 %279, %278
	store i64 %280, i64* %6
	; SwitchStmt
	%281 = load i32, i32* %12, align 4
	%282 = icmp eq i32 %281, 37
	%283 = zext i1 %282 to i8
	%284 = icmp eq i8 1, %283
	br i1 %284, label %switch.case.body-56, label %switch.case.next-55

switch.case.next-55:
	; SelectorExpr
	%285 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 11
	%286 = load i8, i8* %285, align 1
	%287 = icmp eq i8 %286, 0
	%288 = zext i1 %287 to i8
	%289 = icmp eq i8 1, %288
	br i1 %289, label %switch.fall.body-58, label %switch.case.next-57

switch.case.body-56:
	%290 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %290, i8 37, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-61

switch.case.next-57:
	%291 = load i64, i64* %3, align 8
	%292 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%293 = extractvalue {%..any*, i64} %292, 1
	%294 = icmp sge i64 %291, %293
	%295 = zext i1 %294 to i8
	%296 = icmp eq i8 1, %295
	br i1 %296, label %switch.fall.body-60, label %switch.case.next-59

switch.fall.body-58:
	%297 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %297, %..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$171, i64 0, i32 0), i64 23}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-61

switch.case.next-59:
	; IndexExpr
	%298 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%299 = extractvalue {%..any*, i64} %298, 0
	%300 = load i64, i64* %3, align 8
	%301 = extractvalue {%..any*, i64} %298, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$172, i64 0, i32 0), i64 53}, i64 1377, i64 22, i64 %300, i64 %301)
	%302 = getelementptr inbounds %..any, %..any* %299, i64 %300
	%303 = load %..any, %..any* %302, align 8
	%304 = load i32, i32* %12, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %2, %..any %303, i32 %304, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	%305 = load i64, i64* %3, align 8
	%306 = add i64 %305, 1
	store i64 %306, i64* %3
	br label %switch.done-61

switch.fall.body-60:
	%307 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %307, %..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$173, i64 0, i32 0), i64 20}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-61

switch.done-61:
	br label %for.loop-1

for.done-62:
	; IfStmt
	; SelectorExpr
	%308 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0, i32 10
	%309 = load i8, i8* %308, align 1
	%310 = trunc i8 %309 to i1
	br i1 %310, label %if.done-73, label %cmp.and-63

cmp.and-63:
	%311 = load i64, i64* %3, align 8
	%312 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%313 = extractvalue {%..any*, i64} %312, 1
	%314 = icmp slt i64 %311, %313
	%315 = zext i1 %314 to i8
	%316 = trunc i8 %315 to i1
	br i1 %316, label %if.then-64, label %if.done-73

if.then-64:
	%317 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %317, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$174, i64 0, i32 0), i64 9}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; arg
	%318 = bitcast %..any* %15 to %..rawptr
	%319 = call %..rawptr @mem.zero(%..rawptr %318, i64 16) noinline
	store %..any zeroinitializer, %..any* %15
	; index
	%320 = bitcast i64* %16 to %..rawptr
	%321 = call %..rawptr @mem.zero(%..rawptr %320, i64 8) noinline
	store i64 zeroinitializer, i64* %16
	; SliceExpr
	%322 = load i64, i64* %3, align 8
	%323 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%324 = extractvalue {%..any*, i64} %323, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$175, i64 0, i32 0), i64 53}, i64 1384, i64 25, i64 %322, i64 %324, i64 %324)
	%325 = extractvalue {%..any*, i64} %323, 0
	%326 = getelementptr inbounds %..any, %..any* %325, i64 %322
	%327 = sub i64 %324, %322
	%328 = bitcast {%..any*, i64}* %17 to %..rawptr
	%329 = call %..rawptr @mem.zero(%..rawptr %328, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	%330 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %17, i64 0, i32 0
	store %..any* %326, %..any** %330
	%331 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %17, i64 0, i32 1
	store i64 %327, i64* %331
	%332 = load {%..any*, i64}, {%..any*, i64}* %17, align 8
	%333 = bitcast i64* %18 to %..rawptr
	%334 = call %..rawptr @mem.zero(%..rawptr %333, i64 8) noinline
	store i64 zeroinitializer, i64* %18
	%335 = extractvalue {%..any*, i64} %332, 1
	store i64 %335, i64* %18
	%336 = bitcast i64* %19 to %..rawptr
	%337 = call %..rawptr @mem.zero(%..rawptr %336, i64 8) noinline
	store i64 zeroinitializer, i64* %19
	store i64 -1, i64* %19
	br label %for.index.loop-65

for.index.loop-65:
	%338 = load i64, i64* %19, align 8
	%339 = add i64 %338, 1
	store i64 %339, i64* %19
	%340 = load i64, i64* %18, align 8
	%341 = icmp slt i64 %339, %340
	br i1 %341, label %for.index.body-66, label %for.index.done-72

for.index.body-66:
	%342 = load i64, i64* %19, align 8
	%343 = extractvalue {%..any*, i64} %332, 0
	%344 = getelementptr inbounds %..any, %..any* %343, i64 %342
	%345 = load %..any, %..any* %344, align 8
	store %..any %345, %..any* %15
	store i64 %342, i64* %16
	; IfStmt
	%346 = load i64, i64* %16, align 8
	%347 = icmp sgt i64 %346, 0
	%348 = zext i1 %347 to i8
	%349 = trunc i8 %348 to i1
	br i1 %349, label %if.then-67, label %if.done-68

if.then-67:
	%350 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %350, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$176, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-68

if.done-68:
	; IfStmt
	%351 = load %..any, %..any* %15, align 8
	%352 = extractvalue %..any %351, 0
	%353 = extractvalue %..any %351, 1
	%354 = icmp eq %..rawptr %352, null
	%355 = icmp eq %..typeid %353, 0
	%356 = zext i1 %354 to i8
	%357 = zext i1 %355 to i8
	%358 = or i8 %356, %357
	%359 = trunc i8 %358 to i1
	br i1 %359, label %if.then-69, label %if.else-70

if.then-69:
	%360 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %360, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$177, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-71

if.else-70:
	; IndexExpr
	%361 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%362 = extractvalue {%..any*, i64} %361, 0
	%363 = load i64, i64* %16, align 8
	%364 = extractvalue {%..any*, i64} %361, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$178, i64 0, i32 0), i64 53}, i64 1388, i64 39, i64 %363, i64 %364)
	%365 = getelementptr inbounds %..any, %..any* %362, i64 %363
	%366 = load %..any, %..any* %365, align 8
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %2, %..any %366, i32 118, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-71

if.done-71:
	br label %for.index.loop-65

for.index.done-72:
	%367 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %367, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$179, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-73

if.done-73:
	; ReturnStmt
	%368 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%369 = getelementptr inbounds {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %368, i64 0
	%370 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %369, align 8
	%371 = bitcast {i8*, i64, i64, %mem.Allocator}* %20 to %..rawptr
	%372 = call %..rawptr @mem.zero(%..rawptr %371, i64 40) noinline
	store {i8*, i64, i64, %mem.Allocator} zeroinitializer, {i8*, i64, i64, %mem.Allocator}* %20
	store {i8*, i64, i64, %mem.Allocator} %370, {i8*, i64, i64, %mem.Allocator}* %20
	%373 = call %..string @fmt.to_string({i8*, i64, i64, %mem.Allocator}* %20, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret %..string %373
}

define ccc float @math.tan_f32(float %"\CE\B8") #0 {
decls-0:
	%0 = alloca float, align 16
	store float %"\CE\B8", float* %0
	; ReturnStmt
	%1 = load float, float* %0, align 4
	%2 = call ccc float @llvm.sin.f32(float %1)
	%3 = load float, float* %0, align 4
	%4 = call ccc float @llvm.cos.f32(float %3)
	%5 = fdiv float %2, %4
	ret float %5
}

define float @math.to_radians(float %degrees, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca float, align 16
	store float %degrees, float* %0
	; ReturnStmt
	%1 = load float, float* %0, align 4
	%2 = fmul float %1, 0x401921fb40000000
	%3 = fdiv float %2, 0x4076800000000000
	ret float %3
}

define [4 x [4 x float]] @math.mat4_mul([4 x [4 x float]]* %a, [4 x [4 x float]]* %b, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca [4 x [4 x float]], align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = load [4 x [4 x float]], [4 x [4 x float]]* %a, align 4
	%8 = load [4 x [4 x float]], [4 x [4 x float]]* %b, align 4
	; c
	%9 = bitcast [4 x [4 x float]]* %0 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %0
	; RangeStmt
	; j
	%11 = bitcast i64* %1 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 8) noinline
	store i64 zeroinitializer, i64* %1
	%13 = bitcast i64* %2 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	store i64 0, i64* %2
	%15 = bitcast i64* %3 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	store i64 0, i64* %3
	br label %for.interval.loop-1

for.interval.loop-1:
	%17 = load i64, i64* %2, align 8
	%18 = icmp sle i64 %17, 3
	br i1 %18, label %for.interval.body-2, label %for.interval.done-6

for.interval.body-2:
	%19 = load i64, i64* %2, align 8
	%20 = load i64, i64* %3, align 8
	%21 = load i64, i64* %2, align 8
	%22 = add i64 %21, 1
	store i64 %22, i64* %2
	%23 = load i64, i64* %3, align 8
	%24 = add i64 %23, 1
	store i64 %24, i64* %3
	store i64 %19, i64* %1
	; RangeStmt
	; i
	%25 = bitcast i64* %4 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	%27 = bitcast i64* %5 to %..rawptr
	%28 = call %..rawptr @mem.zero(%..rawptr %27, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	store i64 0, i64* %5
	%29 = bitcast i64* %6 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 8) noinline
	store i64 zeroinitializer, i64* %6
	store i64 0, i64* %6
	br label %for.interval.loop-3

for.interval.loop-3:
	%31 = load i64, i64* %5, align 8
	%32 = icmp sle i64 %31, 3
	br i1 %32, label %for.interval.body-4, label %for.interval.done-5

for.interval.body-4:
	%33 = load i64, i64* %5, align 8
	%34 = load i64, i64* %6, align 8
	%35 = load i64, i64* %5, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %5
	%37 = load i64, i64* %6, align 8
	%38 = add i64 %37, 1
	store i64 %38, i64* %6
	store i64 %33, i64* %4
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%39 = load i64, i64* %1, align 8
	%40 = trunc i64 %39 to i32
	%41 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %0, i64 0, i32 %40
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$17a, i64 0, i32 0), i64 55}, i64 226, i64 6, i64 %39, i64 4)
	%42 = load i64, i64* %4, align 8
	%43 = trunc i64 %42 to i32
	%44 = getelementptr inbounds [4 x float], [4 x float]* %41, i64 0, i32 %43
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$17b, i64 0, i32 0), i64 55}, i64 226, i64 9, i64 %42, i64 4)
	; IndexExpr
	; IndexExpr
	%45 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %a, i64 0, i32 0
	%46 = load i64, i64* %4, align 8
	%47 = trunc i64 %46 to i32
	%48 = getelementptr inbounds [4 x float], [4 x float]* %45, i64 0, i32 %47
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$17c, i64 0, i32 0), i64 55}, i64 226, i64 19, i64 %46, i64 4)
	%49 = load float, float* %48, align 4
	; IndexExpr
	; IndexExpr
	%50 = load i64, i64* %1, align 8
	%51 = trunc i64 %50 to i32
	%52 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %b, i64 0, i32 %51
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$17d, i64 0, i32 0), i64 55}, i64 226, i64 24, i64 %50, i64 4)
	%53 = getelementptr inbounds [4 x float], [4 x float]* %52, i64 0, i32 0
	%54 = load float, float* %53, align 4
	%55 = fmul float %49, %54
	; IndexExpr
	; IndexExpr
	%56 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %a, i64 0, i32 1
	%57 = load i64, i64* %4, align 8
	%58 = trunc i64 %57 to i32
	%59 = getelementptr inbounds [4 x float], [4 x float]* %56, i64 0, i32 %58
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$17e, i64 0, i32 0), i64 55}, i64 227, i64 19, i64 %57, i64 4)
	%60 = load float, float* %59, align 4
	; IndexExpr
	; IndexExpr
	%61 = load i64, i64* %1, align 8
	%62 = trunc i64 %61 to i32
	%63 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %b, i64 0, i32 %62
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$17f, i64 0, i32 0), i64 55}, i64 227, i64 24, i64 %61, i64 4)
	%64 = getelementptr inbounds [4 x float], [4 x float]* %63, i64 0, i32 1
	%65 = load float, float* %64, align 4
	%66 = fmul float %60, %65
	%67 = fadd float %55, %66
	; IndexExpr
	; IndexExpr
	%68 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %a, i64 0, i32 2
	%69 = load i64, i64* %4, align 8
	%70 = trunc i64 %69 to i32
	%71 = getelementptr inbounds [4 x float], [4 x float]* %68, i64 0, i32 %70
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$180, i64 0, i32 0), i64 55}, i64 228, i64 19, i64 %69, i64 4)
	%72 = load float, float* %71, align 4
	; IndexExpr
	; IndexExpr
	%73 = load i64, i64* %1, align 8
	%74 = trunc i64 %73 to i32
	%75 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %b, i64 0, i32 %74
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$181, i64 0, i32 0), i64 55}, i64 228, i64 24, i64 %73, i64 4)
	%76 = getelementptr inbounds [4 x float], [4 x float]* %75, i64 0, i32 2
	%77 = load float, float* %76, align 4
	%78 = fmul float %72, %77
	%79 = fadd float %67, %78
	; IndexExpr
	; IndexExpr
	%80 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %a, i64 0, i32 3
	%81 = load i64, i64* %4, align 8
	%82 = trunc i64 %81 to i32
	%83 = getelementptr inbounds [4 x float], [4 x float]* %80, i64 0, i32 %82
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$182, i64 0, i32 0), i64 55}, i64 229, i64 19, i64 %81, i64 4)
	%84 = load float, float* %83, align 4
	; IndexExpr
	; IndexExpr
	%85 = load i64, i64* %1, align 8
	%86 = trunc i64 %85 to i32
	%87 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %b, i64 0, i32 %86
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$183, i64 0, i32 0), i64 55}, i64 229, i64 24, i64 %85, i64 4)
	%88 = getelementptr inbounds [4 x float], [4 x float]* %87, i64 0, i32 3
	%89 = load float, float* %88, align 4
	%90 = fmul float %84, %89
	%91 = fadd float %79, %90
	store float %91, float* %44
	br label %for.interval.loop-3

for.interval.done-5:
	br label %for.interval.loop-1

for.interval.done-6:
	; ReturnStmt
	%92 = load [4 x [4 x float]], [4 x [4 x float]]* %0, align 4
	ret [4 x [4 x float]] %92
}

define [4 x [4 x float]] @math.scale_vec3([4 x [4 x float]]* %m, [3 x float]* %v, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = load [4 x [4 x float]], [4 x [4 x float]]* %m, align 4
	%1 = load [3 x float], [3 x float]* %v, align 4
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%2 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %m, i64 0, i32 0
	%3 = getelementptr inbounds [4 x float], [4 x float]* %2, i64 0, i32 0
	; IndexExpr
	%4 = getelementptr inbounds [3 x float], [3 x float]* %v, i64 0, i32 0
	%5 = load float, float* %4, align 4
	%6 = load float, float* %3, align 4
	%7 = fmul float %6, %5
	store float %7, float* %3
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%8 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %m, i64 0, i32 1
	%9 = getelementptr inbounds [4 x float], [4 x float]* %8, i64 0, i32 1
	; IndexExpr
	%10 = getelementptr inbounds [3 x float], [3 x float]* %v, i64 0, i32 1
	%11 = load float, float* %10, align 4
	%12 = load float, float* %9, align 4
	%13 = fmul float %12, %11
	store float %13, float* %9
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%14 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %m, i64 0, i32 2
	%15 = getelementptr inbounds [4 x float], [4 x float]* %14, i64 0, i32 2
	; IndexExpr
	%16 = getelementptr inbounds [3 x float], [3 x float]* %v, i64 0, i32 2
	%17 = load float, float* %16, align 4
	%18 = load float, float* %15, align 4
	%19 = fmul float %18, %17
	store float %19, float* %15
	; ReturnStmt
	%20 = load [4 x [4 x float]], [4 x [4 x float]]* %m, align 4
	ret [4 x [4 x float]] %20
}

define [4 x [4 x float]] @math.scale_f32([4 x [4 x float]]* %m, float %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca float, align 16
	%1 = load [4 x [4 x float]], [4 x [4 x float]]* %m, align 4
	store float %s, float* %0
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%2 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %m, i64 0, i32 0
	%3 = getelementptr inbounds [4 x float], [4 x float]* %2, i64 0, i32 0
	%4 = load float, float* %0, align 4
	%5 = load float, float* %3, align 4
	%6 = fmul float %5, %4
	store float %6, float* %3
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%7 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %m, i64 0, i32 1
	%8 = getelementptr inbounds [4 x float], [4 x float]* %7, i64 0, i32 1
	%9 = load float, float* %0, align 4
	%10 = load float, float* %8, align 4
	%11 = fmul float %10, %9
	store float %11, float* %8
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%12 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %m, i64 0, i32 2
	%13 = getelementptr inbounds [4 x float], [4 x float]* %12, i64 0, i32 2
	%14 = load float, float* %0, align 4
	%15 = load float, float* %13, align 4
	%16 = fmul float %15, %14
	store float %16, float* %13
	; ReturnStmt
	%17 = load [4 x [4 x float]], [4 x [4 x float]]* %m, align 4
	ret [4 x [4 x float]] %17
}

define [4 x [4 x float]] @math.perspective(float %fovy, float %aspect, float %near, float %far, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca float, align 16
	%1 = alloca float, align 16
	%2 = alloca float, align 16
	%3 = alloca float, align 16
	%4 = alloca [4 x [4 x float]], align 16
	%5 = alloca float, align 16
	store float %fovy, float* %0
	store float %aspect, float* %1
	store float %near, float* %2
	store float %far, float* %3
	; m
	%6 = bitcast [4 x [4 x float]]* %4 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %4
	; tan_half_fovy
	%8 = load float, float* %0, align 4
	%9 = fmul float 0x3fe0000000000000, %8
	%10 = call ccc float @math.tan_f32(float %9)
	store float %10, float* %5
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%11 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %4, i64 0, i32 0
	%12 = getelementptr inbounds [4 x float], [4 x float]* %11, i64 0, i32 0
	%13 = load float, float* %1, align 4
	%14 = load float, float* %5, align 4
	%15 = fmul float %13, %14
	%16 = fdiv float 0x3ff0000000000000, %15
	store float %16, float* %12
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%17 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %4, i64 0, i32 1
	%18 = getelementptr inbounds [4 x float], [4 x float]* %17, i64 0, i32 1
	%19 = load float, float* %5, align 4
	%20 = fdiv float 0x3ff0000000000000, %19
	store float %20, float* %18
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%21 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %4, i64 0, i32 2
	%22 = getelementptr inbounds [4 x float], [4 x float]* %21, i64 0, i32 2
	%23 = load float, float* %3, align 4
	%24 = load float, float* %2, align 4
	%25 = fadd float %23, %24
	%26 = fsub float 0x0000000000000000, %25
	%27 = load float, float* %3, align 4
	%28 = load float, float* %2, align 4
	%29 = fsub float %27, %28
	%30 = fdiv float %26, %29
	store float %30, float* %22
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%31 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %4, i64 0, i32 2
	%32 = getelementptr inbounds [4 x float], [4 x float]* %31, i64 0, i32 3
	store float 0xbff0000000000000, float* %32
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%33 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %4, i64 0, i32 3
	%34 = getelementptr inbounds [4 x float], [4 x float]* %33, i64 0, i32 2
	%35 = load float, float* %3, align 4
	%36 = fmul float 0xc000000000000000, %35
	%37 = load float, float* %2, align 4
	%38 = fmul float %36, %37
	%39 = load float, float* %3, align 4
	%40 = load float, float* %2, align 4
	%41 = fsub float %39, %40
	%42 = fdiv float %38, %41
	store float %42, float* %34
	; ReturnStmt
	%43 = load [4 x [4 x float]], [4 x [4 x float]]* %4, align 4
	ret [4 x [4 x float]] %43
}

define [4 x [4 x float]] @math.ortho3d(float %left, float %right, float %bottom, float %top, float %near, float %far, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca float, align 16
	%1 = alloca float, align 16
	%2 = alloca float, align 16
	%3 = alloca float, align 16
	%4 = alloca float, align 16
	%5 = alloca float, align 16
	%6 = alloca [4 x [4 x float]], align 16
	store float %left, float* %0
	store float %right, float* %1
	store float %bottom, float* %2
	store float %top, float* %3
	store float %near, float* %4
	store float %far, float* %5
	; m
	%7 = call [4 x [4 x float]] @math.identity-15829(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %7, [4 x [4 x float]]* %6
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%8 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %6, i64 0, i32 0
	%9 = getelementptr inbounds [4 x float], [4 x float]* %8, i64 0, i32 0
	%10 = load float, float* %1, align 4
	%11 = load float, float* %0, align 4
	%12 = fsub float %10, %11
	%13 = fdiv float 0x4000000000000000, %12
	store float %13, float* %9
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%14 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %6, i64 0, i32 1
	%15 = getelementptr inbounds [4 x float], [4 x float]* %14, i64 0, i32 1
	%16 = load float, float* %3, align 4
	%17 = load float, float* %2, align 4
	%18 = fsub float %16, %17
	%19 = fdiv float 0x4000000000000000, %18
	store float %19, float* %15
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%20 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %6, i64 0, i32 2
	%21 = getelementptr inbounds [4 x float], [4 x float]* %20, i64 0, i32 2
	%22 = load float, float* %5, align 4
	%23 = load float, float* %4, align 4
	%24 = fsub float %22, %23
	%25 = fdiv float 0xc000000000000000, %24
	store float %25, float* %21
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%26 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %6, i64 0, i32 3
	%27 = getelementptr inbounds [4 x float], [4 x float]* %26, i64 0, i32 0
	%28 = load float, float* %1, align 4
	%29 = load float, float* %0, align 4
	%30 = fadd float %28, %29
	%31 = fsub float 0x0000000000000000, %30
	%32 = load float, float* %1, align 4
	%33 = load float, float* %0, align 4
	%34 = fsub float %32, %33
	%35 = fdiv float %31, %34
	store float %35, float* %27
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%36 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %6, i64 0, i32 3
	%37 = getelementptr inbounds [4 x float], [4 x float]* %36, i64 0, i32 1
	%38 = load float, float* %3, align 4
	%39 = load float, float* %2, align 4
	%40 = fadd float %38, %39
	%41 = fsub float 0x0000000000000000, %40
	%42 = load float, float* %3, align 4
	%43 = load float, float* %2, align 4
	%44 = fsub float %42, %43
	%45 = fdiv float %41, %44
	store float %45, float* %37
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%46 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %6, i64 0, i32 3
	%47 = getelementptr inbounds [4 x float], [4 x float]* %46, i64 0, i32 2
	%48 = load float, float* %5, align 4
	%49 = load float, float* %4, align 4
	%50 = fadd float %48, %49
	%51 = fsub float 0x0000000000000000, %50
	%52 = load float, float* %5, align 4
	%53 = load float, float* %4, align 4
	%54 = fsub float %52, %53
	%55 = fdiv float %51, %54
	store float %55, float* %47
	; ReturnStmt
	%56 = load [4 x [4 x float]], [4 x [4 x float]]* %6, align 4
	ret [4 x [4 x float]] %56
}

define void @workbench._update_input(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i32, align 16
	%4 = alloca %workbench.Controller_State*, align 16
	%5 = alloca i8, align 16
	%6 = alloca {i8*, i64}, align 16
	%7 = alloca %mem.Allocator, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	%9 = alloca %mem.Allocator, align 16
	%10 = alloca %runtime.Source_Code_Location, align 16
	%11 = alloca %mem.Allocator, align 16
	%12 = alloca %runtime.Source_Code_Location, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i64, align 16
	%16 = alloca i8, align 16
	%17 = alloca i64, align 16
	%18 = alloca i8, align 16
	%19 = alloca i8, align 16
	%20 = alloca %imgui.IO*, align 16
	%21 = alloca %workbench.Key_Press, align 16
	%22 = alloca i64, align 16
	%23 = alloca %workbench.Key_Press, align 16
	%24 = alloca %runtime.Source_Code_Location, align 16
	%25 = alloca %workbench.Key_Press, align 16
	%26 = alloca i64, align 16
	%27 = alloca %workbench.Key_Press, align 16
	%28 = alloca %runtime.Source_Code_Location, align 16
	%29 = alloca %workbench.Key_Press, align 16
	%30 = alloca i64, align 16
	%31 = alloca %workbench.Key_Press, align 16
	%32 = alloca %runtime.Source_Code_Location, align 16
	; SelectorExpr
	call ccc void @glfwPollEvents()
	call void @runtime.clear_dynamic_array-16027({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held)
	call void @runtime.clear_dynamic_array-16027({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._down)
	call void @runtime.clear_dynamic_array-16027({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._up)
	; RangeStmt
	; _controller_idx
	%33 = bitcast i64* %0 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %0
	%35 = bitcast i64* %1 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store i64 zeroinitializer, i64* %1
	store i64 16, i64* %1
	%37 = bitcast i64* %2 to %..rawptr
	%38 = call %..rawptr @mem.zero(%..rawptr %37, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	store i64 -1, i64* %2
	br label %for.index.loop-1

for.index.loop-1:
	%39 = load i64, i64* %2, align 8
	%40 = add i64 %39, 1
	store i64 %40, i64* %2
	%41 = icmp slt i64 %40, 16
	br i1 %41, label %for.index.body-2, label %for.index.done-17

for.index.body-2:
	%42 = load i64, i64* %2, align 8
	store i64 %42, i64* %0
	; controller_idx
	%43 = load i64, i64* %0, align 8
	%44 = trunc i64 %43 to i32
	store i32 %44, i32* %3
	; controller
	; IndexExpr
	%45 = load i32, i32* %3, align 4
	%46 = sext i32 %45 to i64
	%47 = trunc i64 %46 to i32
	%48 = getelementptr inbounds [16 x %workbench.Controller_State], [16 x %workbench.Controller_State]* @workbench.controllers, i64 0, i32 %47
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$184, i64 0, i32 0), i64 63}, i64 78, i64 32, i64 %46, i64 16)
	store %workbench.Controller_State* %48, %workbench.Controller_State** %4
	; was_connected
	; SelectorExpr
	%49 = load %workbench.Controller_State*, %workbench.Controller_State** %4, align 8
	%50 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %49, i64 0
	%51 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %50, i64 0, i32 0
	%52 = load i8, i8* %51, align 1
	store i8 %52, i8* %5
	; AssignStmt
	; SelectorExpr
	%53 = load %workbench.Controller_State*, %workbench.Controller_State** %4, align 8
	%54 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %53, i64 0
	%55 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %54, i64 0, i32 0
	; SelectorExpr
	%56 = load i32, i32* %3, align 4
	%57 = call i8 @glfw.JoystickPresent(i32 %56, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i8 %57, i8* %55
	; IfStmt
	; SelectorExpr
	%58 = load %workbench.Controller_State*, %workbench.Controller_State** %4, align 8
	%59 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %58, i64 0
	%60 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %59, i64 0, i32 0
	%61 = load i8, i8* %60, align 1
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.done-4, label %if.then-3

if.then-3:
	; continue
	br label %for.index.loop-1

if.done-4:
	; buttons
	; SelectorExpr
	%63 = load i32, i32* %3, align 4
	%64 = call {i8*, i64} @glfw.GetJoystickButtons(i32 %63, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64} %64, {i8*, i64}* %6
	; AssignStmt
	; SelectorExpr
	%65 = load %workbench.Controller_State*, %workbench.Controller_State** %4, align 8
	%66 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %65, i64 0
	%67 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %66, i64 0, i32 4
	; SelectorExpr
	%68 = load i32, i32* %3, align 4
	%69 = call {float*, i64} @glfw.GetJoystickAxes(i32 %68, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {float*, i64} %69, {float*, i64}* %67
	; IfStmt
	%70 = load i8, i8* %5, align 1
	%71 = trunc i8 %70 to i1
	br i1 %71, label %if.done-6, label %if.then-5

if.then-5:
	; AssignStmt
	; SelectorExpr
	%72 = load %workbench.Controller_State*, %workbench.Controller_State** %4, align 8
	%73 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %72, i64 0
	%74 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %73, i64 0, i32 1
	%75 = load {i8*, i64}, {i8*, i64}* %6, align 8
	%76 = extractvalue {i8*, i64} %75, 1
	; SelectorExpr
	%77 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%78 = load %mem.Allocator, %mem.Allocator* %77, align 8
	%79 = bitcast %mem.Allocator* %7 to %..rawptr
	%80 = call %..rawptr @mem.zero(%..rawptr %79, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %7
	store %mem.Allocator %78, %mem.Allocator* %7
	%81 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$185, i64 0, i32 0), i64 63}, i64 91, i64 24, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$186, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %8
	%83 = call {i8*, i64} @mem.make_slice-14353(i64 %76, %mem.Allocator* %7, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64} %83, {i8*, i64}* %74
	; AssignStmt
	; SelectorExpr
	%84 = load %workbench.Controller_State*, %workbench.Controller_State** %4, align 8
	%85 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %84, i64 0
	%86 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %85, i64 0, i32 2
	%87 = load {i8*, i64}, {i8*, i64}* %6, align 8
	%88 = extractvalue {i8*, i64} %87, 1
	; SelectorExpr
	%89 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%90 = load %mem.Allocator, %mem.Allocator* %89, align 8
	%91 = bitcast %mem.Allocator* %9 to %..rawptr
	%92 = call %..rawptr @mem.zero(%..rawptr %91, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %9
	store %mem.Allocator %90, %mem.Allocator* %9
	%93 = bitcast %runtime.Source_Code_Location* %10 to %..rawptr
	%94 = call %..rawptr @mem.zero(%..rawptr %93, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %10
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$187, i64 0, i32 0), i64 63}, i64 92, i64 24, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$188, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %10
	%95 = call {i8*, i64} @mem.make_slice-14353(i64 %88, %mem.Allocator* %9, %runtime.Source_Code_Location* %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64} %95, {i8*, i64}* %86
	; AssignStmt
	; SelectorExpr
	%96 = load %workbench.Controller_State*, %workbench.Controller_State** %4, align 8
	%97 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %96, i64 0
	%98 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %97, i64 0, i32 3
	%99 = load {i8*, i64}, {i8*, i64}* %6, align 8
	%100 = extractvalue {i8*, i64} %99, 1
	; SelectorExpr
	%101 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%102 = load %mem.Allocator, %mem.Allocator* %101, align 8
	%103 = bitcast %mem.Allocator* %11 to %..rawptr
	%104 = call %..rawptr @mem.zero(%..rawptr %103, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %11
	store %mem.Allocator %102, %mem.Allocator* %11
	%105 = bitcast %runtime.Source_Code_Location* %12 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %12
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$189, i64 0, i32 0), i64 63}, i64 93, i64 24, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$18a, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %12
	%107 = call {i8*, i64} @mem.make_slice-14353(i64 %100, %mem.Allocator* %11, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64} %107, {i8*, i64}* %98
	br label %if.done-6

if.done-6:
	; RangeStmt
	; button_idx
	%108 = bitcast i64* %13 to %..rawptr
	%109 = call %..rawptr @mem.zero(%..rawptr %108, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	%110 = load {i8*, i64}, {i8*, i64}* %6, align 8
	%111 = bitcast i64* %14 to %..rawptr
	%112 = call %..rawptr @mem.zero(%..rawptr %111, i64 8) noinline
	store i64 zeroinitializer, i64* %14
	%113 = extractvalue {i8*, i64} %110, 1
	store i64 %113, i64* %14
	%114 = bitcast i64* %15 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 8) noinline
	store i64 zeroinitializer, i64* %15
	store i64 -1, i64* %15
	br label %for.index.loop-7

for.index.loop-7:
	%116 = load i64, i64* %15, align 8
	%117 = add i64 %116, 1
	store i64 %117, i64* %15
	%118 = load i64, i64* %14, align 8
	%119 = icmp slt i64 %117, %118
	br i1 %119, label %for.index.body-8, label %for.index.done-16

for.index.body-8:
	%120 = load i64, i64* %15, align 8
	store i64 %120, i64* %13
	; value
	; IndexExpr
	%121 = load {i8*, i64}, {i8*, i64}* %6, align 8
	%122 = extractvalue {i8*, i64} %121, 0
	%123 = load i64, i64* %13, align 8
	%124 = extractvalue {i8*, i64} %121, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$18b, i64 0, i32 0), i64 63}, i64 97, i64 23, i64 %123, i64 %124)
	%125 = getelementptr inbounds i8, i8* %122, i64 %123
	%126 = load i8, i8* %125, align 1
	store i8 %126, i8* %16
	; button
	%127 = load i64, i64* %13, align 8
	%128 = bitcast i64 %127 to i64
	%129 = bitcast i64 %128 to i64
	store i64 %129, i64* %17
	; is_held_now
	%130 = load i8, i8* %16, align 1
	%131 = icmp eq i8 %130, 1
	%132 = zext i1 %131 to i8
	store i8 %132, i8* %18
	; was_held_last_frame
	%133 = load i32, i32* %3, align 4
	%134 = load i64, i64* %17, align 8
	%135 = call i8 @workbench.get_button(i32 %133, i64 %134, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i8 %135, i8* %19
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%136 = load %workbench.Controller_State*, %workbench.Controller_State** %4, align 8
	%137 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %136, i64 0
	%138 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %137, i64 0, i32 1
	%139 = load {i8*, i64}, {i8*, i64}* %138, align 8
	%140 = extractvalue {i8*, i64} %139, 0
	%141 = load i64, i64* %13, align 8
	%142 = extractvalue {i8*, i64} %139, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$18c, i64 0, i32 0), i64 63}, i64 105, i64 22, i64 %141, i64 %142)
	%143 = getelementptr inbounds i8, i8* %140, i64 %141
	%144 = load i8, i8* %16, align 1
	store i8 %144, i8* %143
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%145 = load %workbench.Controller_State*, %workbench.Controller_State** %4, align 8
	%146 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %145, i64 0
	%147 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %146, i64 0, i32 2
	%148 = load {i8*, i64}, {i8*, i64}* %147, align 8
	%149 = extractvalue {i8*, i64} %148, 0
	%150 = load i64, i64* %13, align 8
	%151 = extractvalue {i8*, i64} %148, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$18d, i64 0, i32 0), i64 63}, i64 106, i64 22, i64 %150, i64 %151)
	%152 = getelementptr inbounds i8, i8* %149, i64 %150
	store i8 0, i8* %152
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%153 = load %workbench.Controller_State*, %workbench.Controller_State** %4, align 8
	%154 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %153, i64 0
	%155 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %154, i64 0, i32 3
	%156 = load {i8*, i64}, {i8*, i64}* %155, align 8
	%157 = extractvalue {i8*, i64} %156, 0
	%158 = load i64, i64* %13, align 8
	%159 = extractvalue {i8*, i64} %156, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$18e, i64 0, i32 0), i64 63}, i64 107, i64 20, i64 %158, i64 %159)
	%160 = getelementptr inbounds i8, i8* %157, i64 %158
	store i8 0, i8* %160
	; IfStmt
	%161 = load i8, i8* %18, align 1
	%162 = trunc i8 %161 to i1
	br i1 %162, label %cmp.and-9, label %if.else-11

cmp.and-9:
	%163 = load i8, i8* %19, align 1
	%164 = trunc i8 %163 to i1
	br i1 %164, label %if.else-11, label %if.then-10

if.then-10:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%165 = load %workbench.Controller_State*, %workbench.Controller_State** %4, align 8
	%166 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %165, i64 0
	%167 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %166, i64 0, i32 2
	%168 = load {i8*, i64}, {i8*, i64}* %167, align 8
	%169 = extractvalue {i8*, i64} %168, 0
	%170 = load i64, i64* %13, align 8
	%171 = extractvalue {i8*, i64} %168, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$18f, i64 0, i32 0), i64 63}, i64 110, i64 23, i64 %170, i64 %171)
	%172 = getelementptr inbounds i8, i8* %169, i64 %170
	store i8 1, i8* %172
	br label %if.done-15

if.else-11:
	; IfStmt
	%173 = load i8, i8* %18, align 1
	%174 = trunc i8 %173 to i1
	br i1 %174, label %if.done-14, label %cmp.and-12

cmp.and-12:
	%175 = load i8, i8* %19, align 1
	%176 = trunc i8 %175 to i1
	br i1 %176, label %if.then-13, label %if.done-14

if.then-13:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%177 = load %workbench.Controller_State*, %workbench.Controller_State** %4, align 8
	%178 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %177, i64 0
	%179 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %178, i64 0, i32 3
	%180 = load {i8*, i64}, {i8*, i64}* %179, align 8
	%181 = extractvalue {i8*, i64} %180, 0
	%182 = load i64, i64* %13, align 8
	%183 = extractvalue {i8*, i64} %180, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$190, i64 0, i32 0), i64 63}, i64 113, i64 21, i64 %182, i64 %183)
	%184 = getelementptr inbounds i8, i8* %181, i64 %182
	store i8 1, i8* %184
	br label %if.done-14

if.done-14:
	br label %if.done-15

if.done-15:
	br label %for.index.loop-7

for.index.done-16:
	br label %for.index.loop-1

for.index.done-17:
	; io
	; SelectorExpr
	%185 = call ccc %imgui.IO* @igGetIO()
	store %imgui.IO* %185, %imgui.IO** %20
	; IfStmt
	; SelectorExpr
	%186 = load %imgui.IO*, %imgui.IO** %20, align 8
	%187 = getelementptr inbounds %imgui.IO, %imgui.IO* %186, i64 0
	%188 = getelementptr inbounds %imgui.IO, %imgui.IO* %187, i64 0, i32 39
	%189 = load i8, i8* %188, align 1
	%190 = trunc i8 %189 to i1
	br i1 %190, label %if.done-28, label %if.then-18

if.then-18:
	; RangeStmt
	; held
	%191 = bitcast %workbench.Key_Press* %21 to %..rawptr
	%192 = call %..rawptr @mem.zero(%..rawptr %191, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %21
	%193 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held_mid_frame, i64 0, i32 1
	%194 = bitcast i64* %22 to %..rawptr
	%195 = call %..rawptr @mem.zero(%..rawptr %194, i64 8) noinline
	store i64 zeroinitializer, i64* %22
	store i64 -1, i64* %22
	br label %for.index.loop-19

for.index.loop-19:
	%196 = load i64, i64* %22, align 8
	%197 = add i64 %196, 1
	store i64 %197, i64* %22
	%198 = load i64, i64* %193, align 8
	%199 = icmp slt i64 %197, %198
	br i1 %199, label %for.index.body-20, label %for.index.done-21

for.index.body-20:
	%200 = load i64, i64* %22, align 8
	%201 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held_mid_frame, i64 0, i32 0
	%202 = load %workbench.Key_Press*, %workbench.Key_Press** %201, align 8
	%203 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %202, i64 %200
	%204 = load %workbench.Key_Press, %workbench.Key_Press* %203, align 4
	store %workbench.Key_Press %204, %workbench.Key_Press* %21
	%205 = load %workbench.Key_Press, %workbench.Key_Press* %21, align 4
	%206 = bitcast %workbench.Key_Press* %23 to %..rawptr
	%207 = call %..rawptr @mem.zero(%..rawptr %206, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %23
	store %workbench.Key_Press %205, %workbench.Key_Press* %23
	%208 = bitcast %runtime.Source_Code_Location* %24 to %..rawptr
	%209 = call %..rawptr @mem.zero(%..rawptr %208, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %24
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$191, i64 0, i32 0), i64 63}, i64 138, i64 5, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$192, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %24
	%210 = call i64 @runtime.append_elem-16219({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held, %workbench.Key_Press* %23, %runtime.Source_Code_Location* %24, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-19

for.index.done-21:
	; RangeStmt
	; down
	%211 = bitcast %workbench.Key_Press* %25 to %..rawptr
	%212 = call %..rawptr @mem.zero(%..rawptr %211, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %25
	%213 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._down_mid_frame, i64 0, i32 1
	%214 = bitcast i64* %26 to %..rawptr
	%215 = call %..rawptr @mem.zero(%..rawptr %214, i64 8) noinline
	store i64 zeroinitializer, i64* %26
	store i64 -1, i64* %26
	br label %for.index.loop-22

for.index.loop-22:
	%216 = load i64, i64* %26, align 8
	%217 = add i64 %216, 1
	store i64 %217, i64* %26
	%218 = load i64, i64* %213, align 8
	%219 = icmp slt i64 %217, %218
	br i1 %219, label %for.index.body-23, label %for.index.done-24

for.index.body-23:
	%220 = load i64, i64* %26, align 8
	%221 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._down_mid_frame, i64 0, i32 0
	%222 = load %workbench.Key_Press*, %workbench.Key_Press** %221, align 8
	%223 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %222, i64 %220
	%224 = load %workbench.Key_Press, %workbench.Key_Press* %223, align 4
	store %workbench.Key_Press %224, %workbench.Key_Press* %25
	%225 = load %workbench.Key_Press, %workbench.Key_Press* %25, align 4
	%226 = bitcast %workbench.Key_Press* %27 to %..rawptr
	%227 = call %..rawptr @mem.zero(%..rawptr %226, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %27
	store %workbench.Key_Press %225, %workbench.Key_Press* %27
	%228 = bitcast %runtime.Source_Code_Location* %28 to %..rawptr
	%229 = call %..rawptr @mem.zero(%..rawptr %228, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %28
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$193, i64 0, i32 0), i64 63}, i64 141, i64 5, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$194, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %28
	%230 = call i64 @runtime.append_elem-16219({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._down, %workbench.Key_Press* %27, %runtime.Source_Code_Location* %28, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-22

for.index.done-24:
	; RangeStmt
	; up
	%231 = bitcast %workbench.Key_Press* %29 to %..rawptr
	%232 = call %..rawptr @mem.zero(%..rawptr %231, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %29
	%233 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._up_mid_frame, i64 0, i32 1
	%234 = bitcast i64* %30 to %..rawptr
	%235 = call %..rawptr @mem.zero(%..rawptr %234, i64 8) noinline
	store i64 zeroinitializer, i64* %30
	store i64 -1, i64* %30
	br label %for.index.loop-25

for.index.loop-25:
	%236 = load i64, i64* %30, align 8
	%237 = add i64 %236, 1
	store i64 %237, i64* %30
	%238 = load i64, i64* %233, align 8
	%239 = icmp slt i64 %237, %238
	br i1 %239, label %for.index.body-26, label %for.index.done-27

for.index.body-26:
	%240 = load i64, i64* %30, align 8
	%241 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._up_mid_frame, i64 0, i32 0
	%242 = load %workbench.Key_Press*, %workbench.Key_Press** %241, align 8
	%243 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %242, i64 %240
	%244 = load %workbench.Key_Press, %workbench.Key_Press* %243, align 4
	store %workbench.Key_Press %244, %workbench.Key_Press* %29
	%245 = load %workbench.Key_Press, %workbench.Key_Press* %29, align 4
	%246 = bitcast %workbench.Key_Press* %31 to %..rawptr
	%247 = call %..rawptr @mem.zero(%..rawptr %246, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %31
	store %workbench.Key_Press %245, %workbench.Key_Press* %31
	%248 = bitcast %runtime.Source_Code_Location* %32 to %..rawptr
	%249 = call %..rawptr @mem.zero(%..rawptr %248, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %32
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$195, i64 0, i32 0), i64 63}, i64 144, i64 5, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$196, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %32
	%250 = call i64 @runtime.append_elem-16219({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._up, %workbench.Key_Press* %31, %runtime.Source_Code_Location* %32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-25

for.index.done-27:
	br label %if.done-28

if.done-28:
	call void @runtime.clear_dynamic_array-16027({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._down_mid_frame)
	call void @runtime.clear_dynamic_array-16027({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._up_mid_frame)
	ret void
}

define ccc void @workbench._glfw_key_callback(%..rawptr %window, i32 %key, i32 %scancode, i32 %action, i32 %mods) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i32, align 16
	%2 = alloca i32, align 16
	%3 = alloca i32, align 16
	%4 = alloca i32, align 16
	%5 = alloca %workbench.Key_Press, align 16
	%6 = alloca {[0 x <4 x i8>], [4 x i8], i8}, align 16
	%7 = alloca %runtime.Context, align 16
	%8 = bitcast %runtime.Context* %7 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %7
	%10 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %10, %runtime.Context* %7
	call void @runtime.__init_context(%runtime.Context* %7)
	%11 = alloca %workbench.Key_Press, align 16
	%12 = alloca %runtime.Source_Code_Location, align 16
	%13 = alloca %workbench.Key_Press, align 16
	%14 = alloca {[0 x <4 x i8>], [4 x i8], i8}, align 16
	%15 = alloca %workbench.Key_Press, align 16
	%16 = alloca %runtime.Source_Code_Location, align 16
	%17 = alloca i64, align 16
	%18 = alloca %workbench.Key_Press, align 16
	%19 = alloca i64, align 16
	%20 = alloca i64, align 16
	%21 = alloca {i32, i8}, align 16
	%22 = alloca %runtime.Source_Code_Location, align 16
	%23 = alloca %runtime.Context, align 16
	%24 = bitcast %runtime.Context* %23 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %23
	%26 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %26, %runtime.Context* %23
	call void @runtime.__init_context(%runtime.Context* %23)
	%27 = alloca %workbench.Key_Press, align 16
	%28 = alloca {[0 x <4 x i8>], [4 x i8], i8}, align 16
	%29 = alloca %workbench.Key_Press, align 16
	%30 = alloca %runtime.Source_Code_Location, align 16
	store %..rawptr %window, %..rawptr* %0
	store i32 %key, i32* %1
	store i32 %scancode, i32* %2
	store i32 %action, i32* %3
	store i32 %mods, i32* %4
	; SwitchStmt
	%31 = load i32, i32* %3, align 4
	%32 = icmp eq i32 %31, 1
	br i1 %32, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%33 = icmp eq i32 %31, 0
	br i1 %33, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	; CompoundLit
	%34 = bitcast %workbench.Key_Press* %5 to %..rawptr
	%35 = call %..rawptr @mem.zero(%..rawptr %34, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %5
	store %workbench.Key_Press {{[0 x <4 x i8>], [4 x i8], i8} zeroinitializer}, %workbench.Key_Press* %5
	%36 = load i32, i32* %1, align 4
	; union - child to parent
	%37 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %6 to %..rawptr
	%38 = call %..rawptr @mem.zero(%..rawptr %37, i64 8) noinline
	store {[0 x <4 x i8>], [4 x i8], i8} zeroinitializer, {[0 x <4 x i8>], [4 x i8], i8}* %6
	%39 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %6 to i32*
	store i32 %36, i32* %39
	%40 = getelementptr inbounds {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %6, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %40
	%41 = load {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %6, align 4
	%42 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %5, i64 0, i32 0
	store {[0 x <4 x i8>], [4 x i8], i8} %41, {[0 x <4 x i8>], [4 x i8], i8}* %42
	%43 = load %workbench.Key_Press, %workbench.Key_Press* %5, align 4
	%44 = bitcast %workbench.Key_Press* %11 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %11
	store %workbench.Key_Press %43, %workbench.Key_Press* %11
	%46 = bitcast %runtime.Source_Code_Location* %12 to %..rawptr
	%47 = call %..rawptr @mem.zero(%..rawptr %46, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %12
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$197, i64 0, i32 0), i64 63}, i64 199, i64 4, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$198, i64 0, i32 0), i64 18}}, %runtime.Source_Code_Location* %12
	%48 = call i64 @runtime.append_elem-16219({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held_mid_frame, %workbench.Key_Press* %11, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture inreg %7)
	; CompoundLit
	%49 = bitcast %workbench.Key_Press* %13 to %..rawptr
	%50 = call %..rawptr @mem.zero(%..rawptr %49, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %13
	store %workbench.Key_Press {{[0 x <4 x i8>], [4 x i8], i8} zeroinitializer}, %workbench.Key_Press* %13
	%51 = load i32, i32* %1, align 4
	; union - child to parent
	%52 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %14 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 8) noinline
	store {[0 x <4 x i8>], [4 x i8], i8} zeroinitializer, {[0 x <4 x i8>], [4 x i8], i8}* %14
	%54 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %14 to i32*
	store i32 %51, i32* %54
	%55 = getelementptr inbounds {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %14, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %55
	%56 = load {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %14, align 4
	%57 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %13, i64 0, i32 0
	store {[0 x <4 x i8>], [4 x i8], i8} %56, {[0 x <4 x i8>], [4 x i8], i8}* %57
	%58 = load %workbench.Key_Press, %workbench.Key_Press* %13, align 4
	%59 = bitcast %workbench.Key_Press* %15 to %..rawptr
	%60 = call %..rawptr @mem.zero(%..rawptr %59, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %15
	store %workbench.Key_Press %58, %workbench.Key_Press* %15
	%61 = bitcast %runtime.Source_Code_Location* %16 to %..rawptr
	%62 = call %..rawptr @mem.zero(%..rawptr %61, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %16
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$199, i64 0, i32 0), i64 63}, i64 200, i64 4, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$19a, i64 0, i32 0), i64 18}}, %runtime.Source_Code_Location* %16
	%63 = call i64 @runtime.append_elem-16219({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._down_mid_frame, %workbench.Key_Press* %15, %runtime.Source_Code_Location* %16, %runtime.Context* noalias nonnull nocapture inreg %7)
	br label %switch.done-12

switch.case.next-3:
	br label %switch.done-12

switch.fall.body-4:
	; idx
	store i64 -1, i64* %17
	; RangeStmt
	; held
	%64 = bitcast %workbench.Key_Press* %18 to %..rawptr
	%65 = call %..rawptr @mem.zero(%..rawptr %64, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %18
	; i
	%66 = bitcast i64* %19 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 8) noinline
	store i64 zeroinitializer, i64* %19
	%68 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held_mid_frame, i64 0, i32 1
	%69 = bitcast i64* %20 to %..rawptr
	%70 = call %..rawptr @mem.zero(%..rawptr %69, i64 8) noinline
	store i64 zeroinitializer, i64* %20
	store i64 -1, i64* %20
	br label %for.index.loop-5

for.index.loop-5:
	%71 = load i64, i64* %20, align 8
	%72 = add i64 %71, 1
	store i64 %72, i64* %20
	%73 = load i64, i64* %68, align 8
	%74 = icmp slt i64 %72, %73
	br i1 %74, label %for.index.body-6, label %for.index.done-11

for.index.body-6:
	%75 = load i64, i64* %20, align 8
	%76 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held_mid_frame, i64 0, i32 0
	%77 = load %workbench.Key_Press*, %workbench.Key_Press** %76, align 8
	%78 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %77, i64 %75
	%79 = load %workbench.Key_Press, %workbench.Key_Press* %78, align 4
	store %workbench.Key_Press %79, %workbench.Key_Press* %18
	store i64 %75, i64* %19
	; IfStmt
	; SelectorExpr
	%80 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %18, i64 0, i32 0
	%81 = load {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %80, align 4
	; cast - union_cast
	%82 = bitcast {i32, i8}* %21 to %..rawptr
	%83 = call %..rawptr @mem.zero(%..rawptr %82, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %21
	%84 = getelementptr inbounds {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %80, i64 0, i32 2 ; UnionTagPtr
	%85 = load i8, i8* %84, align 1
	%86 = icmp eq i8 %85, 1
	br i1 %86, label %union_cast.ok-7, label %union_cast.end-8

union_cast.ok-7:
	%87 = getelementptr inbounds {i32, i8}, {i32, i8}* %21, i64 0, i32 0
	%88 = getelementptr inbounds {i32, i8}, {i32, i8}* %21, i64 0, i32 1
	%89 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %80 to i32*
	%90 = load i32, i32* %89, align 4
	store i32 %90, i32* %87
	store i8 1, i8* %88
	br label %union_cast.end-8

union_cast.end-8:
	%91 = getelementptr inbounds {i32, i8}, {i32, i8}* %21, i64 0, i32 1
	%92 = load i8, i8* %91, align 1
	%93 = trunc i8 %92 to i1
	call void @runtime.type_assertion_check(i1 %93, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$19b, i64 0, i32 0), i64 63}, i64 205, i64 13, %..typeid 1152921504606847068, %..typeid 3530822107858468957)
	%94 = getelementptr inbounds {i32, i8}, {i32, i8}* %21, i64 0, i32 0
	%95 = load i32, i32* %94, align 4
	%96 = load i32, i32* %1, align 4
	%97 = icmp eq i32 %95, %96
	%98 = zext i1 %97 to i8
	%99 = trunc i8 %98 to i1
	br i1 %99, label %if.then-9, label %if.done-10

if.then-9:
	; AssignStmt
	%100 = load i64, i64* %19, align 8
	store i64 %100, i64* %17
	; break
	br label %for.index.done-11

if.done-10:
	br label %for.index.loop-5

for.index.done-11:
	%101 = load i64, i64* %17, align 8
	%102 = icmp ne i64 %101, -1
	%103 = zext i1 %102 to i8
	%104 = trunc i8 %103 to i1
	%105 = bitcast %runtime.Source_Code_Location* %22 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %22
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$19c, i64 0, i32 0), i64 63}, i64 210, i64 4, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$19d, i64 0, i32 0), i64 18}}, %runtime.Source_Code_Location* %22
	%107 = call i8 @runtime.assert(i1 %104, %..string zeroinitializer, %runtime.Source_Code_Location* %22)
	%108 = load i64, i64* %17, align 8
	call void @workbench.remove_at-16407({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held_mid_frame, i64 %108, %runtime.Context* noalias nonnull nocapture inreg %23)
	; CompoundLit
	%109 = bitcast %workbench.Key_Press* %27 to %..rawptr
	%110 = call %..rawptr @mem.zero(%..rawptr %109, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %27
	store %workbench.Key_Press {{[0 x <4 x i8>], [4 x i8], i8} zeroinitializer}, %workbench.Key_Press* %27
	%111 = load i32, i32* %1, align 4
	; union - child to parent
	%112 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %28 to %..rawptr
	%113 = call %..rawptr @mem.zero(%..rawptr %112, i64 8) noinline
	store {[0 x <4 x i8>], [4 x i8], i8} zeroinitializer, {[0 x <4 x i8>], [4 x i8], i8}* %28
	%114 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %28 to i32*
	store i32 %111, i32* %114
	%115 = getelementptr inbounds {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %28, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %115
	%116 = load {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %28, align 4
	%117 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %27, i64 0, i32 0
	store {[0 x <4 x i8>], [4 x i8], i8} %116, {[0 x <4 x i8>], [4 x i8], i8}* %117
	%118 = load %workbench.Key_Press, %workbench.Key_Press* %27, align 4
	%119 = bitcast %workbench.Key_Press* %29 to %..rawptr
	%120 = call %..rawptr @mem.zero(%..rawptr %119, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %29
	store %workbench.Key_Press %118, %workbench.Key_Press* %29
	%121 = bitcast %runtime.Source_Code_Location* %30 to %..rawptr
	%122 = call %..rawptr @mem.zero(%..rawptr %121, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %30
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$19e, i64 0, i32 0), i64 63}, i64 212, i64 4, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$19f, i64 0, i32 0), i64 18}}, %runtime.Source_Code_Location* %30
	%123 = call i64 @runtime.append_elem-16219({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._up_mid_frame, %workbench.Key_Press* %29, %runtime.Source_Code_Location* %30, %runtime.Context* noalias nonnull nocapture inreg %23)
	br label %switch.done-12

switch.done-12:
	ret void
}

define ccc void @workbench._glfw_mouse_button_callback(%..rawptr %window, i32 %button, i32 %action, i32 %mods) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i32, align 16
	%2 = alloca i32, align 16
	%3 = alloca i32, align 16
	%4 = alloca %workbench.Key_Press, align 16
	%5 = alloca {[0 x <4 x i8>], [4 x i8], i8}, align 16
	%6 = alloca %runtime.Context, align 16
	%7 = bitcast %runtime.Context* %6 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %6
	%9 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %9, %runtime.Context* %6
	call void @runtime.__init_context(%runtime.Context* %6)
	%10 = alloca %workbench.Key_Press, align 16
	%11 = alloca %runtime.Source_Code_Location, align 16
	%12 = alloca %workbench.Key_Press, align 16
	%13 = alloca {[0 x <4 x i8>], [4 x i8], i8}, align 16
	%14 = alloca %workbench.Key_Press, align 16
	%15 = alloca %runtime.Source_Code_Location, align 16
	%16 = alloca i64, align 16
	%17 = alloca %workbench.Key_Press, align 16
	%18 = alloca i64, align 16
	%19 = alloca i64, align 16
	%20 = alloca {i32, i8}, align 16
	%21 = alloca %runtime.Source_Code_Location, align 16
	%22 = alloca %runtime.Context, align 16
	%23 = bitcast %runtime.Context* %22 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %22
	%25 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %25, %runtime.Context* %22
	call void @runtime.__init_context(%runtime.Context* %22)
	%26 = alloca %workbench.Key_Press, align 16
	%27 = alloca {[0 x <4 x i8>], [4 x i8], i8}, align 16
	%28 = alloca %workbench.Key_Press, align 16
	%29 = alloca %runtime.Source_Code_Location, align 16
	store %..rawptr %window, %..rawptr* %0
	store i32 %button, i32* %1
	store i32 %action, i32* %2
	store i32 %mods, i32* %3
	; SwitchStmt
	%30 = load i32, i32* %2, align 4
	%31 = icmp eq i32 %30, 1
	br i1 %31, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%32 = icmp eq i32 %30, 0
	br i1 %32, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	; CompoundLit
	%33 = bitcast %workbench.Key_Press* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %4
	store %workbench.Key_Press {{[0 x <4 x i8>], [4 x i8], i8} zeroinitializer}, %workbench.Key_Press* %4
	%35 = load i32, i32* %1, align 4
	; union - child to parent
	%36 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %5 to %..rawptr
	%37 = call %..rawptr @mem.zero(%..rawptr %36, i64 8) noinline
	store {[0 x <4 x i8>], [4 x i8], i8} zeroinitializer, {[0 x <4 x i8>], [4 x i8], i8}* %5
	%38 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %5 to i32*
	store i32 %35, i32* %38
	%39 = getelementptr inbounds {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %5, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %39
	%40 = load {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %5, align 4
	%41 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %4, i64 0, i32 0
	store {[0 x <4 x i8>], [4 x i8], i8} %40, {[0 x <4 x i8>], [4 x i8], i8}* %41
	%42 = load %workbench.Key_Press, %workbench.Key_Press* %4, align 4
	%43 = bitcast %workbench.Key_Press* %10 to %..rawptr
	%44 = call %..rawptr @mem.zero(%..rawptr %43, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %10
	store %workbench.Key_Press %42, %workbench.Key_Press* %10
	%45 = bitcast %runtime.Source_Code_Location* %11 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %11
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$1a0, i64 0, i32 0), i64 63}, i64 220, i64 4, %..string {i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$1a1, i64 0, i32 0), i64 27}}, %runtime.Source_Code_Location* %11
	%47 = call i64 @runtime.append_elem-16219({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held_mid_frame, %workbench.Key_Press* %10, %runtime.Source_Code_Location* %11, %runtime.Context* noalias nonnull nocapture inreg %6)
	; CompoundLit
	%48 = bitcast %workbench.Key_Press* %12 to %..rawptr
	%49 = call %..rawptr @mem.zero(%..rawptr %48, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %12
	store %workbench.Key_Press {{[0 x <4 x i8>], [4 x i8], i8} zeroinitializer}, %workbench.Key_Press* %12
	%50 = load i32, i32* %1, align 4
	; union - child to parent
	%51 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %13 to %..rawptr
	%52 = call %..rawptr @mem.zero(%..rawptr %51, i64 8) noinline
	store {[0 x <4 x i8>], [4 x i8], i8} zeroinitializer, {[0 x <4 x i8>], [4 x i8], i8}* %13
	%53 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %13 to i32*
	store i32 %50, i32* %53
	%54 = getelementptr inbounds {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %13, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %54
	%55 = load {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %13, align 4
	%56 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %12, i64 0, i32 0
	store {[0 x <4 x i8>], [4 x i8], i8} %55, {[0 x <4 x i8>], [4 x i8], i8}* %56
	%57 = load %workbench.Key_Press, %workbench.Key_Press* %12, align 4
	%58 = bitcast %workbench.Key_Press* %14 to %..rawptr
	%59 = call %..rawptr @mem.zero(%..rawptr %58, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %14
	store %workbench.Key_Press %57, %workbench.Key_Press* %14
	%60 = bitcast %runtime.Source_Code_Location* %15 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %15
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$1a2, i64 0, i32 0), i64 63}, i64 221, i64 4, %..string {i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$1a3, i64 0, i32 0), i64 27}}, %runtime.Source_Code_Location* %15
	%62 = call i64 @runtime.append_elem-16219({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._down_mid_frame, %workbench.Key_Press* %14, %runtime.Source_Code_Location* %15, %runtime.Context* noalias nonnull nocapture inreg %6)
	br label %switch.done-12

switch.case.next-3:
	br label %switch.done-12

switch.fall.body-4:
	; idx
	store i64 -1, i64* %16
	; RangeStmt
	; held
	%63 = bitcast %workbench.Key_Press* %17 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %17
	; i
	%65 = bitcast i64* %18 to %..rawptr
	%66 = call %..rawptr @mem.zero(%..rawptr %65, i64 8) noinline
	store i64 zeroinitializer, i64* %18
	%67 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held_mid_frame, i64 0, i32 1
	%68 = bitcast i64* %19 to %..rawptr
	%69 = call %..rawptr @mem.zero(%..rawptr %68, i64 8) noinline
	store i64 zeroinitializer, i64* %19
	store i64 -1, i64* %19
	br label %for.index.loop-5

for.index.loop-5:
	%70 = load i64, i64* %19, align 8
	%71 = add i64 %70, 1
	store i64 %71, i64* %19
	%72 = load i64, i64* %67, align 8
	%73 = icmp slt i64 %71, %72
	br i1 %73, label %for.index.body-6, label %for.index.done-11

for.index.body-6:
	%74 = load i64, i64* %19, align 8
	%75 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held_mid_frame, i64 0, i32 0
	%76 = load %workbench.Key_Press*, %workbench.Key_Press** %75, align 8
	%77 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %76, i64 %74
	%78 = load %workbench.Key_Press, %workbench.Key_Press* %77, align 4
	store %workbench.Key_Press %78, %workbench.Key_Press* %17
	store i64 %74, i64* %18
	; IfStmt
	; SelectorExpr
	%79 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %17, i64 0, i32 0
	%80 = load {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %79, align 4
	; cast - union_cast
	%81 = bitcast {i32, i8}* %20 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %20
	%83 = getelementptr inbounds {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %79, i64 0, i32 2 ; UnionTagPtr
	%84 = load i8, i8* %83, align 1
	%85 = icmp eq i8 %84, 2
	br i1 %85, label %union_cast.ok-7, label %union_cast.end-8

union_cast.ok-7:
	%86 = getelementptr inbounds {i32, i8}, {i32, i8}* %20, i64 0, i32 0
	%87 = getelementptr inbounds {i32, i8}, {i32, i8}* %20, i64 0, i32 1
	%88 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %79 to i32*
	%89 = load i32, i32* %88, align 4
	store i32 %89, i32* %86
	store i8 1, i8* %87
	br label %union_cast.end-8

union_cast.end-8:
	%90 = getelementptr inbounds {i32, i8}, {i32, i8}* %20, i64 0, i32 1
	%91 = load i8, i8* %90, align 1
	%92 = trunc i8 %91 to i1
	call void @runtime.type_assertion_check(i1 %92, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$1a4, i64 0, i32 0), i64 63}, i64 226, i64 13, %..typeid 1152921504606847068, %..typeid 3530822107858468959)
	%93 = getelementptr inbounds {i32, i8}, {i32, i8}* %20, i64 0, i32 0
	%94 = load i32, i32* %93, align 4
	%95 = load i32, i32* %1, align 4
	%96 = icmp eq i32 %94, %95
	%97 = zext i1 %96 to i8
	%98 = trunc i8 %97 to i1
	br i1 %98, label %if.then-9, label %if.done-10

if.then-9:
	; AssignStmt
	%99 = load i64, i64* %18, align 8
	store i64 %99, i64* %16
	; break
	br label %for.index.done-11

if.done-10:
	br label %for.index.loop-5

for.index.done-11:
	%100 = load i64, i64* %16, align 8
	%101 = icmp ne i64 %100, -1
	%102 = zext i1 %101 to i8
	%103 = trunc i8 %102 to i1
	%104 = bitcast %runtime.Source_Code_Location* %21 to %..rawptr
	%105 = call %..rawptr @mem.zero(%..rawptr %104, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %21
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$1a5, i64 0, i32 0), i64 63}, i64 231, i64 4, %..string {i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$1a6, i64 0, i32 0), i64 27}}, %runtime.Source_Code_Location* %21
	%106 = call i8 @runtime.assert(i1 %103, %..string zeroinitializer, %runtime.Source_Code_Location* %21)
	%107 = load i64, i64* %16, align 8
	call void @workbench.remove_at-16407({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held_mid_frame, i64 %107, %runtime.Context* noalias nonnull nocapture inreg %22)
	; CompoundLit
	%108 = bitcast %workbench.Key_Press* %26 to %..rawptr
	%109 = call %..rawptr @mem.zero(%..rawptr %108, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %26
	store %workbench.Key_Press {{[0 x <4 x i8>], [4 x i8], i8} zeroinitializer}, %workbench.Key_Press* %26
	%110 = load i32, i32* %1, align 4
	; union - child to parent
	%111 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %27 to %..rawptr
	%112 = call %..rawptr @mem.zero(%..rawptr %111, i64 8) noinline
	store {[0 x <4 x i8>], [4 x i8], i8} zeroinitializer, {[0 x <4 x i8>], [4 x i8], i8}* %27
	%113 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %27 to i32*
	store i32 %110, i32* %113
	%114 = getelementptr inbounds {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %27, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %114
	%115 = load {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %27, align 4
	%116 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %26, i64 0, i32 0
	store {[0 x <4 x i8>], [4 x i8], i8} %115, {[0 x <4 x i8>], [4 x i8], i8}* %116
	%117 = load %workbench.Key_Press, %workbench.Key_Press* %26, align 4
	%118 = bitcast %workbench.Key_Press* %28 to %..rawptr
	%119 = call %..rawptr @mem.zero(%..rawptr %118, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %28
	store %workbench.Key_Press %117, %workbench.Key_Press* %28
	%120 = bitcast %runtime.Source_Code_Location* %29 to %..rawptr
	%121 = call %..rawptr @mem.zero(%..rawptr %120, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %29
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$1a7, i64 0, i32 0), i64 63}, i64 233, i64 4, %..string {i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$1a8, i64 0, i32 0), i64 27}}, %runtime.Source_Code_Location* %29
	%122 = call i64 @runtime.append_elem-16219({%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._up_mid_frame, %workbench.Key_Press* %28, %runtime.Source_Code_Location* %29, %runtime.Context* noalias nonnull nocapture inreg %22)
	br label %switch.done-12

switch.done-12:
	ret void
}

define i8 @workbench.get_mouse_down(i32 %mouse, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %workbench.Key_Press, align 16
	%2 = alloca i64, align 16
	%3 = alloca i32, align 16
	%4 = alloca i8, align 16
	%5 = alloca {i32, i8}, align 16
	store i32 %mouse, i32* %0
	; RangeStmt
	; down
	%6 = bitcast %workbench.Key_Press* %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %1
	%8 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._down, i64 0, i32 1
	%9 = bitcast i64* %2 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	store i64 -1, i64* %2
	br label %for.index.loop-1

for.index.loop-1:
	%11 = load i64, i64* %2, align 8
	%12 = add i64 %11, 1
	store i64 %12, i64* %2
	%13 = load i64, i64* %8, align 8
	%14 = icmp slt i64 %12, %13
	br i1 %14, label %for.index.body-2, label %for.index.done-8

for.index.body-2:
	%15 = load i64, i64* %2, align 8
	%16 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._down, i64 0, i32 0
	%17 = load %workbench.Key_Press*, %workbench.Key_Press** %16, align 8
	%18 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %17, i64 %15
	%19 = load %workbench.Key_Press, %workbench.Key_Press* %18, align 4
	store %workbench.Key_Press %19, %workbench.Key_Press* %1
	; IfStmt
	; mouse_down
	; ok
	; SelectorExpr
	%20 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %1, i64 0, i32 0
	%21 = load {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %20, align 4
	; cast - union_cast
	%22 = bitcast {i32, i8}* %5 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %5
	%24 = getelementptr inbounds {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %20, i64 0, i32 2 ; UnionTagPtr
	%25 = load i8, i8* %24, align 1
	%26 = icmp eq i8 %25, 2
	br i1 %26, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%27 = getelementptr inbounds {i32, i8}, {i32, i8}* %5, i64 0, i32 0
	%28 = getelementptr inbounds {i32, i8}, {i32, i8}* %5, i64 0, i32 1
	%29 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %20 to i32*
	%30 = load i32, i32* %29, align 4
	store i32 %30, i32* %27
	store i8 1, i8* %28
	br label %union_cast.end-4

union_cast.end-4:
	%31 = load {i32, i8}, {i32, i8}* %5, align 4
	%32 = extractvalue {i32, i8} %31, 0
	%33 = extractvalue {i32, i8} %31, 1
	store i32 %32, i32* %3
	store i8 %33, i8* %4
	%34 = load i8, i8* %4, align 1
	%35 = trunc i8 %34 to i1
	br i1 %35, label %cmp.and-5, label %if.done-7

cmp.and-5:
	%36 = load i32, i32* %3, align 4
	%37 = load i32, i32* %0, align 4
	%38 = icmp eq i32 %36, %37
	%39 = zext i1 %38 to i8
	%40 = trunc i8 %39 to i1
	br i1 %40, label %if.then-6, label %if.done-7

if.then-6:
	; ReturnStmt
	ret i8 1

if.done-7:
	br label %for.index.loop-1

for.index.done-8:
	; ReturnStmt
	ret i8 0
}

define i8 @workbench.get_mouse_up(i32 %mouse, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %workbench.Key_Press, align 16
	%2 = alloca i64, align 16
	%3 = alloca i32, align 16
	%4 = alloca i8, align 16
	%5 = alloca {i32, i8}, align 16
	store i32 %mouse, i32* %0
	; RangeStmt
	; up
	%6 = bitcast %workbench.Key_Press* %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %1
	%8 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._up, i64 0, i32 1
	%9 = bitcast i64* %2 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	store i64 -1, i64* %2
	br label %for.index.loop-1

for.index.loop-1:
	%11 = load i64, i64* %2, align 8
	%12 = add i64 %11, 1
	store i64 %12, i64* %2
	%13 = load i64, i64* %8, align 8
	%14 = icmp slt i64 %12, %13
	br i1 %14, label %for.index.body-2, label %for.index.done-8

for.index.body-2:
	%15 = load i64, i64* %2, align 8
	%16 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._up, i64 0, i32 0
	%17 = load %workbench.Key_Press*, %workbench.Key_Press** %16, align 8
	%18 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %17, i64 %15
	%19 = load %workbench.Key_Press, %workbench.Key_Press* %18, align 4
	store %workbench.Key_Press %19, %workbench.Key_Press* %1
	; IfStmt
	; mouse_up
	; ok
	; SelectorExpr
	%20 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %1, i64 0, i32 0
	%21 = load {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %20, align 4
	; cast - union_cast
	%22 = bitcast {i32, i8}* %5 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %5
	%24 = getelementptr inbounds {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %20, i64 0, i32 2 ; UnionTagPtr
	%25 = load i8, i8* %24, align 1
	%26 = icmp eq i8 %25, 2
	br i1 %26, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%27 = getelementptr inbounds {i32, i8}, {i32, i8}* %5, i64 0, i32 0
	%28 = getelementptr inbounds {i32, i8}, {i32, i8}* %5, i64 0, i32 1
	%29 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %20 to i32*
	%30 = load i32, i32* %29, align 4
	store i32 %30, i32* %27
	store i8 1, i8* %28
	br label %union_cast.end-4

union_cast.end-4:
	%31 = load {i32, i8}, {i32, i8}* %5, align 4
	%32 = extractvalue {i32, i8} %31, 0
	%33 = extractvalue {i32, i8} %31, 1
	store i32 %32, i32* %3
	store i8 %33, i8* %4
	%34 = load i8, i8* %4, align 1
	%35 = trunc i8 %34 to i1
	br i1 %35, label %cmp.and-5, label %if.done-7

cmp.and-5:
	%36 = load i32, i32* %3, align 4
	%37 = load i32, i32* %0, align 4
	%38 = icmp eq i32 %36, %37
	%39 = zext i1 %38 to i8
	%40 = trunc i8 %39 to i1
	br i1 %40, label %if.then-6, label %if.done-7

if.then-6:
	; ReturnStmt
	ret i8 1

if.done-7:
	br label %for.index.loop-1

for.index.done-8:
	; ReturnStmt
	ret i8 0
}

define i8 @workbench.get_key(i32 %key, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %workbench.Key_Press, align 16
	%2 = alloca i64, align 16
	%3 = alloca i32, align 16
	%4 = alloca i8, align 16
	%5 = alloca {i32, i8}, align 16
	store i32 %key, i32* %0
	; RangeStmt
	; held
	%6 = bitcast %workbench.Key_Press* %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %1
	%8 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held, i64 0, i32 1
	%9 = bitcast i64* %2 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	store i64 -1, i64* %2
	br label %for.index.loop-1

for.index.loop-1:
	%11 = load i64, i64* %2, align 8
	%12 = add i64 %11, 1
	store i64 %12, i64* %2
	%13 = load i64, i64* %8, align 8
	%14 = icmp slt i64 %12, %13
	br i1 %14, label %for.index.body-2, label %for.index.done-8

for.index.body-2:
	%15 = load i64, i64* %2, align 8
	%16 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held, i64 0, i32 0
	%17 = load %workbench.Key_Press*, %workbench.Key_Press** %16, align 8
	%18 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %17, i64 %15
	%19 = load %workbench.Key_Press, %workbench.Key_Press* %18, align 4
	store %workbench.Key_Press %19, %workbench.Key_Press* %1
	; IfStmt
	; key_held
	; ok
	; SelectorExpr
	%20 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %1, i64 0, i32 0
	%21 = load {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %20, align 4
	; cast - union_cast
	%22 = bitcast {i32, i8}* %5 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %5
	%24 = getelementptr inbounds {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %20, i64 0, i32 2 ; UnionTagPtr
	%25 = load i8, i8* %24, align 1
	%26 = icmp eq i8 %25, 1
	br i1 %26, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%27 = getelementptr inbounds {i32, i8}, {i32, i8}* %5, i64 0, i32 0
	%28 = getelementptr inbounds {i32, i8}, {i32, i8}* %5, i64 0, i32 1
	%29 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %20 to i32*
	%30 = load i32, i32* %29, align 4
	store i32 %30, i32* %27
	store i8 1, i8* %28
	br label %union_cast.end-4

union_cast.end-4:
	%31 = load {i32, i8}, {i32, i8}* %5, align 4
	%32 = extractvalue {i32, i8} %31, 0
	%33 = extractvalue {i32, i8} %31, 1
	store i32 %32, i32* %3
	store i8 %33, i8* %4
	%34 = load i8, i8* %4, align 1
	%35 = trunc i8 %34 to i1
	br i1 %35, label %cmp.and-5, label %if.done-7

cmp.and-5:
	%36 = load i32, i32* %3, align 4
	%37 = load i32, i32* %0, align 4
	%38 = icmp eq i32 %36, %37
	%39 = zext i1 %38 to i8
	%40 = trunc i8 %39 to i1
	br i1 %40, label %if.then-6, label %if.done-7

if.then-6:
	; ReturnStmt
	ret i8 1

if.done-7:
	br label %for.index.loop-1

for.index.done-8:
	; ReturnStmt
	ret i8 0
}

define i8 @workbench.get_key_down(i32 %key, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %workbench.Key_Press, align 16
	%2 = alloca i64, align 16
	%3 = alloca i32, align 16
	%4 = alloca i8, align 16
	%5 = alloca {i32, i8}, align 16
	store i32 %key, i32* %0
	; RangeStmt
	; down
	%6 = bitcast %workbench.Key_Press* %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 8) noinline
	store %workbench.Key_Press zeroinitializer, %workbench.Key_Press* %1
	%8 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._down, i64 0, i32 1
	%9 = bitcast i64* %2 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	store i64 -1, i64* %2
	br label %for.index.loop-1

for.index.loop-1:
	%11 = load i64, i64* %2, align 8
	%12 = add i64 %11, 1
	store i64 %12, i64* %2
	%13 = load i64, i64* %8, align 8
	%14 = icmp slt i64 %12, %13
	br i1 %14, label %for.index.body-2, label %for.index.done-8

for.index.body-2:
	%15 = load i64, i64* %2, align 8
	%16 = getelementptr inbounds {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._down, i64 0, i32 0
	%17 = load %workbench.Key_Press*, %workbench.Key_Press** %16, align 8
	%18 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %17, i64 %15
	%19 = load %workbench.Key_Press, %workbench.Key_Press* %18, align 4
	store %workbench.Key_Press %19, %workbench.Key_Press* %1
	; IfStmt
	; key_down
	; ok
	; SelectorExpr
	%20 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %1, i64 0, i32 0
	%21 = load {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %20, align 4
	; cast - union_cast
	%22 = bitcast {i32, i8}* %5 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %5
	%24 = getelementptr inbounds {[0 x <4 x i8>], [4 x i8], i8}, {[0 x <4 x i8>], [4 x i8], i8}* %20, i64 0, i32 2 ; UnionTagPtr
	%25 = load i8, i8* %24, align 1
	%26 = icmp eq i8 %25, 1
	br i1 %26, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%27 = getelementptr inbounds {i32, i8}, {i32, i8}* %5, i64 0, i32 0
	%28 = getelementptr inbounds {i32, i8}, {i32, i8}* %5, i64 0, i32 1
	%29 = bitcast {[0 x <4 x i8>], [4 x i8], i8}* %20 to i32*
	%30 = load i32, i32* %29, align 4
	store i32 %30, i32* %27
	store i8 1, i8* %28
	br label %union_cast.end-4

union_cast.end-4:
	%31 = load {i32, i8}, {i32, i8}* %5, align 4
	%32 = extractvalue {i32, i8} %31, 0
	%33 = extractvalue {i32, i8} %31, 1
	store i32 %32, i32* %3
	store i8 %33, i8* %4
	%34 = load i8, i8* %4, align 1
	%35 = trunc i8 %34 to i1
	br i1 %35, label %cmp.and-5, label %if.done-7

cmp.and-5:
	%36 = load i32, i32* %3, align 4
	%37 = load i32, i32* %0, align 4
	%38 = icmp eq i32 %36, %37
	%39 = zext i1 %38 to i8
	%40 = trunc i8 %39 to i1
	br i1 %40, label %if.then-6, label %if.done-7

if.then-6:
	; ReturnStmt
	ret i8 1

if.done-7:
	br label %for.index.loop-1

for.index.done-8:
	; ReturnStmt
	ret i8 0
}

define i8 @workbench.get_button(i32 %id, i64 %button, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i64, align 16
	%2 = alloca %workbench.Controller_State, align 16
	store i32 %id, i32* %0
	store i64 %button, i64* %1
	; controller
	; IndexExpr
	%3 = load i32, i32* %0, align 4
	%4 = sext i32 %3 to i64
	%5 = trunc i64 %4 to i32
	%6 = getelementptr inbounds [16 x %workbench.Controller_State], [16 x %workbench.Controller_State]* @workbench.controllers, i64 0, i32 %5
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$1a9, i64 0, i32 0), i64 63}, i64 293, i64 28, i64 %4, i64 16) alwaysinline
	%7 = load %workbench.Controller_State, %workbench.Controller_State* %6, align 8
	store %workbench.Controller_State %7, %workbench.Controller_State* %2
	; IfStmt
	; SelectorExpr
	%8 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %2, i64 0, i32 0
	%9 = load i8, i8* %8, align 1
	%10 = trunc i8 %9 to i1
	br i1 %10, label %if.done-2, label %if.then-1

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%11 = getelementptr inbounds %workbench.Controller_State, %workbench.Controller_State* %2, i64 0, i32 1
	%12 = load {i8*, i64}, {i8*, i64}* %11, align 8
	%13 = extractvalue {i8*, i64} %12, 0
	%14 = load i64, i64* %1, align 8
	%15 = bitcast i64 %14 to i64
	%16 = extractvalue {i8*, i64} %12, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$1aa, i64 0, i32 0), i64 63}, i64 296, i64 25, i64 %15, i64 %16) alwaysinline
	%17 = getelementptr inbounds i8, i8* %13, i64 %15
	%18 = load i8, i8* %17, align 1
	%19 = icmp eq i8 %18, 1
	%20 = zext i1 %19 to i8
	ret i8 %20
}

define void @workbench._init_random_number_generator(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	; SelectorExpr
	call void @rand.init(%rand.Rand* @workbench.rstate, i64 8675309, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define float @workbench.random_range(float %min, float %max, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca float, align 16
	%1 = alloca float, align 16
	%2 = alloca float, align 16
	store float %min, float* %0
	store float %max, float* %1
	; value
	%3 = call float @workbench.random01(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	store float %3, float* %2
	; AssignStmt
	%4 = load float, float* %0, align 4
	%5 = load float, float* %1, align 4
	%6 = load float, float* %2, align 4
	%7 = call float @math.lerp-16575(float %4, float %5, float %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	store float %7, float* %2
	; ReturnStmt
	%8 = load float, float* %2, align 4
	ret float %8
}

define float @workbench.random01(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca float, align 16
	; value
	; SelectorExpr
	%1 = call float @rand.float32(%rand.Rand* @workbench.rstate, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	store float %1, float* %0
	; ReturnStmt
	%2 = load float, float* %0, align 4
	ret float %2
}

define %..string @workbench.pretty_location(%runtime.Source_Code_Location* %location, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..any, align 16
	%2 = alloca %..any, align 16
	%3 = alloca %..any, align 16
	%4 = alloca {%..any*, i64}, align 16
	%5 = alloca [3 x %..any], align 16
	%6 = alloca {%..any*, i64}, align 16
	%7 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, align 8
	; file
	; SelectorExpr
	%8 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, i64 0, i32 0
	%9 = load %..string, %..string* %8, align 8
	%10 = call %..string @workbench.file_from_path(%..string %9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	store %..string %10, %..string* %0
	; ReturnStmt
	; SelectorExpr
	%11 = load %..string, %..string* %0, align 8
	; SelectorExpr
	%12 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, i64 0, i32 3
	%13 = load %..string, %..string* %12, align 8
	; SelectorExpr
	%14 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, i64 0, i32 1
	%15 = load i64, i64* %14, align 8
	%16 = bitcast %..any* %1 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 16) noinline
	store %..any zeroinitializer, %..any* %1
	%18 = bitcast %..string* %0 to %..rawptr
	%19 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	store %..rawptr %18, %..rawptr* %19
	%20 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %20
	%21 = load %..any, %..any* %1, align 8
	%22 = bitcast %..any* %2 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 16) noinline
	store %..any zeroinitializer, %..any* %2
	%24 = bitcast %..string* %12 to %..rawptr
	%25 = getelementptr inbounds %..any, %..any* %2, i64 0, i32 0
	store %..rawptr %24, %..rawptr* %25
	%26 = getelementptr inbounds %..any, %..any* %2, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %26
	%27 = load %..any, %..any* %2, align 8
	%28 = bitcast %..any* %3 to %..rawptr
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 16) noinline
	store %..any zeroinitializer, %..any* %3
	%30 = bitcast i64* %14 to %..rawptr
	%31 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	store %..rawptr %30, %..rawptr* %31
	%32 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %32
	%33 = load %..any, %..any* %3, align 8
	; variadic call argument generation
	%34 = bitcast {%..any*, i64}* %4 to %..rawptr
	%35 = call %..rawptr @mem.zero(%..rawptr %34, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %4
	%36 = bitcast [3 x %..any]* %5 to %..rawptr
	%37 = call %..rawptr @mem.zero(%..rawptr %36, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %5
	%38 = getelementptr inbounds [3 x %..any], [3 x %..any]* %5, i64 0, i32 0
	store %..any %21, %..any* %38
	%39 = getelementptr inbounds [3 x %..any], [3 x %..any]* %5, i64 0, i32 1
	store %..any %27, %..any* %39
	%40 = getelementptr inbounds [3 x %..any], [3 x %..any]* %5, i64 0, i32 2
	store %..any %33, %..any* %40
	%41 = getelementptr inbounds [3 x %..any], [3 x %..any]* %5, i64 0, i32 0
	%42 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %4, i64 0, i32 0
	store %..any* %41, %..any** %42
	%43 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %4, i64 0, i32 1
	store i64 3, i64* %43
	%44 = load {%..any*, i64}, {%..any*, i64}* %4, align 8
	%45 = bitcast {%..any*, i64}* %6 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %6
	store {%..any*, i64} %44, {%..any*, i64}* %6
	%47 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$1ab, i64 0, i32 0), i64 10}, {%..any*, i64}* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret %..string %47
}

define void @workbench.logln({%..any*, i64}* %args, %runtime.Source_Code_Location* %location, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca {%..any*, i64}, align 16
	%2 = alloca {%..any*, i64}, align 16
	%3 = alloca %..any, align 16
	%4 = alloca %..any, align 16
	%5 = alloca %..any, align 16
	%6 = alloca {%..any*, i64}, align 16
	%7 = alloca [3 x %..any], align 16
	%8 = alloca {%..any*, i64}, align 16
	%9 = alloca {%..any*, i64}, align 16
	%10 = alloca {%..any*, i64}, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%13 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, align 8
	; file
	; SelectorExpr
	%14 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, i64 0, i32 0
	%15 = load %..string, %..string* %14, align 8
	%16 = call %..string @workbench.file_from_path(%..string %15, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %16, %..string* %0
	; SelectorExpr
	; variadic call argument generation
	%17 = bitcast {%..any*, i64}* %1 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %1
	%19 = load {%..any*, i64}, {%..any*, i64}* %1, align 8
	%20 = bitcast {%..any*, i64}* %2 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %2
	store {%..any*, i64} %19, {%..any*, i64}* %2
	%22 = call i64 @fmt.printf(%..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$1ac, i64 0, i32 0), i64 1}, {%..any*, i64}* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%23 = load %..string, %..string* %0, align 8
	; SelectorExpr
	%24 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, i64 0, i32 3
	%25 = load %..string, %..string* %24, align 8
	; SelectorExpr
	%26 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, i64 0, i32 1
	%27 = load i64, i64* %26, align 8
	%28 = bitcast %..any* %3 to %..rawptr
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 16) noinline
	store %..any zeroinitializer, %..any* %3
	%30 = bitcast %..string* %0 to %..rawptr
	%31 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	store %..rawptr %30, %..rawptr* %31
	%32 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %32
	%33 = load %..any, %..any* %3, align 8
	%34 = bitcast %..any* %4 to %..rawptr
	%35 = call %..rawptr @mem.zero(%..rawptr %34, i64 16) noinline
	store %..any zeroinitializer, %..any* %4
	%36 = bitcast %..string* %24 to %..rawptr
	%37 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	store %..rawptr %36, %..rawptr* %37
	%38 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %38
	%39 = load %..any, %..any* %4, align 8
	%40 = bitcast %..any* %5 to %..rawptr
	%41 = call %..rawptr @mem.zero(%..rawptr %40, i64 16) noinline
	store %..any zeroinitializer, %..any* %5
	%42 = bitcast i64* %26 to %..rawptr
	%43 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	store %..rawptr %42, %..rawptr* %43
	%44 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %44
	%45 = load %..any, %..any* %5, align 8
	; variadic call argument generation
	%46 = bitcast {%..any*, i64}* %6 to %..rawptr
	%47 = call %..rawptr @mem.zero(%..rawptr %46, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %6
	%48 = bitcast [3 x %..any]* %7 to %..rawptr
	%49 = call %..rawptr @mem.zero(%..rawptr %48, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %7
	%50 = getelementptr inbounds [3 x %..any], [3 x %..any]* %7, i64 0, i32 0
	store %..any %33, %..any* %50
	%51 = getelementptr inbounds [3 x %..any], [3 x %..any]* %7, i64 0, i32 1
	store %..any %39, %..any* %51
	%52 = getelementptr inbounds [3 x %..any], [3 x %..any]* %7, i64 0, i32 2
	store %..any %45, %..any* %52
	%53 = getelementptr inbounds [3 x %..any], [3 x %..any]* %7, i64 0, i32 0
	%54 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %6, i64 0, i32 0
	store %..any* %53, %..any** %54
	%55 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %6, i64 0, i32 1
	store i64 3, i64* %55
	%56 = load {%..any*, i64}, {%..any*, i64}* %6, align 8
	%57 = bitcast {%..any*, i64}* %8 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %8
	store {%..any*, i64} %56, {%..any*, i64}* %8
	%59 = call i64 @fmt.printf(%..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$1ad, i64 0, i32 0), i64 13}, {%..any*, i64}* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%60 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%61 = bitcast {%..any*, i64}* %9 to %..rawptr
	%62 = call %..rawptr @mem.zero(%..rawptr %61, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %9
	store {%..any*, i64} %60, {%..any*, i64}* %9
	%63 = call i64 @fmt.print({%..any*, i64}* %9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	; variadic call argument generation
	%64 = bitcast {%..any*, i64}* %10 to %..rawptr
	%65 = call %..rawptr @mem.zero(%..rawptr %64, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %10
	%66 = load {%..any*, i64}, {%..any*, i64}* %10, align 8
	%67 = bitcast {%..any*, i64}* %11 to %..rawptr
	%68 = call %..rawptr @mem.zero(%..rawptr %67, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	store {%..any*, i64} %66, {%..any*, i64}* %11
	%69 = call i64 @fmt.printf(%..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$1ae, i64 0, i32 0), i64 1}, {%..any*, i64}* %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define [4 x [4 x float]] @workbench.translate([4 x [4 x float]]* %m, [3 x float]* %v, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = load [4 x [4 x float]], [4 x [4 x float]]* %m, align 4
	%1 = load [3 x float], [3 x float]* %v, align 4
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%2 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %m, i64 0, i32 3
	%3 = getelementptr inbounds [4 x float], [4 x float]* %2, i64 0, i32 0
	; IndexExpr
	%4 = getelementptr inbounds [3 x float], [3 x float]* %v, i64 0, i32 0
	%5 = load float, float* %4, align 4
	%6 = load float, float* %3, align 4
	%7 = fadd float %6, %5
	store float %7, float* %3
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%8 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %m, i64 0, i32 3
	%9 = getelementptr inbounds [4 x float], [4 x float]* %8, i64 0, i32 1
	; IndexExpr
	%10 = getelementptr inbounds [3 x float], [3 x float]* %v, i64 0, i32 1
	%11 = load float, float* %10, align 4
	%12 = load float, float* %9, align 4
	%13 = fadd float %12, %11
	store float %13, float* %9
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%14 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %m, i64 0, i32 3
	%15 = getelementptr inbounds [4 x float], [4 x float]* %14, i64 0, i32 2
	; IndexExpr
	%16 = getelementptr inbounds [3 x float], [3 x float]* %v, i64 0, i32 2
	%17 = load float, float* %16, align 4
	%18 = load float, float* %15, align 4
	%19 = fadd float %18, %17
	store float %19, float* %15
	; ReturnStmt
	%20 = load [4 x [4 x float]], [4 x [4 x float]]* %m, align 4
	ret [4 x [4 x float]] %20
}

define void @workbench._init_glfw(%..string %window_name, i64 %_window_width, i64 %_window_height, i64 %_opengl_version_major, i64 %_opengl_version_minor, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i32, align 16
	%6 = alloca i32, align 16
	%7 = alloca i32, align 16
	%8 = alloca i32, align 16
	%9 = alloca %glfw.Vid_Mode*, align 16
	store %..string %window_name, %..string* %0
	store i64 %_window_width, i64* %1
	store i64 %_window_height, i64* %2
	store i64 %_opengl_version_major, i64* %3
	store i64 %_opengl_version_minor, i64* %4
	; window_width
	%10 = load i64, i64* %1, align 8
	%11 = trunc i64 %10 to i32
	store i32 %11, i32* %5
	; window_height
	%12 = load i64, i64* %2, align 8
	%13 = trunc i64 %12 to i32
	store i32 %13, i32* %6
	; opengl_version_major
	%14 = load i64, i64* %3, align 8
	%15 = trunc i64 %14 to i32
	store i32 %15, i32* %7
	; opengl_version_minor
	%16 = load i64, i64* %4, align 8
	%17 = trunc i64 %16 to i32
	store i32 %17, i32* %8
	; SelectorExpr
	%18 = bitcast void (i32, i8*)* @workbench._init_glfw.glfw_error_callback-4 to void (i32, i8*)*
	%19 = call ccc void (i32, i8*)* @glfwSetErrorCallback(void (i32, i8*)* %18)
	; IfStmt
	; SelectorExpr
	%20 = call ccc i32 @glfwInit()
	%21 = icmp eq i32 %20, 0
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; SelectorExpr
	%24 = load i32, i32* %7, align 4
	call ccc void @glfwWindowHint(i32 139266, i32 %24)
	; SelectorExpr
	%25 = load i32, i32* %8, align 4
	call ccc void @glfwWindowHint(i32 139267, i32 %25)
	; SelectorExpr
	call ccc void @glfwWindowHint(i32 139272, i32 204801)
	; AssignStmt
	; SelectorExpr
	%26 = load i32, i32* %5, align 4
	%27 = load i32, i32* %6, align 4
	%28 = load %..string, %..string* %0, align 8
	%29 = call %..rawptr @glfw.CreateWindow(i32 %26, i32 %27, %..string %28, %..rawptr zeroinitializer, %..rawptr zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %29, %..rawptr* @workbench.main_window
	; IfStmt
	%30 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	%31 = icmp eq %..rawptr %30, zeroinitializer
	%32 = zext i1 %31 to i8
	%33 = trunc i8 %32 to i1
	br i1 %33, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret void

if.done-4:
	; video_mode
	; SelectorExpr
	; SelectorExpr
	%34 = call ccc %..rawptr @glfwGetPrimaryMonitor()
	%35 = call ccc %glfw.Vid_Mode* @glfwGetVideoMode(%..rawptr %34)
	store %glfw.Vid_Mode* %35, %glfw.Vid_Mode** %9
	; SelectorExpr
	%36 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	; SelectorExpr
	%37 = load %glfw.Vid_Mode*, %glfw.Vid_Mode** %9, align 8
	%38 = getelementptr inbounds %glfw.Vid_Mode, %glfw.Vid_Mode* %37, i64 0
	%39 = getelementptr inbounds %glfw.Vid_Mode, %glfw.Vid_Mode* %38, i64 0, i32 0
	%40 = load i32, i32* %39, align 4
	%41 = sdiv i32 %40, 2
	%42 = load i32, i32* %5, align 4
	%43 = sdiv i32 %42, 2
	%44 = sub i32 %41, %43
	; SelectorExpr
	%45 = load %glfw.Vid_Mode*, %glfw.Vid_Mode** %9, align 8
	%46 = getelementptr inbounds %glfw.Vid_Mode, %glfw.Vid_Mode* %45, i64 0
	%47 = getelementptr inbounds %glfw.Vid_Mode, %glfw.Vid_Mode* %46, i64 0, i32 1
	%48 = load i32, i32* %47, align 4
	%49 = sdiv i32 %48, 2
	%50 = load i32, i32* %6, align 4
	%51 = sdiv i32 %50, 2
	%52 = sub i32 %49, %51
	call ccc void @glfwSetWindowPos(%..rawptr %36, i32 %44, i32 %52)
	; SelectorExpr
	%53 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	call ccc void @glfwMakeContextCurrent(%..rawptr %53)
	; SelectorExpr
	call ccc void @glfwSwapInterval(i32 1)
	; SelectorExpr
	%54 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	%55 = bitcast void (%..rawptr, double, double)* @workbench._init_glfw.glfw_cursor_callback-1 to void (%..rawptr, double, double)*
	%56 = call ccc void (%..rawptr, double, double)* @glfwSetCursorPosCallback(%..rawptr %54, void (%..rawptr, double, double)* %55)
	; SelectorExpr
	%57 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	%58 = bitcast void (%..rawptr, i32, i32)* @workbench._init_glfw.glfw_size_callback-0 to void (%..rawptr, i32, i32)*
	%59 = call ccc void (%..rawptr, i32, i32)* @glfwSetWindowSizeCallback(%..rawptr %57, void (%..rawptr, i32, i32)* %58)
	; SelectorExpr
	%60 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	%61 = bitcast void (%..rawptr, i32, i32, i32, i32)* @workbench._glfw_key_callback to void (%..rawptr, i32, i32, i32, i32)*
	%62 = call ccc void (%..rawptr, i32, i32, i32, i32)* @glfwSetKeyCallback(%..rawptr %60, void (%..rawptr, i32, i32, i32, i32)* %61)
	; SelectorExpr
	%63 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	%64 = bitcast void (%..rawptr, i32, i32, i32)* @workbench._glfw_mouse_button_callback to void (%..rawptr, i32, i32, i32)*
	%65 = call ccc void (%..rawptr, i32, i32, i32)* @glfwSetMouseButtonCallback(%..rawptr %63, void (%..rawptr, i32, i32, i32)* %64)
	; SelectorExpr
	%66 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	%67 = bitcast void (%..rawptr, i32)* @workbench._init_glfw.glfw_character_callback-3 to void (%..rawptr, i32)*
	%68 = call ccc void (%..rawptr, i32)* @glfwSetCharCallback(%..rawptr %66, void (%..rawptr, i32)* %67)
	%69 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	%70 = load i32, i32* %5, align 4
	%71 = load i32, i32* %6, align 4
	call ccc void @workbench._init_glfw.glfw_size_callback-0(%..rawptr %69, i32 %70, i32 %71)
	; SelectorExpr
	%72 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	%73 = bitcast void (%..rawptr, double, double)* @workbench._init_glfw.glfw_scroll_callback-2 to void (%..rawptr, double, double)*
	%74 = call ccc void (%..rawptr, double, double)* @glfwSetScrollCallback(%..rawptr %72, void (%..rawptr, double, double)* %73)
	ret void
}

define ccc void @workbench._init_glfw.glfw_size_callback-0(%..rawptr %window, i32 %w, i32 %h) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i32, align 16
	%2 = alloca i32, align 16
	store %..rawptr %window, %..rawptr* %0
	store i32 %w, i32* %1
	store i32 %h, i32* %2
	; AssignStmt
	%3 = load i32, i32* %1, align 4
	%4 = sitofp i32 %3 to float
	store float %4, float* @workbench._new_window_width
	; AssignStmt
	%5 = load i32, i32* %2, align 4
	%6 = sitofp i32 %5 to float
	store float %6, float* @workbench._new_window_height
	; AssignStmt
	%7 = load i32, i32* %1, align 4
	%8 = sitofp i32 %7 to float
	%9 = load i32, i32* %2, align 4
	%10 = sitofp i32 %9 to float
	%11 = fdiv float %8, %10
	store float %11, float* @workbench._new_aspect_ratio
	ret void
}

define ccc void @workbench._init_glfw.glfw_cursor_callback-1(%..rawptr %window, double %x, double %y) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca double, align 16
	%2 = alloca double, align 16
	%3 = alloca [2 x float], align 16
	store %..rawptr %window, %..rawptr* %0
	store double %x, double* %1
	store double %y, double* %2
	; AssignStmt
	; CompoundLit
	%4 = bitcast [2 x float]* %3 to %..rawptr
	%5 = call %..rawptr @mem.zero(%..rawptr %4, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %3
	store [2 x float] [float zeroinitializer, float zeroinitializer], [2 x float]* %3
	%6 = load double, double* %1, align 8
	%7 = fptrunc double %6 to float
	%8 = getelementptr inbounds [2 x float], [2 x float]* %3, i64 0, i32 0
	store float %7, float* %8
	%9 = load float, float* @workbench.current_window_height, align 4
	%10 = load double, double* %2, align 8
	%11 = fptrunc double %10 to float
	%12 = fsub float %9, %11
	%13 = getelementptr inbounds [2 x float], [2 x float]* %3, i64 0, i32 1
	store float %12, float* %13
	%14 = load [2 x float], [2 x float]* %3, align 4
	store [2 x float] %14, [2 x float]* @workbench._new_cursor_screen_position
	ret void
}

define ccc void @workbench._init_glfw.glfw_scroll_callback-2(%..rawptr %window, double %x, double %y) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca double, align 16
	%2 = alloca double, align 16
	store %..rawptr %window, %..rawptr* %0
	store double %x, double* %1
	store double %y, double* %2
	; AssignStmt
	%3 = load double, double* %2, align 8
	%4 = fptrunc double %3 to float
	store float %4, float* @workbench._new_cursor_scroll
	ret void
}

define ccc void @workbench._init_glfw.glfw_character_callback-3(%..rawptr %window, i32 %codepoint) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i32, align 16
	store %..rawptr %window, %..rawptr* %0
	store i32 %codepoint, i32* %1
	; SelectorExpr
	%2 = load i32, i32* %1, align 4
	%3 = trunc i32 %2 to i16
	call ccc void @ImGuiIO_AddInputCharacter(i16 %3)
	ret void
}

define ccc void @workbench._init_glfw.glfw_error_callback-4(i32 %error, i8* %desc) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i8*, align 16
	%2 = alloca %..any, align 16
	%3 = alloca %..any, align 16
	%4 = alloca %..string, align 16
	%5 = alloca {%..any*, i64}, align 16
	%6 = alloca [2 x %..any], align 16
	%7 = alloca %runtime.Context, align 16
	%8 = bitcast %runtime.Context* %7 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %7
	%10 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %10, %runtime.Context* %7
	call void @runtime.__init_context(%runtime.Context* %7)
	%11 = alloca {%..any*, i64}, align 16
	store i32 %error, i32* %0
	store i8* %desc, i8** %1
	; SelectorExpr
	%12 = load i32, i32* %0, align 4
	%13 = load i8*, i8** %1, align 8
	%14 = call %..string @runtime.cstring_to_string(i8* %13)
	%15 = bitcast %..any* %2 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 16) noinline
	store %..any zeroinitializer, %..any* %2
	%17 = bitcast i32* %0 to %..rawptr
	%18 = getelementptr inbounds %..any, %..any* %2, i64 0, i32 0
	store %..rawptr %17, %..rawptr* %18
	%19 = getelementptr inbounds %..any, %..any* %2, i64 0, i32 1
	store %..typeid 4683743612465315848, %..typeid* %19
	%20 = load %..any, %..any* %2, align 8
	%21 = bitcast %..any* %3 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 16) noinline
	store %..any zeroinitializer, %..any* %3
	%23 = bitcast %..string* %4 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 16) noinline
	store %..string zeroinitializer, %..string* %4
	store %..string %14, %..string* %4
	%25 = bitcast %..string* %4 to %..rawptr
	%26 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	store %..rawptr %25, %..rawptr* %26
	%27 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %27
	%28 = load %..any, %..any* %3, align 8
	; variadic call argument generation
	%29 = bitcast {%..any*, i64}* %5 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %5
	%31 = bitcast [2 x %..any]* %6 to %..rawptr
	%32 = call %..rawptr @mem.zero(%..rawptr %31, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %6
	%33 = getelementptr inbounds [2 x %..any], [2 x %..any]* %6, i64 0, i32 0
	store %..any %20, %..any* %33
	%34 = getelementptr inbounds [2 x %..any], [2 x %..any]* %6, i64 0, i32 1
	store %..any %28, %..any* %34
	%35 = getelementptr inbounds [2 x %..any], [2 x %..any]* %6, i64 0, i32 0
	%36 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %5, i64 0, i32 0
	store %..any* %35, %..any** %36
	%37 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %5, i64 0, i32 1
	store i64 2, i64* %37
	%38 = load {%..any*, i64}, {%..any*, i64}* %5, align 8
	%39 = bitcast {%..any*, i64}* %11 to %..rawptr
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	store {%..any*, i64} %38, {%..any*, i64}* %11
	%41 = call i64 @fmt.printf(%..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$1af, i64 0, i32 0), i64 23}, {%..any*, i64}* %11, %runtime.Context* noalias nonnull nocapture inreg %7)
	ret void
}

define void @workbench._update_glfw(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca [2 x float], align 16
	%1 = alloca [2 x float], align 16
	%2 = alloca float, align 16
	%3 = alloca float, align 16
	%4 = alloca float, align 16
	%5 = alloca float, align 16
	%6 = alloca [3 x float], align 16
	%7 = alloca [4 x [4 x float]], align 16
	%8 = alloca [3 x float], align 16
	%9 = alloca [4 x [4 x float]], align 16
	%10 = alloca [3 x float], align 16
	%11 = alloca [4 x [4 x float]], align 16
	%12 = alloca [3 x float], align 16
	%13 = alloca [4 x [4 x float]], align 16
	%14 = alloca [3 x float], align 16
	%15 = alloca [3 x float], align 16
	%16 = alloca [4 x [4 x float]], align 16
	%17 = alloca [3 x float], align 16
	%18 = alloca [4 x [4 x float]], align 16
	%19 = alloca [3 x float], align 16
	%20 = alloca [4 x [4 x float]], align 16
	%21 = alloca [4 x [4 x float]], align 16
	%22 = alloca [3 x float], align 16
	%23 = alloca [3 x float], align 16
	%24 = alloca [4 x [4 x float]], align 16
	%25 = alloca [3 x float], align 16
	%26 = alloca [4 x [4 x float]], align 16
	%27 = alloca [3 x float], align 16
	%28 = alloca [4 x [4 x float]], align 16
	; AssignStmt
	%29 = load float, float* @workbench._new_window_width, align 4
	store float %29, float* @workbench.current_window_width
	; AssignStmt
	%30 = load float, float* @workbench._new_window_height, align 4
	store float %30, float* @workbench.current_window_height
	; AssignStmt
	%31 = load float, float* @workbench._new_aspect_ratio, align 4
	store float %31, float* @workbench.current_aspect_ratio
	; AssignStmt
	%32 = load float, float* @workbench._new_cursor_scroll, align 4
	store float %32, float* @workbench.cursor_scroll
	; AssignStmt
	store float 0x0000000000000000, float* @workbench._new_cursor_scroll
	; AssignStmt
	%33 = load [2 x float], [2 x float]* @workbench._new_cursor_screen_position, align 4
	store [2 x float] %33, [2 x float]* @workbench.cursor_screen_position
	; AssignStmt
	%34 = load [2 x float], [2 x float]* @workbench.cursor_screen_position, align 4
	; CompoundLit
	%35 = bitcast [2 x float]* %0 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %0
	store [2 x float] [float zeroinitializer, float zeroinitializer], [2 x float]* %0
	%37 = load float, float* @workbench.current_window_width, align 4
	%38 = getelementptr inbounds [2 x float], [2 x float]* %0, i64 0, i32 0
	store float %37, float* %38
	%39 = load float, float* @workbench.current_window_height, align 4
	%40 = getelementptr inbounds [2 x float], [2 x float]* %0, i64 0, i32 1
	store float %39, float* %40
	%41 = load [2 x float], [2 x float]* %0, align 4
	; array.arith.begin
	%42 = bitcast [2 x float]* %1 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %1
	%44 = getelementptr inbounds [2 x float], [2 x float]* @workbench.cursor_screen_position, i64 0, i32 0
	%45 = load float, float* %44, align 4
	%46 = getelementptr inbounds [2 x float], [2 x float]* %0, i64 0, i32 0
	%47 = load float, float* %46, align 4
	%48 = fdiv float %45, %47
	%49 = getelementptr inbounds [2 x float], [2 x float]* %1, i64 0, i32 0
	store float %48, float* %49
	%50 = getelementptr inbounds [2 x float], [2 x float]* @workbench.cursor_screen_position, i64 0, i32 1
	%51 = load float, float* %50, align 4
	%52 = getelementptr inbounds [2 x float], [2 x float]* %0, i64 0, i32 1
	%53 = load float, float* %52, align 4
	%54 = fdiv float %51, %53
	%55 = getelementptr inbounds [2 x float], [2 x float]* %1, i64 0, i32 1
	store float %54, float* %55
	; array.arith.end
	%56 = load [2 x float], [2 x float]* %1, align 4
	store [2 x float] %56, [2 x float]* @workbench.cursor_unit_position
	; AssignStmt
	%57 = load i8, i8* @workbench._new_window_is_focused, align 1
	store i8 %57, i8* @workbench.window_is_focused
	; top
	%58 = load float, float* @workbench.camera_size, align 4
	%59 = fmul float 0x3ff0000000000000, %58
	; SelectorExpr
	%60 = getelementptr inbounds [3 x float], [3 x float]* @workbench.camera_position, i64 0, i32 1
	%61 = load float, float* %60, align 4
	%62 = fadd float %59, %61
	store float %62, float* %2
	; bottom
	%63 = load float, float* @workbench.camera_size, align 4
	%64 = fmul float 0xbff0000000000000, %63
	; SelectorExpr
	%65 = getelementptr inbounds [3 x float], [3 x float]* @workbench.camera_position, i64 0, i32 1
	%66 = load float, float* %65, align 4
	%67 = fadd float %64, %66
	store float %67, float* %3
	; left
	%68 = load float, float* @workbench.current_aspect_ratio, align 4
	%69 = fmul float 0xbff0000000000000, %68
	%70 = load float, float* @workbench.camera_size, align 4
	%71 = fmul float %69, %70
	; SelectorExpr
	%72 = getelementptr inbounds [3 x float], [3 x float]* @workbench.camera_position, i64 0, i32 0
	%73 = load float, float* %72, align 4
	%74 = fadd float %71, %73
	store float %74, float* %4
	; right
	%75 = load float, float* @workbench.current_aspect_ratio, align 4
	%76 = fmul float 0x3ff0000000000000, %75
	%77 = load float, float* @workbench.camera_size, align 4
	%78 = fmul float %76, %77
	; SelectorExpr
	%79 = getelementptr inbounds [3 x float], [3 x float]* @workbench.camera_position, i64 0, i32 0
	%80 = load float, float* %79, align 4
	%81 = fadd float %78, %80
	store float %81, float* %5
	; AssignStmt
	%82 = load float, float* %4, align 4
	%83 = load float, float* %5, align 4
	%84 = load float, float* %3, align 4
	%85 = load float, float* %2, align 4
	%86 = call [4 x [4 x float]] @math.ortho3d(float %82, float %83, float %84, float %85, float 0xbff0000000000000, float 0x3ff0000000000000, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %86, [4 x [4 x float]]* @workbench.orthographic_projection_matrix
	; AssignStmt
	%87 = load float, float* @workbench.camera_size, align 4
	%88 = call float @math.to_radians(float %87, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%89 = load float, float* @workbench.current_aspect_ratio, align 4
	%90 = call [4 x [4 x float]] @math.perspective(float %88, float %89, float 0x3f50624dc0000000, float 0x408f400000000000, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %90, [4 x [4 x float]]* @workbench.perspective_projection_matrix
	; AssignStmt
	%91 = call [4 x [4 x float]] @math.identity-15829(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; CompoundLit
	%92 = bitcast [3 x float]* %6 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %6
	store [3 x float] [float zeroinitializer, float zeroinitializer, float zeroinitializer], [3 x float]* %6
	; SelectorExpr
	%94 = getelementptr inbounds [3 x float], [3 x float]* @workbench.camera_position, i64 0, i32 0
	%95 = load float, float* %94, align 4
	%96 = getelementptr inbounds [3 x float], [3 x float]* %6, i64 0, i32 0
	store float %95, float* %96
	; SelectorExpr
	%97 = getelementptr inbounds [3 x float], [3 x float]* @workbench.camera_position, i64 0, i32 1
	%98 = load float, float* %97, align 4
	%99 = fsub float 0x0000000000000000, %98
	%100 = getelementptr inbounds [3 x float], [3 x float]* %6, i64 0, i32 1
	store float %99, float* %100
	; SelectorExpr
	%101 = getelementptr inbounds [3 x float], [3 x float]* @workbench.camera_position, i64 0, i32 2
	%102 = load float, float* %101, align 4
	%103 = getelementptr inbounds [3 x float], [3 x float]* %6, i64 0, i32 2
	store float %102, float* %103
	%104 = load [3 x float], [3 x float]* %6, align 4
	%105 = bitcast [4 x [4 x float]]* %7 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %7
	store [4 x [4 x float]] %91, [4 x [4 x float]]* %7
	%107 = bitcast [3 x float]* %8 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %8
	store [3 x float] %104, [3 x float]* %8
	%109 = call [4 x [4 x float]] @workbench.translate([4 x [4 x float]]* %7, [3 x float]* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %109, [4 x [4 x float]]* @workbench.view_matrix
	; AssignStmt
	%110 = call [4 x [4 x float]] @math.identity-15829(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %110, [4 x [4 x float]]* @workbench.model_matrix
	; AssignStmt
	%111 = call [4 x [4 x float]] @math.identity-15829(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%112 = bitcast [4 x [4 x float]]* %9 to %..rawptr
	%113 = call %..rawptr @mem.zero(%..rawptr %112, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %9
	store [4 x [4 x float]] %111, [4 x [4 x float]]* %9
	%114 = bitcast [3 x float]* %10 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %10
	store [3 x float] [float 0xbff0000000000000, float 0xbff0000000000000, float 0x0000000000000000], [3 x float]* %10
	%116 = call [4 x [4 x float]] @workbench.translate([4 x [4 x float]]* %9, [3 x float]* %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %116, [4 x [4 x float]]* @workbench.unit_to_viewport_matrix
	; AssignStmt
	%117 = load [4 x [4 x float]], [4 x [4 x float]]* @workbench.unit_to_viewport_matrix, align 4
	%118 = bitcast [4 x [4 x float]]* %11 to %..rawptr
	%119 = call %..rawptr @mem.zero(%..rawptr %118, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %11
	store [4 x [4 x float]] %117, [4 x [4 x float]]* %11
	%120 = call [4 x [4 x float]] @math.scale_f32([4 x [4 x float]]* %11, float 0x4000000000000000, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %120, [4 x [4 x float]]* @workbench.unit_to_viewport_matrix
	; AssignStmt
	%121 = call [4 x [4 x float]] @math.identity-15829(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; CompoundLit
	%122 = bitcast [3 x float]* %12 to %..rawptr
	%123 = call %..rawptr @mem.zero(%..rawptr %122, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %12
	store [3 x float] [float zeroinitializer, float zeroinitializer, float 0x0000000000000000], [3 x float]* %12
	%124 = load float, float* @workbench.current_window_width, align 4
	%125 = getelementptr inbounds [3 x float], [3 x float]* %12, i64 0, i32 0
	store float %124, float* %125
	%126 = load float, float* @workbench.current_window_height, align 4
	%127 = getelementptr inbounds [3 x float], [3 x float]* %12, i64 0, i32 1
	store float %126, float* %127
	%128 = load [3 x float], [3 x float]* %12, align 4
	%129 = bitcast [4 x [4 x float]]* %13 to %..rawptr
	%130 = call %..rawptr @mem.zero(%..rawptr %129, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %13
	store [4 x [4 x float]] %121, [4 x [4 x float]]* %13
	%131 = bitcast [3 x float]* %14 to %..rawptr
	%132 = call %..rawptr @mem.zero(%..rawptr %131, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %14
	store [3 x float] %128, [3 x float]* %14
	%133 = call [4 x [4 x float]] @math.scale_vec3([4 x [4 x float]]* %13, [3 x float]* %14, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %133, [4 x [4 x float]]* @workbench.unit_to_pixel_matrix
	; AssignStmt
	%134 = call [4 x [4 x float]] @math.identity-15829(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; CompoundLit
	%135 = bitcast [3 x float]* %15 to %..rawptr
	%136 = call %..rawptr @mem.zero(%..rawptr %135, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %15
	store [3 x float] [float zeroinitializer, float zeroinitializer, float 0x0000000000000000], [3 x float]* %15
	%137 = load float, float* @workbench.current_window_width, align 4
	%138 = fdiv float 0x3ff0000000000000, %137
	%139 = getelementptr inbounds [3 x float], [3 x float]* %15, i64 0, i32 0
	store float %138, float* %139
	%140 = load float, float* @workbench.current_window_height, align 4
	%141 = fdiv float 0x3ff0000000000000, %140
	%142 = getelementptr inbounds [3 x float], [3 x float]* %15, i64 0, i32 1
	store float %141, float* %142
	%143 = load [3 x float], [3 x float]* %15, align 4
	%144 = bitcast [4 x [4 x float]]* %16 to %..rawptr
	%145 = call %..rawptr @mem.zero(%..rawptr %144, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %16
	store [4 x [4 x float]] %134, [4 x [4 x float]]* %16
	%146 = bitcast [3 x float]* %17 to %..rawptr
	%147 = call %..rawptr @mem.zero(%..rawptr %146, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %17
	store [3 x float] %143, [3 x float]* %17
	%148 = call [4 x [4 x float]] @math.scale_vec3([4 x [4 x float]]* %16, [3 x float]* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %148, [4 x [4 x float]]* @workbench.pixel_to_viewport_matrix
	; AssignStmt
	%149 = load [4 x [4 x float]], [4 x [4 x float]]* @workbench.pixel_to_viewport_matrix, align 4
	%150 = bitcast [4 x [4 x float]]* %18 to %..rawptr
	%151 = call %..rawptr @mem.zero(%..rawptr %150, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %18
	store [4 x [4 x float]] %149, [4 x [4 x float]]* %18
	%152 = bitcast [3 x float]* %19 to %..rawptr
	%153 = call %..rawptr @mem.zero(%..rawptr %152, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %19
	store [3 x float] [float 0xbff0000000000000, float 0xbff0000000000000, float 0x0000000000000000], [3 x float]* %19
	%154 = call [4 x [4 x float]] @workbench.translate([4 x [4 x float]]* %18, [3 x float]* %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %154, [4 x [4 x float]]* @workbench.pixel_to_viewport_matrix
	; AssignStmt
	%155 = load [4 x [4 x float]], [4 x [4 x float]]* @workbench.pixel_to_viewport_matrix, align 4
	%156 = bitcast [4 x [4 x float]]* %20 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %20
	store [4 x [4 x float]] %155, [4 x [4 x float]]* %20
	%158 = call [4 x [4 x float]] @math.scale_f32([4 x [4 x float]]* %20, float 0x4000000000000000, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %158, [4 x [4 x float]]* @workbench.pixel_to_viewport_matrix
	; AssignStmt
	%159 = call [4 x [4 x float]] @math.identity-15829(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %159, [4 x [4 x float]]* @workbench.viewport_to_pixel_matrix
	; AssignStmt
	%160 = load [4 x [4 x float]], [4 x [4 x float]]* @workbench.viewport_to_pixel_matrix, align 4
	%161 = bitcast [4 x [4 x float]]* %21 to %..rawptr
	%162 = call %..rawptr @mem.zero(%..rawptr %161, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %21
	store [4 x [4 x float]] %160, [4 x [4 x float]]* %21
	%163 = bitcast [3 x float]* %22 to %..rawptr
	%164 = call %..rawptr @mem.zero(%..rawptr %163, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %22
	store [3 x float] [float 0x3ff0000000000000, float 0x3ff0000000000000, float 0x0000000000000000], [3 x float]* %22
	%165 = call [4 x [4 x float]] @workbench.translate([4 x [4 x float]]* %21, [3 x float]* %22, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %165, [4 x [4 x float]]* @workbench.viewport_to_pixel_matrix
	; AssignStmt
	%166 = load [4 x [4 x float]], [4 x [4 x float]]* @workbench.viewport_to_pixel_matrix, align 4
	; CompoundLit
	%167 = bitcast [3 x float]* %23 to %..rawptr
	%168 = call %..rawptr @mem.zero(%..rawptr %167, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %23
	store [3 x float] [float zeroinitializer, float zeroinitializer, float 0x0000000000000000], [3 x float]* %23
	%169 = load float, float* @workbench.current_window_width, align 4
	%170 = fdiv float %169, 0x4000000000000000
	%171 = getelementptr inbounds [3 x float], [3 x float]* %23, i64 0, i32 0
	store float %170, float* %171
	%172 = load float, float* @workbench.current_window_height, align 4
	%173 = fdiv float %172, 0x4000000000000000
	%174 = getelementptr inbounds [3 x float], [3 x float]* %23, i64 0, i32 1
	store float %173, float* %174
	%175 = load [3 x float], [3 x float]* %23, align 4
	%176 = bitcast [4 x [4 x float]]* %24 to %..rawptr
	%177 = call %..rawptr @mem.zero(%..rawptr %176, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %24
	store [4 x [4 x float]] %166, [4 x [4 x float]]* %24
	%178 = bitcast [3 x float]* %25 to %..rawptr
	%179 = call %..rawptr @mem.zero(%..rawptr %178, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %25
	store [3 x float] %175, [3 x float]* %25
	%180 = call [4 x [4 x float]] @math.scale_vec3([4 x [4 x float]]* %24, [3 x float]* %25, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %180, [4 x [4 x float]]* @workbench.viewport_to_pixel_matrix
	; AssignStmt
	%181 = call [4 x [4 x float]] @math.identity-15829(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %181, [4 x [4 x float]]* @workbench.viewport_to_unit_matrix
	; AssignStmt
	%182 = load [4 x [4 x float]], [4 x [4 x float]]* @workbench.viewport_to_unit_matrix, align 4
	%183 = bitcast [4 x [4 x float]]* %26 to %..rawptr
	%184 = call %..rawptr @mem.zero(%..rawptr %183, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %26
	store [4 x [4 x float]] %182, [4 x [4 x float]]* %26
	%185 = bitcast [3 x float]* %27 to %..rawptr
	%186 = call %..rawptr @mem.zero(%..rawptr %185, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %27
	store [3 x float] [float 0x3ff0000000000000, float 0x3ff0000000000000, float 0x0000000000000000], [3 x float]* %27
	%187 = call [4 x [4 x float]] @workbench.translate([4 x [4 x float]]* %26, [3 x float]* %27, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %187, [4 x [4 x float]]* @workbench.viewport_to_unit_matrix
	; AssignStmt
	%188 = load [4 x [4 x float]], [4 x [4 x float]]* @workbench.viewport_to_unit_matrix, align 4
	%189 = bitcast [4 x [4 x float]]* %28 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %28
	store [4 x [4 x float]] %188, [4 x [4 x float]]* %28
	%191 = call [4 x [4 x float]] @math.scale_f32([4 x [4 x float]]* %28, float 0x3fe0000000000000, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %191, [4 x [4 x float]]* @workbench.viewport_to_unit_matrix
	ret void
}

define void @workbench.perspective_camera(float %fov, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca float, align 16
	store float %fov, float* %0
	; AssignStmt
	store i8 1, i8* @workbench.is_perspective
	; AssignStmt
	%1 = load float, float* %0, align 4
	store float %1, float* @workbench.camera_size
	ret void
}

define void @workbench.rendermode_world(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca [4 x [4 x float]], align 16
	%1 = alloca [4 x [4 x float]], align 16
	%2 = alloca [4 x [4 x float]], align 16
	%3 = alloca [4 x [4 x float]], align 16
	; AssignStmt
	store void (%runtime.Context*)* @workbench.rendermode_world, void (%runtime.Context*)** @workbench.current_rendermode
	; IfStmt
	%4 = load i8, i8* @workbench.is_perspective, align 1
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-1, label %if.else-2

if.then-1:
	; AssignStmt
	%6 = load [4 x [4 x float]], [4 x [4 x float]]* @workbench.perspective_projection_matrix, align 4
	%7 = load [4 x [4 x float]], [4 x [4 x float]]* @workbench.view_matrix, align 4
	%8 = bitcast [4 x [4 x float]]* %0 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %0
	store [4 x [4 x float]] %6, [4 x [4 x float]]* %0
	%10 = bitcast [4 x [4 x float]]* %1 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %1
	store [4 x [4 x float]] %7, [4 x [4 x float]]* %1
	%12 = call [4 x [4 x float]] @math.mat4_mul([4 x [4 x float]]* %0, [4 x [4 x float]]* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load [4 x [4 x float]], [4 x [4 x float]]* @workbench.model_matrix, align 4
	%14 = bitcast [4 x [4 x float]]* %2 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %2
	store [4 x [4 x float]] %12, [4 x [4 x float]]* %2
	%16 = bitcast [4 x [4 x float]]* %3 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %3
	store [4 x [4 x float]] %13, [4 x [4 x float]]* %3
	%18 = call [4 x [4 x float]] @math.mat4_mul([4 x [4 x float]]* %2, [4 x [4 x float]]* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %18, [4 x [4 x float]]* @workbench.mvp_matrix
	br label %if.done-3

if.else-2:
	; AssignStmt
	%19 = load [4 x [4 x float]], [4 x [4 x float]]* @workbench.orthographic_projection_matrix, align 4
	store [4 x [4 x float]] %19, [4 x [4 x float]]* @workbench.mvp_matrix
	br label %if.done-3

if.done-3:
	ret void
}

define void @workbench.rendermode_pixel(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	; AssignStmt
	store void (%runtime.Context*)* @workbench.rendermode_pixel, void (%runtime.Context*)** @workbench.current_rendermode
	; AssignStmt
	%0 = load [4 x [4 x float]], [4 x [4 x float]]* @workbench.pixel_to_viewport_matrix, align 4
	store [4 x [4 x float]] %0, [4 x [4 x float]]* @workbench.mvp_matrix
	ret void
}

define void @workbench.im_quad_color(void (%runtime.Context*)* %rendermode, i32 %shader, [3 x float]* %min, [3 x float]* %max, %workbench.Colorf* %color, i64 %render_order, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca void (%runtime.Context*)*, align 16
	%1 = alloca i32, align 16
	%2 = alloca i64, align 16
	%3 = alloca [3 x float], align 16
	%4 = alloca [3 x float], align 16
	%5 = alloca %workbench.Sprite, align 16
	%6 = alloca %workbench.Colorf, align 16
	store void (%runtime.Context*)* %rendermode, void (%runtime.Context*)** %0
	store i32 %shader, i32* %1
	%7 = load [3 x float], [3 x float]* %min, align 4
	%8 = load [3 x float], [3 x float]* %max, align 4
	%9 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	store i64 %render_order, i64* %2
	%10 = load void (%runtime.Context*)*, void (%runtime.Context*)** %0, align 8
	%11 = load i32, i32* %1, align 4
	%12 = load [3 x float], [3 x float]* %min, align 4
	%13 = load [3 x float], [3 x float]* %max, align 4
	%14 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%15 = load i64, i64* %2, align 8
	%16 = bitcast [3 x float]* %3 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %3
	store [3 x float] %12, [3 x float]* %3
	%18 = bitcast [3 x float]* %4 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %4
	store [3 x float] %13, [3 x float]* %4
	%20 = bitcast %workbench.Sprite* %5 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 44) noinline
	store %workbench.Sprite zeroinitializer, %workbench.Sprite* %5
	store %workbench.Sprite zeroinitializer, %workbench.Sprite* %5
	%22 = bitcast %workbench.Colorf* %6 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %6
	store %workbench.Colorf %14, %workbench.Colorf* %6
	call void @workbench.im_quad_sprite_color(void (%runtime.Context*)* %10, i32 %11, [3 x float]* %3, [3 x float]* %4, %workbench.Sprite* %5, %workbench.Colorf* %6, i64 %15, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define void @workbench.im_quad_sprite_color(void (%runtime.Context*)* %rendermode, i32 %shader, [3 x float]* %min, [3 x float]* %max, %workbench.Sprite* %sprite, %workbench.Colorf* %color, i64 %render_order, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca void (%runtime.Context*)*, align 16
	%1 = alloca i32, align 16
	%2 = alloca i64, align 16
	%3 = alloca [3 x float], align 16
	%4 = alloca [3 x float], align 16
	%5 = alloca [3 x float], align 16
	%6 = alloca [3 x float], align 16
	%7 = alloca [3 x float], align 16
	%8 = alloca [3 x float], align 16
	%9 = alloca [3 x float], align 16
	%10 = alloca [2 x float], align 16
	%11 = alloca %workbench.Colorf, align 16
	%12 = alloca [3 x float], align 16
	%13 = alloca [2 x float], align 16
	%14 = alloca %workbench.Colorf, align 16
	%15 = alloca [3 x float], align 16
	%16 = alloca [2 x float], align 16
	%17 = alloca %workbench.Colorf, align 16
	%18 = alloca [3 x float], align 16
	%19 = alloca [2 x float], align 16
	%20 = alloca %workbench.Colorf, align 16
	%21 = alloca [3 x float], align 16
	%22 = alloca [2 x float], align 16
	%23 = alloca %workbench.Colorf, align 16
	%24 = alloca [3 x float], align 16
	%25 = alloca [2 x float], align 16
	%26 = alloca %workbench.Colorf, align 16
	store void (%runtime.Context*)* %rendermode, void (%runtime.Context*)** %0
	store i32 %shader, i32* %1
	%27 = load [3 x float], [3 x float]* %min, align 4
	%28 = load [3 x float], [3 x float]* %max, align 4
	%29 = load %workbench.Sprite, %workbench.Sprite* %sprite, align 4
	%30 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	store i64 %render_order, i64* %2
	; p0
	; p1
	; p2
	; p3
	%31 = load [3 x float], [3 x float]* %min, align 4
	; CompoundLit
	%32 = bitcast [3 x float]* %7 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %7
	store [3 x float] [float zeroinitializer, float zeroinitializer, float zeroinitializer], [3 x float]* %7
	; SelectorExpr
	%34 = getelementptr inbounds [3 x float], [3 x float]* %min, i64 0, i32 0
	%35 = load float, float* %34, align 4
	%36 = getelementptr inbounds [3 x float], [3 x float]* %7, i64 0, i32 0
	store float %35, float* %36
	; SelectorExpr
	%37 = getelementptr inbounds [3 x float], [3 x float]* %max, i64 0, i32 1
	%38 = load float, float* %37, align 4
	%39 = getelementptr inbounds [3 x float], [3 x float]* %7, i64 0, i32 1
	store float %38, float* %39
	; SelectorExpr
	%40 = getelementptr inbounds [3 x float], [3 x float]* %max, i64 0, i32 2
	%41 = load float, float* %40, align 4
	%42 = getelementptr inbounds [3 x float], [3 x float]* %7, i64 0, i32 2
	store float %41, float* %42
	%43 = load [3 x float], [3 x float]* %7, align 4
	%44 = load [3 x float], [3 x float]* %max, align 4
	; CompoundLit
	%45 = bitcast [3 x float]* %8 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %8
	store [3 x float] [float zeroinitializer, float zeroinitializer, float zeroinitializer], [3 x float]* %8
	; SelectorExpr
	%47 = getelementptr inbounds [3 x float], [3 x float]* %max, i64 0, i32 0
	%48 = load float, float* %47, align 4
	%49 = getelementptr inbounds [3 x float], [3 x float]* %8, i64 0, i32 0
	store float %48, float* %49
	; SelectorExpr
	%50 = getelementptr inbounds [3 x float], [3 x float]* %min, i64 0, i32 1
	%51 = load float, float* %50, align 4
	%52 = getelementptr inbounds [3 x float], [3 x float]* %8, i64 0, i32 1
	store float %51, float* %52
	; SelectorExpr
	%53 = getelementptr inbounds [3 x float], [3 x float]* %min, i64 0, i32 2
	%54 = load float, float* %53, align 4
	%55 = getelementptr inbounds [3 x float], [3 x float]* %8, i64 0, i32 2
	store float %54, float* %55
	%56 = load [3 x float], [3 x float]* %8, align 4
	store [3 x float] %31, [3 x float]* %3
	store [3 x float] %43, [3 x float]* %4
	store [3 x float] %44, [3 x float]* %5
	store [3 x float] %56, [3 x float]* %6
	%57 = load void (%runtime.Context*)*, void (%runtime.Context*)** %0, align 8
	%58 = load i32, i32* %1, align 4
	; SelectorExpr
	%59 = getelementptr inbounds %workbench.Sprite, %workbench.Sprite* %sprite, i64 0, i32 3
	%60 = load i32, i32* %59, align 4
	%61 = load [3 x float], [3 x float]* %3, align 4
	; IndexExpr
	; SelectorExpr
	%62 = getelementptr inbounds %workbench.Sprite, %workbench.Sprite* %sprite, i64 0, i32 0
	%63 = getelementptr inbounds [4 x [2 x float]], [4 x [2 x float]]* %62, i64 0, i32 0
	%64 = load [2 x float], [2 x float]* %63, align 4
	%65 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%66 = load i64, i64* %2, align 8
	%67 = bitcast [3 x float]* %9 to %..rawptr
	%68 = call %..rawptr @mem.zero(%..rawptr %67, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %9
	store [3 x float] %61, [3 x float]* %9
	%69 = bitcast [2 x float]* %10 to %..rawptr
	%70 = call %..rawptr @mem.zero(%..rawptr %69, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %10
	store [2 x float] %64, [2 x float]* %10
	%71 = bitcast %workbench.Colorf* %11 to %..rawptr
	%72 = call %..rawptr @mem.zero(%..rawptr %71, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %11
	store %workbench.Colorf %65, %workbench.Colorf* %11
	call void @workbench.im_vertex_color_texture(void (%runtime.Context*)* %57, i32 %58, i32 %60, [3 x float]* %9, [2 x float]* %10, %workbench.Colorf* %11, i64 %66, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%73 = load void (%runtime.Context*)*, void (%runtime.Context*)** %0, align 8
	%74 = load i32, i32* %1, align 4
	; SelectorExpr
	%75 = getelementptr inbounds %workbench.Sprite, %workbench.Sprite* %sprite, i64 0, i32 3
	%76 = load i32, i32* %75, align 4
	%77 = load [3 x float], [3 x float]* %4, align 4
	; IndexExpr
	; SelectorExpr
	%78 = getelementptr inbounds %workbench.Sprite, %workbench.Sprite* %sprite, i64 0, i32 0
	%79 = getelementptr inbounds [4 x [2 x float]], [4 x [2 x float]]* %78, i64 0, i32 1
	%80 = load [2 x float], [2 x float]* %79, align 4
	%81 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%82 = load i64, i64* %2, align 8
	%83 = bitcast [3 x float]* %12 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %12
	store [3 x float] %77, [3 x float]* %12
	%85 = bitcast [2 x float]* %13 to %..rawptr
	%86 = call %..rawptr @mem.zero(%..rawptr %85, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %13
	store [2 x float] %80, [2 x float]* %13
	%87 = bitcast %workbench.Colorf* %14 to %..rawptr
	%88 = call %..rawptr @mem.zero(%..rawptr %87, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %14
	store %workbench.Colorf %81, %workbench.Colorf* %14
	call void @workbench.im_vertex_color_texture(void (%runtime.Context*)* %73, i32 %74, i32 %76, [3 x float]* %12, [2 x float]* %13, %workbench.Colorf* %14, i64 %82, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%89 = load void (%runtime.Context*)*, void (%runtime.Context*)** %0, align 8
	%90 = load i32, i32* %1, align 4
	; SelectorExpr
	%91 = getelementptr inbounds %workbench.Sprite, %workbench.Sprite* %sprite, i64 0, i32 3
	%92 = load i32, i32* %91, align 4
	%93 = load [3 x float], [3 x float]* %5, align 4
	; IndexExpr
	; SelectorExpr
	%94 = getelementptr inbounds %workbench.Sprite, %workbench.Sprite* %sprite, i64 0, i32 0
	%95 = getelementptr inbounds [4 x [2 x float]], [4 x [2 x float]]* %94, i64 0, i32 2
	%96 = load [2 x float], [2 x float]* %95, align 4
	%97 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%98 = load i64, i64* %2, align 8
	%99 = bitcast [3 x float]* %15 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %15
	store [3 x float] %93, [3 x float]* %15
	%101 = bitcast [2 x float]* %16 to %..rawptr
	%102 = call %..rawptr @mem.zero(%..rawptr %101, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %16
	store [2 x float] %96, [2 x float]* %16
	%103 = bitcast %workbench.Colorf* %17 to %..rawptr
	%104 = call %..rawptr @mem.zero(%..rawptr %103, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %17
	store %workbench.Colorf %97, %workbench.Colorf* %17
	call void @workbench.im_vertex_color_texture(void (%runtime.Context*)* %89, i32 %90, i32 %92, [3 x float]* %15, [2 x float]* %16, %workbench.Colorf* %17, i64 %98, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%105 = load void (%runtime.Context*)*, void (%runtime.Context*)** %0, align 8
	%106 = load i32, i32* %1, align 4
	; SelectorExpr
	%107 = getelementptr inbounds %workbench.Sprite, %workbench.Sprite* %sprite, i64 0, i32 3
	%108 = load i32, i32* %107, align 4
	%109 = load [3 x float], [3 x float]* %5, align 4
	; IndexExpr
	; SelectorExpr
	%110 = getelementptr inbounds %workbench.Sprite, %workbench.Sprite* %sprite, i64 0, i32 0
	%111 = getelementptr inbounds [4 x [2 x float]], [4 x [2 x float]]* %110, i64 0, i32 2
	%112 = load [2 x float], [2 x float]* %111, align 4
	%113 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%114 = load i64, i64* %2, align 8
	%115 = bitcast [3 x float]* %18 to %..rawptr
	%116 = call %..rawptr @mem.zero(%..rawptr %115, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %18
	store [3 x float] %109, [3 x float]* %18
	%117 = bitcast [2 x float]* %19 to %..rawptr
	%118 = call %..rawptr @mem.zero(%..rawptr %117, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %19
	store [2 x float] %112, [2 x float]* %19
	%119 = bitcast %workbench.Colorf* %20 to %..rawptr
	%120 = call %..rawptr @mem.zero(%..rawptr %119, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %20
	store %workbench.Colorf %113, %workbench.Colorf* %20
	call void @workbench.im_vertex_color_texture(void (%runtime.Context*)* %105, i32 %106, i32 %108, [3 x float]* %18, [2 x float]* %19, %workbench.Colorf* %20, i64 %114, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%121 = load void (%runtime.Context*)*, void (%runtime.Context*)** %0, align 8
	%122 = load i32, i32* %1, align 4
	; SelectorExpr
	%123 = getelementptr inbounds %workbench.Sprite, %workbench.Sprite* %sprite, i64 0, i32 3
	%124 = load i32, i32* %123, align 4
	%125 = load [3 x float], [3 x float]* %6, align 4
	; IndexExpr
	; SelectorExpr
	%126 = getelementptr inbounds %workbench.Sprite, %workbench.Sprite* %sprite, i64 0, i32 0
	%127 = getelementptr inbounds [4 x [2 x float]], [4 x [2 x float]]* %126, i64 0, i32 3
	%128 = load [2 x float], [2 x float]* %127, align 4
	%129 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%130 = load i64, i64* %2, align 8
	%131 = bitcast [3 x float]* %21 to %..rawptr
	%132 = call %..rawptr @mem.zero(%..rawptr %131, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %21
	store [3 x float] %125, [3 x float]* %21
	%133 = bitcast [2 x float]* %22 to %..rawptr
	%134 = call %..rawptr @mem.zero(%..rawptr %133, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %22
	store [2 x float] %128, [2 x float]* %22
	%135 = bitcast %workbench.Colorf* %23 to %..rawptr
	%136 = call %..rawptr @mem.zero(%..rawptr %135, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %23
	store %workbench.Colorf %129, %workbench.Colorf* %23
	call void @workbench.im_vertex_color_texture(void (%runtime.Context*)* %121, i32 %122, i32 %124, [3 x float]* %21, [2 x float]* %22, %workbench.Colorf* %23, i64 %130, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%137 = load void (%runtime.Context*)*, void (%runtime.Context*)** %0, align 8
	%138 = load i32, i32* %1, align 4
	; SelectorExpr
	%139 = getelementptr inbounds %workbench.Sprite, %workbench.Sprite* %sprite, i64 0, i32 3
	%140 = load i32, i32* %139, align 4
	%141 = load [3 x float], [3 x float]* %3, align 4
	; IndexExpr
	; SelectorExpr
	%142 = getelementptr inbounds %workbench.Sprite, %workbench.Sprite* %sprite, i64 0, i32 0
	%143 = getelementptr inbounds [4 x [2 x float]], [4 x [2 x float]]* %142, i64 0, i32 0
	%144 = load [2 x float], [2 x float]* %143, align 4
	%145 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%146 = load i64, i64* %2, align 8
	%147 = bitcast [3 x float]* %24 to %..rawptr
	%148 = call %..rawptr @mem.zero(%..rawptr %147, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %24
	store [3 x float] %141, [3 x float]* %24
	%149 = bitcast [2 x float]* %25 to %..rawptr
	%150 = call %..rawptr @mem.zero(%..rawptr %149, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %25
	store [2 x float] %144, [2 x float]* %25
	%151 = bitcast %workbench.Colorf* %26 to %..rawptr
	%152 = call %..rawptr @mem.zero(%..rawptr %151, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %26
	store %workbench.Colorf %145, %workbench.Colorf* %26
	call void @workbench.im_vertex_color_texture(void (%runtime.Context*)* %137, i32 %138, i32 %140, [3 x float]* %24, [2 x float]* %25, %workbench.Colorf* %26, i64 %146, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define void @workbench.im_vertex_color_texture(void (%runtime.Context*)* %rendermode, i32 %shader, i32 %texture, [3 x float]* %position, [2 x float]* %tex_coord, %workbench.Colorf* %color, i64 %render_order, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca void (%runtime.Context*)*, align 16
	%1 = alloca i32, align 16
	%2 = alloca i32, align 16
	%3 = alloca i64, align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	%5 = alloca i64, align 16
	%6 = alloca %workbench.Buffered_Vertex, align 16
	%7 = alloca %workbench.Buffered_Vertex, align 16
	%8 = alloca %workbench.Buffered_Vertex, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	store void (%runtime.Context*)* %rendermode, void (%runtime.Context*)** %0
	store i32 %shader, i32* %1
	store i32 %texture, i32* %2
	%10 = load [3 x float], [3 x float]* %position, align 4
	%11 = load [2 x float], [2 x float]* %tex_coord, align 4
	%12 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	store i64 %render_order, i64* %3
	%13 = load i32, i32* %1, align 4
	%14 = icmp ne i32 %13, 0
	%15 = zext i1 %14 to i8
	%16 = trunc i8 %15 to i1
	%17 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1b0, i64 0, i32 0), i64 62}, i64 206, i64 2, %..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$1b1, i64 0, i32 0), i64 23}}, %runtime.Source_Code_Location* %4
	%19 = call i8 @runtime.assert(i1 %16, %..string zeroinitializer, %runtime.Source_Code_Location* %4) alwaysinline
	; serial
	%20 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* @workbench.im_buffered_verts, align 8
	%21 = extractvalue {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} %20, 1
	store i64 %21, i64* %5
	; vertex_info
	; CompoundLit
	%22 = bitcast %workbench.Buffered_Vertex* %7 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 112) noinline
	store %workbench.Buffered_Vertex zeroinitializer, %workbench.Buffered_Vertex* %7
	store %workbench.Buffered_Vertex {i64 zeroinitializer, i64 zeroinitializer, [3 x float] zeroinitializer, [2 x float] zeroinitializer, %workbench.Colorf zeroinitializer, void (%runtime.Context*)* zeroinitializer, i32 zeroinitializer, i32 zeroinitializer, i8 zeroinitializer, [4 x i64] zeroinitializer}, %workbench.Buffered_Vertex* %7
	%24 = load i64, i64* %3, align 8
	%25 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %7, i64 0, i32 0
	store i64 %24, i64* %25
	%26 = load i64, i64* %5, align 8
	%27 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %7, i64 0, i32 1
	store i64 %26, i64* %27
	%28 = load [3 x float], [3 x float]* %position, align 4
	%29 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %7, i64 0, i32 2
	store [3 x float] %28, [3 x float]* %29
	%30 = load [2 x float], [2 x float]* %tex_coord, align 4
	%31 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %7, i64 0, i32 3
	store [2 x float] %30, [2 x float]* %31
	%32 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%33 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %7, i64 0, i32 4
	store %workbench.Colorf %32, %workbench.Colorf* %33
	%34 = load void (%runtime.Context*)*, void (%runtime.Context*)** %0, align 8
	%35 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %7, i64 0, i32 5
	store void (%runtime.Context*)* %34, void (%runtime.Context*)** %35
	%36 = load i32, i32* %1, align 4
	%37 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %7, i64 0, i32 6
	store i32 %36, i32* %37
	%38 = load i32, i32* %2, align 4
	%39 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %7, i64 0, i32 7
	store i32 %38, i32* %39
	%40 = load i8, i8* @workbench.do_scissor, align 1
	%41 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %7, i64 0, i32 8
	store i8 %40, i8* %41
	%42 = load [4 x i64], [4 x i64]* @workbench.scissor_rect1, align 8
	%43 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %7, i64 0, i32 9
	store [4 x i64] %42, [4 x i64]* %43
	%44 = load %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %7, align 8
	store %workbench.Buffered_Vertex %44, %workbench.Buffered_Vertex* %6
	%45 = load %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %6, align 8
	%46 = bitcast %workbench.Buffered_Vertex* %8 to %..rawptr
	%47 = call %..rawptr @mem.zero(%..rawptr %46, i64 112) noinline
	store %workbench.Buffered_Vertex zeroinitializer, %workbench.Buffered_Vertex* %8
	store %workbench.Buffered_Vertex %45, %workbench.Buffered_Vertex* %8
	%48 = bitcast %runtime.Source_Code_Location* %9 to %..rawptr
	%49 = call %..rawptr @mem.zero(%..rawptr %48, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %9
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1b2, i64 0, i32 0), i64 62}, i64 209, i64 2, %..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$1b3, i64 0, i32 0), i64 23}}, %runtime.Source_Code_Location* %9
	%50 = call i64 @runtime.append_elem-17064({%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* @workbench.im_buffered_verts, %workbench.Buffered_Vertex* %8, %runtime.Source_Code_Location* %9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define [4 x i64] @workbench.full_screen_scissor_rect(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca [4 x i64], align 16
	; ReturnStmt
	; CompoundLit
	%1 = bitcast [4 x i64]* %0 to %..rawptr
	%2 = call %..rawptr @mem.zero(%..rawptr %1, i64 32) noinline
	store [4 x i64] zeroinitializer, [4 x i64]* %0
	store [4 x i64] [i64 0, i64 0, i64 zeroinitializer, i64 zeroinitializer], [4 x i64]* %0
	%3 = load float, float* @workbench.current_window_width, align 4
	%4 = fadd float %3, 0x3fe0000000000000
	%5 = fptosi float %4 to i64
	%6 = getelementptr inbounds [4 x i64], [4 x i64]* %0, i64 0, i32 2
	store i64 %5, i64* %6
	%7 = load float, float* @workbench.current_window_height, align 4
	%8 = fadd float %7, 0x3fe0000000000000
	%9 = fptosi float %8 to i64
	%10 = getelementptr inbounds [4 x i64], [4 x i64]* %0, i64 0, i32 3
	store i64 %9, i64* %10
	%11 = load [4 x i64], [4 x i64]* %0, align 8
	ret [4 x i64] %11
}

define void @workbench._update_renderer(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Source_Code_Location, align 16
	call void @runtime.clear_dynamic_array-17165({%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* @workbench.debug_vertices)
	call void @runtime.clear_dynamic_array-17165({%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* @workbench.im_buffered_verts)
	%1 = bitcast %runtime.Source_Code_Location* %0 to %..rawptr
	%2 = call %..rawptr @mem.zero(%..rawptr %1, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %0
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1b4, i64 0, i32 0), i64 62}, i64 446, i64 2, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$1b5, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %0
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$1b6, i64 0, i32 0), i64 16}, %runtime.Source_Code_Location* %0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%3 = load void (i32)*, void (i32)** @gl.Enable, align 8
	call ccc void %3(i32 3042)
	; SelectorExpr
	%4 = load void (i32, i32)*, void (i32, i32)** @gl.BlendFunc, align 8
	call ccc void %4(i32 770, i32 771)
	; IfStmt
	%5 = load i8, i8* @workbench.is_perspective, align 1
	%6 = trunc i8 %5 to i1
	br i1 %6, label %if.then-1, label %if.else-2

if.then-1:
	; SelectorExpr
	%7 = load void (i32)*, void (i32)** @gl.Enable, align 8
	call ccc void %7(i32 2929)
	; SelectorExpr
	%8 = load void (i32)*, void (i32)** @gl.Clear, align 8
	call ccc void %8(i32 16640)
	br label %if.done-3

if.else-2:
	; SelectorExpr
	%9 = load void (i32)*, void (i32)** @gl.Disable, align 8
	call ccc void %9(i32 2929)
	; SelectorExpr
	%10 = load void (i32)*, void (i32)** @gl.Clear, align 8
	call ccc void %10(i32 16384)
	br label %if.done-3

if.done-3:
	; SelectorExpr
	%11 = load void (i32, i32, i32, i32)*, void (i32, i32, i32, i32)** @gl.Viewport, align 8
	%12 = load float, float* @workbench.current_window_width, align 4
	%13 = fptosi float %12 to i32
	%14 = load float, float* @workbench.current_window_height, align 4
	%15 = fptosi float %14 to i32
	call ccc void %11(i32 0, i32 0, i32 %13, i32 %15)
	ret void
}

define void @workbench.render_scene(%workbench.Scene* %scene, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Source_Code_Location, align 16
	%1 = alloca {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, align 16
	%2 = alloca %..string, align 16
	%3 = alloca %..any, align 16
	%4 = alloca %..any, align 16
	%5 = alloca {%..any*, i64}, align 16
	%6 = alloca [2 x %..any], align 16
	%7 = alloca {%..any*, i64}, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	%9 = load %workbench.Scene, %workbench.Scene* %scene, align 8
	%10 = bitcast %runtime.Source_Code_Location* %0 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %0
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1b7, i64 0, i32 0), i64 62}, i64 468, i64 2, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$1b8, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %0
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$1b9, i64 0, i32 0), i64 12}, %runtime.Source_Code_Location* %0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	store i32 0, i32* @workbench.num_draw_calls
	; IfStmt
	; SelectorExpr
	%12 = getelementptr inbounds %workbench.Scene, %workbench.Scene* %scene, i64 0, i32 3
	%13 = load void (float, %runtime.Context*)*, void (float, %runtime.Context*)** %12, align 8
	%14 = icmp ne void (float, %runtime.Context*)* %13, zeroinitializer
	%15 = zext i1 %14 to i8
	%16 = trunc i8 %15 to i1
	br i1 %16, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	%17 = getelementptr inbounds %workbench.Scene, %workbench.Scene* %scene, i64 0, i32 3
	%18 = load void (float, %runtime.Context*)*, void (float, %runtime.Context*)** %17, align 8
	%19 = load float, float* @workbench.client_target_delta_time, align 4
	call void %18(float %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-2

if.done-2:
	%20 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* @workbench.im_buffered_verts, align 8
	%21 = bitcast {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %1 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 40) noinline
	store {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} zeroinitializer, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %1
	store {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} %20, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %1
	call void @workbench.im_draw_flush(i32 4, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @workbench.draw_debug_lines(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%23 = getelementptr inbounds %workbench.Scene, %workbench.Scene* %scene, i64 0, i32 0
	%24 = load %..string, %..string* %23, align 8
	%25 = bitcast %..string* %2 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$1ba, i64 0, i32 0), i64 12}, %..string* %2
	%27 = load %..string, %..string* %2, align 8
	%28 = bitcast %..any* %3 to %..rawptr
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 16) noinline
	store %..any zeroinitializer, %..any* %3
	%30 = bitcast %..string* %2 to %..rawptr
	%31 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	store %..rawptr %30, %..rawptr* %31
	%32 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %32
	%33 = load %..any, %..any* %3, align 8
	%34 = bitcast %..any* %4 to %..rawptr
	%35 = call %..rawptr @mem.zero(%..rawptr %34, i64 16) noinline
	store %..any zeroinitializer, %..any* %4
	%36 = bitcast %..string* %23 to %..rawptr
	%37 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	store %..rawptr %36, %..rawptr* %37
	%38 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %38
	%39 = load %..any, %..any* %4, align 8
	; variadic call argument generation
	%40 = bitcast {%..any*, i64}* %5 to %..rawptr
	%41 = call %..rawptr @mem.zero(%..rawptr %40, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %5
	%42 = bitcast [2 x %..any]* %6 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %6
	%44 = getelementptr inbounds [2 x %..any], [2 x %..any]* %6, i64 0, i32 0
	store %..any %33, %..any* %44
	%45 = getelementptr inbounds [2 x %..any], [2 x %..any]* %6, i64 0, i32 1
	store %..any %39, %..any* %45
	%46 = getelementptr inbounds [2 x %..any], [2 x %..any]* %6, i64 0, i32 0
	%47 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %5, i64 0, i32 0
	store %..any* %46, %..any** %47
	%48 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %5, i64 0, i32 1
	store i64 2, i64* %48
	%49 = load {%..any*, i64}, {%..any*, i64}* %5, align 8
	%50 = bitcast {%..any*, i64}* %7 to %..rawptr
	%51 = call %..rawptr @mem.zero(%..rawptr %50, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %7
	store {%..any*, i64} %49, {%..any*, i64}* %7
	%52 = call %..string @fmt.tprint({%..any*, i64}* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%53 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%54 = call %..rawptr @mem.zero(%..rawptr %53, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1bb, i64 0, i32 0), i64 62}, i64 476, i64 2, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$1bc, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %8
	call void @workbench.log_gl_errors(%..string %52, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @workbench.im_draw_flush(i32 %mode, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %verts, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca {%workbench.Buffered_Vertex*, i64}, align 16
	%2 = alloca {%workbench.Buffered_Vertex*, i64}, align 16
	%3 = alloca %workbench.Buffered_Vertex, align 16
	%4 = alloca i64, align 16
	%5 = alloca i8, align 16
	%6 = alloca i8, align 16
	%7 = alloca i8, align 16
	%8 = alloca i8, align 16
	%9 = alloca {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, align 16
	%10 = alloca %runtime.Source_Code_Location, align 16
	%11 = alloca %runtime.Source_Code_Location, align 16
	%12 = alloca %runtime.Source_Code_Location, align 16
	%13 = alloca %workbench.Vertex2D, align 16
	%14 = alloca %workbench.Vertex2D, align 16
	%15 = alloca %workbench.Vertex2D, align 16
	%16 = alloca %runtime.Source_Code_Location, align 16
	%17 = alloca {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, align 16
	%18 = alloca %runtime.Source_Code_Location, align 16
	store i32 %mode, i32* %0
	%19 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %verts, align 8
	; IfStmt
	%20 = load i8, i8* @workbench.is_perspective, align 1
	%21 = trunc i8 %20 to i1
	br i1 %21, label %if.done-2, label %if.then-1

if.then-1:
	; SelectorExpr
	; SliceExpr
	%22 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %verts, align 8
	%23 = extractvalue {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} %22, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1bd, i64 0, i32 0), i64 62}, i64 497, i64 29, i64 0, i64 %23, i64 %23)
	%24 = extractvalue {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} %22, 0
	%25 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %24, i64 0
	%26 = sub i64 %23, 0
	%27 = bitcast {%workbench.Buffered_Vertex*, i64}* %1 to %..rawptr
	%28 = call %..rawptr @mem.zero(%..rawptr %27, i64 16) noinline
	store {%workbench.Buffered_Vertex*, i64} zeroinitializer, {%workbench.Buffered_Vertex*, i64}* %1
	%29 = getelementptr inbounds {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %1, i64 0, i32 0
	store %workbench.Buffered_Vertex* %25, %workbench.Buffered_Vertex** %29
	%30 = getelementptr inbounds {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %1, i64 0, i32 1
	store i64 %26, i64* %30
	%31 = load {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %1, align 8
	%32 = bitcast {%workbench.Buffered_Vertex*, i64}* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store {%workbench.Buffered_Vertex*, i64} zeroinitializer, {%workbench.Buffered_Vertex*, i64}* %2
	store {%workbench.Buffered_Vertex*, i64} %31, {%workbench.Buffered_Vertex*, i64}* %2
	call void @sort.quick_sort_proc-17218({%workbench.Buffered_Vertex*, i64}* %2, i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)* @workbench.im_draw_flush$anon-0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-2

if.done-2:
	; AssignStmt
	%34 = call [4 x [4 x float]] @math.identity-15829(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x [4 x float]] %34, [4 x [4 x float]]* @workbench.model_matrix
	; AssignStmt
	store i32 0, i32* @workbench.current_shader
	; AssignStmt
	store i32 0, i32* @workbench.current_texture
	; AssignStmt
	store void (%runtime.Context*)* zeroinitializer, void (%runtime.Context*)** @workbench.current_rendermode
	; RangeStmt
	; vertex_info
	%35 = bitcast %workbench.Buffered_Vertex* %3 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 112) noinline
	store %workbench.Buffered_Vertex zeroinitializer, %workbench.Buffered_Vertex* %3
	%37 = getelementptr inbounds {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %verts, i64 0, i32 1
	%38 = bitcast i64* %4 to %..rawptr
	%39 = call %..rawptr @mem.zero(%..rawptr %38, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-3

for.index.loop-3:
	%40 = load i64, i64* %4, align 8
	%41 = add i64 %40, 1
	store i64 %41, i64* %4
	%42 = load i64, i64* %37, align 8
	%43 = icmp slt i64 %41, %42
	br i1 %43, label %for.index.body-4, label %for.index.done-21

for.index.body-4:
	%44 = load i64, i64* %4, align 8
	%45 = getelementptr inbounds {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %verts, i64 0, i32 0
	%46 = load %workbench.Buffered_Vertex*, %workbench.Buffered_Vertex** %45, align 8
	%47 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %46, i64 %44
	%48 = load %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %47, align 8
	store %workbench.Buffered_Vertex %48, %workbench.Buffered_Vertex* %3
	; shader_mismatch
	; SelectorExpr
	%49 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %3, i64 0, i32 6
	%50 = load i32, i32* %49, align 4
	%51 = load i32, i32* @workbench.current_shader, align 4
	%52 = icmp ne i32 %50, %51
	%53 = zext i1 %52 to i8
	store i8 %53, i8* %5
	; texture_mismatch
	; SelectorExpr
	%54 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %3, i64 0, i32 7
	%55 = load i32, i32* %54, align 4
	%56 = load i32, i32* @workbench.current_texture, align 4
	%57 = icmp ne i32 %55, %56
	%58 = zext i1 %57 to i8
	store i8 %58, i8* %6
	; scissor_mismatch
	; SelectorExpr
	%59 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %3, i64 0, i32 8
	%60 = load i8, i8* %59, align 1
	%61 = load i8, i8* @workbench.is_scissor, align 1
	%62 = icmp ne i8 %60, %61
	%63 = zext i1 %62 to i8
	store i8 %63, i8* %7
	; rendermode_mismatch
	; SelectorExpr
	%64 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %3, i64 0, i32 5
	%65 = load void (%runtime.Context*)*, void (%runtime.Context*)** %64, align 8
	%66 = load void (%runtime.Context*)*, void (%runtime.Context*)** @workbench.current_rendermode, align 8
	%67 = icmp ne void (%runtime.Context*)* %65, %66
	%68 = zext i1 %67 to i8
	store i8 %68, i8* %8
	; IfStmt
	%69 = load i8, i8* %5, align 1
	%70 = trunc i8 %69 to i1
	br i1 %70, label %if.then-8, label %cmp.or-5

cmp.or-5:
	%71 = load i8, i8* %6, align 1
	%72 = trunc i8 %71 to i1
	br i1 %72, label %if.then-8, label %cmp.or-6

cmp.or-6:
	%73 = load i8, i8* %7, align 1
	%74 = trunc i8 %73 to i1
	br i1 %74, label %if.then-8, label %cmp.or-7

cmp.or-7:
	%75 = load i8, i8* %8, align 1
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-8, label %if.done-9

if.then-8:
	%77 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* @workbench.im_queued_for_drawing, align 8
	%78 = load i32, i32* %0, align 4
	%79 = bitcast {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %9 to %..rawptr
	%80 = call %..rawptr @mem.zero(%..rawptr %79, i64 40) noinline
	store {%workbench.Vertex2D*, i64, i64, %mem.Allocator} zeroinitializer, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %9
	store {%workbench.Vertex2D*, i64, i64, %mem.Allocator} %77, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %9
	%81 = bitcast %runtime.Source_Code_Location* %10 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %10
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1be, i64 0, i32 0), i64 62}, i64 516, i64 4, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$1bf, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %10
	call void @workbench.draw_vertex_list-17232({%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %9, i32 %78, %runtime.Source_Code_Location* %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @runtime.clear_dynamic_array-17239({%workbench.Vertex2D*, i64, i64, %mem.Allocator}* @workbench.im_queued_for_drawing)
	br label %if.done-9

if.done-9:
	; IfStmt
	%83 = load i8, i8* %5, align 1
	%84 = trunc i8 %83 to i1
	br i1 %84, label %if.then-10, label %if.done-11

if.then-10:
	; SelectorExpr
	%85 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %3, i64 0, i32 6
	%86 = load i32, i32* %85, align 4
	%87 = load i32, i32* %0, align 4
	%88 = bitcast %runtime.Source_Code_Location* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %11
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1c0, i64 0, i32 0), i64 62}, i64 520, i64 26, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$1c1, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %11
	call void @workbench.im_draw_flush.set_shader-0(i32 %86, i32 %87, %runtime.Source_Code_Location* %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-11

if.done-11:
	; IfStmt
	%90 = load i8, i8* %6, align 1
	%91 = trunc i8 %90 to i1
	br i1 %91, label %if.then-12, label %if.done-13

if.then-12:
	; SelectorExpr
	%92 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %3, i64 0, i32 7
	%93 = load i32, i32* %92, align 4
	%94 = load i32, i32* %0, align 4
	%95 = bitcast %runtime.Source_Code_Location* %12 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %12
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1c2, i64 0, i32 0), i64 62}, i64 521, i64 26, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$1c3, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %12
	call void @workbench.im_draw_flush.set_texture-1(i32 %93, i32 %94, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-13

if.done-13:
	; IfStmt
	%97 = load i8, i8* %8, align 1
	%98 = trunc i8 %97 to i1
	br i1 %98, label %if.then-14, label %if.done-15

if.then-14:
	; SelectorExpr
	%99 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %3, i64 0, i32 5
	%100 = load void (%runtime.Context*)*, void (%runtime.Context*)** %99, align 8
	call void %100(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-15

if.done-15:
	; IfStmt
	%101 = load i8, i8* %7, align 1
	%102 = trunc i8 %101 to i1
	br i1 %102, label %if.then-16, label %if.done-20

if.then-16:
	; AssignStmt
	; SelectorExpr
	%103 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %3, i64 0, i32 8
	%104 = load i8, i8* %103, align 1
	store i8 %104, i8* @workbench.is_scissor
	; IfStmt
	%105 = load i8, i8* @workbench.is_scissor, align 1
	%106 = trunc i8 %105 to i1
	br i1 %106, label %if.then-17, label %if.else-18

if.then-17:
	; SelectorExpr
	%107 = load void (i32)*, void (i32)** @gl.Enable, align 8
	call ccc void %107(i32 3089)
	; SelectorExpr
	%108 = load void (i32, i32, i32, i32)*, void (i32, i32, i32, i32)** @gl.Scissor, align 8
	; IndexExpr
	; SelectorExpr
	%109 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %3, i64 0, i32 9
	%110 = getelementptr inbounds [4 x i64], [4 x i64]* %109, i64 0, i32 0
	%111 = load i64, i64* %110, align 8
	; IndexExpr
	; SelectorExpr
	%112 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %3, i64 0, i32 9
	%113 = getelementptr inbounds [4 x i64], [4 x i64]* %112, i64 0, i32 1
	%114 = load i64, i64* %113, align 8
	; IndexExpr
	; SelectorExpr
	%115 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %3, i64 0, i32 9
	%116 = getelementptr inbounds [4 x i64], [4 x i64]* %115, i64 0, i32 2
	%117 = load i64, i64* %116, align 8
	; IndexExpr
	; SelectorExpr
	%118 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %3, i64 0, i32 9
	%119 = getelementptr inbounds [4 x i64], [4 x i64]* %118, i64 0, i32 3
	%120 = load i64, i64* %119, align 8
	%121 = trunc i64 %111 to i32
	%122 = trunc i64 %114 to i32
	%123 = trunc i64 %117 to i32
	%124 = trunc i64 %120 to i32
	call ccc void %108(i32 %121, i32 %122, i32 %123, i32 %124)
	br label %if.done-19

if.else-18:
	; SelectorExpr
	%125 = load void (i32)*, void (i32)** @gl.Disable, align 8
	call ccc void %125(i32 3089)
	; SelectorExpr
	%126 = load void (i32, i32, i32, i32)*, void (i32, i32, i32, i32)** @gl.Scissor, align 8
	%127 = load float, float* @workbench.current_window_width, align 4
	%128 = load float, float* @workbench.current_window_height, align 4
	%129 = fptosi float %127 to i32
	%130 = fptosi float %128 to i32
	call ccc void %126(i32 0, i32 0, i32 %129, i32 %130)
	br label %if.done-19

if.done-19:
	br label %if.done-20

if.done-20:
	; vertex
	; CompoundLit
	%131 = bitcast %workbench.Vertex2D* %14 to %..rawptr
	%132 = call %..rawptr @mem.zero(%..rawptr %131, i64 36) noinline
	store %workbench.Vertex2D zeroinitializer, %workbench.Vertex2D* %14
	store %workbench.Vertex2D {[3 x float] zeroinitializer, [2 x float] zeroinitializer, %workbench.Colorf zeroinitializer}, %workbench.Vertex2D* %14
	; SelectorExpr
	%133 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %3, i64 0, i32 2
	%134 = load [3 x float], [3 x float]* %133, align 4
	%135 = getelementptr inbounds %workbench.Vertex2D, %workbench.Vertex2D* %14, i64 0, i32 0
	store [3 x float] %134, [3 x float]* %135
	; SelectorExpr
	%136 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %3, i64 0, i32 3
	%137 = load [2 x float], [2 x float]* %136, align 4
	%138 = getelementptr inbounds %workbench.Vertex2D, %workbench.Vertex2D* %14, i64 0, i32 1
	store [2 x float] %137, [2 x float]* %138
	; SelectorExpr
	%139 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %3, i64 0, i32 4
	%140 = load %workbench.Colorf, %workbench.Colorf* %139, align 4
	%141 = getelementptr inbounds %workbench.Vertex2D, %workbench.Vertex2D* %14, i64 0, i32 2
	store %workbench.Colorf %140, %workbench.Colorf* %141
	%142 = load %workbench.Vertex2D, %workbench.Vertex2D* %14, align 4
	store %workbench.Vertex2D %142, %workbench.Vertex2D* %13
	%143 = load %workbench.Vertex2D, %workbench.Vertex2D* %13, align 4
	%144 = bitcast %workbench.Vertex2D* %15 to %..rawptr
	%145 = call %..rawptr @mem.zero(%..rawptr %144, i64 36) noinline
	store %workbench.Vertex2D zeroinitializer, %workbench.Vertex2D* %15
	store %workbench.Vertex2D %143, %workbench.Vertex2D* %15
	%146 = bitcast %runtime.Source_Code_Location* %16 to %..rawptr
	%147 = call %..rawptr @mem.zero(%..rawptr %146, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %16
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1c4, i64 0, i32 0), i64 62}, i64 536, i64 3, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$1c5, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %16
	%148 = call i64 @runtime.append_elem-17267({%workbench.Vertex2D*, i64, i64, %mem.Allocator}* @workbench.im_queued_for_drawing, %workbench.Vertex2D* %15, %runtime.Source_Code_Location* %16, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-3

for.index.done-21:
	%149 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* @workbench.im_queued_for_drawing, align 8
	%150 = load i32, i32* %0, align 4
	%151 = bitcast {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %17 to %..rawptr
	%152 = call %..rawptr @mem.zero(%..rawptr %151, i64 40) noinline
	store {%workbench.Vertex2D*, i64, i64, %mem.Allocator} zeroinitializer, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %17
	store {%workbench.Vertex2D*, i64, i64, %mem.Allocator} %149, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %17
	%153 = bitcast %runtime.Source_Code_Location* %18 to %..rawptr
	%154 = call %..rawptr @mem.zero(%..rawptr %153, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %18
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1c6, i64 0, i32 0), i64 62}, i64 539, i64 2, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$1c7, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %18
	call void @workbench.draw_vertex_list-17232({%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %17, i32 %150, %runtime.Source_Code_Location* %18, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @runtime.clear_dynamic_array-17239({%workbench.Vertex2D*, i64, i64, %mem.Allocator}* @workbench.im_queued_for_drawing)
	ret void
}

define void @workbench.im_draw_flush.set_shader-0(i32 %program, i32 %mode, %runtime.Source_Code_Location* %location, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i32, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	store i32 %program, i32* %0
	store i32 %mode, i32* %1
	%3 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, align 8
	; AssignStmt
	%4 = load i32, i32* %0, align 4
	store i32 %4, i32* @workbench.current_shader
	%5 = load i32, i32* %0, align 4
	%6 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1c8, i64 0, i32 0), i64 62}, i64 488, i64 3, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$1c9, i64 0, i32 0), i64 10}}, %runtime.Source_Code_Location* %2
	call void @workbench.use_program(i32 %5, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define void @workbench.im_draw_flush.set_texture-1(i32 %texture, i32 %mode, %runtime.Source_Code_Location* %location, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i32, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	store i32 %texture, i32* %0
	store i32 %mode, i32* %1
	%3 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, align 8
	; AssignStmt
	%4 = load i32, i32* %0, align 4
	store i32 %4, i32* @workbench.current_texture
	%5 = load i32, i32* %0, align 4
	%6 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1ca, i64 0, i32 0), i64 62}, i64 493, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$1cb, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %2
	call void @workbench.bind_texture2d(i32 %5, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define i64 @workbench.im_draw_flush$anon-0(%workbench.Buffered_Vertex* %a, %workbench.Buffered_Vertex* %b, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = load %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %a, align 8
	%2 = load %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %b, align 8
	; diff
	; SelectorExpr
	%3 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %a, i64 0, i32 0
	%4 = load i64, i64* %3, align 8
	; SelectorExpr
	%5 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %b, i64 0, i32 0
	%6 = load i64, i64* %5, align 8
	%7 = sub i64 %4, %6
	store i64 %7, i64* %0
	; IfStmt
	%8 = load i64, i64* %0, align 8
	%9 = icmp ne i64 %8, 0
	%10 = zext i1 %9 to i8
	%11 = trunc i8 %10 to i1
	br i1 %11, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%12 = load i64, i64* %0, align 8
	ret i64 %12

if.done-2:
	; ReturnStmt
	; SelectorExpr
	%13 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %a, i64 0, i32 1
	%14 = load i64, i64* %13, align 8
	; SelectorExpr
	%15 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %b, i64 0, i32 1
	%16 = load i64, i64* %15, align 8
	%17 = sub i64 %14, %16
	ret i64 %17
}

define void @workbench.push_debug_vertex(void (%runtime.Context*)* %rendermode, [3 x float]* %a, %workbench.Colorf* %color, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca void (%runtime.Context*)*, align 16
	%1 = alloca %workbench.Buffered_Vertex, align 16
	%2 = alloca %workbench.Buffered_Vertex, align 16
	%3 = alloca %workbench.Buffered_Vertex, align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	store void (%runtime.Context*)* %rendermode, void (%runtime.Context*)** %0
	%5 = load [3 x float], [3 x float]* %a, align 4
	%6 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	; v
	; CompoundLit
	%7 = bitcast %workbench.Buffered_Vertex* %2 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 112) noinline
	store %workbench.Buffered_Vertex zeroinitializer, %workbench.Buffered_Vertex* %2
	store %workbench.Buffered_Vertex {i64 0, i64 zeroinitializer, [3 x float] zeroinitializer, [2 x float] zeroinitializer, %workbench.Colorf zeroinitializer, void (%runtime.Context*)* zeroinitializer, i32 zeroinitializer, i32 zeroinitializer, i8 0, [4 x i64] zeroinitializer}, %workbench.Buffered_Vertex* %2
	%9 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* @workbench.debug_vertices, align 8
	%10 = extractvalue {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} %9, 1
	%11 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %2, i64 0, i32 1
	store i64 %10, i64* %11
	%12 = load [3 x float], [3 x float]* %a, align 4
	%13 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %2, i64 0, i32 2
	store [3 x float] %12, [3 x float]* %13
	%14 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%15 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %2, i64 0, i32 4
	store %workbench.Colorf %14, %workbench.Colorf* %15
	%16 = load void (%runtime.Context*)*, void (%runtime.Context*)** %0, align 8
	%17 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %2, i64 0, i32 5
	store void (%runtime.Context*)* %16, void (%runtime.Context*)** %17
	%18 = load i32, i32* @workbench.shader_rgba, align 4
	%19 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %2, i64 0, i32 6
	store i32 %18, i32* %19
	%20 = call [4 x i64] @workbench.full_screen_scissor_rect(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%21 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %2, i64 0, i32 9
	store [4 x i64] %20, [4 x i64]* %21
	%22 = load %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %2, align 8
	store %workbench.Buffered_Vertex %22, %workbench.Buffered_Vertex* %1
	%23 = load %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %1, align 8
	%24 = bitcast %workbench.Buffered_Vertex* %3 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 112) noinline
	store %workbench.Buffered_Vertex zeroinitializer, %workbench.Buffered_Vertex* %3
	store %workbench.Buffered_Vertex %23, %workbench.Buffered_Vertex* %3
	%26 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1cc, i64 0, i32 0), i64 62}, i64 606, i64 2, %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$1cd, i64 0, i32 0), i64 17}}, %runtime.Source_Code_Location* %4
	%28 = call i64 @runtime.append_elem-17064({%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* @workbench.debug_vertices, %workbench.Buffered_Vertex* %3, %runtime.Source_Code_Location* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define void @workbench.push_debug_line(void (%runtime.Context*)* %rendermode, [3 x float]* %a, [3 x float]* %b, %workbench.Colorf* %color, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca void (%runtime.Context*)*, align 16
	%1 = alloca [3 x float], align 16
	%2 = alloca %workbench.Colorf, align 16
	%3 = alloca [3 x float], align 16
	%4 = alloca %workbench.Colorf, align 16
	store void (%runtime.Context*)* %rendermode, void (%runtime.Context*)** %0
	%5 = load [3 x float], [3 x float]* %a, align 4
	%6 = load [3 x float], [3 x float]* %b, align 4
	%7 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%8 = load void (%runtime.Context*)*, void (%runtime.Context*)** %0, align 8
	%9 = load [3 x float], [3 x float]* %a, align 4
	%10 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%11 = bitcast [3 x float]* %1 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %1
	store [3 x float] %9, [3 x float]* %1
	%13 = bitcast %workbench.Colorf* %2 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %2
	store %workbench.Colorf %10, %workbench.Colorf* %2
	call void @workbench.push_debug_vertex(void (%runtime.Context*)* %8, [3 x float]* %1, %workbench.Colorf* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%15 = load void (%runtime.Context*)*, void (%runtime.Context*)** %0, align 8
	%16 = load [3 x float], [3 x float]* %b, align 4
	%17 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%18 = bitcast [3 x float]* %3 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %3
	store [3 x float] %16, [3 x float]* %3
	%20 = bitcast %workbench.Colorf* %4 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %4
	store %workbench.Colorf %17, %workbench.Colorf* %4
	call void @workbench.push_debug_vertex(void (%runtime.Context*)* %15, [3 x float]* %3, %workbench.Colorf* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define void @workbench.push_debug_box_min_max(void (%runtime.Context*)* %rendermode, [3 x float]* %min, [3 x float]* %max, %workbench.Colorf* %color, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca void (%runtime.Context*)*, align 16
	%1 = alloca [3 x float], align 16
	%2 = alloca [3 x float], align 16
	%3 = alloca [3 x float], align 16
	%4 = alloca [3 x float], align 16
	%5 = alloca %workbench.Colorf, align 16
	%6 = alloca [3 x float], align 16
	%7 = alloca [3 x float], align 16
	%8 = alloca [3 x float], align 16
	%9 = alloca [3 x float], align 16
	%10 = alloca %workbench.Colorf, align 16
	%11 = alloca [3 x float], align 16
	%12 = alloca [3 x float], align 16
	%13 = alloca [3 x float], align 16
	%14 = alloca [3 x float], align 16
	%15 = alloca %workbench.Colorf, align 16
	%16 = alloca [3 x float], align 16
	%17 = alloca [3 x float], align 16
	%18 = alloca [3 x float], align 16
	%19 = alloca [3 x float], align 16
	%20 = alloca %workbench.Colorf, align 16
	store void (%runtime.Context*)* %rendermode, void (%runtime.Context*)** %0
	%21 = load [3 x float], [3 x float]* %min, align 4
	%22 = load [3 x float], [3 x float]* %max, align 4
	%23 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%24 = load void (%runtime.Context*)*, void (%runtime.Context*)** %0, align 8
	; CompoundLit
	%25 = bitcast [3 x float]* %1 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %1
	store [3 x float] [float zeroinitializer, float zeroinitializer, float zeroinitializer], [3 x float]* %1
	; SelectorExpr
	%27 = getelementptr inbounds [3 x float], [3 x float]* %min, i64 0, i32 0
	%28 = load float, float* %27, align 4
	%29 = getelementptr inbounds [3 x float], [3 x float]* %1, i64 0, i32 0
	store float %28, float* %29
	; SelectorExpr
	%30 = getelementptr inbounds [3 x float], [3 x float]* %min, i64 0, i32 1
	%31 = load float, float* %30, align 4
	%32 = getelementptr inbounds [3 x float], [3 x float]* %1, i64 0, i32 1
	store float %31, float* %32
	; SelectorExpr
	%33 = getelementptr inbounds [3 x float], [3 x float]* %min, i64 0, i32 2
	%34 = load float, float* %33, align 4
	%35 = getelementptr inbounds [3 x float], [3 x float]* %1, i64 0, i32 2
	store float %34, float* %35
	%36 = load [3 x float], [3 x float]* %1, align 4
	; CompoundLit
	%37 = bitcast [3 x float]* %2 to %..rawptr
	%38 = call %..rawptr @mem.zero(%..rawptr %37, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %2
	store [3 x float] [float zeroinitializer, float zeroinitializer, float zeroinitializer], [3 x float]* %2
	; SelectorExpr
	%39 = getelementptr inbounds [3 x float], [3 x float]* %min, i64 0, i32 0
	%40 = load float, float* %39, align 4
	%41 = getelementptr inbounds [3 x float], [3 x float]* %2, i64 0, i32 0
	store float %40, float* %41
	; SelectorExpr
	%42 = getelementptr inbounds [3 x float], [3 x float]* %max, i64 0, i32 1
	%43 = load float, float* %42, align 4
	%44 = getelementptr inbounds [3 x float], [3 x float]* %2, i64 0, i32 1
	store float %43, float* %44
	; SelectorExpr
	%45 = getelementptr inbounds [3 x float], [3 x float]* %max, i64 0, i32 2
	%46 = load float, float* %45, align 4
	%47 = getelementptr inbounds [3 x float], [3 x float]* %2, i64 0, i32 2
	store float %46, float* %47
	%48 = load [3 x float], [3 x float]* %2, align 4
	%49 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%50 = bitcast [3 x float]* %3 to %..rawptr
	%51 = call %..rawptr @mem.zero(%..rawptr %50, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %3
	store [3 x float] %36, [3 x float]* %3
	%52 = bitcast [3 x float]* %4 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %4
	store [3 x float] %48, [3 x float]* %4
	%54 = bitcast %workbench.Colorf* %5 to %..rawptr
	%55 = call %..rawptr @mem.zero(%..rawptr %54, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %5
	store %workbench.Colorf %49, %workbench.Colorf* %5
	call void @workbench.push_debug_line(void (%runtime.Context*)* %24, [3 x float]* %3, [3 x float]* %4, %workbench.Colorf* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%56 = load void (%runtime.Context*)*, void (%runtime.Context*)** %0, align 8
	; CompoundLit
	%57 = bitcast [3 x float]* %6 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %6
	store [3 x float] [float zeroinitializer, float zeroinitializer, float zeroinitializer], [3 x float]* %6
	; SelectorExpr
	%59 = getelementptr inbounds [3 x float], [3 x float]* %min, i64 0, i32 0
	%60 = load float, float* %59, align 4
	%61 = getelementptr inbounds [3 x float], [3 x float]* %6, i64 0, i32 0
	store float %60, float* %61
	; SelectorExpr
	%62 = getelementptr inbounds [3 x float], [3 x float]* %max, i64 0, i32 1
	%63 = load float, float* %62, align 4
	%64 = getelementptr inbounds [3 x float], [3 x float]* %6, i64 0, i32 1
	store float %63, float* %64
	; SelectorExpr
	%65 = getelementptr inbounds [3 x float], [3 x float]* %max, i64 0, i32 2
	%66 = load float, float* %65, align 4
	%67 = getelementptr inbounds [3 x float], [3 x float]* %6, i64 0, i32 2
	store float %66, float* %67
	%68 = load [3 x float], [3 x float]* %6, align 4
	; CompoundLit
	%69 = bitcast [3 x float]* %7 to %..rawptr
	%70 = call %..rawptr @mem.zero(%..rawptr %69, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %7
	store [3 x float] [float zeroinitializer, float zeroinitializer, float zeroinitializer], [3 x float]* %7
	; SelectorExpr
	%71 = getelementptr inbounds [3 x float], [3 x float]* %max, i64 0, i32 0
	%72 = load float, float* %71, align 4
	%73 = getelementptr inbounds [3 x float], [3 x float]* %7, i64 0, i32 0
	store float %72, float* %73
	; SelectorExpr
	%74 = getelementptr inbounds [3 x float], [3 x float]* %max, i64 0, i32 1
	%75 = load float, float* %74, align 4
	%76 = getelementptr inbounds [3 x float], [3 x float]* %7, i64 0, i32 1
	store float %75, float* %76
	; SelectorExpr
	%77 = getelementptr inbounds [3 x float], [3 x float]* %max, i64 0, i32 2
	%78 = load float, float* %77, align 4
	%79 = getelementptr inbounds [3 x float], [3 x float]* %7, i64 0, i32 2
	store float %78, float* %79
	%80 = load [3 x float], [3 x float]* %7, align 4
	%81 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%82 = bitcast [3 x float]* %8 to %..rawptr
	%83 = call %..rawptr @mem.zero(%..rawptr %82, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %8
	store [3 x float] %68, [3 x float]* %8
	%84 = bitcast [3 x float]* %9 to %..rawptr
	%85 = call %..rawptr @mem.zero(%..rawptr %84, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %9
	store [3 x float] %80, [3 x float]* %9
	%86 = bitcast %workbench.Colorf* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %10
	store %workbench.Colorf %81, %workbench.Colorf* %10
	call void @workbench.push_debug_line(void (%runtime.Context*)* %56, [3 x float]* %8, [3 x float]* %9, %workbench.Colorf* %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%88 = load void (%runtime.Context*)*, void (%runtime.Context*)** %0, align 8
	; CompoundLit
	%89 = bitcast [3 x float]* %11 to %..rawptr
	%90 = call %..rawptr @mem.zero(%..rawptr %89, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %11
	store [3 x float] [float zeroinitializer, float zeroinitializer, float zeroinitializer], [3 x float]* %11
	; SelectorExpr
	%91 = getelementptr inbounds [3 x float], [3 x float]* %max, i64 0, i32 0
	%92 = load float, float* %91, align 4
	%93 = getelementptr inbounds [3 x float], [3 x float]* %11, i64 0, i32 0
	store float %92, float* %93
	; SelectorExpr
	%94 = getelementptr inbounds [3 x float], [3 x float]* %max, i64 0, i32 1
	%95 = load float, float* %94, align 4
	%96 = getelementptr inbounds [3 x float], [3 x float]* %11, i64 0, i32 1
	store float %95, float* %96
	; SelectorExpr
	%97 = getelementptr inbounds [3 x float], [3 x float]* %max, i64 0, i32 2
	%98 = load float, float* %97, align 4
	%99 = getelementptr inbounds [3 x float], [3 x float]* %11, i64 0, i32 2
	store float %98, float* %99
	%100 = load [3 x float], [3 x float]* %11, align 4
	; CompoundLit
	%101 = bitcast [3 x float]* %12 to %..rawptr
	%102 = call %..rawptr @mem.zero(%..rawptr %101, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %12
	store [3 x float] [float zeroinitializer, float zeroinitializer, float zeroinitializer], [3 x float]* %12
	; SelectorExpr
	%103 = getelementptr inbounds [3 x float], [3 x float]* %max, i64 0, i32 0
	%104 = load float, float* %103, align 4
	%105 = getelementptr inbounds [3 x float], [3 x float]* %12, i64 0, i32 0
	store float %104, float* %105
	; SelectorExpr
	%106 = getelementptr inbounds [3 x float], [3 x float]* %min, i64 0, i32 1
	%107 = load float, float* %106, align 4
	%108 = getelementptr inbounds [3 x float], [3 x float]* %12, i64 0, i32 1
	store float %107, float* %108
	; SelectorExpr
	%109 = getelementptr inbounds [3 x float], [3 x float]* %min, i64 0, i32 2
	%110 = load float, float* %109, align 4
	%111 = getelementptr inbounds [3 x float], [3 x float]* %12, i64 0, i32 2
	store float %110, float* %111
	%112 = load [3 x float], [3 x float]* %12, align 4
	%113 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%114 = bitcast [3 x float]* %13 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %13
	store [3 x float] %100, [3 x float]* %13
	%116 = bitcast [3 x float]* %14 to %..rawptr
	%117 = call %..rawptr @mem.zero(%..rawptr %116, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %14
	store [3 x float] %112, [3 x float]* %14
	%118 = bitcast %workbench.Colorf* %15 to %..rawptr
	%119 = call %..rawptr @mem.zero(%..rawptr %118, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %15
	store %workbench.Colorf %113, %workbench.Colorf* %15
	call void @workbench.push_debug_line(void (%runtime.Context*)* %88, [3 x float]* %13, [3 x float]* %14, %workbench.Colorf* %15, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%120 = load void (%runtime.Context*)*, void (%runtime.Context*)** %0, align 8
	; CompoundLit
	%121 = bitcast [3 x float]* %16 to %..rawptr
	%122 = call %..rawptr @mem.zero(%..rawptr %121, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %16
	store [3 x float] [float zeroinitializer, float zeroinitializer, float zeroinitializer], [3 x float]* %16
	; SelectorExpr
	%123 = getelementptr inbounds [3 x float], [3 x float]* %max, i64 0, i32 0
	%124 = load float, float* %123, align 4
	%125 = getelementptr inbounds [3 x float], [3 x float]* %16, i64 0, i32 0
	store float %124, float* %125
	; SelectorExpr
	%126 = getelementptr inbounds [3 x float], [3 x float]* %min, i64 0, i32 1
	%127 = load float, float* %126, align 4
	%128 = getelementptr inbounds [3 x float], [3 x float]* %16, i64 0, i32 1
	store float %127, float* %128
	; SelectorExpr
	%129 = getelementptr inbounds [3 x float], [3 x float]* %min, i64 0, i32 2
	%130 = load float, float* %129, align 4
	%131 = getelementptr inbounds [3 x float], [3 x float]* %16, i64 0, i32 2
	store float %130, float* %131
	%132 = load [3 x float], [3 x float]* %16, align 4
	; CompoundLit
	%133 = bitcast [3 x float]* %17 to %..rawptr
	%134 = call %..rawptr @mem.zero(%..rawptr %133, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %17
	store [3 x float] [float zeroinitializer, float zeroinitializer, float zeroinitializer], [3 x float]* %17
	; SelectorExpr
	%135 = getelementptr inbounds [3 x float], [3 x float]* %min, i64 0, i32 0
	%136 = load float, float* %135, align 4
	%137 = getelementptr inbounds [3 x float], [3 x float]* %17, i64 0, i32 0
	store float %136, float* %137
	; SelectorExpr
	%138 = getelementptr inbounds [3 x float], [3 x float]* %min, i64 0, i32 1
	%139 = load float, float* %138, align 4
	%140 = getelementptr inbounds [3 x float], [3 x float]* %17, i64 0, i32 1
	store float %139, float* %140
	; SelectorExpr
	%141 = getelementptr inbounds [3 x float], [3 x float]* %min, i64 0, i32 2
	%142 = load float, float* %141, align 4
	%143 = getelementptr inbounds [3 x float], [3 x float]* %17, i64 0, i32 2
	store float %142, float* %143
	%144 = load [3 x float], [3 x float]* %17, align 4
	%145 = load %workbench.Colorf, %workbench.Colorf* %color, align 4
	%146 = bitcast [3 x float]* %18 to %..rawptr
	%147 = call %..rawptr @mem.zero(%..rawptr %146, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %18
	store [3 x float] %132, [3 x float]* %18
	%148 = bitcast [3 x float]* %19 to %..rawptr
	%149 = call %..rawptr @mem.zero(%..rawptr %148, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %19
	store [3 x float] %144, [3 x float]* %19
	%150 = bitcast %workbench.Colorf* %20 to %..rawptr
	%151 = call %..rawptr @mem.zero(%..rawptr %150, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %20
	store %workbench.Colorf %145, %workbench.Colorf* %20
	call void @workbench.push_debug_line(void (%runtime.Context*)* %120, [3 x float]* %18, [3 x float]* %19, %workbench.Colorf* %20, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define void @workbench.draw_debug_lines(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %runtime.Source_Code_Location, align 16
	%1 = alloca {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, align 16
	%2 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* @workbench.debug_vertices, align 8
	%3 = extractvalue {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} %2, 1
	%4 = srem i64 %3, 2
	%5 = icmp eq i64 %4, 0
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	%8 = bitcast %runtime.Source_Code_Location* %0 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %0
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1ce, i64 0, i32 0), i64 62}, i64 629, i64 2, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$1cf, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %0
	%10 = call i8 @runtime.assert(i1 %7, %..string zeroinitializer, %runtime.Source_Code_Location* %0) alwaysinline
	%11 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* @workbench.debug_vertices, align 8
	%12 = bitcast {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %1 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 40) noinline
	store {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} zeroinitializer, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %1
	store {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} %11, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %1
	call void @workbench.im_draw_flush(i32 1, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define i64 @workbench.create_mesh({%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %verts, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %workbench.Mesh, align 16
	%2 = alloca %workbench.Mesh, align 16
	%3 = alloca %runtime.Map_Header, align 16
	%4 = alloca %runtime.Map_Key, align 16
	%5 = alloca %workbench.Mesh, align 16
	%6 = alloca %runtime.Map_Header, align 16
	%7 = alloca %runtime.Map_Key, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	%9 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %verts, align 8
	; id
	%10 = load i64, i64* @workbench.cur_mesh_id, align 8
	store i64 %10, i64* %0
	; AssignStmt
	%11 = load i64, i64* @workbench.cur_mesh_id, align 8
	%12 = add i64 %11, 1
	store i64 %12, i64* @workbench.cur_mesh_id
	; mesh
	; CompoundLit
	%13 = bitcast %workbench.Mesh* %2 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 40) noinline
	store %workbench.Mesh zeroinitializer, %workbench.Mesh* %2
	store %workbench.Mesh {{%workbench.Vertex3D*, i64, i64, %mem.Allocator} zeroinitializer}, %workbench.Mesh* %2
	%15 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %verts, align 8
	%16 = getelementptr inbounds %workbench.Mesh, %workbench.Mesh* %2, i64 0, i32 0
	store {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %15, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %16
	%17 = load %workbench.Mesh, %workbench.Mesh* %2, align 8
	store %workbench.Mesh %17, %workbench.Mesh* %1
	; AssignStmt
	; IndexExpr
	%18 = load i64, i64* %0, align 8
	%19 = load %workbench.Mesh, %workbench.Mesh* %1, align 8
	%20 = bitcast %runtime.Map_Header* %3 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %3
	%22 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %3, i64 0, i32 0
	%23 = bitcast {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench.Mesh}*, i64, i64, %mem.Allocator}}* @workbench.all_meshes to %mem.Raw_Map*
	store %mem.Raw_Map* %23, %mem.Raw_Map** %22
	%24 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %3, i64 0, i32 2
	store i64 72, i64* %24
	%25 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %3, i64 0, i32 3
	store i64 8, i64* %25
	%26 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %3, i64 0, i32 4
	store i64 32, i64* %26
	%27 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %3, i64 0, i32 5
	store i64 40, i64* %27
	%28 = load %runtime.Map_Header, %runtime.Map_Header* %3, align 8
	%29 = bitcast %runtime.Map_Key* %4 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %4
	%31 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %4, i64 0, i32 0
	%32 = bitcast i64 %18 to i64
	store i64 %32, i64* %31
	%33 = load %runtime.Map_Key, %runtime.Map_Key* %4, align 8
	%34 = bitcast %workbench.Mesh* %5 to %..rawptr
	%35 = call %..rawptr @mem.zero(%..rawptr %34, i64 40) noinline
	store %workbench.Mesh zeroinitializer, %workbench.Mesh* %5
	store %workbench.Mesh %19, %workbench.Mesh* %5
	%36 = bitcast %workbench.Mesh* %5 to %..rawptr
	%37 = bitcast %runtime.Map_Header* %6 to %..rawptr
	%38 = call %..rawptr @mem.zero(%..rawptr %37, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %6
	store %runtime.Map_Header %28, %runtime.Map_Header* %6
	%39 = bitcast %runtime.Map_Key* %7 to %..rawptr
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %7
	store %runtime.Map_Key %33, %runtime.Map_Key* %7
	%41 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 0, i64 0, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$1d0, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %8
	call void @runtime.__dynamic_map_set(%runtime.Map_Header* %6, %runtime.Map_Key* %7, %..rawptr %36, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%43 = load i64, i64* %0, align 8
	ret i64 %43
}

define {i64*, i64, i64, %mem.Allocator} @workbench.load_asset(i8* %path, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i8*, align 16
	%1 = alloca %assimp.aiScene*, align 16
	%2 = alloca i64, align 16
	%3 = alloca {i64*, i64, i64, %mem.Allocator}, align 16
	%4 = alloca %mem.Allocator, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca {%assimp.aiMesh**, i64}, align 16
	%7 = alloca %assimp.aiMesh*, align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	%10 = alloca {%assimp.aiVector3D*, i64}, align 16
	%11 = alloca {%assimp.aiVector3D*, i64}, align 16
	%12 = alloca {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, align 16
	%13 = alloca %mem.Allocator, align 16
	%14 = alloca %runtime.Source_Code_Location, align 16
	%15 = alloca i32, align 16
	%16 = alloca i32, align 16
	%17 = alloca i64, align 16
	%18 = alloca %assimp.aiVector3D, align 16
	%19 = alloca %assimp.aiVector3D, align 16
	%20 = alloca float, align 16
	%21 = alloca float, align 16
	%22 = alloca float, align 16
	%23 = alloca %workbench.Vertex3D, align 16
	%24 = alloca %workbench.Vertex3D, align 16
	%25 = alloca [3 x float], align 16
	%26 = alloca %workbench.Colorf, align 16
	%27 = alloca [3 x float], align 16
	%28 = alloca %workbench.Vertex3D, align 16
	%29 = alloca %runtime.Source_Code_Location, align 16
	%30 = alloca {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, align 16
	%31 = alloca %runtime.Source_Code_Location, align 16
	store i8* %path, i8** %0
	; scene
	; SelectorExpr
	%32 = load i8*, i8** %0, align 8
	%33 = call ccc %assimp.aiScene* @aiImportFile(i8* %32, i32 16809993)
	store %assimp.aiScene* %33, %assimp.aiScene** %1
	; DeferStmt
	; mesh_count
	; SelectorExpr
	%34 = load %assimp.aiScene*, %assimp.aiScene** %1, align 8
	%35 = getelementptr inbounds %assimp.aiScene, %assimp.aiScene* %34, i64 0
	%36 = getelementptr inbounds %assimp.aiScene, %assimp.aiScene* %35, i64 0, i32 2
	%37 = load i32, i32* %36, align 4
	%38 = zext i32 %37 to i64
	store i64 %38, i64* %2
	; mesh_ids
	%39 = load i64, i64* %2, align 8
	; SelectorExpr
	%40 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%41 = load %mem.Allocator, %mem.Allocator* %40, align 8
	%42 = bitcast %mem.Allocator* %4 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %4
	store %mem.Allocator %41, %mem.Allocator* %4
	%44 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$1d1, i64 0, i32 0), i64 65}, i64 52, i64 14, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$1d2, i64 0, i32 0), i64 10}}, %runtime.Source_Code_Location* %5
	%46 = call {i64*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len-17443(i64 %39, %mem.Allocator* %4, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i64*, i64, i64, %mem.Allocator} %46, {i64*, i64, i64, %mem.Allocator}* %3
	; meshes
	; SelectorExpr
	; SelectorExpr
	%47 = load %assimp.aiScene*, %assimp.aiScene** %1, align 8
	%48 = getelementptr inbounds %assimp.aiScene, %assimp.aiScene* %47, i64 0
	%49 = getelementptr inbounds %assimp.aiScene, %assimp.aiScene* %48, i64 0, i32 3
	%50 = load %assimp.aiMesh**, %assimp.aiMesh*** %49, align 8
	; SelectorExpr
	%51 = load %assimp.aiScene*, %assimp.aiScene** %1, align 8
	%52 = getelementptr inbounds %assimp.aiScene, %assimp.aiScene* %51, i64 0
	%53 = getelementptr inbounds %assimp.aiScene, %assimp.aiScene* %52, i64 0, i32 2
	%54 = load i32, i32* %53, align 4
	%55 = zext i32 %54 to i64
	%56 = call {%assimp.aiMesh**, i64} @mem.slice_ptr-17469(%assimp.aiMesh** %50, i64 %55)
	store {%assimp.aiMesh**, i64} %56, {%assimp.aiMesh**, i64}* %6
	; RangeStmt
	; mesh
	%57 = bitcast %assimp.aiMesh** %7 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 8) noinline
	store %assimp.aiMesh* zeroinitializer, %assimp.aiMesh** %7
	%59 = load {%assimp.aiMesh**, i64}, {%assimp.aiMesh**, i64}* %6, align 8
	%60 = bitcast i64* %8 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 8) noinline
	store i64 zeroinitializer, i64* %8
	%62 = extractvalue {%assimp.aiMesh**, i64} %59, 1
	store i64 %62, i64* %8
	%63 = bitcast i64* %9 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 8) noinline
	store i64 zeroinitializer, i64* %9
	store i64 -1, i64* %9
	br label %for.index.loop-1

for.index.loop-1:
	%65 = load i64, i64* %9, align 8
	%66 = add i64 %65, 1
	store i64 %66, i64* %9
	%67 = load i64, i64* %8, align 8
	%68 = icmp slt i64 %66, %67
	br i1 %68, label %for.index.body-2, label %for.index.done-6

for.index.body-2:
	%69 = load i64, i64* %9, align 8
	%70 = extractvalue {%assimp.aiMesh**, i64} %59, 0
	%71 = getelementptr inbounds %assimp.aiMesh*, %assimp.aiMesh** %70, i64 %69
	%72 = load %assimp.aiMesh*, %assimp.aiMesh** %71, align 8
	store %assimp.aiMesh* %72, %assimp.aiMesh** %7
	; verts
	; SelectorExpr
	; SelectorExpr
	%73 = load %assimp.aiMesh*, %assimp.aiMesh** %7, align 8
	%74 = getelementptr inbounds %assimp.aiMesh, %assimp.aiMesh* %73, i64 0
	%75 = getelementptr inbounds %assimp.aiMesh, %assimp.aiMesh* %74, i64 0, i32 3
	%76 = load %assimp.aiVector3D*, %assimp.aiVector3D** %75, align 8
	; SelectorExpr
	%77 = load %assimp.aiMesh*, %assimp.aiMesh** %7, align 8
	%78 = getelementptr inbounds %assimp.aiMesh, %assimp.aiMesh* %77, i64 0
	%79 = getelementptr inbounds %assimp.aiMesh, %assimp.aiMesh* %78, i64 0, i32 1
	%80 = load i32, i32* %79, align 4
	%81 = zext i32 %80 to i64
	%82 = call {%assimp.aiVector3D*, i64} @mem.slice_ptr-17476(%assimp.aiVector3D* %76, i64 %81)
	store {%assimp.aiVector3D*, i64} %82, {%assimp.aiVector3D*, i64}* %10
	; norms
	; SelectorExpr
	; SelectorExpr
	%83 = load %assimp.aiMesh*, %assimp.aiMesh** %7, align 8
	%84 = getelementptr inbounds %assimp.aiMesh, %assimp.aiMesh* %83, i64 0
	%85 = getelementptr inbounds %assimp.aiMesh, %assimp.aiMesh* %84, i64 0, i32 4
	%86 = load %assimp.aiVector3D*, %assimp.aiVector3D** %85, align 8
	; SelectorExpr
	%87 = load %assimp.aiMesh*, %assimp.aiMesh** %7, align 8
	%88 = getelementptr inbounds %assimp.aiMesh, %assimp.aiMesh* %87, i64 0
	%89 = getelementptr inbounds %assimp.aiMesh, %assimp.aiMesh* %88, i64 0, i32 1
	%90 = load i32, i32* %89, align 4
	%91 = zext i32 %90 to i64
	%92 = call {%assimp.aiVector3D*, i64} @mem.slice_ptr-17476(%assimp.aiVector3D* %86, i64 %91)
	store {%assimp.aiVector3D*, i64} %92, {%assimp.aiVector3D*, i64}* %11
	; processedVerts
	; SelectorExpr
	%93 = load %assimp.aiMesh*, %assimp.aiMesh** %7, align 8
	%94 = getelementptr inbounds %assimp.aiMesh, %assimp.aiMesh* %93, i64 0
	%95 = getelementptr inbounds %assimp.aiMesh, %assimp.aiMesh* %94, i64 0, i32 1
	%96 = load i32, i32* %95, align 4
	; SelectorExpr
	%97 = load %assimp.aiMesh*, %assimp.aiMesh** %7, align 8
	%98 = getelementptr inbounds %assimp.aiMesh, %assimp.aiMesh* %97, i64 0
	%99 = getelementptr inbounds %assimp.aiMesh, %assimp.aiMesh* %98, i64 0, i32 1
	%100 = load i32, i32* %99, align 4
	; SelectorExpr
	%101 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%102 = load %mem.Allocator, %mem.Allocator* %101, align 8
	%103 = zext i32 %96 to i64
	%104 = zext i32 %100 to i64
	%105 = bitcast %mem.Allocator* %13 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %13
	store %mem.Allocator %102, %mem.Allocator* %13
	%107 = bitcast %runtime.Source_Code_Location* %14 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %14
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$1d3, i64 0, i32 0), i64 65}, i64 60, i64 21, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$1d4, i64 0, i32 0), i64 10}}, %runtime.Source_Code_Location* %14
	%109 = call {%workbench.Vertex3D*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-17527(i64 %103, i64 %104, %mem.Allocator* %13, %runtime.Source_Code_Location* %14, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %109, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %12
	; RangeStmt
	; i
	%110 = bitcast i32* %15 to %..rawptr
	%111 = call %..rawptr @mem.zero(%..rawptr %110, i64 4) noinline
	store i32 zeroinitializer, i32* %15
	%112 = bitcast i32* %16 to %..rawptr
	%113 = call %..rawptr @mem.zero(%..rawptr %112, i64 4) noinline
	store i32 zeroinitializer, i32* %16
	store i32 0, i32* %16
	%114 = bitcast i64* %17 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 8) noinline
	store i64 zeroinitializer, i64* %17
	store i64 0, i64* %17
	br label %for.interval.loop-3

for.interval.loop-3:
	; SelectorExpr
	%116 = load %assimp.aiMesh*, %assimp.aiMesh** %7, align 8
	%117 = getelementptr inbounds %assimp.aiMesh, %assimp.aiMesh* %116, i64 0
	%118 = getelementptr inbounds %assimp.aiMesh, %assimp.aiMesh* %117, i64 0, i32 1
	%119 = load i32, i32* %118, align 4
	%120 = sub i32 %119, 1
	%121 = load i32, i32* %16, align 4
	%122 = icmp ule i32 %121, %120
	br i1 %122, label %for.interval.body-4, label %for.interval.done-5

for.interval.body-4:
	%123 = load i32, i32* %16, align 4
	%124 = load i64, i64* %17, align 8
	%125 = load i32, i32* %16, align 4
	%126 = add i32 %125, 1
	store i32 %126, i32* %16
	%127 = load i64, i64* %17, align 8
	%128 = add i64 %127, 1
	store i64 %128, i64* %17
	store i32 %123, i32* %15
	; normal
	; IndexExpr
	%129 = load {%assimp.aiVector3D*, i64}, {%assimp.aiVector3D*, i64}* %11, align 8
	%130 = extractvalue {%assimp.aiVector3D*, i64} %129, 0
	%131 = load i32, i32* %15, align 4
	%132 = zext i32 %131 to i64
	%133 = extractvalue {%assimp.aiVector3D*, i64} %129, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$1d5, i64 0, i32 0), i64 65}, i64 64, i64 20, i64 %132, i64 %133)
	%134 = getelementptr inbounds %assimp.aiVector3D, %assimp.aiVector3D* %130, i64 %132
	%135 = load %assimp.aiVector3D, %assimp.aiVector3D* %134, align 4
	store %assimp.aiVector3D %135, %assimp.aiVector3D* %18
	; position
	; IndexExpr
	%136 = load {%assimp.aiVector3D*, i64}, {%assimp.aiVector3D*, i64}* %10, align 8
	%137 = extractvalue {%assimp.aiVector3D*, i64} %136, 0
	%138 = load i32, i32* %15, align 4
	%139 = zext i32 %138 to i64
	%140 = extractvalue {%assimp.aiVector3D*, i64} %136, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$1d6, i64 0, i32 0), i64 65}, i64 65, i64 22, i64 %139, i64 %140)
	%141 = getelementptr inbounds %assimp.aiVector3D, %assimp.aiVector3D* %137, i64 %139
	%142 = load %assimp.aiVector3D, %assimp.aiVector3D* %141, align 4
	store %assimp.aiVector3D %142, %assimp.aiVector3D* %19
	; r
	%143 = load i32, i32* %15, align 4
	%144 = uitofp i32 %143 to float
	%145 = load {%assimp.aiVector3D*, i64}, {%assimp.aiVector3D*, i64}* %10, align 8
	%146 = extractvalue {%assimp.aiVector3D*, i64} %145, 1
	%147 = sitofp i64 %146 to float
	%148 = fdiv float %144, %147
	%149 = fmul float %148, 0x3fe8000000000000
	%150 = fadd float %149, 0x3fd0000000000000
	store float %150, float* %20
	; g
	store float 0x0000000000000000, float* %21
	; b
	store float 0x0000000000000000, float* %22
	; vert
	; CompoundLit
	%151 = bitcast %workbench.Vertex3D* %24 to %..rawptr
	%152 = call %..rawptr @mem.zero(%..rawptr %151, i64 48) noinline
	store %workbench.Vertex3D zeroinitializer, %workbench.Vertex3D* %24
	store %workbench.Vertex3D {[3 x float] zeroinitializer, [2 x float] [float 0x0000000000000000, float 0x0000000000000000], %workbench.Colorf zeroinitializer, [3 x float] zeroinitializer}, %workbench.Vertex3D* %24
	; CompoundLit
	%153 = bitcast [3 x float]* %25 to %..rawptr
	%154 = call %..rawptr @mem.zero(%..rawptr %153, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %25
	store [3 x float] [float zeroinitializer, float zeroinitializer, float zeroinitializer], [3 x float]* %25
	; SelectorExpr
	%155 = getelementptr inbounds %assimp.aiVector3D, %assimp.aiVector3D* %19, i64 0, i32 0
	%156 = load float, float* %155, align 4
	%157 = getelementptr inbounds [3 x float], [3 x float]* %25, i64 0, i32 0
	store float %156, float* %157
	; SelectorExpr
	%158 = getelementptr inbounds %assimp.aiVector3D, %assimp.aiVector3D* %19, i64 0, i32 1
	%159 = load float, float* %158, align 4
	%160 = getelementptr inbounds [3 x float], [3 x float]* %25, i64 0, i32 1
	store float %159, float* %160
	; SelectorExpr
	%161 = getelementptr inbounds %assimp.aiVector3D, %assimp.aiVector3D* %19, i64 0, i32 2
	%162 = load float, float* %161, align 4
	%163 = getelementptr inbounds [3 x float], [3 x float]* %25, i64 0, i32 2
	store float %162, float* %163
	%164 = load [3 x float], [3 x float]* %25, align 4
	%165 = getelementptr inbounds %workbench.Vertex3D, %workbench.Vertex3D* %24, i64 0, i32 0
	store [3 x float] %164, [3 x float]* %165
	; CompoundLit
	%166 = bitcast %workbench.Colorf* %26 to %..rawptr
	%167 = call %..rawptr @mem.zero(%..rawptr %166, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %26
	store %workbench.Colorf {float zeroinitializer, float zeroinitializer, float zeroinitializer, float 0x3ff0000000000000}, %workbench.Colorf* %26
	%168 = load float, float* %20, align 4
	%169 = getelementptr inbounds %workbench.Colorf, %workbench.Colorf* %26, i64 0, i32 0
	store float %168, float* %169
	%170 = load float, float* %21, align 4
	%171 = getelementptr inbounds %workbench.Colorf, %workbench.Colorf* %26, i64 0, i32 1
	store float %170, float* %171
	%172 = load float, float* %22, align 4
	%173 = getelementptr inbounds %workbench.Colorf, %workbench.Colorf* %26, i64 0, i32 2
	store float %172, float* %173
	%174 = load %workbench.Colorf, %workbench.Colorf* %26, align 4
	%175 = getelementptr inbounds %workbench.Vertex3D, %workbench.Vertex3D* %24, i64 0, i32 2
	store %workbench.Colorf %174, %workbench.Colorf* %175
	; CompoundLit
	%176 = bitcast [3 x float]* %27 to %..rawptr
	%177 = call %..rawptr @mem.zero(%..rawptr %176, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %27
	store [3 x float] [float zeroinitializer, float zeroinitializer, float zeroinitializer], [3 x float]* %27
	; SelectorExpr
	%178 = getelementptr inbounds %assimp.aiVector3D, %assimp.aiVector3D* %18, i64 0, i32 0
	%179 = load float, float* %178, align 4
	%180 = getelementptr inbounds [3 x float], [3 x float]* %27, i64 0, i32 0
	store float %179, float* %180
	; SelectorExpr
	%181 = getelementptr inbounds %assimp.aiVector3D, %assimp.aiVector3D* %18, i64 0, i32 1
	%182 = load float, float* %181, align 4
	%183 = getelementptr inbounds [3 x float], [3 x float]* %27, i64 0, i32 1
	store float %182, float* %183
	; SelectorExpr
	%184 = getelementptr inbounds %assimp.aiVector3D, %assimp.aiVector3D* %18, i64 0, i32 2
	%185 = load float, float* %184, align 4
	%186 = getelementptr inbounds [3 x float], [3 x float]* %27, i64 0, i32 2
	store float %185, float* %186
	%187 = load [3 x float], [3 x float]* %27, align 4
	%188 = getelementptr inbounds %workbench.Vertex3D, %workbench.Vertex3D* %24, i64 0, i32 3
	store [3 x float] %187, [3 x float]* %188
	%189 = load %workbench.Vertex3D, %workbench.Vertex3D* %24, align 4
	store %workbench.Vertex3D %189, %workbench.Vertex3D* %23
	%190 = load %workbench.Vertex3D, %workbench.Vertex3D* %23, align 4
	%191 = bitcast %workbench.Vertex3D* %28 to %..rawptr
	%192 = call %..rawptr @mem.zero(%..rawptr %191, i64 48) noinline
	store %workbench.Vertex3D zeroinitializer, %workbench.Vertex3D* %28
	store %workbench.Vertex3D %190, %workbench.Vertex3D* %28
	%193 = bitcast %runtime.Source_Code_Location* %29 to %..rawptr
	%194 = call %..rawptr @mem.zero(%..rawptr %193, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %29
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$1d7, i64 0, i32 0), i64 65}, i64 77, i64 4, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$1d8, i64 0, i32 0), i64 10}}, %runtime.Source_Code_Location* %29
	%195 = call i64 @runtime.append_elem-17568({%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %12, %workbench.Vertex3D* %28, %runtime.Source_Code_Location* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-3

for.interval.done-5:
	%196 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %12, align 8
	%197 = bitcast {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %30 to %..rawptr
	%198 = call %..rawptr @mem.zero(%..rawptr %197, i64 40) noinline
	store {%workbench.Vertex3D*, i64, i64, %mem.Allocator} zeroinitializer, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %30
	store {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %196, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %30
	%199 = call i64 @workbench.create_mesh({%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %30, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%200 = bitcast %runtime.Source_Code_Location* %31 to %..rawptr
	%201 = call %..rawptr @mem.zero(%..rawptr %200, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %31
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$1d9, i64 0, i32 0), i64 65}, i64 80, i64 3, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$1da, i64 0, i32 0), i64 10}}, %runtime.Source_Code_Location* %31
	%202 = call i64 @runtime.append_elem-17600({i64*, i64, i64, %mem.Allocator}* %3, i64 %199, %runtime.Source_Code_Location* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-1

for.index.done-6:
	; ReturnStmt
	%203 = load {i64*, i64, i64, %mem.Allocator}, {i64*, i64, i64, %mem.Allocator}* %3, align 8
	; defer
	; SelectorExpr
	%204 = load %assimp.aiScene*, %assimp.aiScene** %1, align 8
	call ccc void @aiReleaseImport(%assimp.aiScene* %204)
	ret {i64*, i64, i64, %mem.Allocator} %203
}

define void @workbench.model_matrix_position([3 x float]* %position, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca [4 x [4 x float]], align 16
	%1 = alloca [3 x float], align 16
	%2 = load [3 x float], [3 x float]* %position, align 4
	; AssignStmt
	%3 = call [4 x [4 x float]] @math.identity-15829(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%4 = load [3 x float], [3 x float]* %position, align 4
	%5 = bitcast [4 x [4 x float]]* %0 to %..rawptr
	%6 = call %..rawptr @mem.zero(%..rawptr %5, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %0
	store [4 x [4 x float]] %3, [4 x [4 x float]]* %0
	%7 = bitcast [3 x float]* %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %1
	store [3 x float] %4, [3 x float]* %1
	%9 = call [4 x [4 x float]] @workbench.translate([4 x [4 x float]]* %0, [3 x float]* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	store [4 x [4 x float]] %9, [4 x [4 x float]]* @workbench.model_matrix
	ret void
}

define void @workbench.draw_mesh(i64 %id, [3 x float]* %position, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %workbench.Mesh, align 16
	%2 = alloca i8, align 16
	%3 = alloca {%workbench.Mesh, i8}, align 16
	%4 = alloca %runtime.Map_Header, align 16
	%5 = alloca %runtime.Map_Key, align 16
	%6 = alloca %runtime.Map_Header, align 16
	%7 = alloca %runtime.Map_Key, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	%9 = alloca [3 x float], align 16
	%10 = alloca {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, align 16
	%11 = alloca %runtime.Source_Code_Location, align 16
	store i64 %id, i64* %0
	%12 = load [3 x float], [3 x float]* %position, align 4
	%13 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; mesh
	; ok
	; IndexExpr
	%14 = load i64, i64* %0, align 8
	%15 = bitcast {%workbench.Mesh, i8}* %3 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 48) noinline
	store {%workbench.Mesh, i8} zeroinitializer, {%workbench.Mesh, i8}* %3
	%17 = bitcast %runtime.Map_Header* %4 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %4
	%19 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %4, i64 0, i32 0
	%20 = bitcast {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench.Mesh}*, i64, i64, %mem.Allocator}}* @workbench.all_meshes to %mem.Raw_Map*
	store %mem.Raw_Map* %20, %mem.Raw_Map** %19
	%21 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %4, i64 0, i32 2
	store i64 72, i64* %21
	%22 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %4, i64 0, i32 3
	store i64 8, i64* %22
	%23 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %4, i64 0, i32 4
	store i64 32, i64* %23
	%24 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %4, i64 0, i32 5
	store i64 40, i64* %24
	%25 = load %runtime.Map_Header, %runtime.Map_Header* %4, align 8
	%26 = bitcast %runtime.Map_Key* %5 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %5
	%28 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %5, i64 0, i32 0
	%29 = bitcast i64 %14 to i64
	store i64 %29, i64* %28
	%30 = load %runtime.Map_Key, %runtime.Map_Key* %5, align 8
	%31 = bitcast %runtime.Map_Header* %6 to %..rawptr
	%32 = call %..rawptr @mem.zero(%..rawptr %31, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %6
	store %runtime.Map_Header %25, %runtime.Map_Header* %6
	%33 = bitcast %runtime.Map_Key* %7 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %7
	store %runtime.Map_Key %30, %runtime.Map_Key* %7
	%35 = call %..rawptr @runtime.__dynamic_map_get(%runtime.Map_Header* %6, %runtime.Map_Key* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%36 = icmp ne %..rawptr %35, null
	%37 = zext i1 %36 to i8
	%38 = getelementptr inbounds {%workbench.Mesh, i8}, {%workbench.Mesh, i8}* %3, i64 0, i32 1
	store i8 %37, i8* %38
	%39 = trunc i8 %37 to i1
	br i1 %39, label %map.get.then-1, label %map.get.done-2

map.get.then-1:
	%40 = getelementptr inbounds {%workbench.Mesh, i8}, {%workbench.Mesh, i8}* %3, i64 0, i32 0
	%41 = bitcast %..rawptr %35 to %workbench.Mesh*
	%42 = load %workbench.Mesh, %workbench.Mesh* %41, align 8
	store %workbench.Mesh %42, %workbench.Mesh* %40
	br label %map.get.done-2

map.get.done-2:
	%43 = load {%workbench.Mesh, i8}, {%workbench.Mesh, i8}* %3, align 8
	%44 = extractvalue {%workbench.Mesh, i8} %43, 0
	%45 = extractvalue {%workbench.Mesh, i8} %43, 1
	store %workbench.Mesh %44, %workbench.Mesh* %1
	store i8 %45, i8* %2
	%46 = load i8, i8* %2, align 1
	%47 = trunc i8 %46 to i1
	%48 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%49 = call %..rawptr @mem.zero(%..rawptr %48, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$1db, i64 0, i32 0), i64 65}, i64 98, i64 2, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$1dc, i64 0, i32 0), i64 9}}, %runtime.Source_Code_Location* %8
	%50 = call i8 @runtime.assert(i1 %47, %..string zeroinitializer, %runtime.Source_Code_Location* %8)
	%51 = load [3 x float], [3 x float]* %position, align 4
	%52 = bitcast [3 x float]* %9 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %9
	store [3 x float] %51, [3 x float]* %9
	call void @workbench.model_matrix_position([3 x float]* %9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @workbench.rendermode_world(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%54 = getelementptr inbounds %workbench.Mesh, %workbench.Mesh* %1, i64 0, i32 0
	%55 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %54, align 8
	%56 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%57 = bitcast {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %10 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 40) noinline
	store {%workbench.Vertex3D*, i64, i64, %mem.Allocator} zeroinitializer, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %10
	store {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %55, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %10
	%59 = bitcast %runtime.Source_Code_Location* %11 to %..rawptr
	%60 = call %..rawptr @mem.zero(%..rawptr %59, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %11
	store %runtime.Source_Code_Location %56, %runtime.Source_Code_Location* %11
	call void @workbench.draw_vertex_list-17636({%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %10, i32 4, %runtime.Source_Code_Location* %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @workbench.make_simple_window(%..string %window_name, i64 %window_width, i64 %window_height, i64 %opengl_version_major, i64 %opengl_version_minor, float %_target_framerate, %workbench.Scene* %scene, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca float, align 16
	%6 = alloca float, align 16
	%7 = alloca %workbench.Scene, align 16
	%8 = alloca double, align 16
	%9 = alloca float, align 16
	%10 = alloca %..string, align 16
	%11 = alloca %..any, align 16
	%12 = alloca %..any, align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca [2 x %..any], align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca %runtime.Source_Code_Location, align 16
	%17 = alloca %runtime.Source_Code_Location, align 16
	%18 = alloca double, align 16
	store %..string %window_name, %..string* %0
	store i64 %window_width, i64* %1
	store i64 %window_height, i64* %2
	store i64 %opengl_version_major, i64* %3
	store i64 %opengl_version_minor, i64* %4
	store float %_target_framerate, float* %5
	%19 = load %workbench.Scene, %workbench.Scene* %scene, align 8
	; AssignStmt
	%20 = load float, float* %5, align 4
	store float %20, float* @workbench.client_target_framerate
	%21 = load %..string, %..string* %0, align 8
	%22 = load i64, i64* %1, align 8
	%23 = load i64, i64* %2, align 8
	%24 = load i64, i64* %3, align 8
	%25 = load i64, i64* %4, align 8
	call void @workbench._init_glfw(%..string %21, i64 %22, i64 %23, i64 %24, i64 %25, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%26 = load i64, i64* %3, align 8
	%27 = load i64, i64* %4, align 8
	call void @workbench._init_opengl(i64 %26, i64 %27, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @workbench._init_random_number_generator(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @workbench._init_dear_imgui(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; acc
	%28 = bitcast float* %6 to %..rawptr
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 4) noinline
	store float zeroinitializer, float* %6
	; AssignStmt
	%30 = load float, float* @workbench.client_target_framerate, align 4
	%31 = fdiv float 0x3ff0000000000000, %30
	store float %31, float* @workbench.client_target_delta_time
	%32 = load %workbench.Scene, %workbench.Scene* %scene, align 8
	%33 = bitcast %workbench.Scene* %7 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 48) noinline
	store %workbench.Scene zeroinitializer, %workbench.Scene* %7
	store %workbench.Scene %32, %workbench.Scene* %7
	%35 = call i64 @workbench.start_scene(%workbench.Scene* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ForStmt
	br label %for.loop-1

for.loop-1:
	; SelectorExpr
	%36 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	%37 = call i8 @glfw.WindowShouldClose(%..rawptr %36, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%38 = trunc i8 %37 to i1
	br i1 %38, label %for.done-11, label %cmp.and-2

cmp.and-2:
	%39 = load i8, i8* @workbench.wb_should_close, align 1
	%40 = trunc i8 %39 to i1
	br i1 %40, label %for.done-11, label %for.body-3

for.body-3:
	; frame_start
	; SelectorExpr
	%41 = call ccc double @glfwGetTime()
	store double %41, double* %8
	; DeferStmt
	; last_time
	%42 = load float, float* @workbench.time, align 4
	store float %42, float* %9
	; AssignStmt
	; SelectorExpr
	%43 = call ccc double @glfwGetTime()
	%44 = fptrunc double %43 to float
	store float %44, float* @workbench.time
	; AssignStmt
	%45 = load float, float* @workbench.time, align 4
	%46 = load float, float* %9, align 4
	%47 = fsub float %45, %46
	store float %47, float* @workbench.lossy_delta_time
	; AssignStmt
	%48 = load float, float* @workbench.lossy_delta_time, align 4
	%49 = load float, float* %6, align 4
	%50 = fadd float %49, %48
	store float %50, float* %6
	; IfStmt
	%51 = load float, float* %6, align 4
	%52 = load float, float* @workbench.client_target_delta_time, align 4
	%53 = fcmp oge float %51, %52
	%54 = zext i1 %53 to i8
	%55 = trunc i8 %54 to i1
	br i1 %55, label %if.then-4, label %if.done-10

if.then-4:
	; ForStmt
	br label %for.body-5

for.body-5:
	; IfStmt
	%56 = load i8, i8* @workbench.do_log_frame_boundaries, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %if.then-6, label %if.done-7

if.then-6:
	%58 = load i64, i64* @workbench.frame_count, align 8
	%59 = bitcast %..string* %10 to %..rawptr
	%60 = call %..rawptr @mem.zero(%..rawptr %59, i64 16) noinline
	store %..string zeroinitializer, %..string* %10
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$1dd, i64 0, i32 0), i64 12}, %..string* %10
	%61 = load %..string, %..string* %10, align 8
	%62 = bitcast %..any* %11 to %..rawptr
	%63 = call %..rawptr @mem.zero(%..rawptr %62, i64 16) noinline
	store %..any zeroinitializer, %..any* %11
	%64 = bitcast %..string* %10 to %..rawptr
	%65 = getelementptr inbounds %..any, %..any* %11, i64 0, i32 0
	store %..rawptr %64, %..rawptr* %65
	%66 = getelementptr inbounds %..any, %..any* %11, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %66
	%67 = load %..any, %..any* %11, align 8
	%68 = bitcast %..any* %12 to %..rawptr
	%69 = call %..rawptr @mem.zero(%..rawptr %68, i64 16) noinline
	store %..any zeroinitializer, %..any* %12
	%70 = bitcast i64* @workbench.frame_count to %..rawptr
	%71 = getelementptr inbounds %..any, %..any* %12, i64 0, i32 0
	store %..rawptr %70, %..rawptr* %71
	%72 = getelementptr inbounds %..any, %..any* %12, i64 0, i32 1
	store %..typeid 72057594037927943, %..typeid* %72
	%73 = load %..any, %..any* %12, align 8
	; variadic call argument generation
	%74 = bitcast {%..any*, i64}* %13 to %..rawptr
	%75 = call %..rawptr @mem.zero(%..rawptr %74, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	%76 = bitcast [2 x %..any]* %14 to %..rawptr
	%77 = call %..rawptr @mem.zero(%..rawptr %76, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %14
	%78 = getelementptr inbounds [2 x %..any], [2 x %..any]* %14, i64 0, i32 0
	store %..any %67, %..any* %78
	%79 = getelementptr inbounds [2 x %..any], [2 x %..any]* %14, i64 0, i32 1
	store %..any %73, %..any* %79
	%80 = getelementptr inbounds [2 x %..any], [2 x %..any]* %14, i64 0, i32 0
	%81 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %13, i64 0, i32 0
	store %..any* %80, %..any** %81
	%82 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %13, i64 0, i32 1
	store i64 2, i64* %82
	%83 = load {%..any*, i64}, {%..any*, i64}* %13, align 8
	%84 = bitcast {%..any*, i64}* %15 to %..rawptr
	%85 = call %..rawptr @mem.zero(%..rawptr %84, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	store {%..any*, i64} %83, {%..any*, i64}* %15
	%86 = bitcast %runtime.Source_Code_Location* %16 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %16
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$1de, i64 0, i32 0), i64 60}, i64 68, i64 6, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$1df, i64 0, i32 0), i64 18}}, %runtime.Source_Code_Location* %16
	call void @workbench.logln({%..any*, i64}* %15, %runtime.Source_Code_Location* %16, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-7

if.done-7:
	; AssignStmt
	%88 = load i64, i64* @workbench.frame_count, align 8
	%89 = add i64 %88, 1
	store i64 %89, i64* @workbench.frame_count
	call void @workbench.imgui_begin_new_frame(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%90 = load %imgui.Font*, %imgui.Font** @workbench.imgui_font_default, align 8
	call ccc void @igPushFont(%imgui.Font* %90)
	call void @workbench._update_catalog(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @workbench._update_renderer(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @workbench._update_glfw(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @workbench._update_input(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @workbench._update_tween(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @workbench._update_ui(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @workbench._update_debug_window(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @workbench._update_scenes(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @workbench._late_update_ui(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	call ccc void @igPopFont()
	; AssignStmt
	%91 = load float, float* @workbench.client_target_delta_time, align 4
	%92 = load float, float* %6, align 4
	%93 = fsub float %92, %91
	store float %93, float* %6
	; IfStmt
	%94 = load float, float* %6, align 4
	%95 = load float, float* @workbench.client_target_delta_time, align 4
	%96 = fcmp oge float %94, %95
	%97 = zext i1 %96 to i8
	%98 = trunc i8 %97 to i1
	br i1 %98, label %if.then-8, label %if.else-9

if.then-8:
	call void @workbench.imgui_render(i1 false, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.body-5

if.else-9:
	; break
	br label %if.done-10

if.done-10:
	call void @workbench._render_scenes(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @workbench.imgui_render(i1 true, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%99 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	call ccc void @glfwSwapBuffers(%..rawptr %99)
	; SelectorExpr
	%100 = load void ()*, void ()** @gl.Finish, align 8
	call ccc void %100()
	%101 = bitcast %runtime.Source_Code_Location* %17 to %..rawptr
	%102 = call %..rawptr @mem.zero(%..rawptr %101, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %17
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$1e0, i64 0, i32 0), i64 60}, i64 110, i64 3, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$1e1, i64 0, i32 0), i64 18}}, %runtime.Source_Code_Location* %17
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$1e2, i64 0, i32 0), i64 19}, %runtime.Source_Code_Location* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; defer
	; frame_end
	; SelectorExpr
	%103 = call ccc double @glfwGetTime()
	store double %103, double* %18
	%104 = load double, double* %18, align 8
	%105 = load double, double* %8, align 8
	%106 = fsub double %104, %105
	call void @workbench.rolling_average_push_sample-17819(%"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* @workbench.whole_frame_time_ra, double %106, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.loop-1

for.done-11:
	ret void
}

define void @workbench.exit(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	; AssignStmt
	store i8 1, i8* @workbench.wb_should_close
	ret void
}

define i64 @workbench.start_scene(%workbench.Scene* %scene, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %workbench._Scene_Internal, align 16
	%2 = alloca %workbench._Scene_Internal, align 16
	%3 = alloca %workbench._Scene_Internal, align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	%5 = load %workbench.Scene, %workbench.Scene* %scene, align 8
	; id
	%6 = load i64, i64* @workbench.cur_scene_serial, align 8
	%7 = bitcast i64 %6 to i64
	%8 = bitcast i64 %7 to i64
	store i64 %8, i64* %0
	; AssignStmt
	%9 = load i64, i64* @workbench.cur_scene_serial, align 8
	%10 = add i64 %9, 1
	store i64 %10, i64* @workbench.cur_scene_serial
	; scene_internal
	; CompoundLit
	%11 = bitcast %workbench._Scene_Internal* %2 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 56) noinline
	store %workbench._Scene_Internal zeroinitializer, %workbench._Scene_Internal* %2
	store %workbench._Scene_Internal {%workbench.Scene zeroinitializer, i64 zeroinitializer}, %workbench._Scene_Internal* %2
	%13 = load %workbench.Scene, %workbench.Scene* %scene, align 8
	%14 = getelementptr inbounds %workbench._Scene_Internal, %workbench._Scene_Internal* %2, i64 0, i32 0
	store %workbench.Scene %13, %workbench.Scene* %14
	%15 = load i64, i64* %0, align 8
	%16 = getelementptr inbounds %workbench._Scene_Internal, %workbench._Scene_Internal* %2, i64 0, i32 1
	store i64 %15, i64* %16
	%17 = load %workbench._Scene_Internal, %workbench._Scene_Internal* %2, align 8
	store %workbench._Scene_Internal %17, %workbench._Scene_Internal* %1
	%18 = load %workbench._Scene_Internal, %workbench._Scene_Internal* %1, align 8
	%19 = bitcast %workbench._Scene_Internal* %3 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 56) noinline
	store %workbench._Scene_Internal zeroinitializer, %workbench._Scene_Internal* %3
	store %workbench._Scene_Internal %18, %workbench._Scene_Internal* %3
	%21 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$1e3, i64 0, i32 0), i64 60}, i64 145, i64 2, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$1e4, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %4
	%23 = call i64 @runtime.append_elem-17835({%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* @workbench.new_scenes, %workbench._Scene_Internal* %3, %runtime.Source_Code_Location* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%24 = load i64, i64* %0, align 8
	ret i64 %24
}

define void @workbench._update_scenes(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %workbench._Scene_Internal, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Map_Header, align 16
	%3 = alloca %runtime.Map_Key, align 16
	%4 = alloca %workbench._Scene_Internal, align 16
	%5 = alloca %runtime.Map_Header, align 16
	%6 = alloca %runtime.Map_Key, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca i64, align 16
	%9 = alloca %workbench._Scene_Internal, align 16
	%10 = alloca i64, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	; RangeStmt
	; scene
	%14 = bitcast %workbench._Scene_Internal* %0 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 56) noinline
	store %workbench._Scene_Internal zeroinitializer, %workbench._Scene_Internal* %0
	%16 = getelementptr inbounds {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* @workbench.new_scenes, i64 0, i32 1
	%17 = bitcast i64* %1 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 8) noinline
	store i64 zeroinitializer, i64* %1
	store i64 -1, i64* %1
	br label %for.index.loop-1

for.index.loop-1:
	%19 = load i64, i64* %1, align 8
	%20 = add i64 %19, 1
	store i64 %20, i64* %1
	%21 = load i64, i64* %16, align 8
	%22 = icmp slt i64 %20, %21
	br i1 %22, label %for.index.body-2, label %for.index.done-5

for.index.body-2:
	%23 = load i64, i64* %1, align 8
	%24 = getelementptr inbounds {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* @workbench.new_scenes, i64 0, i32 0
	%25 = load %workbench._Scene_Internal*, %workbench._Scene_Internal** %24, align 8
	%26 = getelementptr inbounds %workbench._Scene_Internal, %workbench._Scene_Internal* %25, i64 %23
	%27 = load %workbench._Scene_Internal, %workbench._Scene_Internal* %26, align 8
	store %workbench._Scene_Internal %27, %workbench._Scene_Internal* %0
	; IfStmt
	; SelectorExpr
	%28 = getelementptr inbounds %workbench._Scene_Internal, %workbench._Scene_Internal* %0, i64 0, i32 0
	%29 = getelementptr inbounds %workbench.Scene, %workbench.Scene* %28, i64 0, i32 1
	%30 = load void (%runtime.Context*)*, void (%runtime.Context*)** %29, align 8
	%31 = icmp ne void (%runtime.Context*)* %30, zeroinitializer
	%32 = zext i1 %31 to i8
	%33 = trunc i8 %32 to i1
	br i1 %33, label %if.then-3, label %if.done-4

if.then-3:
	; SelectorExpr
	%34 = getelementptr inbounds %workbench._Scene_Internal, %workbench._Scene_Internal* %0, i64 0, i32 0
	%35 = getelementptr inbounds %workbench.Scene, %workbench.Scene* %34, i64 0, i32 1
	%36 = load void (%runtime.Context*)*, void (%runtime.Context*)** %35, align 8
	call void %36(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%37 = getelementptr inbounds %workbench._Scene_Internal, %workbench._Scene_Internal* %0, i64 0, i32 1
	%38 = load i64, i64* %37, align 8
	%39 = load %workbench._Scene_Internal, %workbench._Scene_Internal* %0, align 8
	%40 = bitcast %runtime.Map_Header* %2 to %..rawptr
	%41 = call %..rawptr @mem.zero(%..rawptr %40, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %2
	%42 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %2, i64 0, i32 0
	%43 = bitcast {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}* @workbench.all_scenes to %mem.Raw_Map*
	store %mem.Raw_Map* %43, %mem.Raw_Map** %42
	%44 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %2, i64 0, i32 2
	store i64 88, i64* %44
	%45 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %2, i64 0, i32 3
	store i64 8, i64* %45
	%46 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %2, i64 0, i32 4
	store i64 32, i64* %46
	%47 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %2, i64 0, i32 5
	store i64 56, i64* %47
	%48 = load %runtime.Map_Header, %runtime.Map_Header* %2, align 8
	%49 = bitcast %runtime.Map_Key* %3 to %..rawptr
	%50 = call %..rawptr @mem.zero(%..rawptr %49, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %3
	%51 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %3, i64 0, i32 0
	%52 = bitcast i64 %38 to i64
	store i64 %52, i64* %51
	%53 = load %runtime.Map_Key, %runtime.Map_Key* %3, align 8
	%54 = bitcast %workbench._Scene_Internal* %4 to %..rawptr
	%55 = call %..rawptr @mem.zero(%..rawptr %54, i64 56) noinline
	store %workbench._Scene_Internal zeroinitializer, %workbench._Scene_Internal* %4
	store %workbench._Scene_Internal %39, %workbench._Scene_Internal* %4
	%56 = bitcast %workbench._Scene_Internal* %4 to %..rawptr
	%57 = bitcast %runtime.Map_Header* %5 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %5
	store %runtime.Map_Header %48, %runtime.Map_Header* %5
	%59 = bitcast %runtime.Map_Key* %6 to %..rawptr
	%60 = call %..rawptr @mem.zero(%..rawptr %59, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %6
	store %runtime.Map_Key %53, %runtime.Map_Key* %6
	%61 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%62 = call %..rawptr @mem.zero(%..rawptr %61, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 0, i64 0, %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$1e5, i64 0, i32 0), i64 14}}, %runtime.Source_Code_Location* %7
	call void @runtime.__dynamic_map_set(%runtime.Map_Header* %5, %runtime.Map_Key* %6, %..rawptr %56, %runtime.Source_Code_Location* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-1

for.index.done-5:
	call void @runtime.clear_dynamic_array-17894({%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* @workbench.new_scenes)
	; RangeStmt
	; id
	%63 = bitcast i64* %8 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 8) noinline
	store i64 zeroinitializer, i64* %8
	; scene
	%65 = bitcast %workbench._Scene_Internal* %9 to %..rawptr
	%66 = call %..rawptr @mem.zero(%..rawptr %65, i64 56) noinline
	store %workbench._Scene_Internal zeroinitializer, %workbench._Scene_Internal* %9
	%67 = getelementptr inbounds {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}, {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}* @workbench.all_scenes, i64 0, i32 1
	%68 = getelementptr inbounds {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}* %67, i64 0, i32 1
	%69 = bitcast i64* %10 to %..rawptr
	%70 = call %..rawptr @mem.zero(%..rawptr %69, i64 8) noinline
	store i64 zeroinitializer, i64* %10
	store i64 -1, i64* %10
	br label %for.index.loop-6

for.index.loop-6:
	%71 = load i64, i64* %10, align 8
	%72 = add i64 %71, 1
	store i64 %72, i64* %10
	%73 = load i64, i64* %68, align 8
	%74 = icmp slt i64 %72, %73
	br i1 %74, label %for.index.body-7, label %for.index.done-10

for.index.body-7:
	%75 = load i64, i64* %10, align 8
	%76 = bitcast i64* %11 to %..rawptr
	%77 = call %..rawptr @mem.zero(%..rawptr %76, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	%78 = getelementptr inbounds {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}, {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}* @workbench.all_scenes, i64 0, i32 1
	%79 = getelementptr inbounds {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}* %78, i64 0, i32 0
	%80 = load {%runtime.Map_Key, i64, %workbench._Scene_Internal}*, {%runtime.Map_Key, i64, %workbench._Scene_Internal}** %79, align 8
	%81 = getelementptr inbounds {%runtime.Map_Key, i64, %workbench._Scene_Internal}, {%runtime.Map_Key, i64, %workbench._Scene_Internal}* %80, i64 %75
	%82 = getelementptr inbounds {%runtime.Map_Key, i64, %workbench._Scene_Internal}, {%runtime.Map_Key, i64, %workbench._Scene_Internal}* %81, i64 0, i32 2
	%83 = load %workbench._Scene_Internal, %workbench._Scene_Internal* %82, align 8
	%84 = getelementptr inbounds {%runtime.Map_Key, i64, %workbench._Scene_Internal}, {%runtime.Map_Key, i64, %workbench._Scene_Internal}* %81, i64 0, i32 0
	%85 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %84, i64 0, i32 0
	%86 = bitcast i64* %85 to i64*
	%87 = load i64, i64* %86, align 8
	store i64 %87, i64* %11
	%88 = load i64, i64* %11, align 8
	store i64 %88, i64* %8
	store %workbench._Scene_Internal %83, %workbench._Scene_Internal* %9
	; IfStmt
	; SelectorExpr
	%89 = getelementptr inbounds %workbench._Scene_Internal, %workbench._Scene_Internal* %9, i64 0, i32 0
	%90 = getelementptr inbounds %workbench.Scene, %workbench.Scene* %89, i64 0, i32 2
	%91 = load void (float, %runtime.Context*)*, void (float, %runtime.Context*)** %90, align 8
	%92 = icmp ne void (float, %runtime.Context*)* %91, zeroinitializer
	%93 = zext i1 %92 to i8
	%94 = trunc i8 %93 to i1
	br i1 %94, label %if.then-8, label %if.done-9

if.then-8:
	; SelectorExpr
	%95 = getelementptr inbounds %workbench._Scene_Internal, %workbench._Scene_Internal* %9, i64 0, i32 0
	%96 = getelementptr inbounds %workbench.Scene, %workbench.Scene* %95, i64 0, i32 2
	%97 = load void (float, %runtime.Context*)*, void (float, %runtime.Context*)** %96, align 8
	%98 = load float, float* @workbench.client_target_delta_time, align 4
	call void %97(float %98, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-9

if.done-9:
	br label %for.index.loop-6

for.index.done-10:
	; RangeStmt
	; id
	%99 = bitcast i64* %12 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%101 = getelementptr inbounds {i64*, i64, i64, %mem.Allocator}, {i64*, i64, i64, %mem.Allocator}* @workbench.end_scenes, i64 0, i32 1
	%102 = bitcast i64* %13 to %..rawptr
	%103 = call %..rawptr @mem.zero(%..rawptr %102, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-11

for.index.loop-11:
	%104 = load i64, i64* %13, align 8
	%105 = add i64 %104, 1
	store i64 %105, i64* %13
	%106 = load i64, i64* %101, align 8
	%107 = icmp slt i64 %105, %106
	br i1 %107, label %for.index.body-12, label %for.index.done-13

for.index.body-12:
	%108 = load i64, i64* %13, align 8
	%109 = getelementptr inbounds {i64*, i64, i64, %mem.Allocator}, {i64*, i64, i64, %mem.Allocator}* @workbench.end_scenes, i64 0, i32 0
	%110 = load i64*, i64** %109, align 8
	%111 = getelementptr inbounds i64, i64* %110, i64 %108
	%112 = load i64, i64* %111, align 8
	store i64 %112, i64* %12
	%113 = load i64, i64* %12, align 8
	call void @runtime.delete_key-17924({{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}* @workbench.all_scenes, i64 %113, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-11

for.index.done-13:
	call void @runtime.clear_dynamic_array-17894({%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* @workbench.new_scenes)
	ret void
}

define void @workbench._render_scenes(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %workbench._Scene_Internal, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %workbench.Scene, align 16
	; RangeStmt
	; id
	%5 = bitcast i64* %0 to %..rawptr
	%6 = call %..rawptr @mem.zero(%..rawptr %5, i64 8) noinline
	store i64 zeroinitializer, i64* %0
	; scene
	%7 = bitcast %workbench._Scene_Internal* %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 56) noinline
	store %workbench._Scene_Internal zeroinitializer, %workbench._Scene_Internal* %1
	%9 = getelementptr inbounds {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}, {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}* @workbench.all_scenes, i64 0, i32 1
	%10 = getelementptr inbounds {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}* %9, i64 0, i32 1
	%11 = bitcast i64* %2 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	store i64 -1, i64* %2
	br label %for.index.loop-1

for.index.loop-1:
	%13 = load i64, i64* %2, align 8
	%14 = add i64 %13, 1
	store i64 %14, i64* %2
	%15 = load i64, i64* %10, align 8
	%16 = icmp slt i64 %14, %15
	br i1 %16, label %for.index.body-2, label %for.index.done-3

for.index.body-2:
	%17 = load i64, i64* %2, align 8
	%18 = bitcast i64* %3 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%20 = getelementptr inbounds {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}, {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}* @workbench.all_scenes, i64 0, i32 1
	%21 = getelementptr inbounds {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}* %20, i64 0, i32 0
	%22 = load {%runtime.Map_Key, i64, %workbench._Scene_Internal}*, {%runtime.Map_Key, i64, %workbench._Scene_Internal}** %21, align 8
	%23 = getelementptr inbounds {%runtime.Map_Key, i64, %workbench._Scene_Internal}, {%runtime.Map_Key, i64, %workbench._Scene_Internal}* %22, i64 %17
	%24 = getelementptr inbounds {%runtime.Map_Key, i64, %workbench._Scene_Internal}, {%runtime.Map_Key, i64, %workbench._Scene_Internal}* %23, i64 0, i32 2
	%25 = load %workbench._Scene_Internal, %workbench._Scene_Internal* %24, align 8
	%26 = getelementptr inbounds {%runtime.Map_Key, i64, %workbench._Scene_Internal}, {%runtime.Map_Key, i64, %workbench._Scene_Internal}* %23, i64 0, i32 0
	%27 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %26, i64 0, i32 0
	%28 = bitcast i64* %27 to i64*
	%29 = load i64, i64* %28, align 8
	store i64 %29, i64* %3
	%30 = load i64, i64* %3, align 8
	store i64 %30, i64* %0
	store %workbench._Scene_Internal %25, %workbench._Scene_Internal* %1
	%31 = load %workbench._Scene_Internal, %workbench._Scene_Internal* %1, align 8
	; cast - polymorphism
	%32 = extractvalue %workbench._Scene_Internal %31, 0
	%33 = bitcast %workbench.Scene* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 48) noinline
	store %workbench.Scene zeroinitializer, %workbench.Scene* %4
	store %workbench.Scene %32, %workbench.Scene* %4
	call void @workbench.render_scene(%workbench.Scene* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-1

for.index.done-3:
	ret void
}

define void @workbench._update_debug_window(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %workbench.WB_Debug_Data, align 16
	%1 = alloca %workbench.WB_Debug_Data, align 16
	; IfStmt
	%2 = call i8 @workbench.get_key_down(i32 290, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = trunc i8 %2 to i1
	br i1 %3, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	%4 = load i8, i8* @workbench.debug_window_open, align 1
	%5 = icmp eq i8 %4, 0
	%6 = zext i1 %5 to i8
	store i8 %6, i8* @workbench.debug_window_open
	br label %if.done-2

if.done-2:
	; IfStmt
	%7 = load i8, i8* @workbench.debug_window_open, align 1
	%8 = trunc i8 %7 to i1
	br i1 %8, label %if.then-3, label %if.done-6

if.then-3:
	; data
	; CompoundLit
	%9 = bitcast %workbench.WB_Debug_Data* %1 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 40) noinline
	store %workbench.WB_Debug_Data zeroinitializer, %workbench.WB_Debug_Data* %1
	store %workbench.WB_Debug_Data {[3 x float] zeroinitializer, double zeroinitializer, float zeroinitializer, float zeroinitializer, i32 zeroinitializer}, %workbench.WB_Debug_Data* %1
	%11 = load [3 x float], [3 x float]* @workbench.camera_position, align 4
	%12 = getelementptr inbounds %workbench.WB_Debug_Data, %workbench.WB_Debug_Data* %1, i64 0, i32 0
	store [3 x float] %11, [3 x float]* %12
	%13 = call double @workbench.rolling_average_get_value-17951(%"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* @workbench.whole_frame_time_ra, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%14 = fmul double %13, 0x408f400000000000
	%15 = getelementptr inbounds %workbench.WB_Debug_Data, %workbench.WB_Debug_Data* %1, i64 0, i32 1
	store double %14, double* %15
	%16 = load float, float* @workbench.client_target_delta_time, align 4
	%17 = getelementptr inbounds %workbench.WB_Debug_Data, %workbench.WB_Debug_Data* %1, i64 0, i32 2
	store float %16, float* %17
	%18 = load float, float* @workbench.client_target_framerate, align 4
	%19 = getelementptr inbounds %workbench.WB_Debug_Data, %workbench.WB_Debug_Data* %1, i64 0, i32 3
	store float %18, float* %19
	%20 = load i32, i32* @workbench.num_draw_calls, align 4
	%21 = getelementptr inbounds %workbench.WB_Debug_Data, %workbench.WB_Debug_Data* %1, i64 0, i32 4
	store i32 %20, i32* %21
	%22 = load %workbench.WB_Debug_Data, %workbench.WB_Debug_Data* %1, align 8
	store %workbench.WB_Debug_Data %22, %workbench.WB_Debug_Data* %0
	; IfStmt
	; SelectorExpr
	%23 = call i8 @imgui.begin(%..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$1e6, i64 0, i32 0), i64 5}, i8* zeroinitializer, i32 0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%24 = trunc i8 %23 to i1
	br i1 %24, label %if.then-4, label %if.done-5

if.then-4:
	; DeferStmt
	call void @workbench.imgui_struct-17955(%workbench.WB_Debug_Data* %0, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$1e7, i64 0, i32 0), i64 13}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%25 = call i8 @imgui.checkbox(%..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$1e8, i64 0, i32 0), i64 15}, i8* @workbench.debugging_rendering, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%26 = call i8 @imgui.checkbox(%..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$1e9, i64 0, i32 0), i64 8}, i8* @workbench.debugging_ui, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%27 = call i8 @imgui.checkbox(%..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$1ea, i64 0, i32 0), i64 20}, i8* @workbench.do_log_frame_boundaries, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%28 = load i32, i32* @workbench.num_draw_calls, align 4
	%29 = call ccc i8 @igSliderInt(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$1eb, i64 0, i32 0), i32* @workbench.debugging_rendering_max_draw_calls, i32 -1, i32 %28, i8* zeroinitializer)
	; defer
	; SelectorExpr
	call ccc void @igEnd()
	br label %if.done-5

if.done-5:
	br label %if.done-6

if.done-6:
	ret void
}

define void @workbench._init_opengl(i64 %opengl_version_major, i64 %opengl_version_minor, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i8, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store i64 %opengl_version_major, i64* %0
	store i64 %opengl_version_minor, i64* %1
	; SelectorExpr
	%9 = load i64, i64* %0, align 8
	%10 = load i64, i64* %1, align 8
	%11 = bitcast void (%..rawptr, i8*, %runtime.Context*)* @workbench._init_opengl$anon-1 to void (%..rawptr, i8*, %runtime.Context*)*
	call void @gl.load_up_to(i64 %9, i64 %10, void (%..rawptr, i8*, %runtime.Context*)* %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	%12 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$1ec, i64 0, i32 0), i64 60}, i64 26, i64 8, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$1ed, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %2
	%14 = call i32 @workbench.gen_vao(%runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %14, i32* @workbench.vao
	; AssignStmt
	%15 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$1ee, i64 0, i32 0), i64 60}, i64 27, i64 8, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$1ef, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %3
	%17 = call i32 @workbench.gen_vbo(%runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %17, i32* @workbench.vbo
	; ok
	%18 = bitcast i8* %4 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 1) noinline
	store i8 zeroinitializer, i8* %4
	; AssignStmt
	%20 = call {i32, i8} @workbench.load_shader_text(%..string {i8* getelementptr inbounds ([460 x i8], [460 x i8]* @str$1f0, i64 0, i32 0), i64 459}, %..string {i8* getelementptr inbounds ([105 x i8], [105 x i8]* @str$1f1, i64 0, i32 0), i64 104}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = extractvalue {i32, i8} %20, 0
	%22 = extractvalue {i32, i8} %20, 1
	store i32 %21, i32* @workbench.shader_rgba
	store i8 %22, i8* %4
	%23 = load i8, i8* %4, align 1
	%24 = trunc i8 %23 to i1
	%25 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$1f2, i64 0, i32 0), i64 60}, i64 31, i64 2, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$1f3, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %5
	%27 = call i8 @runtime.assert(i1 %24, %..string zeroinitializer, %runtime.Source_Code_Location* %5)
	; AssignStmt
	%28 = call {i32, i8} @workbench.load_shader_text(%..string {i8* getelementptr inbounds ([511 x i8], [511 x i8]* @str$1f4, i64 0, i32 0), i64 510}, %..string {i8* getelementptr inbounds ([194 x i8], [194 x i8]* @str$1f5, i64 0, i32 0), i64 193}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%29 = extractvalue {i32, i8} %28, 0
	%30 = extractvalue {i32, i8} %28, 1
	store i32 %29, i32* @workbench.shader_texture
	store i8 %30, i8* %4
	%31 = load i8, i8* %4, align 1
	%32 = trunc i8 %31 to i1
	%33 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$1f6, i64 0, i32 0), i64 60}, i64 33, i64 2, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$1f7, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %6
	%35 = call i8 @runtime.assert(i1 %32, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; AssignStmt
	%36 = call {i32, i8} @workbench.load_shader_text(%..string {i8* getelementptr inbounds ([511 x i8], [511 x i8]* @str$1f8, i64 0, i32 0), i64 510}, %..string {i8* getelementptr inbounds ([420 x i8], [420 x i8]* @str$1f9, i64 0, i32 0), i64 419}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%37 = extractvalue {i32, i8} %36, 0
	%38 = extractvalue {i32, i8} %36, 1
	store i32 %37, i32* @workbench.shader_text
	store i8 %38, i8* %4
	%39 = load i8, i8* %4, align 1
	%40 = trunc i8 %39 to i1
	%41 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$1fa, i64 0, i32 0), i64 60}, i64 35, i64 2, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$1fb, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %7
	%43 = call i8 @runtime.assert(i1 %40, %..string zeroinitializer, %runtime.Source_Code_Location* %7)
	; AssignStmt
	%44 = call {i32, i8} @workbench.load_shader_text(%..string {i8* getelementptr inbounds ([489 x i8], [489 x i8]* @str$1fc, i64 0, i32 0), i64 488}, %..string {i8* getelementptr inbounds ([105 x i8], [105 x i8]* @str$1fd, i64 0, i32 0), i64 104}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%45 = extractvalue {i32, i8} %44, 0
	%46 = extractvalue {i32, i8} %44, 1
	store i32 %45, i32* @workbench.shader_rgba_3d
	store i8 %46, i8* %4
	%47 = load i8, i8* %4, align 1
	%48 = trunc i8 %47 to i1
	%49 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%50 = call %..rawptr @mem.zero(%..rawptr %49, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$1fe, i64 0, i32 0), i64 60}, i64 37, i64 2, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$1ff, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %8
	%51 = call i8 @runtime.assert(i1 %48, %..string zeroinitializer, %runtime.Source_Code_Location* %8)
	ret void
}

define void @workbench._init_opengl$anon-1(%..rawptr %p, i8* %name, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i8*, align 16
	store %..rawptr %p, %..rawptr* %0
	store i8* %name, i8** %1
	; AssignStmt
	%2 = load %..rawptr, %..rawptr* %0, align 8
	%3 = bitcast %..rawptr %2 to %..rawptr*
	%4 = getelementptr inbounds %..rawptr, %..rawptr* %3, i64 0
	; SelectorExpr
	%5 = load i8*, i8** %1, align 8
	%6 = call ccc %..rawptr @glfwGetProcAddress(i8* %5)
	store %..rawptr %6, %..rawptr* %4
	ret void
}

define i8 @workbench.is_whitespace(i8 %c, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i8, align 16
	store i8 %c, i8* %0
	; SwitchStmt
	%1 = load i8, i8* %0, align 1
	%2 = icmp eq i8 %1, 32
	br i1 %2, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%3 = icmp eq i8 %1, 13
	br i1 %3, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	; ReturnStmt
	ret i8 1

switch.case.next-3:
	%4 = icmp eq i8 %1, 10
	br i1 %4, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	; ReturnStmt
	ret i8 1

switch.case.next-5:
	%5 = icmp eq i8 %1, 9
	br i1 %5, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	; ReturnStmt
	ret i8 1

switch.case.next-7:
	; ReturnStmt
	ret i8 0

switch.fall.body-8:
	; ReturnStmt
	ret i8 1
}

define %..string @workbench.trim_whitespace(%..string %text, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %..string, align 16
	%4 = alloca %..string, align 16
	store %..string %text, %..string* %0
	; IfStmt
	%5 = load %..string, %..string* %0, align 8
	%6 = extractvalue %..string %5, 1
	%7 = icmp eq i64 %6, 0
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	br i1 %9, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%10 = load %..string, %..string* %0, align 8
	ret %..string %10

if.done-2:
	; start
	store i64 0, i64* %1
	; ForStmt
	br label %for.loop-3

for.loop-3:
	; IndexExpr
	%11 = load %..string, %..string* %0, align 8
	%12 = extractvalue %..string %11, 0
	%13 = extractvalue %..string %11, 1
	%14 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$200, i64 0, i32 0), i64 63}, i64 122, i64 25, i64 %14, i64 %13)
	%15 = getelementptr inbounds i8, i8* %12, i64 %14
	%16 = load i8, i8* %15, align 1
	%17 = call i8 @workbench.is_whitespace(i8 %16, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%18 = trunc i8 %17 to i1
	br i1 %18, label %for.body-4, label %for.done-5

for.body-4:
	; AssignStmt
	%19 = load i64, i64* %1, align 8
	%20 = add i64 %19, 1
	store i64 %20, i64* %1
	br label %for.loop-3

for.done-5:
	; end
	%21 = load %..string, %..string* %0, align 8
	%22 = extractvalue %..string %21, 1
	store i64 %22, i64* %2
	; ForStmt
	br label %for.loop-6

for.loop-6:
	; IndexExpr
	%23 = load %..string, %..string* %0, align 8
	%24 = extractvalue %..string %23, 0
	%25 = extractvalue %..string %23, 1
	%26 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$201, i64 0, i32 0), i64 63}, i64 124, i64 25, i64 %26, i64 %25)
	%27 = getelementptr inbounds i8, i8* %24, i64 %26
	%28 = load i8, i8* %27, align 1
	%29 = call i8 @workbench.is_whitespace(i8 %28, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%30 = trunc i8 %29 to i1
	br i1 %30, label %for.body-7, label %for.done-8

for.body-7:
	; AssignStmt
	%31 = load i64, i64* %2, align 8
	%32 = sub i64 %31, 1
	store i64 %32, i64* %2
	br label %for.loop-6

for.done-8:
	; new_str
	; SliceExpr
	%33 = load i64, i64* %1, align 8
	%34 = load i64, i64* %2, align 8
	%35 = load %..string, %..string* %0, align 8
	%36 = extractvalue %..string %35, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$202, i64 0, i32 0), i64 63}, i64 126, i64 17, i64 %33, i64 %34, i64 %36)
	%37 = extractvalue %..string %35, 0
	%38 = getelementptr inbounds i8, i8* %37, i64 %33
	%39 = sub i64 %34, %33
	%40 = bitcast %..string* %4 to %..rawptr
	%41 = call %..rawptr @mem.zero(%..rawptr %40, i64 16) noinline
	store %..string zeroinitializer, %..string* %4
	%42 = getelementptr inbounds %..string, %..string* %4, i64 0, i32 0
	store i8* %38, i8** %42
	%43 = getelementptr inbounds %..string, %..string* %4, i64 0, i32 1
	store i64 %39, i64* %43
	%44 = load %..string, %..string* %4, align 8
	store %..string %44, %..string* %3
	; ReturnStmt
	%45 = load %..string, %..string* %3, align 8
	ret %..string %45
}

define {i64, i8} @workbench.find_from_right(%..string %str, i32 %c, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i32, align 16
	%2 = alloca i8, align 16
	%3 = alloca i64, align 16
	%4 = alloca {i64, i8}, align 16
	%5 = alloca {i64, i8}, align 16
	store %..string %str, %..string* %0
	store i32 %c, i32* %1
	; u
	%6 = load i32, i32* %1, align 4
	%7 = trunc i32 %6 to i8
	store i8 %7, i8* %2
	; ForStmt
	; i
	%8 = load %..string, %..string* %0, align 8
	%9 = extractvalue %..string %8, 1
	%10 = sub i64 %9, 1
	store i64 %10, i64* %3
	br label %for.loop-1

for.loop-1:
	%11 = load i64, i64* %3, align 8
	%12 = icmp sge i64 %11, 0
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %for.body-2, label %for.done-5

for.body-2:
	; IfStmt
	; IndexExpr
	%15 = load %..string, %..string* %0, align 8
	%16 = extractvalue %..string %15, 0
	%17 = extractvalue %..string %15, 1
	%18 = load i64, i64* %3, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$203, i64 0, i32 0), i64 63}, i64 146, i64 10, i64 %18, i64 %17)
	%19 = getelementptr inbounds i8, i8* %16, i64 %18
	%20 = load i8, i8* %19, align 1
	%21 = load i8, i8* %2, align 1
	%22 = icmp eq i8 %20, %21
	%23 = zext i1 %22 to i8
	%24 = trunc i8 %23 to i1
	br i1 %24, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	%25 = load i64, i64* %3, align 8
	%26 = bitcast {i64, i8}* %4 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %4
	%28 = getelementptr inbounds {i64, i8}, {i64, i8}* %4, i64 0, i32 0
	store i64 %25, i64* %28
	%29 = getelementptr inbounds {i64, i8}, {i64, i8}* %4, i64 0, i32 1
	store i8 1, i8* %29
	%30 = load {i64, i8}, {i64, i8}* %4, align 8
	ret {i64, i8} %30

if.done-4:
	; AssignStmt
	%31 = load i64, i64* %3, align 8
	%32 = sub i64 %31, 1
	store i64 %32, i64* %3
	br label %for.loop-1

for.done-5:
	; ReturnStmt
	%33 = bitcast {i64, i8}* %5 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %5
	%35 = getelementptr inbounds {i64, i8}, {i64, i8}* %5, i64 0, i32 0
	store i64 0, i64* %35
	%36 = getelementptr inbounds {i64, i8}, {i64, i8}* %5, i64 0, i32 1
	store i8 0, i8* %36
	%37 = load {i64, i8}, {i64, i8}* %5, align 8
	ret {i64, i8} %37
}

define %..string @workbench.file_from_path(%..string %path, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i8, align 16
	%6 = alloca i64, align 16
	%7 = alloca i8, align 16
	%8 = alloca %..string, align 16
	store %..string %path, %..string* %0
	; file
	%9 = load %..string, %..string* %0, align 8
	store %..string %9, %..string* %1
	; start
	store i64 0, i64* %2
	; end
	%10 = load %..string, %..string* %1, align 8
	%11 = extractvalue %..string %10, 1
	store i64 %11, i64* %3
	; IfStmt
	; last_slash_idx
	; ok
	%12 = load %..string, %..string* %1, align 8
	%13 = call {i64, i8} @workbench.find_from_right(%..string %12, i32 92, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%14 = extractvalue {i64, i8} %13, 0
	%15 = extractvalue {i64, i8} %13, 1
	store i64 %14, i64* %4
	store i8 %15, i8* %5
	%16 = load i8, i8* %5, align 1
	%17 = trunc i8 %16 to i1
	br i1 %17, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	%18 = load i64, i64* %4, align 8
	store i64 %18, i64* %2
	br label %if.done-2

if.done-2:
	; IfStmt
	; dot
	; ok
	%19 = load %..string, %..string* %1, align 8
	%20 = call {i64, i8} @workbench.find_from_right(%..string %19, i32 46, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = extractvalue {i64, i8} %20, 0
	%22 = extractvalue {i64, i8} %20, 1
	store i64 %21, i64* %6
	store i8 %22, i8* %7
	%23 = load i8, i8* %7, align 1
	%24 = trunc i8 %23 to i1
	br i1 %24, label %if.then-3, label %if.done-4

if.then-3:
	; AssignStmt
	%25 = load i64, i64* %6, align 8
	store i64 %25, i64* %3
	br label %if.done-4

if.done-4:
	; AssignStmt
	; SliceExpr
	%26 = load i64, i64* %2, align 8
	%27 = add i64 %26, 1
	%28 = load i64, i64* %3, align 8
	%29 = load %..string, %..string* %1, align 8
	%30 = extractvalue %..string %29, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$204, i64 0, i32 0), i64 63}, i64 228, i64 13, i64 %27, i64 %28, i64 %30)
	%31 = extractvalue %..string %29, 0
	%32 = getelementptr inbounds i8, i8* %31, i64 %27
	%33 = sub i64 %28, %27
	%34 = bitcast %..string* %8 to %..rawptr
	%35 = call %..rawptr @mem.zero(%..rawptr %34, i64 16) noinline
	store %..string zeroinitializer, %..string* %8
	%36 = getelementptr inbounds %..string, %..string* %8, i64 0, i32 0
	store i8* %32, i8** %36
	%37 = getelementptr inbounds %..string, %..string* %8, i64 0, i32 1
	store i64 %33, i64* %37
	%38 = load %..string, %..string* %8, align 8
	store %..string %38, %..string* %1
	; ReturnStmt
	%39 = load %..string, %..string* %1, align 8
	ret %..string %39
}

define i32 @workbench.gen_vao(%runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; vao
	%3 = bitcast i32* %0 to %..rawptr
	%4 = call %..rawptr @mem.zero(%..rawptr %3, i64 4) noinline
	store i32 zeroinitializer, i32* %0
	; SelectorExpr
	%5 = load void (i32, i32*)*, void (i32, i32*)** @gl.GenVertexArrays, align 8
	call ccc void %5(i32 1, i32* %0) alwaysinline
	%6 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%7 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %6, %runtime.Source_Code_Location* %1
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$205, i64 0, i32 0), i64 7}, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	; ReturnStmt
	%9 = load i32, i32* %0, align 4
	%10 = bitcast i32 %9 to i32
	%11 = bitcast i32 %10 to i32
	ret i32 %11
}

define void @workbench.bind_vao(i32 %vao, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	store i32 %vao, i32* %0
	%2 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%3 = load void (i32)*, void (i32)** @gl.BindVertexArray, align 8
	%4 = load i32, i32* %0, align 4
	%5 = bitcast i32 %4 to i32
	call ccc void %3(i32 %5) alwaysinline
	%6 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%7 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %6, %runtime.Source_Code_Location* %1
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$206, i64 0, i32 0), i64 8}, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define void @workbench.delete_vao(i32 %vao, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	store i32 %vao, i32* %0
	%2 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%3 = load void (i32, i32*)*, void (i32, i32*)** @gl.DeleteVertexArrays, align 8
	%4 = bitcast i32* %0 to i32*
	call ccc void %3(i32 1, i32* %4) alwaysinline
	%5 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%6 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %5, %runtime.Source_Code_Location* %1
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$207, i64 0, i32 0), i64 10}, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define i32 @workbench.gen_vbo(%runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; vbo
	%3 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%4 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%5 = call %..rawptr @mem.zero(%..rawptr %4, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %3, %runtime.Source_Code_Location* %1
	%6 = call i32 @workbench.gen_buffer(%runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%7 = bitcast i32 %6 to i32
	%8 = bitcast i32 %7 to i32
	store i32 %8, i32* %0
	; ReturnStmt
	%9 = load i32, i32* %0, align 4
	ret i32 %9
}

define i32 @workbench.gen_buffer(%runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; vbo
	%3 = bitcast i32* %0 to %..rawptr
	%4 = call %..rawptr @mem.zero(%..rawptr %3, i64 4) noinline
	store i32 zeroinitializer, i32* %0
	; SelectorExpr
	%5 = load void (i32, i32*)*, void (i32, i32*)** @gl.GenBuffers, align 8
	call ccc void %5(i32 1, i32* %0) alwaysinline
	%6 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%7 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %6, %runtime.Source_Code_Location* %1
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$208, i64 0, i32 0), i64 10}, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	; ReturnStmt
	%9 = load i32, i32* %0, align 4
	%10 = bitcast i32 %9 to i32
	%11 = bitcast i32 %10 to i32
	ret i32 %11
}

define void @workbench.bind_buffer_vbo(i32 %vbo, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	store i32 %vbo, i32* %0
	%2 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%3 = load void (i32, i32)*, void (i32, i32)** @gl.BindBuffer, align 8
	%4 = load i32, i32* %0, align 4
	%5 = bitcast i32 %4 to i32
	call ccc void %3(i32 34962, i32 %5) alwaysinline
	%6 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%7 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %6, %runtime.Source_Code_Location* %1
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$209, i64 0, i32 0), i64 15}, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define void @workbench.bind_buffer_ebo(i32 %ebo, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	store i32 %ebo, i32* %0
	%2 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%3 = load void (i32, i32)*, void (i32, i32)** @gl.BindBuffer, align 8
	%4 = load i32, i32* %0, align 4
	%5 = bitcast i32 %4 to i32
	call ccc void %3(i32 34963, i32 %5) alwaysinline
	%6 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%7 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %6, %runtime.Source_Code_Location* %1
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$20a, i64 0, i32 0), i64 15}, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define {i32, i8} @workbench.load_shader_text(%..string %vs_code, %..string %fs_code, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i32, align 16
	%3 = alloca i8, align 16
	%4 = alloca i32, align 16
	%5 = alloca i8, align 16
	%6 = alloca i32, align 16
	%7 = alloca i8, align 16
	%8 = alloca {i32, i8}, align 16
	%9 = alloca i32, align 16
	%10 = alloca i8, align 16
	%11 = alloca {i32*, i64}, align 16
	%12 = alloca {i32*, i64}, align 16
	%13 = alloca {i32, i8}, align 16
	%14 = alloca {i32, i8}, align 16
	store %..string %vs_code, %..string* %0
	store %..string %fs_code, %..string* %1
	%15 = bitcast i32* %2 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 4) noinline
	store i32 zeroinitializer, i32* %2
	%17 = bitcast i8* %3 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 1) noinline
	store i8 zeroinitializer, i8* %3
	; vertex_shader_id
	; ok1
	%19 = load %..string, %..string* %0, align 8
	%20 = call {i32, i8} @workbench.load_shader_text.compile_shader_from_text-1(%..string %19, i32 35633, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = extractvalue {i32, i8} %20, 0
	%22 = extractvalue {i32, i8} %20, 1
	store i32 %21, i32* %4
	store i8 %22, i8* %5
	; DeferStmt
	; fragment_shader_id
	; ok2
	%23 = load %..string, %..string* %1, align 8
	%24 = call {i32, i8} @workbench.load_shader_text.compile_shader_from_text-1(%..string %23, i32 35632, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%25 = extractvalue {i32, i8} %24, 0
	%26 = extractvalue {i32, i8} %24, 1
	store i32 %25, i32* %6
	store i8 %26, i8* %7
	; DeferStmt
	; IfStmt
	%27 = load i8, i8* %5, align 1
	%28 = trunc i8 %27 to i1
	br i1 %28, label %cmp.or-1, label %if.then-2

cmp.or-1:
	%29 = load i8, i8* %7, align 1
	%30 = trunc i8 %29 to i1
	br i1 %30, label %if.done-3, label %if.then-2

if.then-2:
	; ReturnStmt
	%31 = bitcast {i32, i8}* %8 to %..rawptr
	%32 = call %..rawptr @mem.zero(%..rawptr %31, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %8
	%33 = getelementptr inbounds {i32, i8}, {i32, i8}* %8, i64 0, i32 0
	store i32 0, i32* %33
	%34 = getelementptr inbounds {i32, i8}, {i32, i8}* %8, i64 0, i32 1
	store i8 0, i8* %34
	%35 = load {i32, i8}, {i32, i8}* %8, align 4
	; defer
	; SelectorExpr
	%36 = load void (i32)*, void (i32)** @gl.DeleteShader, align 8
	%37 = load i32, i32* %6, align 4
	call ccc void %36(i32 %37)
	; defer
	; SelectorExpr
	%38 = load void (i32)*, void (i32)** @gl.DeleteShader, align 8
	%39 = load i32, i32* %4, align 4
	call ccc void %38(i32 %39)
	ret {i32, i8} %35

if.done-3:
	; program_id
	; ok
	; CompoundLit
	%40 = bitcast {i32*, i64}* %11 to %..rawptr
	%41 = call %..rawptr @mem.zero(%..rawptr %40, i64 16) noinline
	store {i32*, i64} zeroinitializer, {i32*, i64}* %11
	%42 = getelementptr inbounds [2 x i32], [2 x i32]* @csba$1, i64 0, i32 0
	%43 = load i32, i32* %4, align 4
	%44 = getelementptr inbounds i32, i32* %42, i64 0
	store i32 %43, i32* %44
	%45 = load i32, i32* %6, align 4
	%46 = getelementptr inbounds i32, i32* %42, i64 1
	store i32 %45, i32* %46
	%47 = getelementptr inbounds {i32*, i64}, {i32*, i64}* %11, i64 0, i32 0
	store i32* %42, i32** %47
	%48 = getelementptr inbounds {i32*, i64}, {i32*, i64}* %11, i64 0, i32 1
	store i64 2, i64* %48
	%49 = load {i32*, i64}, {i32*, i64}* %11, align 8
	%50 = bitcast {i32*, i64}* %12 to %..rawptr
	%51 = call %..rawptr @mem.zero(%..rawptr %50, i64 16) noinline
	store {i32*, i64} zeroinitializer, {i32*, i64}* %12
	store {i32*, i64} %49, {i32*, i64}* %12
	%52 = call {i32, i8} @workbench.load_shader_text.create_and_link_program-2({i32*, i64}* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%53 = extractvalue {i32, i8} %52, 0
	%54 = extractvalue {i32, i8} %52, 1
	store i32 %53, i32* %9
	store i8 %54, i8* %10
	; IfStmt
	%55 = load i8, i8* %10, align 1
	%56 = trunc i8 %55 to i1
	br i1 %56, label %if.done-5, label %if.then-4

if.then-4:
	; ReturnStmt
	%57 = bitcast {i32, i8}* %13 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %13
	%59 = getelementptr inbounds {i32, i8}, {i32, i8}* %13, i64 0, i32 0
	store i32 0, i32* %59
	%60 = getelementptr inbounds {i32, i8}, {i32, i8}* %13, i64 0, i32 1
	store i8 0, i8* %60
	%61 = load {i32, i8}, {i32, i8}* %13, align 4
	; defer
	; SelectorExpr
	%62 = load void (i32)*, void (i32)** @gl.DeleteShader, align 8
	%63 = load i32, i32* %6, align 4
	call ccc void %62(i32 %63)
	; defer
	; SelectorExpr
	%64 = load void (i32)*, void (i32)** @gl.DeleteShader, align 8
	%65 = load i32, i32* %4, align 4
	call ccc void %64(i32 %65)
	ret {i32, i8} %61

if.done-5:
	; ReturnStmt
	%66 = load i32, i32* %9, align 4
	%67 = bitcast i32 %66 to i32
	%68 = bitcast {i32, i8}* %14 to %..rawptr
	%69 = call %..rawptr @mem.zero(%..rawptr %68, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %14
	%70 = bitcast i32 %67 to i32
	%71 = getelementptr inbounds {i32, i8}, {i32, i8}* %14, i64 0, i32 0
	store i32 %70, i32* %71
	%72 = getelementptr inbounds {i32, i8}, {i32, i8}* %14, i64 0, i32 1
	store i8 1, i8* %72
	%73 = load {i32, i8}, {i32, i8}* %14, align 4
	; defer
	; SelectorExpr
	%74 = load void (i32)*, void (i32)** @gl.DeleteShader, align 8
	%75 = load i32, i32* %6, align 4
	call ccc void %74(i32 %75)
	; defer
	; SelectorExpr
	%76 = load void (i32)*, void (i32)** @gl.DeleteShader, align 8
	%77 = load i32, i32* %4, align 4
	call ccc void %76(i32 %77)
	ret {i32, i8} %73
}

define i8 @workbench.load_shader_text.check_error-0(i32 %id, i32 %type_, i32 %status, void (i32, i32, i32*)* %iv_func, void (i32, i32, i32*, i8*)* %log_func, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i32, align 16
	%2 = alloca i32, align 16
	%3 = alloca void (i32, i32, i32*)*, align 16
	%4 = alloca void (i32, i32, i32*, i8*)*, align 16
	%5 = alloca i32, align 16
	%6 = alloca i32, align 16
	%7 = alloca {i8*, i64}, align 16
	%8 = alloca %mem.Allocator, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca {i8*, i64}, align 16
	%11 = alloca %..string, align 16
	%12 = alloca %..any, align 16
	%13 = alloca %..any, align 16
	%14 = alloca {%..any*, i64}, align 16
	%15 = alloca [2 x %..any], align 16
	%16 = alloca {%..any*, i64}, align 16
	%17 = alloca {i8*, i64}, align 16
	%18 = alloca %mem.Allocator, align 16
	%19 = alloca %runtime.Source_Code_Location, align 16
	%20 = alloca {i8*, i64}, align 16
	%21 = alloca %mem.Allocator, align 16
	%22 = alloca %runtime.Source_Code_Location, align 16
	store i32 %id, i32* %0
	store i32 %type_, i32* %1
	store i32 %status, i32* %2
	store void (i32, i32, i32*)* %iv_func, void (i32, i32, i32*)** %3
	store void (i32, i32, i32*, i8*)* %log_func, void (i32, i32, i32*, i8*)** %4
	; result
	%23 = bitcast i32* %5 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 4) noinline
	store i32 zeroinitializer, i32* %5
	; info_log_length
	%25 = bitcast i32* %6 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 4) noinline
	store i32 zeroinitializer, i32* %6
	%27 = load void (i32, i32, i32*)*, void (i32, i32, i32*)** %3, align 8
	%28 = load i32, i32* %0, align 4
	%29 = load i32, i32* %2, align 4
	call ccc void %27(i32 %28, i32 %29, i32* %5)
	%30 = load void (i32, i32, i32*)*, void (i32, i32, i32*)** %3, align 8
	%31 = load i32, i32* %0, align 4
	call ccc void %30(i32 %31, i32 35716, i32* %6)
	; IfStmt
	%32 = load i32, i32* %5, align 4
	%33 = icmp eq i32 %32, 0
	%34 = zext i1 %33 to i8
	%35 = trunc i8 %34 to i1
	br i1 %35, label %if.then-1, label %if.done-2

if.then-1:
	; error_message
	%36 = load i32, i32* %6, align 4
	; SelectorExpr
	%37 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%38 = load %mem.Allocator, %mem.Allocator* %37, align 8
	%39 = sext i32 %36 to i64
	%40 = bitcast %mem.Allocator* %8 to %..rawptr
	%41 = call %..rawptr @mem.zero(%..rawptr %40, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %8
	store %mem.Allocator %38, %mem.Allocator* %8
	%42 = bitcast %runtime.Source_Code_Location* %9 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %9
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$20b, i64 0, i32 0), i64 69}, i64 100, i64 30, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$20c, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %9
	%44 = call {i8*, i64} @mem.make_slice-14353(i64 %39, %mem.Allocator* %8, %runtime.Source_Code_Location* %9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64} %44, {i8*, i64}* %7
	; DeferStmt
	%45 = load void (i32, i32, i32*, i8*)*, void (i32, i32, i32*, i8*)** %4, align 8
	%46 = load i32, i32* %0, align 4
	%47 = load i32, i32* %6, align 4
	; IndexExpr
	%48 = load {i8*, i64}, {i8*, i64}* %7, align 8
	%49 = extractvalue {i8*, i64} %48, 0
	%50 = extractvalue {i8*, i64} %48, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$20d, i64 0, i32 0), i64 69}, i64 103, i64 68, i64 0, i64 %50)
	%51 = getelementptr inbounds i8, i8* %49, i64 0
	call ccc void %45(i32 %46, i32 %47, i32* zeroinitializer, i8* %51)
	; SelectorExpr
	%52 = load i32, i32* %1, align 4
	; SliceExpr
	%53 = load {i8*, i64}, {i8*, i64}* %7, align 8
	%54 = extractvalue {i8*, i64} %53, 1
	%55 = sub i64 %54, 1
	%56 = load {i8*, i64}, {i8*, i64}* %7, align 8
	%57 = extractvalue {i8*, i64} %56, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$20e, i64 0, i32 0), i64 69}, i64 104, i64 75, i64 0, i64 %55, i64 %57)
	%58 = extractvalue {i8*, i64} %56, 0
	%59 = getelementptr inbounds i8, i8* %58, i64 0
	%60 = sub i64 %55, 0
	%61 = bitcast {i8*, i64}* %10 to %..rawptr
	%62 = call %..rawptr @mem.zero(%..rawptr %61, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %10
	%63 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %10, i64 0, i32 0
	store i8* %59, i8** %63
	%64 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %10, i64 0, i32 1
	store i64 %60, i64* %64
	%65 = load {i8*, i64}, {i8*, i64}* %10, align 8
	%66 = extractvalue {i8*, i64} %65, 0
	%67 = extractvalue {i8*, i64} %65, 1
	%68 = bitcast %..string* %11 to %..rawptr
	%69 = call %..rawptr @mem.zero(%..rawptr %68, i64 16) noinline
	store %..string zeroinitializer, %..string* %11
	%70 = getelementptr inbounds %..string, %..string* %11, i64 0, i32 0
	store i8* %66, i8** %70
	%71 = getelementptr inbounds %..string, %..string* %11, i64 0, i32 1
	store i64 %67, i64* %71
	%72 = load %..string, %..string* %11, align 8
	%73 = bitcast %..any* %12 to %..rawptr
	%74 = call %..rawptr @mem.zero(%..rawptr %73, i64 16) noinline
	store %..any zeroinitializer, %..any* %12
	%75 = bitcast i32* %1 to %..rawptr
	%76 = getelementptr inbounds %..any, %..any* %12, i64 0, i32 0
	store %..rawptr %75, %..rawptr* %76
	%77 = getelementptr inbounds %..any, %..any* %12, i64 0, i32 1
	store %..typeid 3530822107858468961, %..typeid* %77
	%78 = load %..any, %..any* %12, align 8
	%79 = bitcast %..any* %13 to %..rawptr
	%80 = call %..rawptr @mem.zero(%..rawptr %79, i64 16) noinline
	store %..any zeroinitializer, %..any* %13
	%81 = bitcast %..string* %11 to %..rawptr
	%82 = getelementptr inbounds %..any, %..any* %13, i64 0, i32 0
	store %..rawptr %81, %..rawptr* %82
	%83 = getelementptr inbounds %..any, %..any* %13, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %83
	%84 = load %..any, %..any* %13, align 8
	; variadic call argument generation
	%85 = bitcast {%..any*, i64}* %14 to %..rawptr
	%86 = call %..rawptr @mem.zero(%..rawptr %85, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %14
	%87 = bitcast [2 x %..any]* %15 to %..rawptr
	%88 = call %..rawptr @mem.zero(%..rawptr %87, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %15
	%89 = getelementptr inbounds [2 x %..any], [2 x %..any]* %15, i64 0, i32 0
	store %..any %78, %..any* %89
	%90 = getelementptr inbounds [2 x %..any], [2 x %..any]* %15, i64 0, i32 1
	store %..any %84, %..any* %90
	%91 = getelementptr inbounds [2 x %..any], [2 x %..any]* %15, i64 0, i32 0
	%92 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %14, i64 0, i32 0
	store %..any* %91, %..any** %92
	%93 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %14, i64 0, i32 1
	store i64 2, i64* %93
	%94 = load {%..any*, i64}, {%..any*, i64}* %14, align 8
	%95 = bitcast {%..any*, i64}* %16 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %16
	store {%..any*, i64} %94, {%..any*, i64}* %16
	%97 = call i64 @fmt.printf_err(%..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$20f, i64 0, i32 0), i64 15}, {%..any*, i64}* %16, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	; defer
	%98 = load {i8*, i64}, {i8*, i64}* %7, align 8
	; SelectorExpr
	%99 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%100 = load %mem.Allocator, %mem.Allocator* %99, align 8
	%101 = bitcast {i8*, i64}* %17 to %..rawptr
	%102 = call %..rawptr @mem.zero(%..rawptr %101, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %17
	store {i8*, i64} %98, {i8*, i64}* %17
	%103 = bitcast %mem.Allocator* %18 to %..rawptr
	%104 = call %..rawptr @mem.zero(%..rawptr %103, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %18
	store %mem.Allocator %100, %mem.Allocator* %18
	%105 = bitcast %runtime.Source_Code_Location* %19 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %19
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$210, i64 0, i32 0), i64 69}, i64 101, i64 19, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$211, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %19
	call void @mem.delete_slice-14873({i8*, i64}* %17, %mem.Allocator* %18, %runtime.Source_Code_Location* %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret i8 1

if.done-2:
	; ReturnStmt
	ret i8 0
}

define {i32, i8} @workbench.load_shader_text.compile_shader_from_text-1(%..string %shader_code, i32 %shader_type, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i32, align 16
	%2 = alloca i32, align 16
	%3 = alloca i32, align 16
	%4 = alloca {i32, i8}, align 16
	%5 = alloca {i32, i8}, align 16
	store %..string %shader_code, %..string* %0
	store i32 %shader_type, i32* %1
	; shader_id
	; SelectorExpr
	%6 = load i32 (i32)*, i32 (i32)** @gl.CreateShader, align 8
	%7 = load i32, i32* %1, align 4
	%8 = bitcast i32 %7 to i32
	%9 = call ccc i32 %6(i32 %8)
	store i32 %9, i32* %2
	; length
	%10 = load %..string, %..string* %0, align 8
	%11 = extractvalue %..string %10, 1
	%12 = trunc i64 %11 to i32
	store i32 %12, i32* %3
	; SelectorExpr
	%13 = load void (i32, i32, i8**, i32*)*, void (i32, i32, i8**, i32*)** @gl.ShaderSource, align 8
	%14 = load i32, i32* %2, align 4
	%15 = bitcast %..string* %0 to i8**
	call ccc void %13(i32 %14, i32 1, i8** %15, i32* %3)
	; SelectorExpr
	%16 = load void (i32)*, void (i32)** @gl.CompileShader, align 8
	%17 = load i32, i32* %2, align 4
	call ccc void %16(i32 %17)
	; IfStmt
	%18 = load i32, i32* %2, align 4
	%19 = load i32, i32* %1, align 4
	; SelectorExpr
	%20 = load void (i32, i32, i32*)*, void (i32, i32, i32*)** @gl.GetShaderiv, align 8
	; SelectorExpr
	%21 = load void (i32, i32, i32*, i8*)*, void (i32, i32, i32*, i8*)** @gl.GetShaderInfoLog, align 8
	%22 = call i8 @workbench.load_shader_text.check_error-0(i32 %18, i32 %19, i32 35713, void (i32, i32, i32*)* %20, void (i32, i32, i32*, i8*)* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%24 = bitcast {i32, i8}* %4 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %4
	%26 = getelementptr inbounds {i32, i8}, {i32, i8}* %4, i64 0, i32 0
	store i32 0, i32* %26
	%27 = getelementptr inbounds {i32, i8}, {i32, i8}* %4, i64 0, i32 1
	store i8 0, i8* %27
	%28 = load {i32, i8}, {i32, i8}* %4, align 4
	ret {i32, i8} %28

if.done-2:
	; ReturnStmt
	%29 = load i32, i32* %2, align 4
	%30 = bitcast {i32, i8}* %5 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %5
	%32 = getelementptr inbounds {i32, i8}, {i32, i8}* %5, i64 0, i32 0
	store i32 %29, i32* %32
	%33 = getelementptr inbounds {i32, i8}, {i32, i8}* %5, i64 0, i32 1
	store i8 1, i8* %33
	%34 = load {i32, i8}, {i32, i8}* %5, align 4
	ret {i32, i8} %34
}

define {i32, i8} @workbench.load_shader_text.create_and_link_program-2({i32*, i64}* %shader_ids, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i32, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca {i32, i8}, align 16
	%5 = alloca {i32, i8}, align 16
	%6 = load {i32*, i64}, {i32*, i64}* %shader_ids, align 8
	; program_id
	; SelectorExpr
	%7 = load i32 ()*, i32 ()** @gl.CreateProgram, align 8
	%8 = call ccc i32 %7()
	store i32 %8, i32* %0
	; RangeStmt
	; id
	%9 = bitcast i32* %1 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 4) noinline
	store i32 zeroinitializer, i32* %1
	%11 = load {i32*, i64}, {i32*, i64}* %shader_ids, align 8
	%12 = bitcast i64* %2 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	%14 = extractvalue {i32*, i64} %11, 1
	store i64 %14, i64* %2
	%15 = bitcast i64* %3 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	store i64 -1, i64* %3
	br label %for.index.loop-1

for.index.loop-1:
	%17 = load i64, i64* %3, align 8
	%18 = add i64 %17, 1
	store i64 %18, i64* %3
	%19 = load i64, i64* %2, align 8
	%20 = icmp slt i64 %18, %19
	br i1 %20, label %for.index.body-2, label %for.index.done-3

for.index.body-2:
	%21 = load i64, i64* %3, align 8
	%22 = extractvalue {i32*, i64} %11, 0
	%23 = getelementptr inbounds i32, i32* %22, i64 %21
	%24 = load i32, i32* %23, align 4
	store i32 %24, i32* %1
	; SelectorExpr
	%25 = load void (i32, i32)*, void (i32, i32)** @gl.AttachShader, align 8
	%26 = load i32, i32* %0, align 4
	%27 = load i32, i32* %1, align 4
	call ccc void %25(i32 %26, i32 %27)
	br label %for.index.loop-1

for.index.done-3:
	; SelectorExpr
	%28 = load void (i32)*, void (i32)** @gl.LinkProgram, align 8
	%29 = load i32, i32* %0, align 4
	call ccc void %28(i32 %29)
	; IfStmt
	%30 = load i32, i32* %0, align 4
	; SelectorExpr
	%31 = load void (i32, i32, i32*)*, void (i32, i32, i32*)** @gl.GetProgramiv, align 8
	; SelectorExpr
	%32 = load void (i32, i32, i32*, i8*)*, void (i32, i32, i32*, i8*)** @gl.GetProgramInfoLog, align 8
	%33 = call i8 @workbench.load_shader_text.check_error-0(i32 %30, i32 0, i32 35714, void (i32, i32, i32*)* %31, void (i32, i32, i32*, i8*)* %32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%34 = trunc i8 %33 to i1
	br i1 %34, label %if.then-4, label %if.done-5

if.then-4:
	; ReturnStmt
	%35 = bitcast {i32, i8}* %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %4
	%37 = getelementptr inbounds {i32, i8}, {i32, i8}* %4, i64 0, i32 0
	store i32 0, i32* %37
	%38 = getelementptr inbounds {i32, i8}, {i32, i8}* %4, i64 0, i32 1
	store i8 0, i8* %38
	%39 = load {i32, i8}, {i32, i8}* %4, align 4
	ret {i32, i8} %39

if.done-5:
	; ReturnStmt
	%40 = load i32, i32* %0, align 4
	%41 = bitcast {i32, i8}* %5 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %5
	%43 = getelementptr inbounds {i32, i8}, {i32, i8}* %5, i64 0, i32 0
	store i32 %40, i32* %43
	%44 = getelementptr inbounds {i32, i8}, {i32, i8}* %5, i64 0, i32 1
	store i8 1, i8* %44
	%45 = load {i32, i8}, {i32, i8}* %5, align 4
	ret {i32, i8} %45
}

define void @workbench.use_program(i32 %program, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	store i32 %program, i32* %0
	%2 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%3 = load void (i32)*, void (i32)** @gl.UseProgram, align 8
	%4 = load i32, i32* %0, align 4
	%5 = bitcast i32 %4 to i32
	call ccc void %3(i32 %5) alwaysinline
	%6 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%7 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %6, %runtime.Source_Code_Location* %1
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$212, i64 0, i32 0), i64 11}, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define i32 @workbench.gen_texture(%runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; texture
	%3 = bitcast i32* %0 to %..rawptr
	%4 = call %..rawptr @mem.zero(%..rawptr %3, i64 4) noinline
	store i32 zeroinitializer, i32* %0
	; SelectorExpr
	%5 = load void (i32, i32*)*, void (i32, i32*)** @gl.GenTextures, align 8
	call ccc void %5(i32 1, i32* %0) alwaysinline
	%6 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%7 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %6, %runtime.Source_Code_Location* %1
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$213, i64 0, i32 0), i64 11}, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	; ReturnStmt
	%9 = load i32, i32* %0, align 4
	%10 = bitcast i32 %9 to i32
	%11 = bitcast i32 %10 to i32
	ret i32 %11
}

define void @workbench.bind_texture2d(i32 %texture, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	store i32 %texture, i32* %0
	%2 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%3 = load void (i32, i32)*, void (i32, i32)** @gl.BindTexture, align 8
	%4 = load i32, i32* %0, align 4
	%5 = bitcast i32 %4 to i32
	call ccc void %3(i32 3553, i32 %5) alwaysinline
	%6 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%7 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %6, %runtime.Source_Code_Location* %1
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$214, i64 0, i32 0), i64 14}, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define i32 @workbench.get_uniform_location(i32 %program, %..string %str, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i32, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	store i32 %program, i32* %0
	store %..string %str, %..string* %1
	%4 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; uniform_loc
	; SelectorExpr
	%5 = load i32 (i32, i8*)*, i32 (i32, i8*)** @gl.GetUniformLocation, align 8
	%6 = load i32, i32* %0, align 4
	%7 = bitcast i32 %6 to i32
	; IndexExpr
	%8 = load %..string, %..string* %1, align 8
	%9 = extractvalue %..string %8, 0
	%10 = extractvalue %..string %8, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$215, i64 0, i32 0), i64 69}, i64 225, i64 66, i64 0, i64 %10) alwaysinline
	%11 = getelementptr inbounds i8, i8* %9, i64 0
	%12 = call ccc i32 %5(i32 %7, i8* %11) alwaysinline
	store i32 %12, i32* %2
	%13 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%14 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %13, %runtime.Source_Code_Location* %3
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$216, i64 0, i32 0), i64 20}, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	; ReturnStmt
	%16 = load i32, i32* %2, align 4
	%17 = bitcast i32 %16 to i32
	%18 = bitcast i32 %17 to i32
	ret i32 %18
}

define i32 @workbench.get_attrib_location(i32 %program, %..string %str, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i32, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	store i32 %program, i32* %0
	store %..string %str, %..string* %1
	%4 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; attrib_loc
	; SelectorExpr
	%5 = load i32 (i32, i8*)*, i32 (i32, i8*)** @gl.GetAttribLocation, align 8
	%6 = load i32, i32* %0, align 4
	%7 = bitcast i32 %6 to i32
	; IndexExpr
	%8 = load %..string, %..string* %1, align 8
	%9 = extractvalue %..string %8, 0
	%10 = extractvalue %..string %8, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$217, i64 0, i32 0), i64 69}, i64 231, i64 64, i64 0, i64 %10) alwaysinline
	%11 = getelementptr inbounds i8, i8* %9, i64 0
	%12 = call ccc i32 %5(i32 %7, i8* %11) alwaysinline
	store i32 %12, i32* %2
	%13 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%14 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %13, %runtime.Source_Code_Location* %3
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$218, i64 0, i32 0), i64 19}, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	; ReturnStmt
	%16 = load i32, i32* %2, align 4
	%17 = bitcast i32 %16 to i32
	%18 = bitcast i32 %17 to i32
	ret i32 %18
}

define i32 @workbench.get_int(i32 %pname, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i32, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	store i32 %pname, i32* %0
	%3 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; i
	%4 = bitcast i32* %1 to %..rawptr
	%5 = call %..rawptr @mem.zero(%..rawptr %4, i64 4) noinline
	store i32 zeroinitializer, i32* %1
	; SelectorExpr
	%6 = load void (i32, i32*)*, void (i32, i32*)** @gl.GetIntegerv, align 8
	%7 = load i32, i32* %0, align 4
	call ccc void %6(i32 %7, i32* %1) alwaysinline
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%9 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %8, %runtime.Source_Code_Location* %2
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$219, i64 0, i32 0), i64 7}, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	; ReturnStmt
	%11 = load i32, i32* %1, align 4
	ret i32 %11
}

define i32 @workbench.get_current_shader(%runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; id
	%3 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%4 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%5 = call %..rawptr @mem.zero(%..rawptr %4, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %3, %runtime.Source_Code_Location* %1
	%6 = call i32 @workbench.get_int(i32 35725, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	store i32 %6, i32* %0
	; ReturnStmt
	%7 = load i32, i32* %0, align 4
	%8 = bitcast i32 %7 to i32
	ret i32 %8
}

define void @workbench.uniform1i(i32 %program, %..string %name, i32 %v0, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i32, align 16
	%3 = alloca i32, align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	store i32 %program, i32* %0
	store %..string %name, %..string* %1
	store i32 %v0, i32* %2
	%6 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; location
	%7 = load i32, i32* %0, align 4
	%8 = load %..string, %..string* %1, align 8
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%10 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location %9, %runtime.Source_Code_Location* %4
	%12 = call i32 @workbench.get_uniform_location(i32 %7, %..string %8, %runtime.Source_Code_Location* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	store i32 %12, i32* %3
	; SelectorExpr
	%13 = load void (i32, i32)*, void (i32, i32)** @gl.Uniform1i, align 8
	%14 = load i32, i32* %3, align 4
	%15 = bitcast i32 %14 to i32
	%16 = load i32, i32* %2, align 4
	call ccc void %13(i32 %15, i32 %16) alwaysinline
	%17 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%18 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location %17, %runtime.Source_Code_Location* %5
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$21a, i64 0, i32 0), i64 9}, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define void @workbench.uniform_matrix4fv(i32 %program, %..string %name, i32 %count, i1 %transpose, float* %value, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i32, align 16
	%3 = alloca i8, align 16
	%4 = alloca float*, align 16
	%5 = alloca i32, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	store i32 %program, i32* %0
	store %..string %name, %..string* %1
	store i32 %count, i32* %2
	%8 = zext i1 %transpose to i8
	store i8 %8, i8* %3
	store float* %value, float** %4
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; location
	%10 = load i32, i32* %0, align 4
	%11 = load %..string, %..string* %1, align 8
	%12 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%13 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location %12, %runtime.Source_Code_Location* %6
	%15 = call i32 @workbench.get_uniform_location(i32 %10, %..string %11, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	store i32 %15, i32* %5
	; SelectorExpr
	%16 = load void (i32, i32, i8, float*)*, void (i32, i32, i8, float*)** @gl.UniformMatrix4fv, align 8
	%17 = load i32, i32* %5, align 4
	%18 = bitcast i32 %17 to i32
	%19 = load i32, i32* %2, align 4
	%20 = load i8, i8* %3, align 1
	%21 = icmp ne i8 %20, 0
	%22 = zext i1 %21 to i8
	%23 = load float*, float** %4, align 8
	call ccc void %16(i32 %18, i32 %19, i8 %22, float* %23) alwaysinline
	%24 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%25 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location %24, %runtime.Source_Code_Location* %7
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$21b, i64 0, i32 0), i64 17}, %runtime.Source_Code_Location* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define void @workbench.log_gl_errors(%..string %caller_context, %runtime.Source_Code_Location* %location, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i32, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i64, align 16
	%4 = alloca i8, align 16
	%5 = alloca %..string, align 16
	%6 = alloca %..any, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %..any, align 16
	%9 = alloca %..any, align 16
	%10 = alloca {%..any*, i64}, align 16
	%11 = alloca [4 x %..any], align 16
	%12 = alloca {%..any*, i64}, align 16
	store %..string %caller_context, %..string* %0
	%13 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, align 8
	; ForStmt
	br label %for.body-1

for.body-1:
	; err
	; SelectorExpr
	%14 = load i32 ()*, i32 ()** @gl.GetError, align 8
	%15 = call ccc i32 %14()
	store i32 %15, i32* %1
	; IfStmt
	%16 = load i32, i32* %1, align 4
	%17 = icmp eq i32 %16, 0
	%18 = zext i1 %17 to i8
	%19 = trunc i8 %18 to i1
	br i1 %19, label %if.then-2, label %if.done-3

if.then-2:
	; break
	ret void

if.done-3:
	; file
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, i64 0, i32 0
	%21 = load %..string, %..string* %20, align 8
	store %..string %21, %..string* %2
	; idx
	; ok
	; SelectorExpr
	%22 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, i64 0, i32 0
	%23 = load %..string, %..string* %22, align 8
	%24 = call {i64, i8} @workbench.find_from_right(%..string %23, i32 92, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%25 = extractvalue {i64, i8} %24, 0
	%26 = extractvalue {i64, i8} %24, 1
	store i64 %25, i64* %3
	store i8 %26, i8* %4
	; IfStmt
	%27 = load i8, i8* %4, align 1
	%28 = trunc i8 %27 to i1
	br i1 %28, label %if.then-4, label %if.done-5

if.then-4:
	; AssignStmt
	; SliceExpr
	%29 = load i64, i64* %3, align 8
	%30 = add i64 %29, 1
	; SelectorExpr
	%31 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, i64 0, i32 0
	%32 = load %..string, %..string* %31, align 8
	%33 = extractvalue %..string %32, 1
	; SelectorExpr
	%34 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, i64 0, i32 0
	%35 = load %..string, %..string* %34, align 8
	%36 = extractvalue %..string %35, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$21c, i64 0, i32 0), i64 69}, i64 469, i64 29, i64 %30, i64 %33, i64 %36)
	%37 = extractvalue %..string %35, 0
	%38 = getelementptr inbounds i8, i8* %37, i64 %30
	%39 = sub i64 %33, %30
	%40 = bitcast %..string* %5 to %..rawptr
	%41 = call %..rawptr @mem.zero(%..rawptr %40, i64 16) noinline
	store %..string zeroinitializer, %..string* %5
	%42 = getelementptr inbounds %..string, %..string* %5, i64 0, i32 0
	store i8* %38, i8** %42
	%43 = getelementptr inbounds %..string, %..string* %5, i64 0, i32 1
	store i64 %39, i64* %43
	%44 = load %..string, %..string* %5, align 8
	store %..string %44, %..string* %2
	br label %if.done-5

if.done-5:
	; SelectorExpr
	%45 = load %..string, %..string* %0, align 8
	%46 = load %..string, %..string* %2, align 8
	; SelectorExpr
	%47 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, i64 0, i32 1
	%48 = load i64, i64* %47, align 8
	%49 = load i32, i32* %1, align 4
	%50 = bitcast %..any* %6 to %..rawptr
	%51 = call %..rawptr @mem.zero(%..rawptr %50, i64 16) noinline
	store %..any zeroinitializer, %..any* %6
	%52 = bitcast %..string* %0 to %..rawptr
	%53 = getelementptr inbounds %..any, %..any* %6, i64 0, i32 0
	store %..rawptr %52, %..rawptr* %53
	%54 = getelementptr inbounds %..any, %..any* %6, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %54
	%55 = load %..any, %..any* %6, align 8
	%56 = bitcast %..any* %7 to %..rawptr
	%57 = call %..rawptr @mem.zero(%..rawptr %56, i64 16) noinline
	store %..any zeroinitializer, %..any* %7
	%58 = bitcast %..string* %2 to %..rawptr
	%59 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 0
	store %..rawptr %58, %..rawptr* %59
	%60 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %60
	%61 = load %..any, %..any* %7, align 8
	%62 = bitcast %..any* %8 to %..rawptr
	%63 = call %..rawptr @mem.zero(%..rawptr %62, i64 16) noinline
	store %..any zeroinitializer, %..any* %8
	%64 = bitcast i64* %47 to %..rawptr
	%65 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 0
	store %..rawptr %64, %..rawptr* %65
	%66 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %66
	%67 = load %..any, %..any* %8, align 8
	%68 = bitcast %..any* %9 to %..rawptr
	%69 = call %..rawptr @mem.zero(%..rawptr %68, i64 16) noinline
	store %..any zeroinitializer, %..any* %9
	%70 = bitcast i32* %1 to %..rawptr
	%71 = getelementptr inbounds %..any, %..any* %9, i64 0, i32 0
	store %..rawptr %70, %..rawptr* %71
	%72 = getelementptr inbounds %..any, %..any* %9, i64 0, i32 1
	store %..typeid 72057594037928002, %..typeid* %72
	%73 = load %..any, %..any* %9, align 8
	; variadic call argument generation
	%74 = bitcast {%..any*, i64}* %10 to %..rawptr
	%75 = call %..rawptr @mem.zero(%..rawptr %74, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %10
	%76 = bitcast [4 x %..any]* %11 to %..rawptr
	%77 = call %..rawptr @mem.zero(%..rawptr %76, i64 64) noinline
	store [4 x %..any] zeroinitializer, [4 x %..any]* %11
	%78 = getelementptr inbounds [4 x %..any], [4 x %..any]* %11, i64 0, i32 0
	store %..any %55, %..any* %78
	%79 = getelementptr inbounds [4 x %..any], [4 x %..any]* %11, i64 0, i32 1
	store %..any %61, %..any* %79
	%80 = getelementptr inbounds [4 x %..any], [4 x %..any]* %11, i64 0, i32 2
	store %..any %67, %..any* %80
	%81 = getelementptr inbounds [4 x %..any], [4 x %..any]* %11, i64 0, i32 3
	store %..any %73, %..any* %81
	%82 = getelementptr inbounds [4 x %..any], [4 x %..any]* %11, i64 0, i32 0
	%83 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %10, i64 0, i32 0
	store %..any* %82, %..any** %83
	%84 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %10, i64 0, i32 1
	store i64 4, i64* %84
	%85 = load {%..any*, i64}, {%..any*, i64}* %10, align 8
	%86 = bitcast {%..any*, i64}* %12 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %12
	store {%..any*, i64} %85, {%..any*, i64}* %12
	%88 = call i64 @fmt.printf(%..string {i8* getelementptr inbounds ([32 x i8], [32 x i8]* @str$21d, i64 0, i32 0), i64 31}, {%..any*, i64}* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.body-1
}

define void @workbench.tween_destroy_index(i64 %idx, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %workbench.Tweener*, align 16
	%2 = alloca %mem.Allocator, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	store i64 %idx, i64* %0
	; tweener
	; IndexExpr
	%4 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}, {%workbench.Tweener**, i64, i64, %mem.Allocator}* @workbench.tweeners, align 8
	%5 = extractvalue {%workbench.Tweener**, i64, i64, %mem.Allocator} %4, 0
	%6 = extractvalue {%workbench.Tweener**, i64, i64, %mem.Allocator} %4, 1
	%7 = load i64, i64* %0, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$21e, i64 0, i32 0), i64 63}, i64 65, i64 22, i64 %7, i64 %6) alwaysinline
	%8 = getelementptr inbounds %workbench.Tweener*, %workbench.Tweener** %5, i64 %7
	%9 = load %workbench.Tweener*, %workbench.Tweener** %8, align 8
	store %workbench.Tweener* %9, %workbench.Tweener** %1
	%10 = load i64, i64* %0, align 8
	call void @workbench.remove_at-18157({%workbench.Tweener**, i64, i64, %mem.Allocator}* @workbench.tweeners, i64 %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%11 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	; SelectorExpr
	%12 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%13 = load %mem.Allocator, %mem.Allocator* %12, align 8
	%14 = bitcast %workbench.Tweener* %11 to %..rawptr
	%15 = bitcast %mem.Allocator* %2 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %2
	store %mem.Allocator %13, %mem.Allocator* %2
	%17 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$21f, i64 0, i32 0), i64 63}, i64 67, i64 2, %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$220, i64 0, i32 0), i64 19}}, %runtime.Source_Code_Location* %3
	call void @mem.free(%..rawptr %14, %mem.Allocator* %2, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define void @workbench._update_tween(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %workbench.Tweener*, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca float*, align 16
	%4 = alloca [2 x float]*, align 16
	%5 = alloca [3 x float]*, align 16
	%6 = alloca [4 x float]*, align 16
	%7 = alloca float*, align 16
	%8 = alloca {[0 x <4 x i8>], [16 x i8], i8}, align 16
	%9 = alloca [2 x float]*, align 16
	%10 = alloca {[0 x <4 x i8>], [16 x i8], i8}, align 16
	%11 = alloca [3 x float]*, align 16
	%12 = alloca {[0 x <4 x i8>], [16 x i8], i8}, align 16
	%13 = alloca [4 x float]*, align 16
	%14 = alloca {[0 x <4 x i8>], [16 x i8], i8}, align 16
	; tweener_idx
	%15 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}, {%workbench.Tweener**, i64, i64, %mem.Allocator}* @workbench.tweeners, align 8
	%16 = extractvalue {%workbench.Tweener**, i64, i64, %mem.Allocator} %15, 1
	%17 = sub i64 %16, 1
	store i64 %17, i64* %0
	; AssignStmt
	store i8 1, i8* @workbench.updating_tweens
	; DeferStmt
	; ForStmt
	br label %for.loop-1

for.loop-1:
	%18 = load i64, i64* %0, align 8
	%19 = icmp sge i64 %18, 0
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %for.body-2, label %for.done-32

for.body-2:
	; DeferStmt
	; tweener
	; IndexExpr
	%22 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}, {%workbench.Tweener**, i64, i64, %mem.Allocator}* @workbench.tweeners, align 8
	%23 = extractvalue {%workbench.Tweener**, i64, i64, %mem.Allocator} %22, 0
	%24 = extractvalue {%workbench.Tweener**, i64, i64, %mem.Allocator} %22, 1
	%25 = load i64, i64* %0, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$221, i64 0, i32 0), i64 63}, i64 102, i64 23, i64 %25, i64 %24)
	%26 = getelementptr inbounds %workbench.Tweener*, %workbench.Tweener** %23, i64 %25
	%27 = load %workbench.Tweener*, %workbench.Tweener** %26, align 8
	store %workbench.Tweener* %27, %workbench.Tweener** %1
	; SelectorExpr
	%28 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%29 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %28, i64 0
	%30 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %29, i64 0, i32 5
	%31 = load float, float* %30, align 4
	%32 = fcmp one float %31, 0x0000000000000000
	%33 = zext i1 %32 to i8
	%34 = trunc i8 %33 to i1
	%35 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$222, i64 0, i32 0), i64 63}, i64 103, i64 3, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$223, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %2
	%37 = call i8 @runtime.assert(i1 %34, %..string zeroinitializer, %runtime.Source_Code_Location* %2)
	; IfStmt
	; SelectorExpr
	%38 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%39 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %38, i64 0
	%40 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %39, i64 0, i32 9
	%41 = load i8, i8* %40, align 1
	%42 = trunc i8 %41 to i1
	br i1 %42, label %if.done-4, label %if.then-3

if.then-3:
	; defer
	; AssignStmt
	%43 = load i64, i64* %0, align 8
	%44 = sub i64 %43, 1
	store i64 %44, i64* %0
	; continue
	br label %for.loop-1

if.done-4:
	; IfStmt
	%45 = load float, float* @workbench.time, align 4
	; SelectorExpr
	%46 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%47 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %46, i64 0
	%48 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %47, i64 0, i32 7
	%49 = load float, float* %48, align 4
	%50 = fcmp olt float %45, %49
	%51 = zext i1 %50 to i8
	%52 = trunc i8 %51 to i1
	br i1 %52, label %if.then-5, label %if.done-6

if.then-5:
	; defer
	; AssignStmt
	%53 = load i64, i64* %0, align 8
	%54 = sub i64 %53, 1
	store i64 %54, i64* %0
	; continue
	br label %for.loop-1

if.done-6:
	; TypeSwitchStmt
	; SelectorExpr
	%55 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%56 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %55, i64 0
	%57 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %56, i64 0, i32 1
	%58 = load {[0 x <8 x i8>], [8 x i8], i8}, {[0 x <8 x i8>], [8 x i8], i8}* %57, align 8
	; get union's tag
	%59 = getelementptr inbounds {[0 x <8 x i8>], [8 x i8], i8}, {[0 x <8 x i8>], [8 x i8], i8}* %57, i64 0, i32 2 ; UnionTagPtr
	%60 = load i8, i8* %59, align 1
	%61 = bitcast {[0 x <8 x i8>], [8 x i8], i8}* %57 to %..rawptr
	%62 = icmp eq i8 %60, 1
	br i1 %62, label %typeswitch.body-8, label %typeswitch.next-7

typeswitch.next-7:
	%63 = icmp eq i8 %60, 2
	br i1 %63, label %typeswitch.body-10, label %typeswitch.next-9

typeswitch.body-8:
	%64 = bitcast %..rawptr %61 to float**
	%65 = load float*, float** %64, align 8
	store float* %65, float** %3
	; AssignStmt
	%66 = load float*, float** %3, align 8
	%67 = getelementptr inbounds float, float* %66, i64 0
	%68 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%69 = load float, float* @workbench.client_target_delta_time, align 4
	%70 = call float @workbench._update_one_tweener-18165(%workbench.Tweener* %68, float %69, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store float %70, float* %67
	br label %typeswitch.done-15

typeswitch.next-9:
	%71 = icmp eq i8 %60, 3
	br i1 %71, label %typeswitch.body-12, label %typeswitch.next-11

typeswitch.body-10:
	%72 = bitcast %..rawptr %61 to [2 x float]**
	%73 = load [2 x float]*, [2 x float]** %72, align 8
	store [2 x float]* %73, [2 x float]** %4
	; AssignStmt
	%74 = load [2 x float]*, [2 x float]** %4, align 8
	%75 = getelementptr inbounds [2 x float], [2 x float]* %74, i64 0
	%76 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%77 = load float, float* @workbench.client_target_delta_time, align 4
	%78 = call [2 x float] @workbench._update_one_tweener-18171(%workbench.Tweener* %76, float %77, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [2 x float] %78, [2 x float]* %75
	br label %typeswitch.done-15

typeswitch.next-11:
	%79 = icmp eq i8 %60, 4
	br i1 %79, label %typeswitch.body-14, label %typeswitch.next-13

typeswitch.body-12:
	%80 = bitcast %..rawptr %61 to [3 x float]**
	%81 = load [3 x float]*, [3 x float]** %80, align 8
	store [3 x float]* %81, [3 x float]** %5
	; AssignStmt
	%82 = load [3 x float]*, [3 x float]** %5, align 8
	%83 = getelementptr inbounds [3 x float], [3 x float]* %82, i64 0
	%84 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%85 = load float, float* @workbench.client_target_delta_time, align 4
	%86 = call [3 x float] @workbench._update_one_tweener-18177(%workbench.Tweener* %84, float %85, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [3 x float] %86, [3 x float]* %83
	br label %typeswitch.done-15

typeswitch.next-13:
	br label %typeswitch.done-15

typeswitch.body-14:
	%87 = bitcast %..rawptr %61 to [4 x float]**
	%88 = load [4 x float]*, [4 x float]** %87, align 8
	store [4 x float]* %88, [4 x float]** %6
	; AssignStmt
	%89 = load [4 x float]*, [4 x float]** %6, align 8
	%90 = getelementptr inbounds [4 x float], [4 x float]* %89, i64 0
	%91 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%92 = load float, float* @workbench.client_target_delta_time, align 4
	%93 = call [4 x float] @workbench._update_one_tweener-18183(%workbench.Tweener* %91, float %92, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x float] %93, [4 x float]* %90
	br label %typeswitch.done-15

typeswitch.done-15:
	; IfStmt
	; SelectorExpr
	%94 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%95 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %94, i64 0
	%96 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %95, i64 0, i32 8
	%97 = load i8, i8* %96, align 1
	%98 = trunc i8 %97 to i1
	br i1 %98, label %if.done-31, label %cmp.and-16

cmp.and-16:
	; SelectorExpr
	%99 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%100 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %99, i64 0
	%101 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %100, i64 0, i32 4
	%102 = load float, float* %101, align 4
	; SelectorExpr
	%103 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%104 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %103, i64 0
	%105 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %104, i64 0, i32 5
	%106 = load float, float* %105, align 4
	%107 = fcmp oge float %102, %106
	%108 = zext i1 %107 to i8
	%109 = trunc i8 %108 to i1
	br i1 %109, label %if.then-17, label %if.done-31

if.then-17:
	; IfStmt
	; SelectorExpr
	%110 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%111 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %110, i64 0
	%112 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %111, i64 0, i32 10
	%113 = load void (%..rawptr, %runtime.Context*)*, void (%..rawptr, %runtime.Context*)** %112, align 8
	%114 = icmp ne void (%..rawptr, %runtime.Context*)* %113, zeroinitializer
	%115 = zext i1 %114 to i8
	%116 = trunc i8 %115 to i1
	br i1 %116, label %if.then-18, label %if.done-19

if.then-18:
	; SelectorExpr
	%117 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%118 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %117, i64 0
	%119 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %118, i64 0, i32 10
	%120 = load void (%..rawptr, %runtime.Context*)*, void (%..rawptr, %runtime.Context*)** %119, align 8
	; SelectorExpr
	%121 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%122 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %121, i64 0
	%123 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %122, i64 0, i32 11
	%124 = load %..rawptr, %..rawptr* %123, align 8
	call void %120(%..rawptr %124, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-19

if.done-19:
	; IfStmt
	; SelectorExpr
	%125 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%126 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %125, i64 0
	%127 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %126, i64 0, i32 12
	%128 = load %workbench.Tweener*, %workbench.Tweener** %127, align 8
	%129 = icmp ne %workbench.Tweener* %128, zeroinitializer
	%130 = zext i1 %129 to i8
	%131 = trunc i8 %130 to i1
	br i1 %131, label %if.then-20, label %if.done-30

if.then-20:
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%132 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%133 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %132, i64 0
	%134 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %133, i64 0, i32 12
	%135 = load %workbench.Tweener*, %workbench.Tweener** %134, align 8
	%136 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %135, i64 0
	%137 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %136, i64 0, i32 9
	store i8 1, i8* %137
	; TypeSwitchStmt
	; SelectorExpr
	; SelectorExpr
	%138 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%139 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %138, i64 0
	%140 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %139, i64 0, i32 12
	%141 = load %workbench.Tweener*, %workbench.Tweener** %140, align 8
	%142 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %141, i64 0
	%143 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %142, i64 0, i32 1
	%144 = load {[0 x <8 x i8>], [8 x i8], i8}, {[0 x <8 x i8>], [8 x i8], i8}* %143, align 8
	; get union's tag
	%145 = getelementptr inbounds {[0 x <8 x i8>], [8 x i8], i8}, {[0 x <8 x i8>], [8 x i8], i8}* %143, i64 0, i32 2 ; UnionTagPtr
	%146 = load i8, i8* %145, align 1
	%147 = bitcast {[0 x <8 x i8>], [8 x i8], i8}* %143 to %..rawptr
	%148 = icmp eq i8 %146, 1
	br i1 %148, label %typeswitch.body-22, label %typeswitch.next-21

typeswitch.next-21:
	%149 = icmp eq i8 %146, 2
	br i1 %149, label %typeswitch.body-24, label %typeswitch.next-23

typeswitch.body-22:
	%150 = bitcast %..rawptr %147 to float**
	%151 = load float*, float** %150, align 8
	store float* %151, float** %7
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%152 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%153 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %152, i64 0
	%154 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %153, i64 0, i32 12
	%155 = load %workbench.Tweener*, %workbench.Tweener** %154, align 8
	%156 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %155, i64 0
	%157 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %156, i64 0, i32 2
	%158 = load float*, float** %7, align 8
	%159 = getelementptr inbounds float, float* %158, i64 0
	%160 = load float, float* %159, align 4
	; union - child to parent
	%161 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %8 to %..rawptr
	%162 = call %..rawptr @mem.zero(%..rawptr %161, i64 20) noinline
	store {[0 x <4 x i8>], [16 x i8], i8} zeroinitializer, {[0 x <4 x i8>], [16 x i8], i8}* %8
	%163 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %8 to float*
	store float %160, float* %163
	%164 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %8, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %164
	%165 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %8, align 4
	store {[0 x <4 x i8>], [16 x i8], i8} %165, {[0 x <4 x i8>], [16 x i8], i8}* %157
	br label %typeswitch.done-29

typeswitch.next-23:
	%166 = icmp eq i8 %146, 3
	br i1 %166, label %typeswitch.body-26, label %typeswitch.next-25

typeswitch.body-24:
	%167 = bitcast %..rawptr %147 to [2 x float]**
	%168 = load [2 x float]*, [2 x float]** %167, align 8
	store [2 x float]* %168, [2 x float]** %9
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%169 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%170 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %169, i64 0
	%171 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %170, i64 0, i32 12
	%172 = load %workbench.Tweener*, %workbench.Tweener** %171, align 8
	%173 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %172, i64 0
	%174 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %173, i64 0, i32 2
	%175 = load [2 x float]*, [2 x float]** %9, align 8
	%176 = getelementptr inbounds [2 x float], [2 x float]* %175, i64 0
	%177 = load [2 x float], [2 x float]* %176, align 4
	; union - child to parent
	%178 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %10 to %..rawptr
	%179 = call %..rawptr @mem.zero(%..rawptr %178, i64 20) noinline
	store {[0 x <4 x i8>], [16 x i8], i8} zeroinitializer, {[0 x <4 x i8>], [16 x i8], i8}* %10
	%180 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %10 to [2 x float]*
	store [2 x float] %177, [2 x float]* %180
	%181 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %10, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %181
	%182 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %10, align 4
	store {[0 x <4 x i8>], [16 x i8], i8} %182, {[0 x <4 x i8>], [16 x i8], i8}* %174
	br label %typeswitch.done-29

typeswitch.next-25:
	%183 = icmp eq i8 %146, 4
	br i1 %183, label %typeswitch.body-28, label %typeswitch.next-27

typeswitch.body-26:
	%184 = bitcast %..rawptr %147 to [3 x float]**
	%185 = load [3 x float]*, [3 x float]** %184, align 8
	store [3 x float]* %185, [3 x float]** %11
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%186 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%187 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %186, i64 0
	%188 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %187, i64 0, i32 12
	%189 = load %workbench.Tweener*, %workbench.Tweener** %188, align 8
	%190 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %189, i64 0
	%191 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %190, i64 0, i32 2
	%192 = load [3 x float]*, [3 x float]** %11, align 8
	%193 = getelementptr inbounds [3 x float], [3 x float]* %192, i64 0
	%194 = load [3 x float], [3 x float]* %193, align 4
	; union - child to parent
	%195 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %12 to %..rawptr
	%196 = call %..rawptr @mem.zero(%..rawptr %195, i64 20) noinline
	store {[0 x <4 x i8>], [16 x i8], i8} zeroinitializer, {[0 x <4 x i8>], [16 x i8], i8}* %12
	%197 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %12 to [3 x float]*
	store [3 x float] %194, [3 x float]* %197
	%198 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %12, i64 0, i32 2 ; UnionTagPtr
	store i8 3, i8* %198
	%199 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %12, align 4
	store {[0 x <4 x i8>], [16 x i8], i8} %199, {[0 x <4 x i8>], [16 x i8], i8}* %191
	br label %typeswitch.done-29

typeswitch.next-27:
	br label %typeswitch.done-29

typeswitch.body-28:
	%200 = bitcast %..rawptr %147 to [4 x float]**
	%201 = load [4 x float]*, [4 x float]** %200, align 8
	store [4 x float]* %201, [4 x float]** %13
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%202 = load %workbench.Tweener*, %workbench.Tweener** %1, align 8
	%203 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %202, i64 0
	%204 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %203, i64 0, i32 12
	%205 = load %workbench.Tweener*, %workbench.Tweener** %204, align 8
	%206 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %205, i64 0
	%207 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %206, i64 0, i32 2
	%208 = load [4 x float]*, [4 x float]** %13, align 8
	%209 = getelementptr inbounds [4 x float], [4 x float]* %208, i64 0
	%210 = load [4 x float], [4 x float]* %209, align 4
	; union - child to parent
	%211 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %14 to %..rawptr
	%212 = call %..rawptr @mem.zero(%..rawptr %211, i64 20) noinline
	store {[0 x <4 x i8>], [16 x i8], i8} zeroinitializer, {[0 x <4 x i8>], [16 x i8], i8}* %14
	%213 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %14 to [4 x float]*
	store [4 x float] %210, [4 x float]* %213
	%214 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %14, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %214
	%215 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %14, align 4
	store {[0 x <4 x i8>], [16 x i8], i8} %215, {[0 x <4 x i8>], [16 x i8], i8}* %207
	br label %typeswitch.done-29

typeswitch.done-29:
	br label %if.done-30

if.done-30:
	%216 = load i64, i64* %0, align 8
	call void @workbench.tween_destroy_index(i64 %216, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-31

if.done-31:
	; defer
	; AssignStmt
	%217 = load i64, i64* %0, align 8
	%218 = sub i64 %217, 1
	store i64 %218, i64* %0
	br label %for.loop-1

for.done-32:
	; defer
	; AssignStmt
	store i8 0, i8* @workbench.updating_tweens
	ret void
}

define void @workbench._init_dear_imgui(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %imgui.IO*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca %runtime.Source_Code_Location, align 16
	%11 = alloca %runtime.Source_Code_Location, align 16
	%12 = alloca {i16*, i64}, align 16
	%13 = alloca {i16*, i64}, align 16
	%14 = alloca i8*, align 16
	%15 = alloca i32, align 16
	%16 = alloca i32, align 16
	%17 = alloca i32, align 16
	%18 = alloca %runtime.Source_Code_Location, align 16
	%19 = alloca %runtime.Source_Code_Location, align 16
	%20 = alloca %imgui.Style*, align 16
	; io
	; SelectorExpr
	%21 = call ccc %imgui.IO* @igGetIO()
	store %imgui.IO* %21, %imgui.IO** %0
	; AssignStmt
	; SelectorExpr
	%22 = load %imgui.IO*, %imgui.IO** %0, align 8
	%23 = getelementptr inbounds %imgui.IO, %imgui.IO* %22, i64 0
	%24 = getelementptr inbounds %imgui.IO, %imgui.IO* %23, i64 0, i32 28
	%25 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	store %..rawptr %25, %..rawptr* %24
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%26 = load %imgui.IO*, %imgui.IO** %0, align 8
	%27 = getelementptr inbounds %imgui.IO, %imgui.IO* %26, i64 0
	%28 = getelementptr inbounds %imgui.IO, %imgui.IO* %27, i64 0, i32 8
	%29 = getelementptr inbounds [19 x i32], [19 x i32]* %28, i64 0, i32 0
	store i32 258, i32* %29
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%30 = load %imgui.IO*, %imgui.IO** %0, align 8
	%31 = getelementptr inbounds %imgui.IO, %imgui.IO* %30, i64 0
	%32 = getelementptr inbounds %imgui.IO, %imgui.IO* %31, i64 0, i32 8
	%33 = getelementptr inbounds [19 x i32], [19 x i32]* %32, i64 0, i32 1
	store i32 263, i32* %33
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%34 = load %imgui.IO*, %imgui.IO** %0, align 8
	%35 = getelementptr inbounds %imgui.IO, %imgui.IO* %34, i64 0
	%36 = getelementptr inbounds %imgui.IO, %imgui.IO* %35, i64 0, i32 8
	%37 = getelementptr inbounds [19 x i32], [19 x i32]* %36, i64 0, i32 2
	store i32 262, i32* %37
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%38 = load %imgui.IO*, %imgui.IO** %0, align 8
	%39 = getelementptr inbounds %imgui.IO, %imgui.IO* %38, i64 0
	%40 = getelementptr inbounds %imgui.IO, %imgui.IO* %39, i64 0, i32 8
	%41 = getelementptr inbounds [19 x i32], [19 x i32]* %40, i64 0, i32 3
	store i32 265, i32* %41
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%42 = load %imgui.IO*, %imgui.IO** %0, align 8
	%43 = getelementptr inbounds %imgui.IO, %imgui.IO* %42, i64 0
	%44 = getelementptr inbounds %imgui.IO, %imgui.IO* %43, i64 0, i32 8
	%45 = getelementptr inbounds [19 x i32], [19 x i32]* %44, i64 0, i32 4
	store i32 264, i32* %45
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%46 = load %imgui.IO*, %imgui.IO** %0, align 8
	%47 = getelementptr inbounds %imgui.IO, %imgui.IO* %46, i64 0
	%48 = getelementptr inbounds %imgui.IO, %imgui.IO* %47, i64 0, i32 8
	%49 = getelementptr inbounds [19 x i32], [19 x i32]* %48, i64 0, i32 5
	store i32 266, i32* %49
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%50 = load %imgui.IO*, %imgui.IO** %0, align 8
	%51 = getelementptr inbounds %imgui.IO, %imgui.IO* %50, i64 0
	%52 = getelementptr inbounds %imgui.IO, %imgui.IO* %51, i64 0, i32 8
	%53 = getelementptr inbounds [19 x i32], [19 x i32]* %52, i64 0, i32 6
	store i32 267, i32* %53
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%54 = load %imgui.IO*, %imgui.IO** %0, align 8
	%55 = getelementptr inbounds %imgui.IO, %imgui.IO* %54, i64 0
	%56 = getelementptr inbounds %imgui.IO, %imgui.IO* %55, i64 0, i32 8
	%57 = getelementptr inbounds [19 x i32], [19 x i32]* %56, i64 0, i32 7
	store i32 268, i32* %57
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%58 = load %imgui.IO*, %imgui.IO** %0, align 8
	%59 = getelementptr inbounds %imgui.IO, %imgui.IO* %58, i64 0
	%60 = getelementptr inbounds %imgui.IO, %imgui.IO* %59, i64 0, i32 8
	%61 = getelementptr inbounds [19 x i32], [19 x i32]* %60, i64 0, i32 8
	store i32 269, i32* %61
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%62 = load %imgui.IO*, %imgui.IO** %0, align 8
	%63 = getelementptr inbounds %imgui.IO, %imgui.IO* %62, i64 0
	%64 = getelementptr inbounds %imgui.IO, %imgui.IO* %63, i64 0, i32 8
	%65 = getelementptr inbounds [19 x i32], [19 x i32]* %64, i64 0, i32 9
	store i32 261, i32* %65
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%66 = load %imgui.IO*, %imgui.IO** %0, align 8
	%67 = getelementptr inbounds %imgui.IO, %imgui.IO* %66, i64 0
	%68 = getelementptr inbounds %imgui.IO, %imgui.IO* %67, i64 0, i32 8
	%69 = getelementptr inbounds [19 x i32], [19 x i32]* %68, i64 0, i32 10
	store i32 259, i32* %69
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%70 = load %imgui.IO*, %imgui.IO** %0, align 8
	%71 = getelementptr inbounds %imgui.IO, %imgui.IO* %70, i64 0
	%72 = getelementptr inbounds %imgui.IO, %imgui.IO* %71, i64 0, i32 8
	%73 = getelementptr inbounds [19 x i32], [19 x i32]* %72, i64 0, i32 11
	store i32 257, i32* %73
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%74 = load %imgui.IO*, %imgui.IO** %0, align 8
	%75 = getelementptr inbounds %imgui.IO, %imgui.IO* %74, i64 0
	%76 = getelementptr inbounds %imgui.IO, %imgui.IO* %75, i64 0, i32 8
	%77 = getelementptr inbounds [19 x i32], [19 x i32]* %76, i64 0, i32 12
	store i32 256, i32* %77
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%78 = load %imgui.IO*, %imgui.IO** %0, align 8
	%79 = getelementptr inbounds %imgui.IO, %imgui.IO* %78, i64 0
	%80 = getelementptr inbounds %imgui.IO, %imgui.IO* %79, i64 0, i32 8
	%81 = getelementptr inbounds [19 x i32], [19 x i32]* %80, i64 0, i32 13
	store i32 65, i32* %81
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%82 = load %imgui.IO*, %imgui.IO** %0, align 8
	%83 = getelementptr inbounds %imgui.IO, %imgui.IO* %82, i64 0
	%84 = getelementptr inbounds %imgui.IO, %imgui.IO* %83, i64 0, i32 8
	%85 = getelementptr inbounds [19 x i32], [19 x i32]* %84, i64 0, i32 14
	store i32 67, i32* %85
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%86 = load %imgui.IO*, %imgui.IO** %0, align 8
	%87 = getelementptr inbounds %imgui.IO, %imgui.IO* %86, i64 0
	%88 = getelementptr inbounds %imgui.IO, %imgui.IO* %87, i64 0, i32 8
	%89 = getelementptr inbounds [19 x i32], [19 x i32]* %88, i64 0, i32 15
	store i32 86, i32* %89
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%90 = load %imgui.IO*, %imgui.IO** %0, align 8
	%91 = getelementptr inbounds %imgui.IO, %imgui.IO* %90, i64 0
	%92 = getelementptr inbounds %imgui.IO, %imgui.IO* %91, i64 0, i32 8
	%93 = getelementptr inbounds [19 x i32], [19 x i32]* %92, i64 0, i32 16
	store i32 88, i32* %93
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%94 = load %imgui.IO*, %imgui.IO** %0, align 8
	%95 = getelementptr inbounds %imgui.IO, %imgui.IO* %94, i64 0
	%96 = getelementptr inbounds %imgui.IO, %imgui.IO* %95, i64 0, i32 8
	%97 = getelementptr inbounds [19 x i32], [19 x i32]* %96, i64 0, i32 17
	store i32 89, i32* %97
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%98 = load %imgui.IO*, %imgui.IO** %0, align 8
	%99 = getelementptr inbounds %imgui.IO, %imgui.IO* %98, i64 0
	%100 = getelementptr inbounds %imgui.IO, %imgui.IO* %99, i64 0, i32 8
	%101 = getelementptr inbounds [19 x i32], [19 x i32]* %100, i64 0, i32 18
	store i32 90, i32* %101
	; ok
	%102 = bitcast i8* %1 to %..rawptr
	%103 = call %..rawptr @mem.zero(%..rawptr %102, i64 1) noinline
	store i8 zeroinitializer, i8* %1
	; AssignStmt
	%104 = call {i32, i8} @workbench.load_shader_text(%..string {i8* getelementptr inbounds ([321 x i8], [321 x i8]* @str$224, i64 0, i32 0), i64 320}, %..string {i8* getelementptr inbounds ([236 x i8], [236 x i8]* @str$225, i64 0, i32 0), i64 235}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%105 = extractvalue {i32, i8} %104, 0
	%106 = extractvalue {i32, i8} %104, 1
	store i32 %105, i32* @workbench.imgui_program
	store i8 %106, i8* %1
	%107 = load i8, i8* %1, align 1
	%108 = trunc i8 %107 to i1
	%109 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%110 = call %..rawptr @mem.zero(%..rawptr %109, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$226, i64 0, i32 0), i64 63}, i64 98, i64 5, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$227, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %2
	%111 = call i8 @runtime.assert(i1 %108, %..string zeroinitializer, %runtime.Source_Code_Location* %2)
	; AssignStmt
	%112 = load i32, i32* @workbench.imgui_program, align 4
	%113 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%114 = call %..rawptr @mem.zero(%..rawptr %113, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$228, i64 0, i32 0), i64 63}, i64 100, i64 32, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$229, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %3
	%115 = call i32 @workbench.get_uniform_location(i32 %112, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$22a, i64 0, i32 0), i64 7}, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %115, i32* @workbench.imgui_uniform_texture
	; AssignStmt
	%116 = load i32, i32* @workbench.imgui_program, align 4
	%117 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	%118 = call %..rawptr @mem.zero(%..rawptr %117, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$22b, i64 0, i32 0), i64 63}, i64 101, i64 32, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$22c, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %4
	%119 = call i32 @workbench.get_uniform_location(i32 %116, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$22d, i64 0, i32 0), i64 7}, %runtime.Source_Code_Location* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %119, i32* @workbench.imgui_uniform_projection
	; AssignStmt
	%120 = load i32, i32* @workbench.imgui_program, align 4
	%121 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	%122 = call %..rawptr @mem.zero(%..rawptr %121, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$22e, i64 0, i32 0), i64 63}, i64 103, i64 29, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$22f, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %5
	%123 = call i32 @workbench.get_attrib_location(i32 %120, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$230, i64 0, i32 0), i64 8}, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %123, i32* @workbench.imgui_attrib_position
	; AssignStmt
	%124 = load i32, i32* @workbench.imgui_program, align 4
	%125 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%126 = call %..rawptr @mem.zero(%..rawptr %125, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$231, i64 0, i32 0), i64 63}, i64 104, i64 29, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$232, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %6
	%127 = call i32 @workbench.get_attrib_location(i32 %124, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$233, i64 0, i32 0), i64 2}, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %127, i32* @workbench.imgui_attrib_uv
	; AssignStmt
	%128 = load i32, i32* @workbench.imgui_program, align 4
	%129 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%130 = call %..rawptr @mem.zero(%..rawptr %129, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$234, i64 0, i32 0), i64 63}, i64 105, i64 29, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$235, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %7
	%131 = call i32 @workbench.get_attrib_location(i32 %128, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$236, i64 0, i32 0), i64 5}, %runtime.Source_Code_Location* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %131, i32* @workbench.imgui_attrib_color
	; AssignStmt
	%132 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$237, i64 0, i32 0), i64 63}, i64 107, i64 33, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$238, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %8
	%134 = call i32 @workbench.gen_buffer(%runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%135 = bitcast i32 %134 to i32
	%136 = bitcast i32 %135 to i32
	store i32 %136, i32* @workbench.imgui_vbo_handle
	; AssignStmt
	%137 = bitcast %runtime.Source_Code_Location* %9 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %9
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$239, i64 0, i32 0), i64 63}, i64 108, i64 33, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$23a, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %9
	%139 = call i32 @workbench.gen_buffer(%runtime.Source_Code_Location* %9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%140 = bitcast i32 %139 to i32
	%141 = bitcast i32 %140 to i32
	store i32 %141, i32* @workbench.imgui_ebo_handle
	%142 = load i32, i32* @workbench.imgui_vbo_handle, align 4
	%143 = bitcast %runtime.Source_Code_Location* %10 to %..rawptr
	%144 = call %..rawptr @mem.zero(%..rawptr %143, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %10
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$23b, i64 0, i32 0), i64 63}, i64 110, i64 5, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$23c, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %10
	call void @workbench.bind_buffer_vbo(i32 %142, %runtime.Source_Code_Location* %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%145 = load i32, i32* @workbench.imgui_ebo_handle, align 4
	%146 = bitcast %runtime.Source_Code_Location* %11 to %..rawptr
	%147 = call %..rawptr @mem.zero(%..rawptr %146, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %11
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$23d, i64 0, i32 0), i64 63}, i64 111, i64 5, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$23e, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %11
	call void @workbench.bind_buffer_ebo(i32 %145, %runtime.Source_Code_Location* %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%148 = load %imgui.IO*, %imgui.IO** %0, align 8
	%149 = getelementptr inbounds %imgui.IO, %imgui.IO* %148, i64 0
	%150 = getelementptr inbounds %imgui.IO, %imgui.IO* %149, i64 0, i32 12
	%151 = load %imgui.FontAtlas*, %imgui.FontAtlas** %150, align 8
	%152 = bitcast {i16*, i64}* %12 to %..rawptr
	%153 = call %..rawptr @mem.zero(%..rawptr %152, i64 16) noinline
	store {i16*, i64} zeroinitializer, {i16*, i64}* %12
	store {i16*, i64} zeroinitializer, {i16*, i64}* %12
	%154 = call %imgui.Font* @imgui.font_atlas_add_font_from_file_ttf(%imgui.FontAtlas* %151, %..string {i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$23f, i64 0, i32 0), i64 26}, float 0x4034000000000000, %imgui.FontConfig* zeroinitializer, {i16*, i64}* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %imgui.Font* %154, %imgui.Font** @workbench.imgui_font_default
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%155 = load %imgui.IO*, %imgui.IO** %0, align 8
	%156 = getelementptr inbounds %imgui.IO, %imgui.IO* %155, i64 0
	%157 = getelementptr inbounds %imgui.IO, %imgui.IO* %156, i64 0, i32 12
	%158 = load %imgui.FontAtlas*, %imgui.FontAtlas** %157, align 8
	%159 = bitcast {i16*, i64}* %13 to %..rawptr
	%160 = call %..rawptr @mem.zero(%..rawptr %159, i64 16) noinline
	store {i16*, i64} zeroinitializer, {i16*, i64}* %13
	store {i16*, i64} zeroinitializer, {i16*, i64}* %13
	%161 = call %imgui.Font* @imgui.font_atlas_add_font_from_file_ttf(%imgui.FontAtlas* %158, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$240, i64 0, i32 0), i64 21}, float 0x4030000000000000, %imgui.FontConfig* zeroinitializer, {i16*, i64}* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %imgui.Font* %161, %imgui.Font** @workbench.imgui_font_mono
	; pixels
	%162 = bitcast i8** %14 to %..rawptr
	%163 = call %..rawptr @mem.zero(%..rawptr %162, i64 8) noinline
	store i8* zeroinitializer, i8** %14
	; width
	%164 = bitcast i32* %15 to %..rawptr
	%165 = call %..rawptr @mem.zero(%..rawptr %164, i64 4) noinline
	store i32 zeroinitializer, i32* %15
	; height
	%166 = bitcast i32* %16 to %..rawptr
	%167 = call %..rawptr @mem.zero(%..rawptr %166, i64 4) noinline
	store i32 zeroinitializer, i32* %16
	; SelectorExpr
	; SelectorExpr
	%168 = load %imgui.IO*, %imgui.IO** %0, align 8
	%169 = getelementptr inbounds %imgui.IO, %imgui.IO* %168, i64 0
	%170 = getelementptr inbounds %imgui.IO, %imgui.IO* %169, i64 0, i32 12
	%171 = load %imgui.FontAtlas*, %imgui.FontAtlas** %170, align 8
	call ccc void @ImFontAtlas_GetTexDataAsRGBA32(%imgui.FontAtlas* %171, i8** %14, i32* %15, i32* %16, i32* zeroinitializer)
	; tex
	%172 = bitcast %runtime.Source_Code_Location* %18 to %..rawptr
	%173 = call %..rawptr @mem.zero(%..rawptr %172, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %18
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$241, i64 0, i32 0), i64 63}, i64 147, i64 12, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$242, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %18
	%174 = call i32 @workbench.gen_texture(%runtime.Source_Code_Location* %18, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %174, i32* %17
	%175 = load i32, i32* %17, align 4
	%176 = bitcast %runtime.Source_Code_Location* %19 to %..rawptr
	%177 = call %..rawptr @mem.zero(%..rawptr %176, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %19
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$243, i64 0, i32 0), i64 63}, i64 148, i64 5, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$244, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %19
	call void @workbench.bind_texture2d(i32 %175, %runtime.Source_Code_Location* %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%178 = load void (i32, i32, i32)*, void (i32, i32, i32)** @gl.TexParameteri, align 8
	call ccc void %178(i32 3553, i32 10241, i32 9729)
	; SelectorExpr
	%179 = load void (i32, i32, i32)*, void (i32, i32, i32)** @gl.TexParameteri, align 8
	call ccc void %179(i32 3553, i32 10240, i32 9729)
	; SelectorExpr
	%180 = load void (i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)*, void (i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.TexImage2D, align 8
	%181 = load i32, i32* %15, align 4
	%182 = load i32, i32* %16, align 4
	%183 = load i8*, i8** %14, align 8
	%184 = bitcast i8* %183 to %..rawptr
	call ccc void %180(i32 3553, i32 0, i32 6408, i32 %181, i32 %182, i32 0, i32 6408, i32 5121, %..rawptr %184)
	; SelectorExpr
	; SelectorExpr
	%185 = load %imgui.IO*, %imgui.IO** %0, align 8
	%186 = getelementptr inbounds %imgui.IO, %imgui.IO* %185, i64 0
	%187 = getelementptr inbounds %imgui.IO, %imgui.IO* %186, i64 0, i32 12
	%188 = load %imgui.FontAtlas*, %imgui.FontAtlas** %187, align 8
	%189 = load i32, i32* %17, align 4
	%190 = zext i32 %189 to i64
	%191 = bitcast i64 %190 to i64
	%192 = inttoptr i64 %191 to %..rawptr
	call ccc void @ImFontAtlas_SetTexID(%imgui.FontAtlas* %188, %..rawptr %192)
	; style
	; SelectorExpr
	%193 = call ccc %imgui.Style* @igGetStyle()
	store %imgui.Style* %193, %imgui.Style** %20
	; AssignStmt
	; SelectorExpr
	%194 = load %imgui.Style*, %imgui.Style** %20, align 8
	%195 = getelementptr inbounds %imgui.Style, %imgui.Style* %194, i64 0
	%196 = getelementptr inbounds %imgui.Style, %imgui.Style* %195, i64 0, i32 1
	store %imgui.Vec2 {float 0x4018000000000000, float 0x4018000000000000}, %imgui.Vec2* %196
	; AssignStmt
	; SelectorExpr
	%197 = load %imgui.Style*, %imgui.Style** %20, align 8
	%198 = getelementptr inbounds %imgui.Style, %imgui.Style* %197, i64 0
	%199 = getelementptr inbounds %imgui.Style, %imgui.Style* %198, i64 0, i32 2
	store float 0x4000000000000000, float* %199
	; AssignStmt
	; SelectorExpr
	%200 = load %imgui.Style*, %imgui.Style** %20, align 8
	%201 = getelementptr inbounds %imgui.Style, %imgui.Style* %200, i64 0
	%202 = getelementptr inbounds %imgui.Style, %imgui.Style* %201, i64 0, i32 6
	store float 0x4000000000000000, float* %202
	; AssignStmt
	; SelectorExpr
	%203 = load %imgui.Style*, %imgui.Style** %20, align 8
	%204 = getelementptr inbounds %imgui.Style, %imgui.Style* %203, i64 0
	%205 = getelementptr inbounds %imgui.Style, %imgui.Style* %204, i64 0, i32 10
	store %imgui.Vec2 {float 0x4010000000000000, float 0x4000000000000000}, %imgui.Vec2* %205
	; AssignStmt
	; SelectorExpr
	%206 = load %imgui.Style*, %imgui.Style** %20, align 8
	%207 = getelementptr inbounds %imgui.Style, %imgui.Style* %206, i64 0
	%208 = getelementptr inbounds %imgui.Style, %imgui.Style* %207, i64 0, i32 11
	store float 0x3ff0000000000000, float* %208
	; AssignStmt
	; SelectorExpr
	%209 = load %imgui.Style*, %imgui.Style** %20, align 8
	%210 = getelementptr inbounds %imgui.Style, %imgui.Style* %209, i64 0
	%211 = getelementptr inbounds %imgui.Style, %imgui.Style* %210, i64 0, i32 13
	store %imgui.Vec2 {float 0x4020000000000000, float 0x4010000000000000}, %imgui.Vec2* %211
	; AssignStmt
	; SelectorExpr
	%212 = load %imgui.Style*, %imgui.Style** %20, align 8
	%213 = getelementptr inbounds %imgui.Style, %imgui.Style* %212, i64 0
	%214 = getelementptr inbounds %imgui.Style, %imgui.Style* %213, i64 0, i32 14
	store %imgui.Vec2 {float 0x4010000000000000, float 0x4010000000000000}, %imgui.Vec2* %214
	; AssignStmt
	; SelectorExpr
	%215 = load %imgui.Style*, %imgui.Style** %20, align 8
	%216 = getelementptr inbounds %imgui.Style, %imgui.Style* %215, i64 0
	%217 = getelementptr inbounds %imgui.Style, %imgui.Style* %216, i64 0, i32 15
	store %imgui.Vec2 {float 0x0000000000000000, float 0x0000000000000000}, %imgui.Vec2* %217
	; AssignStmt
	; SelectorExpr
	%218 = load %imgui.Style*, %imgui.Style** %20, align 8
	%219 = getelementptr inbounds %imgui.Style, %imgui.Style* %218, i64 0
	%220 = getelementptr inbounds %imgui.Style, %imgui.Style* %219, i64 0, i32 16
	store float 0x4034000000000000, float* %220
	; AssignStmt
	; SelectorExpr
	%221 = load %imgui.Style*, %imgui.Style** %20, align 8
	%222 = getelementptr inbounds %imgui.Style, %imgui.Style* %221, i64 0
	%223 = getelementptr inbounds %imgui.Style, %imgui.Style* %222, i64 0, i32 18
	store float 0x4028000000000000, float* %223
	; AssignStmt
	; SelectorExpr
	%224 = load %imgui.Style*, %imgui.Style** %20, align 8
	%225 = getelementptr inbounds %imgui.Style, %imgui.Style* %224, i64 0
	%226 = getelementptr inbounds %imgui.Style, %imgui.Style* %225, i64 0, i32 19
	store float 0x4022000000000000, float* %226
	; AssignStmt
	; SelectorExpr
	%227 = load %imgui.Style*, %imgui.Style** %20, align 8
	%228 = getelementptr inbounds %imgui.Style, %imgui.Style* %227, i64 0
	%229 = getelementptr inbounds %imgui.Style, %imgui.Style* %228, i64 0, i32 20
	store float 0x4022000000000000, float* %229
	; AssignStmt
	; SelectorExpr
	%230 = load %imgui.Style*, %imgui.Style** %20, align 8
	%231 = getelementptr inbounds %imgui.Style, %imgui.Style* %230, i64 0
	%232 = getelementptr inbounds %imgui.Style, %imgui.Style* %231, i64 0, i32 21
	store float 0x3ff0000000000000, float* %232
	; AssignStmt
	; SelectorExpr
	%233 = load %imgui.Style*, %imgui.Style** %20, align 8
	%234 = getelementptr inbounds %imgui.Style, %imgui.Style* %233, i64 0
	%235 = getelementptr inbounds %imgui.Style, %imgui.Style* %234, i64 0, i32 5
	store %imgui.Vec2 {float 0x3fdeb851e0000000, float 0x3fe0000000000000}, %imgui.Vec2* %235
	; AssignStmt
	; SelectorExpr
	%236 = load %imgui.Style*, %imgui.Style** %20, align 8
	%237 = getelementptr inbounds %imgui.Style, %imgui.Style* %236, i64 0
	%238 = getelementptr inbounds %imgui.Style, %imgui.Style* %237, i64 0, i32 22
	store %imgui.Vec2 {float 0x3fe0000000000000, float 0x3fe0000000000000}, %imgui.Vec2* %238
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%239 = load %imgui.Style*, %imgui.Style** %20, align 8
	%240 = getelementptr inbounds %imgui.Style, %imgui.Style* %239, i64 0
	%241 = getelementptr inbounds %imgui.Style, %imgui.Style* %240, i64 0, i32 28
	%242 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %241, i64 0, i32 0
	store %imgui.Vec4 {float 0x3ff0000000000000, float 0x3ff0000000000000, float 0x3ff0000000000000, float 0x3ff0000000000000}, %imgui.Vec4* %242
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%243 = load %imgui.Style*, %imgui.Style** %20, align 8
	%244 = getelementptr inbounds %imgui.Style, %imgui.Style* %243, i64 0
	%245 = getelementptr inbounds %imgui.Style, %imgui.Style* %244, i64 0, i32 28
	%246 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %245, i64 0, i32 1
	store %imgui.Vec4 {float 0x3fe428f5c0000000, float 0x3fe428f5c0000000, float 0x3fe428f5c0000000, float 0x3ff0000000000000}, %imgui.Vec4* %246
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%247 = load %imgui.Style*, %imgui.Style** %20, align 8
	%248 = getelementptr inbounds %imgui.Style, %imgui.Style* %247, i64 0
	%249 = getelementptr inbounds %imgui.Style, %imgui.Style* %248, i64 0, i32 28
	%250 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %249, i64 0, i32 2
	store %imgui.Vec4 {float 0x3fcd70a3c0000000, float 0x3fcd70a3c0000000, float 0x3fcd70a3c0000000, float 0x3fef5c28e0000000}, %imgui.Vec4* %250
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%251 = load %imgui.Style*, %imgui.Style** %20, align 8
	%252 = getelementptr inbounds %imgui.Style, %imgui.Style* %251, i64 0
	%253 = getelementptr inbounds %imgui.Style, %imgui.Style* %252, i64 0, i32 28
	%254 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %253, i64 0, i32 3
	store %imgui.Vec4 {float 0x3fc9999980000000, float 0x3fc9999980000000, float 0x3fc9999980000000, float 0x3ff0000000000000}, %imgui.Vec4* %254
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%255 = load %imgui.Style*, %imgui.Style** %20, align 8
	%256 = getelementptr inbounds %imgui.Style, %imgui.Style* %255, i64 0
	%257 = getelementptr inbounds %imgui.Style, %imgui.Style* %256, i64 0, i32 28
	%258 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %257, i64 0, i32 4
	store %imgui.Vec4 {float 0x3fd0000000000000, float 0x3fd0000000000000, float 0x3fd0000000000000, float 0x3feeb851e0000000}, %imgui.Vec4* %258
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%259 = load %imgui.Style*, %imgui.Style** %20, align 8
	%260 = getelementptr inbounds %imgui.Style, %imgui.Style* %259, i64 0
	%261 = getelementptr inbounds %imgui.Style, %imgui.Style* %260, i64 0, i32 28
	%262 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %261, i64 0, i32 5
	store %imgui.Vec4 {float 0x3fc70a3d60000000, float 0x3fc70a3d60000000, float 0x3fc70a3d60000000, float 0x3fef5c28e0000000}, %imgui.Vec4* %262
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%263 = load %imgui.Style*, %imgui.Style** %20, align 8
	%264 = getelementptr inbounds %imgui.Style, %imgui.Style* %263, i64 0
	%265 = getelementptr inbounds %imgui.Style, %imgui.Style* %264, i64 0, i32 28
	%266 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %265, i64 0, i32 6
	store %imgui.Vec4 {float 0x0000000000000000, float 0x0000000000000000, float 0x0000000000000000, float 0x3fa47ae140000000}, %imgui.Vec4* %266
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%267 = load %imgui.Style*, %imgui.Style** %20, align 8
	%268 = getelementptr inbounds %imgui.Style, %imgui.Style* %267, i64 0
	%269 = getelementptr inbounds %imgui.Style, %imgui.Style* %268, i64 0, i32 28
	%270 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %269, i64 0, i32 7
	store %imgui.Vec4 {float 0x0000000000000000, float 0x0000000000000000, float 0x0000000000000000, float 0x3fd28f5c20000000}, %imgui.Vec4* %270
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%271 = load %imgui.Style*, %imgui.Style** %20, align 8
	%272 = getelementptr inbounds %imgui.Style, %imgui.Style* %271, i64 0
	%273 = getelementptr inbounds %imgui.Style, %imgui.Style* %272, i64 0, i32 28
	%274 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %273, i64 0, i32 10
	store %imgui.Vec4 {float 0x3fd0000000000000, float 0x3fd0000000000000, float 0x3fd0000000000000, float 0x3fef5c28e0000000}, %imgui.Vec4* %274
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%275 = load %imgui.Style*, %imgui.Style** %20, align 8
	%276 = getelementptr inbounds %imgui.Style, %imgui.Style* %275, i64 0
	%277 = getelementptr inbounds %imgui.Style, %imgui.Style* %276, i64 0, i32 28
	%278 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %277, i64 0, i32 12
	store %imgui.Vec4 {float 0x3fbeb851e0000000, float 0x3fbeb851e0000000, float 0x3fbeb851e0000000, float 0x3fdf5c28e0000000}, %imgui.Vec4* %278
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%279 = load %imgui.Style*, %imgui.Style** %20, align 8
	%280 = getelementptr inbounds %imgui.Style, %imgui.Style* %279, i64 0
	%281 = getelementptr inbounds %imgui.Style, %imgui.Style* %280, i64 0, i32 28
	%282 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %281, i64 0, i32 11
	store %imgui.Vec4 {float 0x3fd51eb840000000, float 0x3fd51eb840000000, float 0x3fd51eb840000000, float 0x3fef5c28e0000000}, %imgui.Vec4* %282
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%283 = load %imgui.Style*, %imgui.Style** %20, align 8
	%284 = getelementptr inbounds %imgui.Style, %imgui.Style* %283, i64 0
	%285 = getelementptr inbounds %imgui.Style, %imgui.Style* %284, i64 0, i32 28
	%286 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %285, i64 0, i32 13
	store %imgui.Vec4 {float 0x3fbc28f5c0000000, float 0x3fbc28f5c0000000, float 0x3fbc28f5c0000000, float 0x3fdae147a0000000}, %imgui.Vec4* %286
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%287 = load %imgui.Style*, %imgui.Style** %20, align 8
	%288 = getelementptr inbounds %imgui.Style, %imgui.Style* %287, i64 0
	%289 = getelementptr inbounds %imgui.Style, %imgui.Style* %288, i64 0, i32 28
	%290 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %289, i64 0, i32 14
	store %imgui.Vec4 {float 0x0000000000000000, float 0x0000000000000000, float 0x0000000000000000, float 0x3fb47ae140000000}, %imgui.Vec4* %290
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%291 = load %imgui.Style*, %imgui.Style** %20, align 8
	%292 = getelementptr inbounds %imgui.Style, %imgui.Style* %291, i64 0
	%293 = getelementptr inbounds %imgui.Style, %imgui.Style* %292, i64 0, i32 28
	%294 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %293, i64 0, i32 15
	store %imgui.Vec4 {float 0x3fd147ae00000000, float 0x3fd147ae00000000, float 0x3fd147ae00000000, float 0x3ff0000000000000}, %imgui.Vec4* %294
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%295 = load %imgui.Style*, %imgui.Style** %20, align 8
	%296 = getelementptr inbounds %imgui.Style, %imgui.Style* %295, i64 0
	%297 = getelementptr inbounds %imgui.Style, %imgui.Style* %296, i64 0, i32 28
	%298 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %297, i64 0, i32 16
	store %imgui.Vec4 {float 0x3fe8f5c280000000, float 0x3fe8f5c280000000, float 0x3fe8f5c280000000, float 0x3fd9999980000000}, %imgui.Vec4* %298
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%299 = load %imgui.Style*, %imgui.Style** %20, align 8
	%300 = getelementptr inbounds %imgui.Style, %imgui.Style* %299, i64 0
	%301 = getelementptr inbounds %imgui.Style, %imgui.Style* %300, i64 0, i32 28
	%302 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %301, i64 0, i32 18
	store %imgui.Vec4 {float 0x3fe8f5c280000000, float 0x3fe8f5c280000000, float 0x3fe8f5c280000000, float 0x3fee147ae0000000}, %imgui.Vec4* %302
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%303 = load %imgui.Style*, %imgui.Style** %20, align 8
	%304 = getelementptr inbounds %imgui.Style, %imgui.Style* %303, i64 0
	%305 = getelementptr inbounds %imgui.Style, %imgui.Style* %304, i64 0, i32 28
	%306 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %305, i64 0, i32 19
	store %imgui.Vec4 {float 0x3fe8f5c280000000, float 0x3fe8f5c280000000, float 0x3fe8f5c280000000, float 0x3fee147ae0000000}, %imgui.Vec4* %306
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%307 = load %imgui.Style*, %imgui.Style** %20, align 8
	%308 = getelementptr inbounds %imgui.Style, %imgui.Style* %307, i64 0
	%309 = getelementptr inbounds %imgui.Style, %imgui.Style* %308, i64 0, i32 28
	%310 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %309, i64 0, i32 21
	store %imgui.Vec4 {float 0x3fdae147a0000000, float 0x3fdae147a0000000, float 0x3fdae147a0000000, float 0x3fe3333320000000}, %imgui.Vec4* %310
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%311 = load %imgui.Style*, %imgui.Style** %20, align 8
	%312 = getelementptr inbounds %imgui.Style, %imgui.Style* %311, i64 0
	%313 = getelementptr inbounds %imgui.Style, %imgui.Style* %312, i64 0, i32 28
	%314 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %313, i64 0, i32 22
	store %imgui.Vec4 {float 0x3fe8f5c280000000, float 0x3fe8f5c280000000, float 0x3fe8f5c280000000, float 0x3fd9999980000000}, %imgui.Vec4* %314
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%315 = load %imgui.Style*, %imgui.Style** %20, align 8
	%316 = getelementptr inbounds %imgui.Style, %imgui.Style* %315, i64 0
	%317 = getelementptr inbounds %imgui.Style, %imgui.Style* %316, i64 0, i32 28
	%318 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %317, i64 0, i32 24
	store %imgui.Vec4 {float 0x3fd3d70a20000000, float 0x3fd3d70a20000000, float 0x3fd3d70a20000000, float 0x3fef5c28e0000000}, %imgui.Vec4* %318
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%319 = load %imgui.Style*, %imgui.Style** %20, align 8
	%320 = getelementptr inbounds %imgui.Style, %imgui.Style* %319, i64 0
	%321 = getelementptr inbounds %imgui.Style, %imgui.Style* %320, i64 0, i32 28
	%322 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %321, i64 0, i32 25
	store %imgui.Vec4 {float 0x3fe8f5c280000000, float 0x3fe8f5c280000000, float 0x3fe8f5c280000000, float 0x3fd9999980000000}, %imgui.Vec4* %322
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%323 = load %imgui.Style*, %imgui.Style** %20, align 8
	%324 = getelementptr inbounds %imgui.Style, %imgui.Style* %323, i64 0
	%325 = getelementptr inbounds %imgui.Style, %imgui.Style* %324, i64 0, i32 28
	%326 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %325, i64 0, i32 26
	store %imgui.Vec4 {float 0x3fe9999980000000, float 0x3fe0000000000000, float 0x3fe0000000000000, float 0x3ff0000000000000}, %imgui.Vec4* %326
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%327 = load %imgui.Style*, %imgui.Style** %20, align 8
	%328 = getelementptr inbounds %imgui.Style, %imgui.Style* %327, i64 0
	%329 = getelementptr inbounds %imgui.Style, %imgui.Style* %328, i64 0, i32 28
	%330 = getelementptr inbounds [43 x %imgui.Vec4], [43 x %imgui.Vec4]* %329, i64 0, i32 40
	store %imgui.Vec4 {float 0x3fe4ccccc0000000, float 0x3fd6666660000000, float 0x3fd6666660000000, float 0x3fd0a3d700000000}, %imgui.Vec4* %330
	ret void
}

define void @workbench.imgui_begin_new_frame(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %imgui.IO*, align 16
	%1 = alloca double, align 16
	%2 = alloca double, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	; io
	; SelectorExpr
	%9 = call ccc %imgui.IO* @igGetIO()
	store %imgui.IO* %9, %imgui.IO** %0
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%10 = load %imgui.IO*, %imgui.IO** %0, align 8
	%11 = getelementptr inbounds %imgui.IO, %imgui.IO* %10, i64 0
	%12 = getelementptr inbounds %imgui.IO, %imgui.IO* %11, i64 0, i32 0
	%13 = getelementptr inbounds %imgui.Vec2, %imgui.Vec2* %12, i64 0, i32 0
	%14 = load float, float* @workbench.current_window_width, align 4
	store float %14, float* %13
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%15 = load %imgui.IO*, %imgui.IO** %0, align 8
	%16 = getelementptr inbounds %imgui.IO, %imgui.IO* %15, i64 0
	%17 = getelementptr inbounds %imgui.IO, %imgui.IO* %16, i64 0, i32 0
	%18 = getelementptr inbounds %imgui.Vec2, %imgui.Vec2* %17, i64 0, i32 1
	%19 = load float, float* @workbench.current_window_height, align 4
	store float %19, float* %18
	; IfStmt
	%20 = load i8, i8* @workbench.window_is_focused, align 1
	%21 = trunc i8 %20 to i1
	br i1 %21, label %if.then-1, label %if.else-13

if.then-1:
	; posx
	; posy
	; SelectorExpr
	%22 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	%23 = call {double, double} @glfw.GetCursorPos(%..rawptr %22, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%24 = extractvalue {double, double} %23, 0
	%25 = extractvalue {double, double} %23, 1
	store double %24, double* %1
	store double %25, double* %2
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%26 = load %imgui.IO*, %imgui.IO** %0, align 8
	%27 = getelementptr inbounds %imgui.IO, %imgui.IO* %26, i64 0
	%28 = getelementptr inbounds %imgui.IO, %imgui.IO* %27, i64 0, i32 29
	%29 = getelementptr inbounds %imgui.Vec2, %imgui.Vec2* %28, i64 0, i32 0
	%30 = load double, double* %1, align 8
	%31 = fptrunc double %30 to float
	store float %31, float* %29
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%32 = load %imgui.IO*, %imgui.IO** %0, align 8
	%33 = getelementptr inbounds %imgui.IO, %imgui.IO* %32, i64 0
	%34 = getelementptr inbounds %imgui.IO, %imgui.IO* %33, i64 0, i32 29
	%35 = getelementptr inbounds %imgui.Vec2, %imgui.Vec2* %34, i64 0, i32 1
	%36 = load double, double* %2, align 8
	%37 = fptrunc double %36 to float
	store float %37, float* %35
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%38 = load %imgui.IO*, %imgui.IO** %0, align 8
	%39 = getelementptr inbounds %imgui.IO, %imgui.IO* %38, i64 0
	%40 = getelementptr inbounds %imgui.IO, %imgui.IO* %39, i64 0, i32 30
	%41 = getelementptr inbounds [5 x i8], [5 x i8]* %40, i64 0, i32 0
	; SelectorExpr
	%42 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	%43 = call ccc i32 @glfwGetMouseButton(%..rawptr %42, i32 0)
	%44 = icmp eq i32 %43, 1
	%45 = zext i1 %44 to i8
	store i8 %45, i8* %41
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%46 = load %imgui.IO*, %imgui.IO** %0, align 8
	%47 = getelementptr inbounds %imgui.IO, %imgui.IO* %46, i64 0
	%48 = getelementptr inbounds %imgui.IO, %imgui.IO* %47, i64 0, i32 30
	%49 = getelementptr inbounds [5 x i8], [5 x i8]* %48, i64 0, i32 1
	; SelectorExpr
	%50 = load %..rawptr, %..rawptr* @workbench.main_window, align 8
	%51 = call ccc i32 @glfwGetMouseButton(%..rawptr %50, i32 1)
	%52 = icmp eq i32 %51, 1
	%53 = zext i1 %52 to i8
	store i8 %53, i8* %49
	; AssignStmt
	; SelectorExpr
	%54 = load %imgui.IO*, %imgui.IO** %0, align 8
	%55 = getelementptr inbounds %imgui.IO, %imgui.IO* %54, i64 0
	%56 = getelementptr inbounds %imgui.IO, %imgui.IO* %55, i64 0, i32 31
	%57 = load float, float* @workbench.cursor_scroll, align 4
	store float %57, float* %56
	; AssignStmt
	; SelectorExpr
	%58 = load %imgui.IO*, %imgui.IO** %0, align 8
	%59 = getelementptr inbounds %imgui.IO, %imgui.IO* %58, i64 0
	%60 = getelementptr inbounds %imgui.IO, %imgui.IO* %59, i64 0, i32 33
	%61 = call i8 @workbench.get_key_down(i32 341, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%62 = call i8 @workbench.get_key_down(i32 341, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%63 = trunc i8 %62 to i1
	br i1 %63, label %logical.cmp.done-3, label %logical.cmp.rhs-2

logical.cmp.rhs-2:
	%64 = call i8 @workbench.get_key_down(i32 345, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %logical.cmp.done-3

logical.cmp.done-3:
	%65 = phi i8 [ 1, %if.then-1 ], [ %64, %logical.cmp.rhs-2 ]
	store i8 %65, i8* %60
	; AssignStmt
	; SelectorExpr
	%66 = load %imgui.IO*, %imgui.IO** %0, align 8
	%67 = getelementptr inbounds %imgui.IO, %imgui.IO* %66, i64 0
	%68 = getelementptr inbounds %imgui.IO, %imgui.IO* %67, i64 0, i32 34
	%69 = call i8 @workbench.get_key_down(i32 340, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%70 = call i8 @workbench.get_key_down(i32 340, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%71 = trunc i8 %70 to i1
	br i1 %71, label %logical.cmp.done-5, label %logical.cmp.rhs-4

logical.cmp.rhs-4:
	%72 = call i8 @workbench.get_key_down(i32 344, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %logical.cmp.done-5

logical.cmp.done-5:
	%73 = phi i8 [ 1, %logical.cmp.done-3 ], [ %72, %logical.cmp.rhs-4 ]
	store i8 %73, i8* %68
	; AssignStmt
	; SelectorExpr
	%74 = load %imgui.IO*, %imgui.IO** %0, align 8
	%75 = getelementptr inbounds %imgui.IO, %imgui.IO* %74, i64 0
	%76 = getelementptr inbounds %imgui.IO, %imgui.IO* %75, i64 0, i32 35
	%77 = call i8 @workbench.get_key_down(i32 342, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%78 = call i8 @workbench.get_key_down(i32 342, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%79 = trunc i8 %78 to i1
	br i1 %79, label %logical.cmp.done-7, label %logical.cmp.rhs-6

logical.cmp.rhs-6:
	%80 = call i8 @workbench.get_key_down(i32 346, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %logical.cmp.done-7

logical.cmp.done-7:
	%81 = phi i8 [ 1, %logical.cmp.done-5 ], [ %80, %logical.cmp.rhs-6 ]
	store i8 %81, i8* %76
	; AssignStmt
	; SelectorExpr
	%82 = load %imgui.IO*, %imgui.IO** %0, align 8
	%83 = getelementptr inbounds %imgui.IO, %imgui.IO* %82, i64 0
	%84 = getelementptr inbounds %imgui.IO, %imgui.IO* %83, i64 0, i32 36
	%85 = call i8 @workbench.get_key_down(i32 343, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%86 = call i8 @workbench.get_key_down(i32 343, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%87 = trunc i8 %86 to i1
	br i1 %87, label %logical.cmp.done-9, label %logical.cmp.rhs-8

logical.cmp.rhs-8:
	%88 = call i8 @workbench.get_key_down(i32 347, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %logical.cmp.done-9

logical.cmp.done-9:
	%89 = phi i8 [ 1, %logical.cmp.done-7 ], [ %88, %logical.cmp.rhs-8 ]
	store i8 %89, i8* %84
	; RangeStmt
	; i
	%90 = bitcast i64* %3 to %..rawptr
	%91 = call %..rawptr @mem.zero(%..rawptr %90, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%92 = bitcast i64* %4 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 0, i64* %4
	%94 = bitcast i64* %5 to %..rawptr
	%95 = call %..rawptr @mem.zero(%..rawptr %94, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	store i64 0, i64* %5
	br label %for.interval.loop-10

for.interval.loop-10:
	%96 = load i64, i64* %4, align 8
	%97 = icmp sle i64 %96, 256
	br i1 %97, label %for.interval.body-11, label %for.interval.done-12

for.interval.body-11:
	%98 = load i64, i64* %4, align 8
	%99 = load i64, i64* %5, align 8
	%100 = load i64, i64* %4, align 8
	%101 = add i64 %100, 1
	store i64 %101, i64* %4
	%102 = load i64, i64* %5, align 8
	%103 = add i64 %102, 1
	store i64 %103, i64* %5
	store i64 %98, i64* %3
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%104 = load %imgui.IO*, %imgui.IO** %0, align 8
	%105 = getelementptr inbounds %imgui.IO, %imgui.IO* %104, i64 0
	%106 = getelementptr inbounds %imgui.IO, %imgui.IO* %105, i64 0, i32 37
	%107 = load i64, i64* %3, align 8
	%108 = trunc i64 %107 to i32
	%109 = getelementptr inbounds [512 x i8], [512 x i8]* %106, i64 0, i32 %108
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$245, i64 0, i32 0), i64 63}, i64 295, i64 26, i64 %107, i64 512)
	%110 = load i64, i64* %3, align 8
	%111 = trunc i64 %110 to i32
	%112 = call i8 @workbench.get_key_down(i32 %111, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i8 %112, i8* %109
	br label %for.interval.loop-10

for.interval.done-12:
	br label %if.done-17

if.else-13:
	; AssignStmt
	; SelectorExpr
	%113 = load %imgui.IO*, %imgui.IO** %0, align 8
	%114 = getelementptr inbounds %imgui.IO, %imgui.IO* %113, i64 0
	%115 = getelementptr inbounds %imgui.IO, %imgui.IO* %114, i64 0, i32 29
	store %imgui.Vec2 {float 0xc7efffffc0000000, float 0xc7efffffc0000000}, %imgui.Vec2* %115
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%116 = load %imgui.IO*, %imgui.IO** %0, align 8
	%117 = getelementptr inbounds %imgui.IO, %imgui.IO* %116, i64 0
	%118 = getelementptr inbounds %imgui.IO, %imgui.IO* %117, i64 0, i32 30
	%119 = getelementptr inbounds [5 x i8], [5 x i8]* %118, i64 0, i32 0
	store i8 0, i8* %119
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%120 = load %imgui.IO*, %imgui.IO** %0, align 8
	%121 = getelementptr inbounds %imgui.IO, %imgui.IO* %120, i64 0
	%122 = getelementptr inbounds %imgui.IO, %imgui.IO* %121, i64 0, i32 30
	%123 = getelementptr inbounds [5 x i8], [5 x i8]* %122, i64 0, i32 1
	store i8 0, i8* %123
	; AssignStmt
	; SelectorExpr
	%124 = load %imgui.IO*, %imgui.IO** %0, align 8
	%125 = getelementptr inbounds %imgui.IO, %imgui.IO* %124, i64 0
	%126 = getelementptr inbounds %imgui.IO, %imgui.IO* %125, i64 0, i32 31
	store float 0x0000000000000000, float* %126
	; AssignStmt
	; SelectorExpr
	%127 = load %imgui.IO*, %imgui.IO** %0, align 8
	%128 = getelementptr inbounds %imgui.IO, %imgui.IO* %127, i64 0
	%129 = getelementptr inbounds %imgui.IO, %imgui.IO* %128, i64 0, i32 33
	store i8 0, i8* %129
	; AssignStmt
	; SelectorExpr
	%130 = load %imgui.IO*, %imgui.IO** %0, align 8
	%131 = getelementptr inbounds %imgui.IO, %imgui.IO* %130, i64 0
	%132 = getelementptr inbounds %imgui.IO, %imgui.IO* %131, i64 0, i32 34
	store i8 0, i8* %132
	; AssignStmt
	; SelectorExpr
	%133 = load %imgui.IO*, %imgui.IO** %0, align 8
	%134 = getelementptr inbounds %imgui.IO, %imgui.IO* %133, i64 0
	%135 = getelementptr inbounds %imgui.IO, %imgui.IO* %134, i64 0, i32 35
	store i8 0, i8* %135
	; AssignStmt
	; SelectorExpr
	%136 = load %imgui.IO*, %imgui.IO** %0, align 8
	%137 = getelementptr inbounds %imgui.IO, %imgui.IO* %136, i64 0
	%138 = getelementptr inbounds %imgui.IO, %imgui.IO* %137, i64 0, i32 36
	store i8 0, i8* %138
	; RangeStmt
	; i
	%139 = bitcast i64* %6 to %..rawptr
	%140 = call %..rawptr @mem.zero(%..rawptr %139, i64 8) noinline
	store i64 zeroinitializer, i64* %6
	%141 = bitcast i64* %7 to %..rawptr
	%142 = call %..rawptr @mem.zero(%..rawptr %141, i64 8) noinline
	store i64 zeroinitializer, i64* %7
	store i64 0, i64* %7
	%143 = bitcast i64* %8 to %..rawptr
	%144 = call %..rawptr @mem.zero(%..rawptr %143, i64 8) noinline
	store i64 zeroinitializer, i64* %8
	store i64 0, i64* %8
	br label %for.interval.loop-14

for.interval.loop-14:
	%145 = load i64, i64* %7, align 8
	%146 = icmp sle i64 %145, 256
	br i1 %146, label %for.interval.body-15, label %for.interval.done-16

for.interval.body-15:
	%147 = load i64, i64* %7, align 8
	%148 = load i64, i64* %8, align 8
	%149 = load i64, i64* %7, align 8
	%150 = add i64 %149, 1
	store i64 %150, i64* %7
	%151 = load i64, i64* %8, align 8
	%152 = add i64 %151, 1
	store i64 %152, i64* %8
	store i64 %147, i64* %6
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%153 = load %imgui.IO*, %imgui.IO** %0, align 8
	%154 = getelementptr inbounds %imgui.IO, %imgui.IO* %153, i64 0
	%155 = getelementptr inbounds %imgui.IO, %imgui.IO* %154, i64 0, i32 37
	%156 = load i64, i64* %6, align 8
	%157 = trunc i64 %156 to i32
	%158 = getelementptr inbounds [512 x i8], [512 x i8]* %155, i64 0, i32 %157
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$246, i64 0, i32 0), i64 63}, i64 309, i64 26, i64 %156, i64 512)
	store i8 0, i8* %158
	br label %for.interval.loop-14

for.interval.done-16:
	br label %if.done-17

if.done-17:
	; AssignStmt
	; SelectorExpr
	%159 = load %imgui.IO*, %imgui.IO** %0, align 8
	%160 = getelementptr inbounds %imgui.IO, %imgui.IO* %159, i64 0
	%161 = getelementptr inbounds %imgui.IO, %imgui.IO* %160, i64 0, i32 1
	%162 = load float, float* @workbench.client_target_delta_time, align 4
	store float %162, float* %161
	; SelectorExpr
	call ccc void @igNewFrame()
	ret void
}

define void @workbench.imgui_render(i1 %render_to_screen, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca %imgui.DrawData*, align 16
	%2 = alloca %imgui.IO*, align 16
	%3 = alloca i32, align 16
	%4 = alloca i32, align 16
	%5 = alloca [4 x i32], align 16
	%6 = alloca [4 x i32], align 16
	%7 = alloca i32, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	%9 = alloca i32, align 16
	%10 = alloca %runtime.Source_Code_Location, align 16
	%11 = alloca i32, align 16
	%12 = alloca %runtime.Source_Code_Location, align 16
	%13 = alloca i32, align 16
	%14 = alloca %runtime.Source_Code_Location, align 16
	%15 = alloca [4 x [4 x float]], align 16
	%16 = alloca [4 x [4 x float]], align 16
	%17 = alloca [4 x float], align 16
	%18 = alloca [4 x float], align 16
	%19 = alloca i32, align 16
	%20 = alloca %runtime.Source_Code_Location, align 16
	%21 = alloca %runtime.Source_Code_Location, align 16
	%22 = alloca %runtime.Source_Code_Location, align 16
	%23 = alloca %runtime.Source_Code_Location, align 16
	%24 = alloca i32, align 16
	%25 = alloca %runtime.Source_Code_Location, align 16
	%26 = alloca %runtime.Source_Code_Location, align 16
	%27 = alloca %runtime.Source_Code_Location, align 16
	%28 = alloca {%imgui.DrawList**, i64}, align 16
	%29 = alloca %imgui.DrawList*, align 16
	%30 = alloca i64, align 16
	%31 = alloca i64, align 16
	%32 = alloca i16*, align 16
	%33 = alloca %runtime.Source_Code_Location, align 16
	%34 = alloca %runtime.Source_Code_Location, align 16
	%35 = alloca i32, align 16
	%36 = alloca %imgui.DrawCmd*, align 16
	%37 = alloca %runtime.Source_Code_Location, align 16
	%38 = alloca %runtime.Source_Code_Location, align 16
	%39 = alloca %runtime.Source_Code_Location, align 16
	%40 = zext i1 %render_to_screen to i8
	store i8 %40, i8* %0
	; SelectorExpr
	call ccc void @igRender()
	; IfStmt
	%41 = load i8, i8* %0, align 1
	%42 = trunc i8 %41 to i1
	br i1 %42, label %if.done-2, label %if.then-1

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; data
	; SelectorExpr
	%43 = call ccc %imgui.DrawData* @igGetDrawData()
	store %imgui.DrawData* %43, %imgui.DrawData** %1
	; io
	; SelectorExpr
	%44 = call ccc %imgui.IO* @igGetIO()
	store %imgui.IO* %44, %imgui.IO** %2
	; width
	; SelectorExpr
	; SelectorExpr
	%45 = load %imgui.IO*, %imgui.IO** %2, align 8
	%46 = getelementptr inbounds %imgui.IO, %imgui.IO* %45, i64 0
	%47 = getelementptr inbounds %imgui.IO, %imgui.IO* %46, i64 0, i32 0
	%48 = getelementptr inbounds %imgui.Vec2, %imgui.Vec2* %47, i64 0, i32 0
	%49 = load float, float* %48, align 4
	; SelectorExpr
	; SelectorExpr
	%50 = load %imgui.IO*, %imgui.IO** %2, align 8
	%51 = getelementptr inbounds %imgui.IO, %imgui.IO* %50, i64 0
	%52 = getelementptr inbounds %imgui.IO, %imgui.IO* %51, i64 0, i32 16
	%53 = getelementptr inbounds %imgui.Vec2, %imgui.Vec2* %52, i64 0, i32 0
	%54 = load float, float* %53, align 4
	%55 = fmul float %49, %54
	%56 = fptosi float %55 to i32
	store i32 %56, i32* %3
	; height
	; SelectorExpr
	; SelectorExpr
	%57 = load %imgui.IO*, %imgui.IO** %2, align 8
	%58 = getelementptr inbounds %imgui.IO, %imgui.IO* %57, i64 0
	%59 = getelementptr inbounds %imgui.IO, %imgui.IO* %58, i64 0, i32 0
	%60 = getelementptr inbounds %imgui.Vec2, %imgui.Vec2* %59, i64 0, i32 1
	%61 = load float, float* %60, align 4
	; SelectorExpr
	; SelectorExpr
	%62 = load %imgui.IO*, %imgui.IO** %2, align 8
	%63 = getelementptr inbounds %imgui.IO, %imgui.IO* %62, i64 0
	%64 = getelementptr inbounds %imgui.IO, %imgui.IO* %63, i64 0, i32 16
	%65 = getelementptr inbounds %imgui.Vec2, %imgui.Vec2* %64, i64 0, i32 1
	%66 = load float, float* %65, align 4
	%67 = fmul float %61, %66
	%68 = fptosi float %67 to i32
	store i32 %68, i32* %4
	; IfStmt
	%69 = load i32, i32* %4, align 4
	%70 = icmp eq i32 %69, 0
	%71 = zext i1 %70 to i8
	%72 = trunc i8 %71 to i1
	br i1 %72, label %if.then-4, label %cmp.or-3

cmp.or-3:
	%73 = load i32, i32* %3, align 4
	%74 = icmp eq i32 %73, 0
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-4, label %if.done-5

if.then-4:
	; ReturnStmt
	ret void

if.done-5:
	; lastViewport
	%77 = bitcast [4 x i32]* %5 to %..rawptr
	%78 = call %..rawptr @mem.zero(%..rawptr %77, i64 16) noinline
	store [4 x i32] zeroinitializer, [4 x i32]* %5
	; lastScissor
	%79 = bitcast [4 x i32]* %6 to %..rawptr
	%80 = call %..rawptr @mem.zero(%..rawptr %79, i64 16) noinline
	store [4 x i32] zeroinitializer, [4 x i32]* %6
	; cull
	%81 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$247, i64 0, i32 0), i64 63}, i64 337, i64 16, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$248, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %8
	%83 = call i32 @workbench.get_int(i32 2884, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %83, i32* %7
	; depth
	%84 = bitcast %runtime.Source_Code_Location* %10 to %..rawptr
	%85 = call %..rawptr @mem.zero(%..rawptr %84, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %10
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$249, i64 0, i32 0), i64 63}, i64 338, i64 16, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$24a, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %10
	%86 = call i32 @workbench.get_int(i32 2929, %runtime.Source_Code_Location* %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %86, i32* %9
	; scissor
	%87 = bitcast %runtime.Source_Code_Location* %12 to %..rawptr
	%88 = call %..rawptr @mem.zero(%..rawptr %87, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %12
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$24b, i64 0, i32 0), i64 63}, i64 339, i64 16, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$24c, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %12
	%89 = call i32 @workbench.get_int(i32 3089, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %89, i32* %11
	; blend
	%90 = bitcast %runtime.Source_Code_Location* %14 to %..rawptr
	%91 = call %..rawptr @mem.zero(%..rawptr %90, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %14
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$24d, i64 0, i32 0), i64 63}, i64 340, i64 16, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$24e, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %14
	%92 = call i32 @workbench.get_int(i32 3042, %runtime.Source_Code_Location* %14, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %92, i32* %13
	; SelectorExpr
	%93 = load void (i32, i32*)*, void (i32, i32*)** @gl.GetIntegerv, align 8
	; IndexExpr
	%94 = getelementptr inbounds [4 x i32], [4 x i32]* %5, i64 0, i32 0
	call ccc void %93(i32 2978, i32* %94)
	; SelectorExpr
	%95 = load void (i32, i32*)*, void (i32, i32*)** @gl.GetIntegerv, align 8
	; IndexExpr
	%96 = getelementptr inbounds [4 x i32], [4 x i32]* %6, i64 0, i32 0
	call ccc void %95(i32 3088, i32* %96)
	; SelectorExpr
	%97 = load void (i32)*, void (i32)** @gl.Enable, align 8
	call ccc void %97(i32 3042)
	; SelectorExpr
	%98 = load void (i32)*, void (i32)** @gl.BlendEquation, align 8
	call ccc void %98(i32 32774)
	; SelectorExpr
	%99 = load void (i32, i32)*, void (i32, i32)** @gl.BlendFunc, align 8
	call ccc void %99(i32 770, i32 771)
	; SelectorExpr
	%100 = load void (i32)*, void (i32)** @gl.Disable, align 8
	call ccc void %100(i32 2884)
	; SelectorExpr
	%101 = load void (i32)*, void (i32)** @gl.Disable, align 8
	call ccc void %101(i32 2929)
	; SelectorExpr
	%102 = load void (i32)*, void (i32)** @gl.Enable, align 8
	call ccc void %102(i32 3089)
	; SelectorExpr
	%103 = load void (i32, i32)*, void (i32, i32)** @gl.PolygonMode, align 8
	call ccc void %103(i32 1032, i32 6914)
	; SelectorExpr
	%104 = load void (i32, i32, i32, i32)*, void (i32, i32, i32, i32)** @gl.Viewport, align 8
	%105 = load i32, i32* %3, align 4
	%106 = load i32, i32* %4, align 4
	call ccc void %104(i32 0, i32 0, i32 %105, i32 %106)
	; ortho_projection
	; CompoundLit
	%107 = bitcast [4 x [4 x float]]* %16 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %16
	store [4 x [4 x float]] [[4 x float] zeroinitializer, [4 x float] zeroinitializer, [4 x float] [float 0x0000000000000000, float 0x0000000000000000, float 0xbff0000000000000, float 0x0000000000000000], [4 x float] [float 0xbff0000000000000, float 0x3ff0000000000000, float 0x0000000000000000, float 0x3ff0000000000000]], [4 x [4 x float]]* %16
	; CompoundLit
	%109 = bitcast [4 x float]* %17 to %..rawptr
	%110 = call %..rawptr @mem.zero(%..rawptr %109, i64 16) noinline
	store [4 x float] zeroinitializer, [4 x float]* %17
	store [4 x float] [float zeroinitializer, float 0x0000000000000000, float 0x0000000000000000, float 0x0000000000000000], [4 x float]* %17
	; SelectorExpr
	; SelectorExpr
	%111 = load %imgui.IO*, %imgui.IO** %2, align 8
	%112 = getelementptr inbounds %imgui.IO, %imgui.IO* %111, i64 0
	%113 = getelementptr inbounds %imgui.IO, %imgui.IO* %112, i64 0, i32 0
	%114 = getelementptr inbounds %imgui.Vec2, %imgui.Vec2* %113, i64 0, i32 0
	%115 = load float, float* %114, align 4
	%116 = fdiv float 0x4000000000000000, %115
	%117 = getelementptr inbounds [4 x float], [4 x float]* %17, i64 0, i32 0
	store float %116, float* %117
	%118 = load [4 x float], [4 x float]* %17, align 4
	%119 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %16, i64 0, i32 0
	store [4 x float] %118, [4 x float]* %119
	; CompoundLit
	%120 = bitcast [4 x float]* %18 to %..rawptr
	%121 = call %..rawptr @mem.zero(%..rawptr %120, i64 16) noinline
	store [4 x float] zeroinitializer, [4 x float]* %18
	store [4 x float] [float 0x0000000000000000, float zeroinitializer, float 0x0000000000000000, float 0x0000000000000000], [4 x float]* %18
	; SelectorExpr
	; SelectorExpr
	%122 = load %imgui.IO*, %imgui.IO** %2, align 8
	%123 = getelementptr inbounds %imgui.IO, %imgui.IO* %122, i64 0
	%124 = getelementptr inbounds %imgui.IO, %imgui.IO* %123, i64 0, i32 0
	%125 = getelementptr inbounds %imgui.Vec2, %imgui.Vec2* %124, i64 0, i32 1
	%126 = load float, float* %125, align 4
	%127 = fsub float 0x0000000000000000, %126
	%128 = fdiv float 0x4000000000000000, %127
	%129 = getelementptr inbounds [4 x float], [4 x float]* %18, i64 0, i32 1
	store float %128, float* %129
	%130 = load [4 x float], [4 x float]* %18, align 4
	%131 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %16, i64 0, i32 1
	store [4 x float] %130, [4 x float]* %131
	%132 = load [4 x [4 x float]], [4 x [4 x float]]* %16, align 4
	store [4 x [4 x float]] %132, [4 x [4 x float]]* %15
	; old_program
	%133 = bitcast %runtime.Source_Code_Location* %20 to %..rawptr
	%134 = call %..rawptr @mem.zero(%..rawptr %133, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %20
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$24f, i64 0, i32 0), i64 63}, i64 362, i64 20, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$250, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %20
	%135 = call i32 @workbench.get_current_shader(%runtime.Source_Code_Location* %20, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %135, i32* %19
	; DeferStmt
	%136 = load i32, i32* @workbench.imgui_program, align 4
	%137 = bitcast %runtime.Source_Code_Location* %21 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %21
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$251, i64 0, i32 0), i64 63}, i64 365, i64 5, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$252, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %21
	call void @workbench.use_program(i32 %136, %runtime.Source_Code_Location* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%139 = load i32, i32* @workbench.imgui_program, align 4
	%140 = bitcast %runtime.Source_Code_Location* %22 to %..rawptr
	%141 = call %..rawptr @mem.zero(%..rawptr %140, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %22
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$253, i64 0, i32 0), i64 63}, i64 366, i64 5, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$254, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %22
	call void @workbench.uniform1i(i32 %139, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$255, i64 0, i32 0), i64 7}, i32 0, %runtime.Source_Code_Location* %22, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%142 = load i32, i32* @workbench.imgui_program, align 4
	; IndexExpr
	; IndexExpr
	%143 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %15, i64 0, i32 0
	%144 = getelementptr inbounds [4 x float], [4 x float]* %143, i64 0, i32 0
	%145 = bitcast %runtime.Source_Code_Location* %23 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %23
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$256, i64 0, i32 0), i64 63}, i64 367, i64 5, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$257, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %23
	call void @workbench.uniform_matrix4fv(i32 %142, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$258, i64 0, i32 0), i64 7}, i32 1, i1 false, float* %144, %runtime.Source_Code_Location* %23, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; vao_handle
	%147 = bitcast %runtime.Source_Code_Location* %25 to %..rawptr
	%148 = call %..rawptr @mem.zero(%..rawptr %147, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %25
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$259, i64 0, i32 0), i64 63}, i64 369, i64 19, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$25a, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %25
	%149 = call i32 @workbench.gen_vao(%runtime.Source_Code_Location* %25, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %149, i32* %24
	%150 = load i32, i32* %24, align 4
	%151 = bitcast %runtime.Source_Code_Location* %26 to %..rawptr
	%152 = call %..rawptr @mem.zero(%..rawptr %151, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %26
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$25b, i64 0, i32 0), i64 63}, i64 370, i64 5, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$25c, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %26
	call void @workbench.bind_vao(i32 %150, %runtime.Source_Code_Location* %26, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%153 = load i32, i32* @workbench.imgui_vbo_handle, align 4
	%154 = bitcast %runtime.Source_Code_Location* %27 to %..rawptr
	%155 = call %..rawptr @mem.zero(%..rawptr %154, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %27
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$25d, i64 0, i32 0), i64 63}, i64 371, i64 5, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$25e, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %27
	call void @workbench.bind_buffer_vbo(i32 %153, %runtime.Source_Code_Location* %27, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%156 = load void (i32)*, void (i32)** @gl.EnableVertexAttribArray, align 8
	%157 = load i32, i32* @workbench.imgui_attrib_position, align 4
	%158 = bitcast i32 %157 to i32
	call ccc void %156(i32 %158)
	; SelectorExpr
	%159 = load void (i32)*, void (i32)** @gl.EnableVertexAttribArray, align 8
	%160 = load i32, i32* @workbench.imgui_attrib_uv, align 4
	%161 = bitcast i32 %160 to i32
	call ccc void %159(i32 %161)
	; SelectorExpr
	%162 = load void (i32)*, void (i32)** @gl.EnableVertexAttribArray, align 8
	%163 = load i32, i32* @workbench.imgui_attrib_color, align 4
	%164 = bitcast i32 %163 to i32
	call ccc void %162(i32 %164)
	; SelectorExpr
	%165 = load void (i32, i32, i32, i8, i32, %..rawptr)*, void (i32, i32, i32, i8, i32, %..rawptr)** @gl.VertexAttribPointer, align 8
	%166 = load i32, i32* @workbench.imgui_attrib_position, align 4
	%167 = bitcast i32 %166 to i32
	call ccc void %165(i32 %167, i32 2, i32 5126, i8 0, i32 20, %..rawptr null)
	; SelectorExpr
	%168 = load void (i32, i32, i32, i8, i32, %..rawptr)*, void (i32, i32, i32, i8, i32, %..rawptr)** @gl.VertexAttribPointer, align 8
	%169 = load i32, i32* @workbench.imgui_attrib_uv, align 4
	%170 = bitcast i32 %169 to i32
	call ccc void %168(i32 %170, i32 2, i32 5126, i8 0, i32 20, %..rawptr inttoptr (i64 8 to %..rawptr))
	; SelectorExpr
	%171 = load void (i32, i32, i32, i8, i32, %..rawptr)*, void (i32, i32, i32, i8, i32, %..rawptr)** @gl.VertexAttribPointer, align 8
	%172 = load i32, i32* @workbench.imgui_attrib_color, align 4
	%173 = bitcast i32 %172 to i32
	call ccc void %171(i32 %173, i32 4, i32 5121, i8 1, i32 20, %..rawptr inttoptr (i64 16 to %..rawptr))
	; new_list
	; SelectorExpr
	; SelectorExpr
	%174 = load %imgui.DrawData*, %imgui.DrawData** %1, align 8
	%175 = getelementptr inbounds %imgui.DrawData, %imgui.DrawData* %174, i64 0
	%176 = getelementptr inbounds %imgui.DrawData, %imgui.DrawData* %175, i64 0, i32 1
	%177 = load %imgui.DrawList**, %imgui.DrawList*** %176, align 8
	; SelectorExpr
	%178 = load %imgui.DrawData*, %imgui.DrawData** %1, align 8
	%179 = getelementptr inbounds %imgui.DrawData, %imgui.DrawData* %178, i64 0
	%180 = getelementptr inbounds %imgui.DrawData, %imgui.DrawData* %179, i64 0, i32 2
	%181 = load i32, i32* %180, align 4
	%182 = sext i32 %181 to i64
	%183 = call {%imgui.DrawList**, i64} @mem.slice_ptr-18228(%imgui.DrawList** %177, i64 %182)
	store {%imgui.DrawList**, i64} %183, {%imgui.DrawList**, i64}* %28
	; RangeStmt
	; list
	%184 = bitcast %imgui.DrawList** %29 to %..rawptr
	%185 = call %..rawptr @mem.zero(%..rawptr %184, i64 8) noinline
	store %imgui.DrawList* zeroinitializer, %imgui.DrawList** %29
	%186 = load {%imgui.DrawList**, i64}, {%imgui.DrawList**, i64}* %28, align 8
	%187 = bitcast i64* %30 to %..rawptr
	%188 = call %..rawptr @mem.zero(%..rawptr %187, i64 8) noinline
	store i64 zeroinitializer, i64* %30
	%189 = extractvalue {%imgui.DrawList**, i64} %186, 1
	store i64 %189, i64* %30
	%190 = bitcast i64* %31 to %..rawptr
	%191 = call %..rawptr @mem.zero(%..rawptr %190, i64 8) noinline
	store i64 zeroinitializer, i64* %31
	store i64 -1, i64* %31
	br label %for.index.loop-6

for.index.loop-6:
	%192 = load i64, i64* %31, align 8
	%193 = add i64 %192, 1
	store i64 %193, i64* %31
	%194 = load i64, i64* %30, align 8
	%195 = icmp slt i64 %193, %194
	br i1 %195, label %for.index.body-7, label %for.index.done-11

for.index.body-7:
	%196 = load i64, i64* %31, align 8
	%197 = extractvalue {%imgui.DrawList**, i64} %186, 0
	%198 = getelementptr inbounds %imgui.DrawList*, %imgui.DrawList** %197, i64 %196
	%199 = load %imgui.DrawList*, %imgui.DrawList** %198, align 8
	store %imgui.DrawList* %199, %imgui.DrawList** %29
	; idx_buffer_offset
	store i16* zeroinitializer, i16** %32
	%200 = load i32, i32* @workbench.imgui_vbo_handle, align 4
	%201 = bitcast %runtime.Source_Code_Location* %33 to %..rawptr
	%202 = call %..rawptr @mem.zero(%..rawptr %201, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %33
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$25f, i64 0, i32 0), i64 63}, i64 385, i64 9, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$260, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %33
	call void @workbench.bind_buffer_vbo(i32 %200, %runtime.Source_Code_Location* %33, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%203 = load void (i32, i64, %..rawptr, i32)*, void (i32, i64, %..rawptr, i32)** @gl.BufferData, align 8
	; SelectorExpr
	%204 = load %imgui.DrawList*, %imgui.DrawList** %29, align 8
	%205 = call ccc i32 @ImDrawList_GetVertexBufferSize(%imgui.DrawList* %204)
	%206 = mul i32 %205, 20
	%207 = sext i32 %206 to i64
	; SelectorExpr
	%208 = load %imgui.DrawList*, %imgui.DrawList** %29, align 8
	%209 = call ccc %imgui.DrawVert* @ImDrawList_GetVertexPtr(%imgui.DrawList* %208, i32 0)
	%210 = bitcast %imgui.DrawVert* %209 to %..rawptr
	call ccc void %203(i32 34962, i64 %207, %..rawptr %210, i32 35040)
	%211 = load i32, i32* @workbench.imgui_ebo_handle, align 4
	%212 = bitcast %runtime.Source_Code_Location* %34 to %..rawptr
	%213 = call %..rawptr @mem.zero(%..rawptr %212, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %34
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$261, i64 0, i32 0), i64 63}, i64 391, i64 9, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$262, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %34
	call void @workbench.bind_buffer_ebo(i32 %211, %runtime.Source_Code_Location* %34, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%214 = load void (i32, i64, %..rawptr, i32)*, void (i32, i64, %..rawptr, i32)** @gl.BufferData, align 8
	; SelectorExpr
	%215 = load %imgui.DrawList*, %imgui.DrawList** %29, align 8
	%216 = call ccc i32 @ImDrawList_GetIndexBufferSize(%imgui.DrawList* %215)
	%217 = mul i32 %216, 2
	%218 = sext i32 %217 to i64
	; SelectorExpr
	%219 = load %imgui.DrawList*, %imgui.DrawList** %29, align 8
	%220 = call ccc i16* @ImDrawList_GetIndexPtr(%imgui.DrawList* %219, i32 0)
	%221 = bitcast i16* %220 to %..rawptr
	call ccc void %214(i32 34963, i64 %218, %..rawptr %221, i32 35040)
	; ForStmt
	; j
	store i32 0, i32* %35
	br label %for.loop-8

for.loop-8:
	%222 = load i32, i32* %35, align 4
	; SelectorExpr
	%223 = load %imgui.DrawList*, %imgui.DrawList** %29, align 8
	%224 = call ccc i32 @ImDrawList_GetCmdSize(%imgui.DrawList* %223)
	%225 = icmp slt i32 %222, %224
	%226 = zext i1 %225 to i8
	%227 = trunc i8 %226 to i1
	br i1 %227, label %for.body-9, label %for.done-10

for.body-9:
	; cmd
	; SelectorExpr
	%228 = load %imgui.DrawList*, %imgui.DrawList** %29, align 8
	%229 = load i32, i32* %35, align 4
	%230 = call ccc %imgui.DrawCmd* @ImDrawList_GetCmdPtr(%imgui.DrawList* %228, i32 %229)
	store %imgui.DrawCmd* %230, %imgui.DrawCmd** %36
	; SelectorExpr
	%231 = load %imgui.DrawCmd*, %imgui.DrawCmd** %36, align 8
	%232 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %231, i64 0
	%233 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %232, i64 0, i32 2
	%234 = load %..rawptr, %..rawptr* %233, align 8
	%235 = ptrtoint %..rawptr %234 to i64
	%236 = bitcast i64 %235 to i64
	%237 = trunc i64 %236 to i32
	%238 = bitcast %runtime.Source_Code_Location* %37 to %..rawptr
	%239 = call %..rawptr @mem.zero(%..rawptr %238, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %37
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$263, i64 0, i32 0), i64 63}, i64 399, i64 13, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$264, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %37
	call void @workbench.bind_texture2d(i32 %237, %runtime.Source_Code_Location* %37, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%240 = load void (i32, i32, i32, i32)*, void (i32, i32, i32, i32)** @gl.Scissor, align 8
	; SelectorExpr
	; SelectorExpr
	%241 = load %imgui.DrawCmd*, %imgui.DrawCmd** %36, align 8
	%242 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %241, i64 0
	%243 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %242, i64 0, i32 1
	%244 = getelementptr inbounds %imgui.Vec4, %imgui.Vec4* %243, i64 0, i32 0
	%245 = load float, float* %244, align 4
	%246 = fptosi float %245 to i32
	%247 = load i32, i32* %4, align 4
	; SelectorExpr
	; SelectorExpr
	%248 = load %imgui.DrawCmd*, %imgui.DrawCmd** %36, align 8
	%249 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %248, i64 0
	%250 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %249, i64 0, i32 1
	%251 = getelementptr inbounds %imgui.Vec4, %imgui.Vec4* %250, i64 0, i32 3
	%252 = load float, float* %251, align 4
	%253 = fptosi float %252 to i32
	%254 = sub i32 %247, %253
	; SelectorExpr
	; SelectorExpr
	%255 = load %imgui.DrawCmd*, %imgui.DrawCmd** %36, align 8
	%256 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %255, i64 0
	%257 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %256, i64 0, i32 1
	%258 = getelementptr inbounds %imgui.Vec4, %imgui.Vec4* %257, i64 0, i32 2
	%259 = load float, float* %258, align 4
	; SelectorExpr
	; SelectorExpr
	%260 = load %imgui.DrawCmd*, %imgui.DrawCmd** %36, align 8
	%261 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %260, i64 0
	%262 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %261, i64 0, i32 1
	%263 = getelementptr inbounds %imgui.Vec4, %imgui.Vec4* %262, i64 0, i32 0
	%264 = load float, float* %263, align 4
	%265 = fsub float %259, %264
	%266 = fptosi float %265 to i32
	; SelectorExpr
	; SelectorExpr
	%267 = load %imgui.DrawCmd*, %imgui.DrawCmd** %36, align 8
	%268 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %267, i64 0
	%269 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %268, i64 0, i32 1
	%270 = getelementptr inbounds %imgui.Vec4, %imgui.Vec4* %269, i64 0, i32 3
	%271 = load float, float* %270, align 4
	; SelectorExpr
	; SelectorExpr
	%272 = load %imgui.DrawCmd*, %imgui.DrawCmd** %36, align 8
	%273 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %272, i64 0
	%274 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %273, i64 0, i32 1
	%275 = getelementptr inbounds %imgui.Vec4, %imgui.Vec4* %274, i64 0, i32 1
	%276 = load float, float* %275, align 4
	%277 = fsub float %271, %276
	%278 = fptosi float %277 to i32
	call ccc void %240(i32 %246, i32 %254, i32 %266, i32 %278)
	; SelectorExpr
	%279 = load void (i32, i32, i32, %..rawptr)*, void (i32, i32, i32, %..rawptr)** @gl.DrawElements, align 8
	; SelectorExpr
	%280 = load %imgui.DrawCmd*, %imgui.DrawCmd** %36, align 8
	%281 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %280, i64 0
	%282 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %281, i64 0, i32 0
	%283 = load i32, i32* %282, align 4
	%284 = bitcast i32 %283 to i32
	%285 = load i16*, i16** %32, align 8
	%286 = bitcast i16* %285 to %..rawptr
	call ccc void %279(i32 4, i32 %284, i32 5123, %..rawptr %286)
	; AssignStmt
	; SelectorExpr
	%287 = load i16*, i16** %32, align 8
	; SelectorExpr
	%288 = load %imgui.DrawCmd*, %imgui.DrawCmd** %36, align 8
	%289 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %288, i64 0
	%290 = getelementptr inbounds %imgui.DrawCmd, %imgui.DrawCmd* %289, i64 0, i32 0
	%291 = load i32, i32* %290, align 4
	%292 = zext i32 %291 to i64
	%293 = call i16* @mem.ptr_offset-18238(i16* %287, i64 %292)
	store i16* %293, i16** %32
	; AssignStmt
	%294 = load i32, i32* %35, align 4
	%295 = add i32 %294, 1
	store i32 %295, i32* %35
	br label %for.loop-8

for.done-10:
	br label %for.index.loop-6

for.index.done-11:
	%296 = load i32, i32* %24, align 4
	%297 = bitcast %runtime.Source_Code_Location* %38 to %..rawptr
	%298 = call %..rawptr @mem.zero(%..rawptr %297, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %38
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$265, i64 0, i32 0), i64 63}, i64 408, i64 5, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$266, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %38
	call void @workbench.delete_vao(i32 %296, %runtime.Source_Code_Location* %38, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	%299 = load i32, i32* %13, align 4
	%300 = icmp eq i32 %299, 1
	%301 = zext i1 %300 to i8
	%302 = trunc i8 %301 to i1
	br i1 %302, label %if.then-12, label %if.else-13

if.then-12:
	; SelectorExpr
	%303 = load void (i32)*, void (i32)** @gl.Enable, align 8
	call ccc void %303(i32 3042)
	br label %if.done-14

if.else-13:
	; SelectorExpr
	%304 = load void (i32)*, void (i32)** @gl.Disable, align 8
	call ccc void %304(i32 3042)
	br label %if.done-14

if.done-14:
	; IfStmt
	%305 = load i32, i32* %7, align 4
	%306 = icmp eq i32 %305, 1
	%307 = zext i1 %306 to i8
	%308 = trunc i8 %307 to i1
	br i1 %308, label %if.then-15, label %if.else-16

if.then-15:
	; SelectorExpr
	%309 = load void (i32)*, void (i32)** @gl.Enable, align 8
	call ccc void %309(i32 2884)
	br label %if.done-17

if.else-16:
	; SelectorExpr
	%310 = load void (i32)*, void (i32)** @gl.Disable, align 8
	call ccc void %310(i32 2884)
	br label %if.done-17

if.done-17:
	; IfStmt
	%311 = load i32, i32* %9, align 4
	%312 = icmp eq i32 %311, 1
	%313 = zext i1 %312 to i8
	%314 = trunc i8 %313 to i1
	br i1 %314, label %if.then-18, label %if.else-19

if.then-18:
	; SelectorExpr
	%315 = load void (i32)*, void (i32)** @gl.Enable, align 8
	call ccc void %315(i32 2929)
	br label %if.done-20

if.else-19:
	; SelectorExpr
	%316 = load void (i32)*, void (i32)** @gl.Disable, align 8
	call ccc void %316(i32 2929)
	br label %if.done-20

if.done-20:
	; IfStmt
	%317 = load i32, i32* %11, align 4
	%318 = icmp eq i32 %317, 1
	%319 = zext i1 %318 to i8
	%320 = trunc i8 %319 to i1
	br i1 %320, label %if.then-21, label %if.else-22

if.then-21:
	; SelectorExpr
	%321 = load void (i32)*, void (i32)** @gl.Enable, align 8
	call ccc void %321(i32 3089)
	br label %if.done-23

if.else-22:
	; SelectorExpr
	%322 = load void (i32)*, void (i32)** @gl.Disable, align 8
	call ccc void %322(i32 3089)
	br label %if.done-23

if.done-23:
	; SelectorExpr
	%323 = load void (i32, i32, i32, i32)*, void (i32, i32, i32, i32)** @gl.Viewport, align 8
	; IndexExpr
	%324 = getelementptr inbounds [4 x i32], [4 x i32]* %5, i64 0, i32 0
	%325 = load i32, i32* %324, align 4
	; IndexExpr
	%326 = getelementptr inbounds [4 x i32], [4 x i32]* %5, i64 0, i32 1
	%327 = load i32, i32* %326, align 4
	; IndexExpr
	%328 = getelementptr inbounds [4 x i32], [4 x i32]* %5, i64 0, i32 2
	%329 = load i32, i32* %328, align 4
	; IndexExpr
	%330 = getelementptr inbounds [4 x i32], [4 x i32]* %5, i64 0, i32 3
	%331 = load i32, i32* %330, align 4
	call ccc void %323(i32 %325, i32 %327, i32 %329, i32 %331)
	; SelectorExpr
	%332 = load void (i32, i32, i32, i32)*, void (i32, i32, i32, i32)** @gl.Scissor, align 8
	; IndexExpr
	%333 = getelementptr inbounds [4 x i32], [4 x i32]* %6, i64 0, i32 0
	%334 = load i32, i32* %333, align 4
	; IndexExpr
	%335 = getelementptr inbounds [4 x i32], [4 x i32]* %6, i64 0, i32 1
	%336 = load i32, i32* %335, align 4
	; IndexExpr
	%337 = getelementptr inbounds [4 x i32], [4 x i32]* %6, i64 0, i32 2
	%338 = load i32, i32* %337, align 4
	; IndexExpr
	%339 = getelementptr inbounds [4 x i32], [4 x i32]* %6, i64 0, i32 3
	%340 = load i32, i32* %339, align 4
	call ccc void %332(i32 %334, i32 %336, i32 %338, i32 %340)
	; defer
	%341 = load i32, i32* %19, align 4
	%342 = bitcast %runtime.Source_Code_Location* %39 to %..rawptr
	%343 = call %..rawptr @mem.zero(%..rawptr %342, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %39
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$267, i64 0, i32 0), i64 63}, i64 363, i64 11, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$268, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %39
	call void @workbench.use_program(i32 %341, %runtime.Source_Code_Location* %39, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define i8 @workbench._imgui_struct_block_field_start(%..string %name, %..string %typename, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	%2 = alloca %..any, align 16
	%3 = alloca %..string, align 16
	%4 = alloca %..any, align 16
	%5 = alloca %..any, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..any, align 16
	%8 = alloca {%..any*, i64}, align 16
	%9 = alloca [4 x %..any], align 16
	%10 = alloca {%..any*, i64}, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..string %typename, %..string* %1
	; IfStmt
	%13 = load %..string, %..string* %0, align 8
	%14 = call i8 @runtime.string_ne(%..string %13, %..string zeroinitializer)
	%15 = trunc i8 %14 to i1
	br i1 %15, label %if.then-1, label %if.done-4

if.then-1:
	; IfStmt
	; SelectorExpr
	%16 = load %..string, %..string* %0, align 8
	%17 = load %..string, %..string* %1, align 8
	%18 = bitcast %..any* %2 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 16) noinline
	store %..any zeroinitializer, %..any* %2
	%20 = bitcast %..string* %0 to %..rawptr
	%21 = getelementptr inbounds %..any, %..any* %2, i64 0, i32 0
	store %..rawptr %20, %..rawptr* %21
	%22 = getelementptr inbounds %..any, %..any* %2, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %22
	%23 = load %..any, %..any* %2, align 8
	%24 = bitcast %..string* %3 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %..string zeroinitializer, %..string* %3
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$269, i64 0, i32 0), i64 2}, %..string* %3
	%26 = load %..string, %..string* %3, align 8
	%27 = bitcast %..any* %4 to %..rawptr
	%28 = call %..rawptr @mem.zero(%..rawptr %27, i64 16) noinline
	store %..any zeroinitializer, %..any* %4
	%29 = bitcast %..string* %3 to %..rawptr
	%30 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	store %..rawptr %29, %..rawptr* %30
	%31 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %31
	%32 = load %..any, %..any* %4, align 8
	%33 = bitcast %..any* %5 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 16) noinline
	store %..any zeroinitializer, %..any* %5
	%35 = bitcast %..string* %1 to %..rawptr
	%36 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	store %..rawptr %35, %..rawptr* %36
	%37 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %37
	%38 = load %..any, %..any* %5, align 8
	%39 = bitcast %..string* %6 to %..rawptr
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$26a, i64 0, i32 0), i64 2}, %..string* %6
	%41 = load %..string, %..string* %6, align 8
	%42 = bitcast %..any* %7 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 16) noinline
	store %..any zeroinitializer, %..any* %7
	%44 = bitcast %..string* %6 to %..rawptr
	%45 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 0
	store %..rawptr %44, %..rawptr* %45
	%46 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %46
	%47 = load %..any, %..any* %7, align 8
	; variadic call argument generation
	%48 = bitcast {%..any*, i64}* %8 to %..rawptr
	%49 = call %..rawptr @mem.zero(%..rawptr %48, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %8
	%50 = bitcast [4 x %..any]* %9 to %..rawptr
	%51 = call %..rawptr @mem.zero(%..rawptr %50, i64 64) noinline
	store [4 x %..any] zeroinitializer, [4 x %..any]* %9
	%52 = getelementptr inbounds [4 x %..any], [4 x %..any]* %9, i64 0, i32 0
	store %..any %23, %..any* %52
	%53 = getelementptr inbounds [4 x %..any], [4 x %..any]* %9, i64 0, i32 1
	store %..any %32, %..any* %53
	%54 = getelementptr inbounds [4 x %..any], [4 x %..any]* %9, i64 0, i32 2
	store %..any %38, %..any* %54
	%55 = getelementptr inbounds [4 x %..any], [4 x %..any]* %9, i64 0, i32 3
	store %..any %47, %..any* %55
	%56 = getelementptr inbounds [4 x %..any], [4 x %..any]* %9, i64 0, i32 0
	%57 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %8, i64 0, i32 0
	store %..any* %56, %..any** %57
	%58 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %8, i64 0, i32 1
	store i64 4, i64* %58
	%59 = load {%..any*, i64}, {%..any*, i64}* %8, align 8
	%60 = bitcast {%..any*, i64}* %10 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %10
	store {%..any*, i64} %59, {%..any*, i64}* %10
	%62 = call %..string @fmt.tprint({%..any*, i64}* %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%63 = call i8 @imgui.collapsing_header_(%..string %62, i32 0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%64 = trunc i8 %63 to i1
	br i1 %64, label %if.then-2, label %if.else-3

if.then-2:
	; SelectorExpr
	call ccc void @igIndent(float 0x0000000000000000)
	; ReturnStmt
	ret i8 1

if.else-3:
	; SelectorExpr
	call ccc void @igSameLine(float 0x0000000000000000, float 0xbff0000000000000)
	; SelectorExpr
	; variadic call argument generation
	%65 = bitcast {%..any*, i64}* %11 to %..rawptr
	%66 = call %..rawptr @mem.zero(%..rawptr %65, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	%67 = load {%..any*, i64}, {%..any*, i64}* %11, align 8
	%68 = bitcast {%..any*, i64}* %12 to %..rawptr
	%69 = call %..rawptr @mem.zero(%..rawptr %68, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %12
	store {%..any*, i64} %67, {%..any*, i64}* %12
	call void @imgui.text(%..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$26b, i64 0, i32 0), i64 6}, {%..any*, i64}* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret i8 0

if.done-4:
	; ReturnStmt
	ret i8 1
}

define void @workbench._imgui_struct_block_field_end(%..string %name, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca {%..any*, i64}, align 16
	%2 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	; IfStmt
	%3 = load %..string, %..string* %0, align 8
	%4 = call i8 @runtime.string_ne(%..string %3, %..string zeroinitializer)
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	call ccc void @igUnindent(float 0x0000000000000000)
	; SelectorExpr
	; variadic call argument generation
	%6 = bitcast {%..any*, i64}* %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %1
	%8 = load {%..any*, i64}, {%..any*, i64}* %1, align 8
	%9 = bitcast {%..any*, i64}* %2 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %2
	store {%..any*, i64} %8, {%..any*, i64}* %2
	call void @imgui.text(%..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$26c, i64 0, i32 0), i64 1}, {%..any*, i64}* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-2

if.done-2:
	ret void
}

define void @workbench._imgui_struct_internal(%..string %name, %..rawptr %data, %runtime.Type_Info* %ti, %..string %type_name, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca %..string, align 16
	%4 = alloca %runtime.Type_Info_Integer, align 16
	%5 = alloca %..any, align 16
	%6 = alloca {%..any*, i64}, align 16
	%7 = alloca [1 x %..any], align 16
	%8 = alloca {%..any*, i64}, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [1 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %runtime.Source_Code_Location, align 16
	%15 = alloca %runtime.Type_Info_Float, align 16
	%16 = alloca %..any, align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca [1 x %..any], align 16
	%19 = alloca {%..any*, i64}, align 16
	%20 = alloca %runtime.Source_Code_Location, align 16
	%21 = alloca %runtime.Type_Info_String, align 16
	%22 = alloca %runtime.Source_Code_Location, align 16
	%23 = alloca %runtime.Type_Info_Boolean, align 16
	%24 = alloca %runtime.Source_Code_Location, align 16
	%25 = alloca %runtime.Type_Info_Pointer, align 16
	%26 = alloca %runtime.Type_Info_Named, align 16
	%27 = alloca %runtime.Type_Info_Struct, align 16
	%28 = alloca %..string, align 16
	%29 = alloca i64, align 16
	%30 = alloca i64, align 16
	%31 = alloca i64, align 16
	%32 = alloca %runtime.Type_Info*, align 16
	%33 = alloca i64, align 16
	%34 = alloca i8*, align 16
	%35 = alloca %runtime.Type_Info_Enum, align 16
	%36 = alloca %runtime.Type_Info_Enum_Value, align 16
	%37 = alloca i64, align 16
	%38 = alloca i64, align 16
	%39 = alloca i64, align 16
	%40 = alloca i8, align 16
	%41 = alloca i16, align 16
	%42 = alloca i32, align 16
	%43 = alloca i64, align 16
	%44 = alloca i64, align 16
	%45 = alloca i8, align 16
	%46 = alloca i16, align 16
	%47 = alloca i32, align 16
	%48 = alloca i64, align 16
	%49 = alloca %runtime.Type_Info_Slice, align 16
	%50 = alloca %..string, align 16
	%51 = alloca %..any, align 16
	%52 = alloca %..any, align 16
	%53 = alloca {%..any*, i64}, align 16
	%54 = alloca [2 x %..any], align 16
	%55 = alloca {%..any*, i64}, align 16
	%56 = alloca %mem.Raw_Slice, align 16
	%57 = alloca i64, align 16
	%58 = alloca i64, align 16
	%59 = alloca i64, align 16
	%60 = alloca %..any, align 16
	%61 = alloca {%..any*, i64}, align 16
	%62 = alloca [1 x %..any], align 16
	%63 = alloca {%..any*, i64}, align 16
	%64 = alloca %..string, align 16
	%65 = alloca %..any, align 16
	%66 = alloca %..any, align 16
	%67 = alloca %..string, align 16
	%68 = alloca %..any, align 16
	%69 = alloca {%..any*, i64}, align 16
	%70 = alloca [3 x %..any], align 16
	%71 = alloca {%..any*, i64}, align 16
	%72 = alloca %runtime.Type_Info_Array, align 16
	%73 = alloca %..string, align 16
	%74 = alloca %..any, align 16
	%75 = alloca %..any, align 16
	%76 = alloca %..string, align 16
	%77 = alloca %..any, align 16
	%78 = alloca %..any, align 16
	%79 = alloca {%..any*, i64}, align 16
	%80 = alloca [4 x %..any], align 16
	%81 = alloca {%..any*, i64}, align 16
	%82 = alloca i64, align 16
	%83 = alloca i64, align 16
	%84 = alloca i64, align 16
	%85 = alloca %..any, align 16
	%86 = alloca {%..any*, i64}, align 16
	%87 = alloca [1 x %..any], align 16
	%88 = alloca {%..any*, i64}, align 16
	%89 = alloca %..string, align 16
	%90 = alloca %..any, align 16
	%91 = alloca %..any, align 16
	%92 = alloca %..string, align 16
	%93 = alloca %..any, align 16
	%94 = alloca {%..any*, i64}, align 16
	%95 = alloca [3 x %..any], align 16
	%96 = alloca {%..any*, i64}, align 16
	%97 = alloca %runtime.Type_Info_Dynamic_Array, align 16
	%98 = alloca %..string, align 16
	%99 = alloca %..any, align 16
	%100 = alloca %..any, align 16
	%101 = alloca {%..any*, i64}, align 16
	%102 = alloca [2 x %..any], align 16
	%103 = alloca {%..any*, i64}, align 16
	%104 = alloca %mem.Raw_Dynamic_Array, align 16
	%105 = alloca i64, align 16
	%106 = alloca i64, align 16
	%107 = alloca i64, align 16
	%108 = alloca %..any, align 16
	%109 = alloca {%..any*, i64}, align 16
	%110 = alloca [1 x %..any], align 16
	%111 = alloca {%..any*, i64}, align 16
	%112 = alloca %..string, align 16
	%113 = alloca %..any, align 16
	%114 = alloca %..any, align 16
	%115 = alloca %..string, align 16
	%116 = alloca %..any, align 16
	%117 = alloca {%..any*, i64}, align 16
	%118 = alloca [3 x %..any], align 16
	%119 = alloca {%..any*, i64}, align 16
	%120 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	%121 = alloca %..string, align 16
	%122 = alloca %..any, align 16
	%123 = alloca %..any, align 16
	%124 = alloca {%..any*, i64}, align 16
	%125 = alloca [2 x %..any], align 16
	%126 = alloca {%..any*, i64}, align 16
	%127 = alloca {%..any*, i64}, align 16
	%128 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..rawptr %data, %..rawptr* %1
	store %runtime.Type_Info* %ti, %runtime.Type_Info** %2
	store %..string %type_name, %..string* %3
	; TypeSwitchStmt
	; SelectorExpr
	%129 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%130 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %129, i64 0
	%131 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %130, i64 0, i32 3
	%132 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %131, align 8
	; get union's tag
	%133 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %131, i64 0, i32 2 ; UnionTagPtr
	%134 = load i8, i8* %133, align 1
	%135 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %131 to %..rawptr
	%136 = icmp eq i8 %134, 2
	br i1 %136, label %typeswitch.body-2, label %typeswitch.next-1

typeswitch.next-1:
	%137 = icmp eq i8 %134, 4
	br i1 %137, label %typeswitch.body-25, label %typeswitch.next-24

typeswitch.body-2:
	%138 = bitcast %..rawptr %135 to %runtime.Type_Info_Integer*
	%139 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %138, align 1
	store %runtime.Type_Info_Integer %139, %runtime.Type_Info_Integer* %4
	; IfStmt
	; SelectorExpr
	%140 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %4, i64 0, i32 0
	%141 = load i8, i8* %140, align 1
	%142 = trunc i8 %141 to i1
	br i1 %142, label %if.then-3, label %if.else-13

if.then-3:
	; SwitchStmt
	; SelectorExpr
	%143 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%144 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %143, i64 0
	%145 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %144, i64 0, i32 0
	%146 = load i64, i64* %145, align 8
	%147 = icmp eq i64 %146, 8
	br i1 %147, label %switch.case.body-5, label %switch.case.next-4

switch.case.next-4:
	%148 = icmp eq i64 %146, 4
	br i1 %148, label %switch.fall.body-7, label %switch.case.next-6

switch.case.body-5:
	%149 = load %..string, %..string* %0, align 8
	%150 = load %..rawptr, %..rawptr* %1, align 8
	call void @workbench._imgui_struct_internal.simple_field-0(%..string %149, %..rawptr %150, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-12

switch.case.next-6:
	%151 = icmp eq i64 %146, 2
	br i1 %151, label %switch.fall.body-9, label %switch.case.next-8

switch.fall.body-7:
	%152 = load %..string, %..string* %0, align 8
	%153 = load %..rawptr, %..rawptr* %1, align 8
	call void @workbench._imgui_struct_internal.simple_field-1(%..string %152, %..rawptr %153, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-12

switch.case.next-8:
	%154 = icmp eq i64 %146, 1
	br i1 %154, label %switch.fall.body-11, label %switch.case.next-10

switch.fall.body-9:
	%155 = load %..string, %..string* %0, align 8
	%156 = load %..rawptr, %..rawptr* %1, align 8
	call void @workbench._imgui_struct_internal.simple_field-2(%..string %155, %..rawptr %156, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-12

switch.case.next-10:
	; SelectorExpr
	%157 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%158 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %157, i64 0
	%159 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %158, i64 0, i32 0
	%160 = load i64, i64* %159, align 8
	%161 = bitcast %..any* %5 to %..rawptr
	%162 = call %..rawptr @mem.zero(%..rawptr %161, i64 16) noinline
	store %..any zeroinitializer, %..any* %5
	%163 = bitcast i64* %159 to %..rawptr
	%164 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	store %..rawptr %163, %..rawptr* %164
	%165 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %165
	%166 = load %..any, %..any* %5, align 8
	; variadic call argument generation
	%167 = bitcast {%..any*, i64}* %6 to %..rawptr
	%168 = call %..rawptr @mem.zero(%..rawptr %167, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %6
	%169 = bitcast [1 x %..any]* %7 to %..rawptr
	%170 = call %..rawptr @mem.zero(%..rawptr %169, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %7
	%171 = getelementptr inbounds [1 x %..any], [1 x %..any]* %7, i64 0, i32 0
	store %..any %166, %..any* %171
	%172 = getelementptr inbounds [1 x %..any], [1 x %..any]* %7, i64 0, i32 0
	%173 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %6, i64 0, i32 0
	store %..any* %172, %..any** %173
	%174 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %6, i64 0, i32 1
	store i64 1, i64* %174
	%175 = load {%..any*, i64}, {%..any*, i64}* %6, align 8
	%176 = bitcast {%..any*, i64}* %8 to %..rawptr
	%177 = call %..rawptr @mem.zero(%..rawptr %176, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %8
	store {%..any*, i64} %175, {%..any*, i64}* %8
	%178 = call %..string @fmt.tprint({%..any*, i64}* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%179 = bitcast %runtime.Source_Code_Location* %9 to %..rawptr
	%180 = call %..rawptr @mem.zero(%..rawptr %179, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %9
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$26d, i64 0, i32 0), i64 63}, i64 503, i64 27, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$26e, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %9
	%181 = call i8 @runtime.assert(i1 false, %..string %178, %runtime.Source_Code_Location* %9)
	br label %switch.done-12

switch.fall.body-11:
	%182 = load %..string, %..string* %0, align 8
	%183 = load %..rawptr, %..rawptr* %1, align 8
	call void @workbench._imgui_struct_internal.simple_field-3(%..string %182, %..rawptr %183, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-12

switch.done-12:
	br label %if.done-23

if.else-13:
	; SwitchStmt
	; SelectorExpr
	%184 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%185 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %184, i64 0
	%186 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %185, i64 0, i32 0
	%187 = load i64, i64* %186, align 8
	%188 = icmp eq i64 %187, 8
	br i1 %188, label %switch.case.body-15, label %switch.case.next-14

switch.case.next-14:
	%189 = icmp eq i64 %187, 4
	br i1 %189, label %switch.fall.body-17, label %switch.case.next-16

switch.case.body-15:
	%190 = load %..string, %..string* %0, align 8
	%191 = load %..rawptr, %..rawptr* %1, align 8
	call void @workbench._imgui_struct_internal.simple_field-4(%..string %190, %..rawptr %191, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-22

switch.case.next-16:
	%192 = icmp eq i64 %187, 2
	br i1 %192, label %switch.fall.body-19, label %switch.case.next-18

switch.fall.body-17:
	%193 = load %..string, %..string* %0, align 8
	%194 = load %..rawptr, %..rawptr* %1, align 8
	call void @workbench._imgui_struct_internal.simple_field-5(%..string %193, %..rawptr %194, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-22

switch.case.next-18:
	%195 = icmp eq i64 %187, 1
	br i1 %195, label %switch.fall.body-21, label %switch.case.next-20

switch.fall.body-19:
	%196 = load %..string, %..string* %0, align 8
	%197 = load %..rawptr, %..rawptr* %1, align 8
	call void @workbench._imgui_struct_internal.simple_field-6(%..string %196, %..rawptr %197, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-22

switch.case.next-20:
	; SelectorExpr
	%198 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%199 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %198, i64 0
	%200 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %199, i64 0, i32 0
	%201 = load i64, i64* %200, align 8
	%202 = bitcast %..any* %10 to %..rawptr
	%203 = call %..rawptr @mem.zero(%..rawptr %202, i64 16) noinline
	store %..any zeroinitializer, %..any* %10
	%204 = bitcast i64* %200 to %..rawptr
	%205 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 0
	store %..rawptr %204, %..rawptr* %205
	%206 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %206
	%207 = load %..any, %..any* %10, align 8
	; variadic call argument generation
	%208 = bitcast {%..any*, i64}* %11 to %..rawptr
	%209 = call %..rawptr @mem.zero(%..rawptr %208, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	%210 = bitcast [1 x %..any]* %12 to %..rawptr
	%211 = call %..rawptr @mem.zero(%..rawptr %210, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %12
	%212 = getelementptr inbounds [1 x %..any], [1 x %..any]* %12, i64 0, i32 0
	store %..any %207, %..any* %212
	%213 = getelementptr inbounds [1 x %..any], [1 x %..any]* %12, i64 0, i32 0
	%214 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 0
	store %..any* %213, %..any** %214
	%215 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 1
	store i64 1, i64* %215
	%216 = load {%..any*, i64}, {%..any*, i64}* %11, align 8
	%217 = bitcast {%..any*, i64}* %13 to %..rawptr
	%218 = call %..rawptr @mem.zero(%..rawptr %217, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	store {%..any*, i64} %216, {%..any*, i64}* %13
	%219 = call %..string @fmt.tprint({%..any*, i64}* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%220 = bitcast %runtime.Source_Code_Location* %14 to %..rawptr
	%221 = call %..rawptr @mem.zero(%..rawptr %220, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %14
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$26f, i64 0, i32 0), i64 63}, i64 512, i64 27, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$270, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %14
	%222 = call i8 @runtime.assert(i1 false, %..string %219, %runtime.Source_Code_Location* %14)
	br label %switch.done-22

switch.fall.body-21:
	%223 = load %..string, %..string* %0, align 8
	%224 = load %..rawptr, %..rawptr* %1, align 8
	call void @workbench._imgui_struct_internal.simple_field-7(%..string %223, %..rawptr %224, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-22

switch.done-22:
	br label %if.done-23

if.done-23:
	br label %typeswitch.done-109

typeswitch.next-24:
	%225 = icmp eq i8 %134, 6
	br i1 %225, label %typeswitch.body-32, label %typeswitch.next-31

typeswitch.body-25:
	%226 = bitcast %..rawptr %135 to %runtime.Type_Info_Float*
	%227 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %226, align 1
	store %runtime.Type_Info_Float %227, %runtime.Type_Info_Float* %15
	; SwitchStmt
	; SelectorExpr
	%228 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%229 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %228, i64 0
	%230 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %229, i64 0, i32 0
	%231 = load i64, i64* %230, align 8
	%232 = icmp eq i64 %231, 8
	br i1 %232, label %switch.case.body-27, label %switch.case.next-26

switch.case.next-26:
	%233 = icmp eq i64 %231, 4
	br i1 %233, label %switch.fall.body-29, label %switch.case.next-28

switch.case.body-27:
	%234 = load %..string, %..string* %0, align 8
	%235 = load %..rawptr, %..rawptr* %1, align 8
	call void @workbench._imgui_struct_internal.simple_field-8(%..string %234, %..rawptr %235, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-30

switch.case.next-28:
	; SelectorExpr
	%236 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%237 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %236, i64 0
	%238 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %237, i64 0, i32 0
	%239 = load i64, i64* %238, align 8
	%240 = bitcast %..any* %16 to %..rawptr
	%241 = call %..rawptr @mem.zero(%..rawptr %240, i64 16) noinline
	store %..any zeroinitializer, %..any* %16
	%242 = bitcast i64* %238 to %..rawptr
	%243 = getelementptr inbounds %..any, %..any* %16, i64 0, i32 0
	store %..rawptr %242, %..rawptr* %243
	%244 = getelementptr inbounds %..any, %..any* %16, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %244
	%245 = load %..any, %..any* %16, align 8
	; variadic call argument generation
	%246 = bitcast {%..any*, i64}* %17 to %..rawptr
	%247 = call %..rawptr @mem.zero(%..rawptr %246, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	%248 = bitcast [1 x %..any]* %18 to %..rawptr
	%249 = call %..rawptr @mem.zero(%..rawptr %248, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %18
	%250 = getelementptr inbounds [1 x %..any], [1 x %..any]* %18, i64 0, i32 0
	store %..any %245, %..any* %250
	%251 = getelementptr inbounds [1 x %..any], [1 x %..any]* %18, i64 0, i32 0
	%252 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %17, i64 0, i32 0
	store %..any* %251, %..any** %252
	%253 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %17, i64 0, i32 1
	store i64 1, i64* %253
	%254 = load {%..any*, i64}, {%..any*, i64}* %17, align 8
	%255 = bitcast {%..any*, i64}* %19 to %..rawptr
	%256 = call %..rawptr @mem.zero(%..rawptr %255, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %19
	store {%..any*, i64} %254, {%..any*, i64}* %19
	%257 = call %..string @fmt.tprint({%..any*, i64}* %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%258 = bitcast %runtime.Source_Code_Location* %20 to %..rawptr
	%259 = call %..rawptr @mem.zero(%..rawptr %258, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %20
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$271, i64 0, i32 0), i64 63}, i64 520, i64 23, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$272, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %20
	%260 = call i8 @runtime.assert(i1 false, %..string %257, %runtime.Source_Code_Location* %20)
	br label %switch.done-30

switch.fall.body-29:
	%261 = load %..string, %..string* %0, align 8
	%262 = load %..rawptr, %..rawptr* %1, align 8
	call void @workbench._imgui_struct_internal.simple_field-9(%..string %261, %..rawptr %262, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-30

switch.done-30:
	br label %typeswitch.done-109

typeswitch.next-31:
	%263 = icmp eq i8 %134, 7
	br i1 %263, label %typeswitch.body-34, label %typeswitch.next-33

typeswitch.body-32:
	%264 = bitcast %..rawptr %135 to %runtime.Type_Info_String*
	%265 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %264, align 1
	store %runtime.Type_Info_String %265, %runtime.Type_Info_String* %21
	; SelectorExpr
	%266 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%267 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %266, i64 0
	%268 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %267, i64 0, i32 0
	%269 = load i64, i64* %268, align 8
	%270 = icmp eq i64 %269, 16
	%271 = zext i1 %270 to i8
	%272 = trunc i8 %271 to i1
	%273 = bitcast %runtime.Source_Code_Location* %22 to %..rawptr
	%274 = call %..rawptr @mem.zero(%..rawptr %273, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %22
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$273, i64 0, i32 0), i64 63}, i64 524, i64 13, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$274, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %22
	%275 = call i8 @runtime.assert(i1 %272, %..string zeroinitializer, %runtime.Source_Code_Location* %22)
	%276 = load %..string, %..string* %0, align 8
	%277 = load %..rawptr, %..rawptr* %1, align 8
	call void @workbench._imgui_struct_internal.simple_field-10(%..string %276, %..rawptr %277, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-109

typeswitch.next-33:
	%278 = icmp eq i8 %134, 10
	br i1 %278, label %typeswitch.body-36, label %typeswitch.next-35

typeswitch.body-34:
	%279 = bitcast %..rawptr %135 to %runtime.Type_Info_Boolean*
	%280 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %279, align 1
	store %runtime.Type_Info_Boolean %280, %runtime.Type_Info_Boolean* %23
	; SelectorExpr
	%281 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%282 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %281, i64 0
	%283 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %282, i64 0, i32 0
	%284 = load i64, i64* %283, align 8
	%285 = icmp eq i64 %284, 1
	%286 = zext i1 %285 to i8
	%287 = trunc i8 %286 to i1
	%288 = bitcast %runtime.Source_Code_Location* %24 to %..rawptr
	%289 = call %..rawptr @mem.zero(%..rawptr %288, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %24
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$275, i64 0, i32 0), i64 63}, i64 528, i64 13, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$276, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %24
	%290 = call i8 @runtime.assert(i1 %287, %..string zeroinitializer, %runtime.Source_Code_Location* %24)
	%291 = load %..string, %..string* %0, align 8
	%292 = load %..rawptr, %..rawptr* %1, align 8
	call void @workbench._imgui_struct_internal.simple_field-11(%..string %291, %..rawptr %292, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-109

typeswitch.next-35:
	%293 = icmp eq i8 %134, 1
	br i1 %293, label %typeswitch.body-38, label %typeswitch.next-37

typeswitch.body-36:
	%294 = bitcast %..rawptr %135 to %runtime.Type_Info_Pointer*
	%295 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %294, align 8
	store %runtime.Type_Info_Pointer %295, %runtime.Type_Info_Pointer* %25
	%296 = load %..string, %..string* %0, align 8
	%297 = load %..rawptr, %..rawptr* %1, align 8
	call void @workbench._imgui_struct_internal.simple_field-12(%..string %296, %..rawptr %297, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-109

typeswitch.next-37:
	%298 = icmp eq i8 %134, 16
	br i1 %298, label %typeswitch.body-40, label %typeswitch.next-39

typeswitch.body-38:
	%299 = bitcast %..rawptr %135 to %runtime.Type_Info_Named*
	%300 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %299, align 8
	store %runtime.Type_Info_Named %300, %runtime.Type_Info_Named* %26
	%301 = load %..string, %..string* %0, align 8
	%302 = load %..rawptr, %..rawptr* %1, align 8
	; SelectorExpr
	%303 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %26, i64 0, i32 1
	%304 = load %runtime.Type_Info*, %runtime.Type_Info** %303, align 8
	; SelectorExpr
	%305 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %26, i64 0, i32 0
	%306 = load %..string, %..string* %305, align 8
	call void @workbench._imgui_struct_internal(%..string %301, %..rawptr %302, %runtime.Type_Info* %304, %..string %306, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-109

typeswitch.next-39:
	%307 = icmp eq i8 %134, 18
	br i1 %307, label %typeswitch.body-47, label %typeswitch.next-46

typeswitch.body-40:
	%308 = bitcast %..rawptr %135 to %runtime.Type_Info_Struct*
	%309 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %308, align 8
	store %runtime.Type_Info_Struct %309, %runtime.Type_Info_Struct* %27
	; IfStmt
	%310 = load %..string, %..string* %0, align 8
	%311 = load %..string, %..string* %3, align 8
	%312 = call i8 @workbench._imgui_struct_block_field_start(%..string %310, %..string %311, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%313 = trunc i8 %312 to i1
	br i1 %313, label %if.then-41, label %if.done-45

if.then-41:
	; DeferStmt
	; RangeStmt
	; field_name
	%314 = bitcast %..string* %28 to %..rawptr
	%315 = call %..rawptr @mem.zero(%..rawptr %314, i64 16) noinline
	store %..string zeroinitializer, %..string* %28
	; i
	%316 = bitcast i64* %29 to %..rawptr
	%317 = call %..rawptr @mem.zero(%..rawptr %316, i64 8) noinline
	store i64 zeroinitializer, i64* %29
	; SelectorExpr
	%318 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %27, i64 0, i32 1
	%319 = load {%..string*, i64}, {%..string*, i64}* %318, align 8
	%320 = bitcast i64* %30 to %..rawptr
	%321 = call %..rawptr @mem.zero(%..rawptr %320, i64 8) noinline
	store i64 zeroinitializer, i64* %30
	%322 = extractvalue {%..string*, i64} %319, 1
	store i64 %322, i64* %30
	%323 = bitcast i64* %31 to %..rawptr
	%324 = call %..rawptr @mem.zero(%..rawptr %323, i64 8) noinline
	store i64 zeroinitializer, i64* %31
	store i64 -1, i64* %31
	br label %for.index.loop-42

for.index.loop-42:
	%325 = load i64, i64* %31, align 8
	%326 = add i64 %325, 1
	store i64 %326, i64* %31
	%327 = load i64, i64* %30, align 8
	%328 = icmp slt i64 %326, %327
	br i1 %328, label %for.index.body-43, label %for.index.done-44

for.index.body-43:
	%329 = load i64, i64* %31, align 8
	%330 = extractvalue {%..string*, i64} %319, 0
	%331 = getelementptr inbounds %..string, %..string* %330, i64 %329
	%332 = load %..string, %..string* %331, align 8
	store %..string %332, %..string* %28
	store i64 %329, i64* %29
	; t
	; IndexExpr
	; SelectorExpr
	%333 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %27, i64 0, i32 0
	%334 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %333, align 8
	%335 = extractvalue {%runtime.Type_Info**, i64} %334, 0
	%336 = load i64, i64* %29, align 8
	%337 = extractvalue {%runtime.Type_Info**, i64} %334, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$277, i64 0, i32 0), i64 63}, i64 541, i64 37, i64 %336, i64 %337)
	%338 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %335, i64 %336
	%339 = load %runtime.Type_Info*, %runtime.Type_Info** %338, align 8
	store %runtime.Type_Info* %339, %runtime.Type_Info** %32
	; offset
	; IndexExpr
	; SelectorExpr
	%340 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %27, i64 0, i32 2
	%341 = load {i64*, i64}, {i64*, i64}* %340, align 8
	%342 = extractvalue {i64*, i64} %341, 0
	%343 = load i64, i64* %29, align 8
	%344 = extractvalue {i64*, i64} %341, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$278, i64 0, i32 0), i64 63}, i64 542, i64 44, i64 %343, i64 %344)
	%345 = getelementptr inbounds i64, i64* %342, i64 %343
	%346 = load i64, i64* %345, align 8
	store i64 %346, i64* %33
	; data
	; SelectorExpr
	%347 = load %..rawptr, %..rawptr* %1, align 8
	%348 = bitcast %..rawptr %347 to i8*
	%349 = load i64, i64* %33, align 8
	%350 = bitcast i64 %349 to i64
	%351 = call i8* @mem.ptr_offset-13926(i8* %348, i64 %350)
	store i8* %351, i8** %34
	%352 = load %..string, %..string* %28, align 8
	%353 = load i8*, i8** %34, align 8
	%354 = load %runtime.Type_Info*, %runtime.Type_Info** %32, align 8
	%355 = bitcast i8* %353 to %..rawptr
	call void @workbench._imgui_struct_internal(%..string %352, %..rawptr %355, %runtime.Type_Info* %354, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-42

for.index.done-44:
	; defer
	%356 = load %..string, %..string* %0, align 8
	call void @workbench._imgui_struct_block_field_end(%..string %356, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-45

if.done-45:
	br label %typeswitch.done-109

typeswitch.next-46:
	%357 = icmp eq i8 %134, 14
	br i1 %357, label %typeswitch.body-89, label %typeswitch.next-88

typeswitch.body-47:
	%358 = bitcast %..rawptr %135 to %runtime.Type_Info_Enum*
	%359 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %358, align 8
	store %runtime.Type_Info_Enum %359, %runtime.Type_Info_Enum* %35
	; RangeStmt
	; value
	%360 = bitcast %runtime.Type_Info_Enum_Value* %36 to %..rawptr
	%361 = call %..rawptr @mem.zero(%..rawptr %360, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %36
	; val_idx
	%362 = bitcast i64* %37 to %..rawptr
	%363 = call %..rawptr @mem.zero(%..rawptr %362, i64 8) noinline
	store i64 zeroinitializer, i64* %37
	; SelectorExpr
	%364 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %35, i64 0, i32 2
	%365 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %364, align 8
	%366 = bitcast i64* %38 to %..rawptr
	%367 = call %..rawptr @mem.zero(%..rawptr %366, i64 8) noinline
	store i64 zeroinitializer, i64* %38
	%368 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %365, 1
	store i64 %368, i64* %38
	%369 = bitcast i64* %39 to %..rawptr
	%370 = call %..rawptr @mem.zero(%..rawptr %369, i64 8) noinline
	store i64 zeroinitializer, i64* %39
	store i64 -1, i64* %39
	br label %for.index.loop-48

for.index.loop-48:
	%371 = load i64, i64* %39, align 8
	%372 = add i64 %371, 1
	store i64 %372, i64* %39
	%373 = load i64, i64* %38, align 8
	%374 = icmp slt i64 %372, %373
	br i1 %374, label %for.index.body-49, label %for.index.done-87

for.index.body-49:
	%375 = load i64, i64* %39, align 8
	%376 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %365, 0
	%377 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %376, i64 %375
	%378 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %377, align 8
	store %runtime.Type_Info_Enum_Value %378, %runtime.Type_Info_Enum_Value* %36
	store i64 %375, i64* %37
	; TypeSwitchStmt
	%379 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %36, align 8
	; get union's tag
	%380 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %36, i64 0, i32 2 ; UnionTagPtr
	%381 = load i8, i8* %380, align 1
	%382 = bitcast %runtime.Type_Info_Enum_Value* %36 to %..rawptr
	%383 = icmp eq i8 %381, 2
	br i1 %383, label %typeswitch.body-51, label %typeswitch.next-50

typeswitch.next-50:
	%384 = icmp eq i8 %381, 3
	br i1 %384, label %typeswitch.body-55, label %typeswitch.next-54

typeswitch.body-51:
	%385 = bitcast %..rawptr %382 to i8*
	%386 = load i8, i8* %385, align 1
	store i8 %386, i8* %40
	; IfStmt
	%387 = load %..rawptr, %..rawptr* %1, align 8
	%388 = bitcast %..rawptr %387 to i8*
	%389 = getelementptr inbounds i8, i8* %388, i64 0
	%390 = load i8, i8* %389, align 1
	%391 = load i8, i8* %40, align 1
	%392 = icmp eq i8 %390, %391
	%393 = zext i1 %392 to i8
	%394 = trunc i8 %393 to i1
	br i1 %394, label %if.then-52, label %if.done-53

if.then-52:
	%395 = load %..string, %..string* %0, align 8
	; IndexExpr
	; SelectorExpr
	%396 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %35, i64 0, i32 1
	%397 = load {%..string*, i64}, {%..string*, i64}* %396, align 8
	%398 = extractvalue {%..string*, i64} %397, 0
	%399 = load i64, i64* %37, align 8
	%400 = extractvalue {%..string*, i64} %397, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$279, i64 0, i32 0), i64 63}, i64 551, i64 95, i64 %399, i64 %400)
	%401 = getelementptr inbounds %..string, %..string* %398, i64 %399
	%402 = bitcast %..string* %401 to %..rawptr
	call void @workbench._imgui_struct_internal.simple_field-10(%..string %395, %..rawptr %402, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-53

if.done-53:
	br label %typeswitch.done-86

typeswitch.next-54:
	%403 = icmp eq i8 %381, 4
	br i1 %403, label %typeswitch.body-59, label %typeswitch.next-58

typeswitch.body-55:
	%404 = bitcast %..rawptr %382 to i16*
	%405 = load i16, i16* %404, align 2
	store i16 %405, i16* %41
	; IfStmt
	%406 = load %..rawptr, %..rawptr* %1, align 8
	%407 = bitcast %..rawptr %406 to i16*
	%408 = getelementptr inbounds i16, i16* %407, i64 0
	%409 = load i16, i16* %408, align 2
	%410 = load i16, i16* %41, align 2
	%411 = icmp eq i16 %409, %410
	%412 = zext i1 %411 to i8
	%413 = trunc i8 %412 to i1
	br i1 %413, label %if.then-56, label %if.done-57

if.then-56:
	%414 = load %..string, %..string* %0, align 8
	; IndexExpr
	; SelectorExpr
	%415 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %35, i64 0, i32 1
	%416 = load {%..string*, i64}, {%..string*, i64}* %415, align 8
	%417 = extractvalue {%..string*, i64} %416, 0
	%418 = load i64, i64* %37, align 8
	%419 = extractvalue {%..string*, i64} %416, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$27a, i64 0, i32 0), i64 63}, i64 552, i64 95, i64 %418, i64 %419)
	%420 = getelementptr inbounds %..string, %..string* %417, i64 %418
	%421 = bitcast %..string* %420 to %..rawptr
	call void @workbench._imgui_struct_internal.simple_field-10(%..string %414, %..rawptr %421, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-57

if.done-57:
	br label %typeswitch.done-86

typeswitch.next-58:
	%422 = icmp eq i8 %381, 5
	br i1 %422, label %typeswitch.body-63, label %typeswitch.next-62

typeswitch.body-59:
	%423 = bitcast %..rawptr %382 to i32*
	%424 = load i32, i32* %423, align 4
	store i32 %424, i32* %42
	; IfStmt
	%425 = load %..rawptr, %..rawptr* %1, align 8
	%426 = bitcast %..rawptr %425 to i32*
	%427 = getelementptr inbounds i32, i32* %426, i64 0
	%428 = load i32, i32* %427, align 4
	%429 = load i32, i32* %42, align 4
	%430 = icmp eq i32 %428, %429
	%431 = zext i1 %430 to i8
	%432 = trunc i8 %431 to i1
	br i1 %432, label %if.then-60, label %if.done-61

if.then-60:
	%433 = load %..string, %..string* %0, align 8
	; IndexExpr
	; SelectorExpr
	%434 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %35, i64 0, i32 1
	%435 = load {%..string*, i64}, {%..string*, i64}* %434, align 8
	%436 = extractvalue {%..string*, i64} %435, 0
	%437 = load i64, i64* %37, align 8
	%438 = extractvalue {%..string*, i64} %435, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$27b, i64 0, i32 0), i64 63}, i64 553, i64 95, i64 %437, i64 %438)
	%439 = getelementptr inbounds %..string, %..string* %436, i64 %437
	%440 = bitcast %..string* %439 to %..rawptr
	call void @workbench._imgui_struct_internal.simple_field-10(%..string %433, %..rawptr %440, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-61

if.done-61:
	br label %typeswitch.done-86

typeswitch.next-62:
	%441 = icmp eq i8 %381, 6
	br i1 %441, label %typeswitch.body-67, label %typeswitch.next-66

typeswitch.body-63:
	%442 = bitcast %..rawptr %382 to i64*
	%443 = load i64, i64* %442, align 8
	store i64 %443, i64* %43
	; IfStmt
	%444 = load %..rawptr, %..rawptr* %1, align 8
	%445 = bitcast %..rawptr %444 to i64*
	%446 = getelementptr inbounds i64, i64* %445, i64 0
	%447 = load i64, i64* %446, align 8
	%448 = load i64, i64* %43, align 8
	%449 = icmp eq i64 %447, %448
	%450 = zext i1 %449 to i8
	%451 = trunc i8 %450 to i1
	br i1 %451, label %if.then-64, label %if.done-65

if.then-64:
	%452 = load %..string, %..string* %0, align 8
	; IndexExpr
	; SelectorExpr
	%453 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %35, i64 0, i32 1
	%454 = load {%..string*, i64}, {%..string*, i64}* %453, align 8
	%455 = extractvalue {%..string*, i64} %454, 0
	%456 = load i64, i64* %37, align 8
	%457 = extractvalue {%..string*, i64} %454, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$27c, i64 0, i32 0), i64 63}, i64 554, i64 95, i64 %456, i64 %457)
	%458 = getelementptr inbounds %..string, %..string* %455, i64 %456
	%459 = bitcast %..string* %458 to %..rawptr
	call void @workbench._imgui_struct_internal.simple_field-10(%..string %452, %..rawptr %459, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-65

if.done-65:
	br label %typeswitch.done-86

typeswitch.next-66:
	%460 = icmp eq i8 %381, 7
	br i1 %460, label %typeswitch.body-71, label %typeswitch.next-70

typeswitch.body-67:
	%461 = bitcast %..rawptr %382 to i64*
	%462 = load i64, i64* %461, align 8
	store i64 %462, i64* %44
	; IfStmt
	%463 = load %..rawptr, %..rawptr* %1, align 8
	%464 = bitcast %..rawptr %463 to i64*
	%465 = getelementptr inbounds i64, i64* %464, i64 0
	%466 = load i64, i64* %465, align 8
	%467 = load i64, i64* %44, align 8
	%468 = icmp eq i64 %466, %467
	%469 = zext i1 %468 to i8
	%470 = trunc i8 %469 to i1
	br i1 %470, label %if.then-68, label %if.done-69

if.then-68:
	%471 = load %..string, %..string* %0, align 8
	; IndexExpr
	; SelectorExpr
	%472 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %35, i64 0, i32 1
	%473 = load {%..string*, i64}, {%..string*, i64}* %472, align 8
	%474 = extractvalue {%..string*, i64} %473, 0
	%475 = load i64, i64* %37, align 8
	%476 = extractvalue {%..string*, i64} %473, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$27d, i64 0, i32 0), i64 63}, i64 555, i64 95, i64 %475, i64 %476)
	%477 = getelementptr inbounds %..string, %..string* %474, i64 %475
	%478 = bitcast %..string* %477 to %..rawptr
	call void @workbench._imgui_struct_internal.simple_field-10(%..string %471, %..rawptr %478, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-69

if.done-69:
	br label %typeswitch.done-86

typeswitch.next-70:
	%479 = icmp eq i8 %381, 8
	br i1 %479, label %typeswitch.body-75, label %typeswitch.next-74

typeswitch.body-71:
	%480 = bitcast %..rawptr %382 to i8*
	%481 = load i8, i8* %480, align 1
	store i8 %481, i8* %45
	; IfStmt
	%482 = load %..rawptr, %..rawptr* %1, align 8
	%483 = bitcast %..rawptr %482 to i8*
	%484 = getelementptr inbounds i8, i8* %483, i64 0
	%485 = load i8, i8* %484, align 1
	%486 = load i8, i8* %45, align 1
	%487 = icmp eq i8 %485, %486
	%488 = zext i1 %487 to i8
	%489 = trunc i8 %488 to i1
	br i1 %489, label %if.then-72, label %if.done-73

if.then-72:
	%490 = load %..string, %..string* %0, align 8
	; IndexExpr
	; SelectorExpr
	%491 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %35, i64 0, i32 1
	%492 = load {%..string*, i64}, {%..string*, i64}* %491, align 8
	%493 = extractvalue {%..string*, i64} %492, 0
	%494 = load i64, i64* %37, align 8
	%495 = extractvalue {%..string*, i64} %492, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$27e, i64 0, i32 0), i64 63}, i64 556, i64 95, i64 %494, i64 %495)
	%496 = getelementptr inbounds %..string, %..string* %493, i64 %494
	%497 = bitcast %..string* %496 to %..rawptr
	call void @workbench._imgui_struct_internal.simple_field-10(%..string %490, %..rawptr %497, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-73

if.done-73:
	br label %typeswitch.done-86

typeswitch.next-74:
	%498 = icmp eq i8 %381, 9
	br i1 %498, label %typeswitch.body-79, label %typeswitch.next-78

typeswitch.body-75:
	%499 = bitcast %..rawptr %382 to i16*
	%500 = load i16, i16* %499, align 2
	store i16 %500, i16* %46
	; IfStmt
	%501 = load %..rawptr, %..rawptr* %1, align 8
	%502 = bitcast %..rawptr %501 to i16*
	%503 = getelementptr inbounds i16, i16* %502, i64 0
	%504 = load i16, i16* %503, align 2
	%505 = load i16, i16* %46, align 2
	%506 = icmp eq i16 %504, %505
	%507 = zext i1 %506 to i8
	%508 = trunc i8 %507 to i1
	br i1 %508, label %if.then-76, label %if.done-77

if.then-76:
	%509 = load %..string, %..string* %0, align 8
	; IndexExpr
	; SelectorExpr
	%510 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %35, i64 0, i32 1
	%511 = load {%..string*, i64}, {%..string*, i64}* %510, align 8
	%512 = extractvalue {%..string*, i64} %511, 0
	%513 = load i64, i64* %37, align 8
	%514 = extractvalue {%..string*, i64} %511, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$27f, i64 0, i32 0), i64 63}, i64 557, i64 95, i64 %513, i64 %514)
	%515 = getelementptr inbounds %..string, %..string* %512, i64 %513
	%516 = bitcast %..string* %515 to %..rawptr
	call void @workbench._imgui_struct_internal.simple_field-10(%..string %509, %..rawptr %516, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-77

if.done-77:
	br label %typeswitch.done-86

typeswitch.next-78:
	%517 = icmp eq i8 %381, 10
	br i1 %517, label %typeswitch.body-83, label %typeswitch.next-82

typeswitch.body-79:
	%518 = bitcast %..rawptr %382 to i32*
	%519 = load i32, i32* %518, align 4
	store i32 %519, i32* %47
	; IfStmt
	%520 = load %..rawptr, %..rawptr* %1, align 8
	%521 = bitcast %..rawptr %520 to i32*
	%522 = getelementptr inbounds i32, i32* %521, i64 0
	%523 = load i32, i32* %522, align 4
	%524 = load i32, i32* %47, align 4
	%525 = icmp eq i32 %523, %524
	%526 = zext i1 %525 to i8
	%527 = trunc i8 %526 to i1
	br i1 %527, label %if.then-80, label %if.done-81

if.then-80:
	%528 = load %..string, %..string* %0, align 8
	; IndexExpr
	; SelectorExpr
	%529 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %35, i64 0, i32 1
	%530 = load {%..string*, i64}, {%..string*, i64}* %529, align 8
	%531 = extractvalue {%..string*, i64} %530, 0
	%532 = load i64, i64* %37, align 8
	%533 = extractvalue {%..string*, i64} %530, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$280, i64 0, i32 0), i64 63}, i64 558, i64 95, i64 %532, i64 %533)
	%534 = getelementptr inbounds %..string, %..string* %531, i64 %532
	%535 = bitcast %..string* %534 to %..rawptr
	call void @workbench._imgui_struct_internal.simple_field-10(%..string %528, %..rawptr %535, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-81

if.done-81:
	br label %typeswitch.done-86

typeswitch.next-82:
	br label %typeswitch.done-86

typeswitch.body-83:
	%536 = bitcast %..rawptr %382 to i64*
	%537 = load i64, i64* %536, align 8
	store i64 %537, i64* %48
	; IfStmt
	%538 = load %..rawptr, %..rawptr* %1, align 8
	%539 = bitcast %..rawptr %538 to i64*
	%540 = getelementptr inbounds i64, i64* %539, i64 0
	%541 = load i64, i64* %540, align 8
	%542 = load i64, i64* %48, align 8
	%543 = icmp eq i64 %541, %542
	%544 = zext i1 %543 to i8
	%545 = trunc i8 %544 to i1
	br i1 %545, label %if.then-84, label %if.done-85

if.then-84:
	%546 = load %..string, %..string* %0, align 8
	; IndexExpr
	; SelectorExpr
	%547 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %35, i64 0, i32 1
	%548 = load {%..string*, i64}, {%..string*, i64}* %547, align 8
	%549 = extractvalue {%..string*, i64} %548, 0
	%550 = load i64, i64* %37, align 8
	%551 = extractvalue {%..string*, i64} %548, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$281, i64 0, i32 0), i64 63}, i64 559, i64 95, i64 %550, i64 %551)
	%552 = getelementptr inbounds %..string, %..string* %549, i64 %550
	%553 = bitcast %..string* %552 to %..rawptr
	call void @workbench._imgui_struct_internal.simple_field-10(%..string %546, %..rawptr %553, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-85

if.done-85:
	br label %typeswitch.done-86

typeswitch.done-86:
	br label %for.index.loop-48

for.index.done-87:
	br label %typeswitch.done-109

typeswitch.next-88:
	%554 = icmp eq i8 %134, 12
	br i1 %554, label %typeswitch.body-96, label %typeswitch.next-95

typeswitch.body-89:
	%555 = bitcast %..rawptr %135 to %runtime.Type_Info_Slice*
	%556 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %555, align 8
	store %runtime.Type_Info_Slice %556, %runtime.Type_Info_Slice* %49
	; IfStmt
	%557 = load %..string, %..string* %0, align 8
	; SelectorExpr
	%558 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %49, i64 0, i32 0
	%559 = load %runtime.Type_Info*, %runtime.Type_Info** %558, align 8
	%560 = bitcast %..string* %50 to %..rawptr
	%561 = call %..rawptr @mem.zero(%..rawptr %560, i64 16) noinline
	store %..string zeroinitializer, %..string* %50
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$282, i64 0, i32 0), i64 2}, %..string* %50
	%562 = load %..string, %..string* %50, align 8
	%563 = bitcast %..any* %51 to %..rawptr
	%564 = call %..rawptr @mem.zero(%..rawptr %563, i64 16) noinline
	store %..any zeroinitializer, %..any* %51
	%565 = bitcast %..string* %50 to %..rawptr
	%566 = getelementptr inbounds %..any, %..any* %51, i64 0, i32 0
	store %..rawptr %565, %..rawptr* %566
	%567 = getelementptr inbounds %..any, %..any* %51, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %567
	%568 = load %..any, %..any* %51, align 8
	%569 = bitcast %..any* %52 to %..rawptr
	%570 = call %..rawptr @mem.zero(%..rawptr %569, i64 16) noinline
	store %..any zeroinitializer, %..any* %52
	%571 = bitcast %runtime.Type_Info** %558 to %..rawptr
	%572 = getelementptr inbounds %..any, %..any* %52, i64 0, i32 0
	store %..rawptr %571, %..rawptr* %572
	%573 = getelementptr inbounds %..any, %..any* %52, i64 0, i32 1
	store %..typeid 648518346341351435, %..typeid* %573
	%574 = load %..any, %..any* %52, align 8
	; variadic call argument generation
	%575 = bitcast {%..any*, i64}* %53 to %..rawptr
	%576 = call %..rawptr @mem.zero(%..rawptr %575, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %53
	%577 = bitcast [2 x %..any]* %54 to %..rawptr
	%578 = call %..rawptr @mem.zero(%..rawptr %577, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %54
	%579 = getelementptr inbounds [2 x %..any], [2 x %..any]* %54, i64 0, i32 0
	store %..any %568, %..any* %579
	%580 = getelementptr inbounds [2 x %..any], [2 x %..any]* %54, i64 0, i32 1
	store %..any %574, %..any* %580
	%581 = getelementptr inbounds [2 x %..any], [2 x %..any]* %54, i64 0, i32 0
	%582 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %53, i64 0, i32 0
	store %..any* %581, %..any** %582
	%583 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %53, i64 0, i32 1
	store i64 2, i64* %583
	%584 = load {%..any*, i64}, {%..any*, i64}* %53, align 8
	%585 = bitcast {%..any*, i64}* %55 to %..rawptr
	%586 = call %..rawptr @mem.zero(%..rawptr %585, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %55
	store {%..any*, i64} %584, {%..any*, i64}* %55
	%587 = call %..string @fmt.tprint({%..any*, i64}* %55, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%588 = call i8 @workbench._imgui_struct_block_field_start(%..string %557, %..string %587, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%589 = trunc i8 %588 to i1
	br i1 %589, label %if.then-90, label %if.done-94

if.then-90:
	; DeferStmt
	; slice
	%590 = load %..rawptr, %..rawptr* %1, align 8
	%591 = bitcast %..rawptr %590 to %mem.Raw_Slice*
	%592 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %591, i64 0
	%593 = load %mem.Raw_Slice, %mem.Raw_Slice* %592, align 8
	store %mem.Raw_Slice %593, %mem.Raw_Slice* %56
	; RangeStmt
	; i
	%594 = bitcast i64* %57 to %..rawptr
	%595 = call %..rawptr @mem.zero(%..rawptr %594, i64 8) noinline
	store i64 zeroinitializer, i64* %57
	%596 = bitcast i64* %58 to %..rawptr
	%597 = call %..rawptr @mem.zero(%..rawptr %596, i64 8) noinline
	store i64 zeroinitializer, i64* %58
	store i64 0, i64* %58
	%598 = bitcast i64* %59 to %..rawptr
	%599 = call %..rawptr @mem.zero(%..rawptr %598, i64 8) noinline
	store i64 zeroinitializer, i64* %59
	store i64 0, i64* %59
	br label %for.interval.loop-91

for.interval.loop-91:
	; SelectorExpr
	%600 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %56, i64 0, i32 1
	%601 = load i64, i64* %600, align 8
	%602 = sub i64 %601, 1
	%603 = load i64, i64* %58, align 8
	%604 = icmp sle i64 %603, %602
	br i1 %604, label %for.interval.body-92, label %for.interval.done-93

for.interval.body-92:
	%605 = load i64, i64* %58, align 8
	%606 = load i64, i64* %59, align 8
	%607 = load i64, i64* %58, align 8
	%608 = add i64 %607, 1
	store i64 %608, i64* %58
	%609 = load i64, i64* %59, align 8
	%610 = add i64 %609, 1
	store i64 %610, i64* %59
	store i64 %605, i64* %57
	; SelectorExpr
	%611 = load i64, i64* %57, align 8
	%612 = bitcast %..any* %60 to %..rawptr
	%613 = call %..rawptr @mem.zero(%..rawptr %612, i64 16) noinline
	store %..any zeroinitializer, %..any* %60
	%614 = bitcast i64* %57 to %..rawptr
	%615 = getelementptr inbounds %..any, %..any* %60, i64 0, i32 0
	store %..rawptr %614, %..rawptr* %615
	%616 = getelementptr inbounds %..any, %..any* %60, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %616
	%617 = load %..any, %..any* %60, align 8
	; variadic call argument generation
	%618 = bitcast {%..any*, i64}* %61 to %..rawptr
	%619 = call %..rawptr @mem.zero(%..rawptr %618, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %61
	%620 = bitcast [1 x %..any]* %62 to %..rawptr
	%621 = call %..rawptr @mem.zero(%..rawptr %620, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %62
	%622 = getelementptr inbounds [1 x %..any], [1 x %..any]* %62, i64 0, i32 0
	store %..any %617, %..any* %622
	%623 = getelementptr inbounds [1 x %..any], [1 x %..any]* %62, i64 0, i32 0
	%624 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %61, i64 0, i32 0
	store %..any* %623, %..any** %624
	%625 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %61, i64 0, i32 1
	store i64 1, i64* %625
	%626 = load {%..any*, i64}, {%..any*, i64}* %61, align 8
	%627 = bitcast {%..any*, i64}* %63 to %..rawptr
	%628 = call %..rawptr @mem.zero(%..rawptr %627, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %63
	store {%..any*, i64} %626, {%..any*, i64}* %63
	%629 = call %..string @fmt.tprint({%..any*, i64}* %63, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @imgui.push_id_str(%..string %629, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	%630 = load i64, i64* %57, align 8
	%631 = bitcast %..string* %64 to %..rawptr
	%632 = call %..rawptr @mem.zero(%..rawptr %631, i64 16) noinline
	store %..string zeroinitializer, %..string* %64
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$283, i64 0, i32 0), i64 1}, %..string* %64
	%633 = load %..string, %..string* %64, align 8
	%634 = bitcast %..any* %65 to %..rawptr
	%635 = call %..rawptr @mem.zero(%..rawptr %634, i64 16) noinline
	store %..any zeroinitializer, %..any* %65
	%636 = bitcast %..string* %64 to %..rawptr
	%637 = getelementptr inbounds %..any, %..any* %65, i64 0, i32 0
	store %..rawptr %636, %..rawptr* %637
	%638 = getelementptr inbounds %..any, %..any* %65, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %638
	%639 = load %..any, %..any* %65, align 8
	%640 = bitcast %..any* %66 to %..rawptr
	%641 = call %..rawptr @mem.zero(%..rawptr %640, i64 16) noinline
	store %..any zeroinitializer, %..any* %66
	%642 = bitcast i64* %57 to %..rawptr
	%643 = getelementptr inbounds %..any, %..any* %66, i64 0, i32 0
	store %..rawptr %642, %..rawptr* %643
	%644 = getelementptr inbounds %..any, %..any* %66, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %644
	%645 = load %..any, %..any* %66, align 8
	%646 = bitcast %..string* %67 to %..rawptr
	%647 = call %..rawptr @mem.zero(%..rawptr %646, i64 16) noinline
	store %..string zeroinitializer, %..string* %67
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$284, i64 0, i32 0), i64 1}, %..string* %67
	%648 = load %..string, %..string* %67, align 8
	%649 = bitcast %..any* %68 to %..rawptr
	%650 = call %..rawptr @mem.zero(%..rawptr %649, i64 16) noinline
	store %..any zeroinitializer, %..any* %68
	%651 = bitcast %..string* %67 to %..rawptr
	%652 = getelementptr inbounds %..any, %..any* %68, i64 0, i32 0
	store %..rawptr %651, %..rawptr* %652
	%653 = getelementptr inbounds %..any, %..any* %68, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %653
	%654 = load %..any, %..any* %68, align 8
	; variadic call argument generation
	%655 = bitcast {%..any*, i64}* %69 to %..rawptr
	%656 = call %..rawptr @mem.zero(%..rawptr %655, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %69
	%657 = bitcast [3 x %..any]* %70 to %..rawptr
	%658 = call %..rawptr @mem.zero(%..rawptr %657, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %70
	%659 = getelementptr inbounds [3 x %..any], [3 x %..any]* %70, i64 0, i32 0
	store %..any %639, %..any* %659
	%660 = getelementptr inbounds [3 x %..any], [3 x %..any]* %70, i64 0, i32 1
	store %..any %645, %..any* %660
	%661 = getelementptr inbounds [3 x %..any], [3 x %..any]* %70, i64 0, i32 2
	store %..any %654, %..any* %661
	%662 = getelementptr inbounds [3 x %..any], [3 x %..any]* %70, i64 0, i32 0
	%663 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %69, i64 0, i32 0
	store %..any* %662, %..any** %663
	%664 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %69, i64 0, i32 1
	store i64 3, i64* %664
	%665 = load {%..any*, i64}, {%..any*, i64}* %69, align 8
	%666 = bitcast {%..any*, i64}* %71 to %..rawptr
	%667 = call %..rawptr @mem.zero(%..rawptr %666, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %71
	store {%..any*, i64} %665, {%..any*, i64}* %71
	%668 = call %..string @fmt.tprint({%..any*, i64}* %71, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%669 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %56, i64 0, i32 0
	%670 = load %..rawptr, %..rawptr* %669, align 8
	%671 = bitcast %..rawptr %670 to i8*
	%672 = load i64, i64* %57, align 8
	; SelectorExpr
	%673 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %49, i64 0, i32 1
	%674 = load i64, i64* %673, align 8
	%675 = mul i64 %672, %674
	%676 = call i8* @mem.ptr_offset-13926(i8* %671, i64 %675)
	; SelectorExpr
	%677 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %49, i64 0, i32 0
	%678 = load %runtime.Type_Info*, %runtime.Type_Info** %677, align 8
	%679 = bitcast i8* %676 to %..rawptr
	call void @workbench._imgui_struct_internal(%..string %668, %..rawptr %679, %runtime.Type_Info* %678, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; defer
	; SelectorExpr
	call ccc void @igPopID()
	br label %for.interval.loop-91

for.interval.done-93:
	; defer
	%680 = load %..string, %..string* %0, align 8
	call void @workbench._imgui_struct_block_field_end(%..string %680, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-94

if.done-94:
	br label %typeswitch.done-109

typeswitch.next-95:
	%681 = icmp eq i8 %134, 13
	br i1 %681, label %typeswitch.body-103, label %typeswitch.next-102

typeswitch.body-96:
	%682 = bitcast %..rawptr %135 to %runtime.Type_Info_Array*
	%683 = load %runtime.Type_Info_Array, %runtime.Type_Info_Array* %682, align 8
	store %runtime.Type_Info_Array %683, %runtime.Type_Info_Array* %72
	; IfStmt
	%684 = load %..string, %..string* %0, align 8
	; SelectorExpr
	%685 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %72, i64 0, i32 2
	%686 = load i64, i64* %685, align 8
	; SelectorExpr
	%687 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %72, i64 0, i32 0
	%688 = load %runtime.Type_Info*, %runtime.Type_Info** %687, align 8
	%689 = bitcast %..string* %73 to %..rawptr
	%690 = call %..rawptr @mem.zero(%..rawptr %689, i64 16) noinline
	store %..string zeroinitializer, %..string* %73
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$285, i64 0, i32 0), i64 1}, %..string* %73
	%691 = load %..string, %..string* %73, align 8
	%692 = bitcast %..any* %74 to %..rawptr
	%693 = call %..rawptr @mem.zero(%..rawptr %692, i64 16) noinline
	store %..any zeroinitializer, %..any* %74
	%694 = bitcast %..string* %73 to %..rawptr
	%695 = getelementptr inbounds %..any, %..any* %74, i64 0, i32 0
	store %..rawptr %694, %..rawptr* %695
	%696 = getelementptr inbounds %..any, %..any* %74, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %696
	%697 = load %..any, %..any* %74, align 8
	%698 = bitcast %..any* %75 to %..rawptr
	%699 = call %..rawptr @mem.zero(%..rawptr %698, i64 16) noinline
	store %..any zeroinitializer, %..any* %75
	%700 = bitcast i64* %685 to %..rawptr
	%701 = getelementptr inbounds %..any, %..any* %75, i64 0, i32 0
	store %..rawptr %700, %..rawptr* %701
	%702 = getelementptr inbounds %..any, %..any* %75, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %702
	%703 = load %..any, %..any* %75, align 8
	%704 = bitcast %..string* %76 to %..rawptr
	%705 = call %..rawptr @mem.zero(%..rawptr %704, i64 16) noinline
	store %..string zeroinitializer, %..string* %76
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$286, i64 0, i32 0), i64 1}, %..string* %76
	%706 = load %..string, %..string* %76, align 8
	%707 = bitcast %..any* %77 to %..rawptr
	%708 = call %..rawptr @mem.zero(%..rawptr %707, i64 16) noinline
	store %..any zeroinitializer, %..any* %77
	%709 = bitcast %..string* %76 to %..rawptr
	%710 = getelementptr inbounds %..any, %..any* %77, i64 0, i32 0
	store %..rawptr %709, %..rawptr* %710
	%711 = getelementptr inbounds %..any, %..any* %77, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %711
	%712 = load %..any, %..any* %77, align 8
	%713 = bitcast %..any* %78 to %..rawptr
	%714 = call %..rawptr @mem.zero(%..rawptr %713, i64 16) noinline
	store %..any zeroinitializer, %..any* %78
	%715 = bitcast %runtime.Type_Info** %687 to %..rawptr
	%716 = getelementptr inbounds %..any, %..any* %78, i64 0, i32 0
	store %..rawptr %715, %..rawptr* %716
	%717 = getelementptr inbounds %..any, %..any* %78, i64 0, i32 1
	store %..typeid 648518346341351435, %..typeid* %717
	%718 = load %..any, %..any* %78, align 8
	; variadic call argument generation
	%719 = bitcast {%..any*, i64}* %79 to %..rawptr
	%720 = call %..rawptr @mem.zero(%..rawptr %719, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %79
	%721 = bitcast [4 x %..any]* %80 to %..rawptr
	%722 = call %..rawptr @mem.zero(%..rawptr %721, i64 64) noinline
	store [4 x %..any] zeroinitializer, [4 x %..any]* %80
	%723 = getelementptr inbounds [4 x %..any], [4 x %..any]* %80, i64 0, i32 0
	store %..any %697, %..any* %723
	%724 = getelementptr inbounds [4 x %..any], [4 x %..any]* %80, i64 0, i32 1
	store %..any %703, %..any* %724
	%725 = getelementptr inbounds [4 x %..any], [4 x %..any]* %80, i64 0, i32 2
	store %..any %712, %..any* %725
	%726 = getelementptr inbounds [4 x %..any], [4 x %..any]* %80, i64 0, i32 3
	store %..any %718, %..any* %726
	%727 = getelementptr inbounds [4 x %..any], [4 x %..any]* %80, i64 0, i32 0
	%728 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %79, i64 0, i32 0
	store %..any* %727, %..any** %728
	%729 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %79, i64 0, i32 1
	store i64 4, i64* %729
	%730 = load {%..any*, i64}, {%..any*, i64}* %79, align 8
	%731 = bitcast {%..any*, i64}* %81 to %..rawptr
	%732 = call %..rawptr @mem.zero(%..rawptr %731, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %81
	store {%..any*, i64} %730, {%..any*, i64}* %81
	%733 = call %..string @fmt.tprint({%..any*, i64}* %81, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%734 = call i8 @workbench._imgui_struct_block_field_start(%..string %684, %..string %733, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%735 = trunc i8 %734 to i1
	br i1 %735, label %if.then-97, label %if.done-101

if.then-97:
	; DeferStmt
	; RangeStmt
	; i
	%736 = bitcast i64* %82 to %..rawptr
	%737 = call %..rawptr @mem.zero(%..rawptr %736, i64 8) noinline
	store i64 zeroinitializer, i64* %82
	%738 = bitcast i64* %83 to %..rawptr
	%739 = call %..rawptr @mem.zero(%..rawptr %738, i64 8) noinline
	store i64 zeroinitializer, i64* %83
	store i64 0, i64* %83
	%740 = bitcast i64* %84 to %..rawptr
	%741 = call %..rawptr @mem.zero(%..rawptr %740, i64 8) noinline
	store i64 zeroinitializer, i64* %84
	store i64 0, i64* %84
	br label %for.interval.loop-98

for.interval.loop-98:
	; SelectorExpr
	%742 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %72, i64 0, i32 2
	%743 = load i64, i64* %742, align 8
	%744 = sub i64 %743, 1
	%745 = load i64, i64* %83, align 8
	%746 = icmp sle i64 %745, %744
	br i1 %746, label %for.interval.body-99, label %for.interval.done-100

for.interval.body-99:
	%747 = load i64, i64* %83, align 8
	%748 = load i64, i64* %84, align 8
	%749 = load i64, i64* %83, align 8
	%750 = add i64 %749, 1
	store i64 %750, i64* %83
	%751 = load i64, i64* %84, align 8
	%752 = add i64 %751, 1
	store i64 %752, i64* %84
	store i64 %747, i64* %82
	; SelectorExpr
	%753 = load i64, i64* %82, align 8
	%754 = bitcast %..any* %85 to %..rawptr
	%755 = call %..rawptr @mem.zero(%..rawptr %754, i64 16) noinline
	store %..any zeroinitializer, %..any* %85
	%756 = bitcast i64* %82 to %..rawptr
	%757 = getelementptr inbounds %..any, %..any* %85, i64 0, i32 0
	store %..rawptr %756, %..rawptr* %757
	%758 = getelementptr inbounds %..any, %..any* %85, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %758
	%759 = load %..any, %..any* %85, align 8
	; variadic call argument generation
	%760 = bitcast {%..any*, i64}* %86 to %..rawptr
	%761 = call %..rawptr @mem.zero(%..rawptr %760, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %86
	%762 = bitcast [1 x %..any]* %87 to %..rawptr
	%763 = call %..rawptr @mem.zero(%..rawptr %762, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %87
	%764 = getelementptr inbounds [1 x %..any], [1 x %..any]* %87, i64 0, i32 0
	store %..any %759, %..any* %764
	%765 = getelementptr inbounds [1 x %..any], [1 x %..any]* %87, i64 0, i32 0
	%766 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %86, i64 0, i32 0
	store %..any* %765, %..any** %766
	%767 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %86, i64 0, i32 1
	store i64 1, i64* %767
	%768 = load {%..any*, i64}, {%..any*, i64}* %86, align 8
	%769 = bitcast {%..any*, i64}* %88 to %..rawptr
	%770 = call %..rawptr @mem.zero(%..rawptr %769, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %88
	store {%..any*, i64} %768, {%..any*, i64}* %88
	%771 = call %..string @fmt.tprint({%..any*, i64}* %88, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @imgui.push_id_str(%..string %771, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	%772 = load i64, i64* %82, align 8
	%773 = bitcast %..string* %89 to %..rawptr
	%774 = call %..rawptr @mem.zero(%..rawptr %773, i64 16) noinline
	store %..string zeroinitializer, %..string* %89
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$287, i64 0, i32 0), i64 1}, %..string* %89
	%775 = load %..string, %..string* %89, align 8
	%776 = bitcast %..any* %90 to %..rawptr
	%777 = call %..rawptr @mem.zero(%..rawptr %776, i64 16) noinline
	store %..any zeroinitializer, %..any* %90
	%778 = bitcast %..string* %89 to %..rawptr
	%779 = getelementptr inbounds %..any, %..any* %90, i64 0, i32 0
	store %..rawptr %778, %..rawptr* %779
	%780 = getelementptr inbounds %..any, %..any* %90, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %780
	%781 = load %..any, %..any* %90, align 8
	%782 = bitcast %..any* %91 to %..rawptr
	%783 = call %..rawptr @mem.zero(%..rawptr %782, i64 16) noinline
	store %..any zeroinitializer, %..any* %91
	%784 = bitcast i64* %82 to %..rawptr
	%785 = getelementptr inbounds %..any, %..any* %91, i64 0, i32 0
	store %..rawptr %784, %..rawptr* %785
	%786 = getelementptr inbounds %..any, %..any* %91, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %786
	%787 = load %..any, %..any* %91, align 8
	%788 = bitcast %..string* %92 to %..rawptr
	%789 = call %..rawptr @mem.zero(%..rawptr %788, i64 16) noinline
	store %..string zeroinitializer, %..string* %92
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$288, i64 0, i32 0), i64 1}, %..string* %92
	%790 = load %..string, %..string* %92, align 8
	%791 = bitcast %..any* %93 to %..rawptr
	%792 = call %..rawptr @mem.zero(%..rawptr %791, i64 16) noinline
	store %..any zeroinitializer, %..any* %93
	%793 = bitcast %..string* %92 to %..rawptr
	%794 = getelementptr inbounds %..any, %..any* %93, i64 0, i32 0
	store %..rawptr %793, %..rawptr* %794
	%795 = getelementptr inbounds %..any, %..any* %93, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %795
	%796 = load %..any, %..any* %93, align 8
	; variadic call argument generation
	%797 = bitcast {%..any*, i64}* %94 to %..rawptr
	%798 = call %..rawptr @mem.zero(%..rawptr %797, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %94
	%799 = bitcast [3 x %..any]* %95 to %..rawptr
	%800 = call %..rawptr @mem.zero(%..rawptr %799, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %95
	%801 = getelementptr inbounds [3 x %..any], [3 x %..any]* %95, i64 0, i32 0
	store %..any %781, %..any* %801
	%802 = getelementptr inbounds [3 x %..any], [3 x %..any]* %95, i64 0, i32 1
	store %..any %787, %..any* %802
	%803 = getelementptr inbounds [3 x %..any], [3 x %..any]* %95, i64 0, i32 2
	store %..any %796, %..any* %803
	%804 = getelementptr inbounds [3 x %..any], [3 x %..any]* %95, i64 0, i32 0
	%805 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %94, i64 0, i32 0
	store %..any* %804, %..any** %805
	%806 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %94, i64 0, i32 1
	store i64 3, i64* %806
	%807 = load {%..any*, i64}, {%..any*, i64}* %94, align 8
	%808 = bitcast {%..any*, i64}* %96 to %..rawptr
	%809 = call %..rawptr @mem.zero(%..rawptr %808, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %96
	store {%..any*, i64} %807, {%..any*, i64}* %96
	%810 = call %..string @fmt.tprint({%..any*, i64}* %96, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%811 = load %..rawptr, %..rawptr* %1, align 8
	%812 = bitcast %..rawptr %811 to i8*
	%813 = load i64, i64* %82, align 8
	; SelectorExpr
	%814 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %72, i64 0, i32 1
	%815 = load i64, i64* %814, align 8
	%816 = mul i64 %813, %815
	%817 = call i8* @mem.ptr_offset-13926(i8* %812, i64 %816)
	; SelectorExpr
	%818 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %72, i64 0, i32 0
	%819 = load %runtime.Type_Info*, %runtime.Type_Info** %818, align 8
	%820 = bitcast i8* %817 to %..rawptr
	call void @workbench._imgui_struct_internal(%..string %810, %..rawptr %820, %runtime.Type_Info* %819, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; defer
	; SelectorExpr
	call ccc void @igPopID()
	br label %for.interval.loop-98

for.interval.done-100:
	; defer
	%821 = load %..string, %..string* %0, align 8
	call void @workbench._imgui_struct_block_field_end(%..string %821, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-101

if.done-101:
	br label %typeswitch.done-109

typeswitch.next-102:
	store {[0 x <8 x i8>], [72 x i8], i8} %132, {[0 x <8 x i8>], [72 x i8], i8}* %120
	; SelectorExpr
	%822 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %120, align 8
	%823 = bitcast %..string* %121 to %..rawptr
	%824 = call %..rawptr @mem.zero(%..rawptr %823, i64 16) noinline
	store %..string zeroinitializer, %..string* %121
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$289, i64 0, i32 0), i64 16}, %..string* %121
	%825 = load %..string, %..string* %121, align 8
	%826 = bitcast %..any* %122 to %..rawptr
	%827 = call %..rawptr @mem.zero(%..rawptr %826, i64 16) noinline
	store %..any zeroinitializer, %..any* %122
	%828 = bitcast %..string* %121 to %..rawptr
	%829 = getelementptr inbounds %..any, %..any* %122, i64 0, i32 0
	store %..rawptr %828, %..rawptr* %829
	%830 = getelementptr inbounds %..any, %..any* %122, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %830
	%831 = load %..any, %..any* %122, align 8
	%832 = bitcast %..any* %123 to %..rawptr
	%833 = call %..rawptr @mem.zero(%..rawptr %832, i64 16) noinline
	store %..any zeroinitializer, %..any* %123
	%834 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %120 to %..rawptr
	%835 = getelementptr inbounds %..any, %..any* %123, i64 0, i32 0
	store %..rawptr %834, %..rawptr* %835
	%836 = getelementptr inbounds %..any, %..any* %123, i64 0, i32 1
	store %..typeid 1152921504606846991, %..typeid* %836
	%837 = load %..any, %..any* %123, align 8
	; variadic call argument generation
	%838 = bitcast {%..any*, i64}* %124 to %..rawptr
	%839 = call %..rawptr @mem.zero(%..rawptr %838, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %124
	%840 = bitcast [2 x %..any]* %125 to %..rawptr
	%841 = call %..rawptr @mem.zero(%..rawptr %840, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %125
	%842 = getelementptr inbounds [2 x %..any], [2 x %..any]* %125, i64 0, i32 0
	store %..any %831, %..any* %842
	%843 = getelementptr inbounds [2 x %..any], [2 x %..any]* %125, i64 0, i32 1
	store %..any %837, %..any* %843
	%844 = getelementptr inbounds [2 x %..any], [2 x %..any]* %125, i64 0, i32 0
	%845 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %124, i64 0, i32 0
	store %..any* %844, %..any** %845
	%846 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %124, i64 0, i32 1
	store i64 2, i64* %846
	%847 = load {%..any*, i64}, {%..any*, i64}* %124, align 8
	%848 = bitcast {%..any*, i64}* %126 to %..rawptr
	%849 = call %..rawptr @mem.zero(%..rawptr %848, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %126
	store {%..any*, i64} %847, {%..any*, i64}* %126
	%850 = call %..string @fmt.tprint({%..any*, i64}* %126, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; variadic call argument generation
	%851 = bitcast {%..any*, i64}* %127 to %..rawptr
	%852 = call %..rawptr @mem.zero(%..rawptr %851, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %127
	%853 = load {%..any*, i64}, {%..any*, i64}* %127, align 8
	%854 = bitcast {%..any*, i64}* %128 to %..rawptr
	%855 = call %..rawptr @mem.zero(%..rawptr %854, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %128
	store {%..any*, i64} %853, {%..any*, i64}* %128
	call void @imgui.text(%..string %850, {%..any*, i64}* %128, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-109

typeswitch.body-103:
	%856 = bitcast %..rawptr %135 to %runtime.Type_Info_Dynamic_Array*
	%857 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %856, align 8
	store %runtime.Type_Info_Dynamic_Array %857, %runtime.Type_Info_Dynamic_Array* %97
	; IfStmt
	%858 = load %..string, %..string* %0, align 8
	; SelectorExpr
	%859 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %97, i64 0, i32 0
	%860 = load %runtime.Type_Info*, %runtime.Type_Info** %859, align 8
	%861 = bitcast %..string* %98 to %..rawptr
	%862 = call %..rawptr @mem.zero(%..rawptr %861, i64 16) noinline
	store %..string zeroinitializer, %..string* %98
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$28a, i64 0, i32 0), i64 9}, %..string* %98
	%863 = load %..string, %..string* %98, align 8
	%864 = bitcast %..any* %99 to %..rawptr
	%865 = call %..rawptr @mem.zero(%..rawptr %864, i64 16) noinline
	store %..any zeroinitializer, %..any* %99
	%866 = bitcast %..string* %98 to %..rawptr
	%867 = getelementptr inbounds %..any, %..any* %99, i64 0, i32 0
	store %..rawptr %866, %..rawptr* %867
	%868 = getelementptr inbounds %..any, %..any* %99, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %868
	%869 = load %..any, %..any* %99, align 8
	%870 = bitcast %..any* %100 to %..rawptr
	%871 = call %..rawptr @mem.zero(%..rawptr %870, i64 16) noinline
	store %..any zeroinitializer, %..any* %100
	%872 = bitcast %runtime.Type_Info** %859 to %..rawptr
	%873 = getelementptr inbounds %..any, %..any* %100, i64 0, i32 0
	store %..rawptr %872, %..rawptr* %873
	%874 = getelementptr inbounds %..any, %..any* %100, i64 0, i32 1
	store %..typeid 648518346341351435, %..typeid* %874
	%875 = load %..any, %..any* %100, align 8
	; variadic call argument generation
	%876 = bitcast {%..any*, i64}* %101 to %..rawptr
	%877 = call %..rawptr @mem.zero(%..rawptr %876, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %101
	%878 = bitcast [2 x %..any]* %102 to %..rawptr
	%879 = call %..rawptr @mem.zero(%..rawptr %878, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %102
	%880 = getelementptr inbounds [2 x %..any], [2 x %..any]* %102, i64 0, i32 0
	store %..any %869, %..any* %880
	%881 = getelementptr inbounds [2 x %..any], [2 x %..any]* %102, i64 0, i32 1
	store %..any %875, %..any* %881
	%882 = getelementptr inbounds [2 x %..any], [2 x %..any]* %102, i64 0, i32 0
	%883 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %101, i64 0, i32 0
	store %..any* %882, %..any** %883
	%884 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %101, i64 0, i32 1
	store i64 2, i64* %884
	%885 = load {%..any*, i64}, {%..any*, i64}* %101, align 8
	%886 = bitcast {%..any*, i64}* %103 to %..rawptr
	%887 = call %..rawptr @mem.zero(%..rawptr %886, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %103
	store {%..any*, i64} %885, {%..any*, i64}* %103
	%888 = call %..string @fmt.tprint({%..any*, i64}* %103, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%889 = call i8 @workbench._imgui_struct_block_field_start(%..string %858, %..string %888, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%890 = trunc i8 %889 to i1
	br i1 %890, label %if.then-104, label %if.done-108

if.then-104:
	; DeferStmt
	; array
	%891 = load %..rawptr, %..rawptr* %1, align 8
	%892 = bitcast %..rawptr %891 to %mem.Raw_Dynamic_Array*
	%893 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %892, i64 0
	%894 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %893, align 8
	store %mem.Raw_Dynamic_Array %894, %mem.Raw_Dynamic_Array* %104
	; RangeStmt
	; i
	%895 = bitcast i64* %105 to %..rawptr
	%896 = call %..rawptr @mem.zero(%..rawptr %895, i64 8) noinline
	store i64 zeroinitializer, i64* %105
	%897 = bitcast i64* %106 to %..rawptr
	%898 = call %..rawptr @mem.zero(%..rawptr %897, i64 8) noinline
	store i64 zeroinitializer, i64* %106
	store i64 0, i64* %106
	%899 = bitcast i64* %107 to %..rawptr
	%900 = call %..rawptr @mem.zero(%..rawptr %899, i64 8) noinline
	store i64 zeroinitializer, i64* %107
	store i64 0, i64* %107
	br label %for.interval.loop-105

for.interval.loop-105:
	; SelectorExpr
	%901 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %104, i64 0, i32 1
	%902 = load i64, i64* %901, align 8
	%903 = sub i64 %902, 1
	%904 = load i64, i64* %106, align 8
	%905 = icmp sle i64 %904, %903
	br i1 %905, label %for.interval.body-106, label %for.interval.done-107

for.interval.body-106:
	%906 = load i64, i64* %106, align 8
	%907 = load i64, i64* %107, align 8
	%908 = load i64, i64* %106, align 8
	%909 = add i64 %908, 1
	store i64 %909, i64* %106
	%910 = load i64, i64* %107, align 8
	%911 = add i64 %910, 1
	store i64 %911, i64* %107
	store i64 %906, i64* %105
	; SelectorExpr
	%912 = load i64, i64* %105, align 8
	%913 = bitcast %..any* %108 to %..rawptr
	%914 = call %..rawptr @mem.zero(%..rawptr %913, i64 16) noinline
	store %..any zeroinitializer, %..any* %108
	%915 = bitcast i64* %105 to %..rawptr
	%916 = getelementptr inbounds %..any, %..any* %108, i64 0, i32 0
	store %..rawptr %915, %..rawptr* %916
	%917 = getelementptr inbounds %..any, %..any* %108, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %917
	%918 = load %..any, %..any* %108, align 8
	; variadic call argument generation
	%919 = bitcast {%..any*, i64}* %109 to %..rawptr
	%920 = call %..rawptr @mem.zero(%..rawptr %919, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %109
	%921 = bitcast [1 x %..any]* %110 to %..rawptr
	%922 = call %..rawptr @mem.zero(%..rawptr %921, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %110
	%923 = getelementptr inbounds [1 x %..any], [1 x %..any]* %110, i64 0, i32 0
	store %..any %918, %..any* %923
	%924 = getelementptr inbounds [1 x %..any], [1 x %..any]* %110, i64 0, i32 0
	%925 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %109, i64 0, i32 0
	store %..any* %924, %..any** %925
	%926 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %109, i64 0, i32 1
	store i64 1, i64* %926
	%927 = load {%..any*, i64}, {%..any*, i64}* %109, align 8
	%928 = bitcast {%..any*, i64}* %111 to %..rawptr
	%929 = call %..rawptr @mem.zero(%..rawptr %928, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %111
	store {%..any*, i64} %927, {%..any*, i64}* %111
	%930 = call %..string @fmt.tprint({%..any*, i64}* %111, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call void @imgui.push_id_str(%..string %930, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	%931 = load i64, i64* %105, align 8
	%932 = bitcast %..string* %112 to %..rawptr
	%933 = call %..rawptr @mem.zero(%..rawptr %932, i64 16) noinline
	store %..string zeroinitializer, %..string* %112
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$28b, i64 0, i32 0), i64 1}, %..string* %112
	%934 = load %..string, %..string* %112, align 8
	%935 = bitcast %..any* %113 to %..rawptr
	%936 = call %..rawptr @mem.zero(%..rawptr %935, i64 16) noinline
	store %..any zeroinitializer, %..any* %113
	%937 = bitcast %..string* %112 to %..rawptr
	%938 = getelementptr inbounds %..any, %..any* %113, i64 0, i32 0
	store %..rawptr %937, %..rawptr* %938
	%939 = getelementptr inbounds %..any, %..any* %113, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %939
	%940 = load %..any, %..any* %113, align 8
	%941 = bitcast %..any* %114 to %..rawptr
	%942 = call %..rawptr @mem.zero(%..rawptr %941, i64 16) noinline
	store %..any zeroinitializer, %..any* %114
	%943 = bitcast i64* %105 to %..rawptr
	%944 = getelementptr inbounds %..any, %..any* %114, i64 0, i32 0
	store %..rawptr %943, %..rawptr* %944
	%945 = getelementptr inbounds %..any, %..any* %114, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %945
	%946 = load %..any, %..any* %114, align 8
	%947 = bitcast %..string* %115 to %..rawptr
	%948 = call %..rawptr @mem.zero(%..rawptr %947, i64 16) noinline
	store %..string zeroinitializer, %..string* %115
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$28c, i64 0, i32 0), i64 1}, %..string* %115
	%949 = load %..string, %..string* %115, align 8
	%950 = bitcast %..any* %116 to %..rawptr
	%951 = call %..rawptr @mem.zero(%..rawptr %950, i64 16) noinline
	store %..any zeroinitializer, %..any* %116
	%952 = bitcast %..string* %115 to %..rawptr
	%953 = getelementptr inbounds %..any, %..any* %116, i64 0, i32 0
	store %..rawptr %952, %..rawptr* %953
	%954 = getelementptr inbounds %..any, %..any* %116, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %954
	%955 = load %..any, %..any* %116, align 8
	; variadic call argument generation
	%956 = bitcast {%..any*, i64}* %117 to %..rawptr
	%957 = call %..rawptr @mem.zero(%..rawptr %956, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %117
	%958 = bitcast [3 x %..any]* %118 to %..rawptr
	%959 = call %..rawptr @mem.zero(%..rawptr %958, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %118
	%960 = getelementptr inbounds [3 x %..any], [3 x %..any]* %118, i64 0, i32 0
	store %..any %940, %..any* %960
	%961 = getelementptr inbounds [3 x %..any], [3 x %..any]* %118, i64 0, i32 1
	store %..any %946, %..any* %961
	%962 = getelementptr inbounds [3 x %..any], [3 x %..any]* %118, i64 0, i32 2
	store %..any %955, %..any* %962
	%963 = getelementptr inbounds [3 x %..any], [3 x %..any]* %118, i64 0, i32 0
	%964 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %117, i64 0, i32 0
	store %..any* %963, %..any** %964
	%965 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %117, i64 0, i32 1
	store i64 3, i64* %965
	%966 = load {%..any*, i64}, {%..any*, i64}* %117, align 8
	%967 = bitcast {%..any*, i64}* %119 to %..rawptr
	%968 = call %..rawptr @mem.zero(%..rawptr %967, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %119
	store {%..any*, i64} %966, {%..any*, i64}* %119
	%969 = call %..string @fmt.tprint({%..any*, i64}* %119, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%970 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %104, i64 0, i32 0
	%971 = load %..rawptr, %..rawptr* %970, align 8
	%972 = bitcast %..rawptr %971 to i8*
	%973 = load i64, i64* %105, align 8
	; SelectorExpr
	%974 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %97, i64 0, i32 1
	%975 = load i64, i64* %974, align 8
	%976 = mul i64 %973, %975
	%977 = call i8* @mem.ptr_offset-13926(i8* %972, i64 %976)
	; SelectorExpr
	%978 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %97, i64 0, i32 0
	%979 = load %runtime.Type_Info*, %runtime.Type_Info** %978, align 8
	%980 = bitcast i8* %977 to %..rawptr
	call void @workbench._imgui_struct_internal(%..string %969, %..rawptr %980, %runtime.Type_Info* %979, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; defer
	; SelectorExpr
	call ccc void @igPopID()
	br label %for.interval.loop-105

for.interval.done-107:
	; defer
	%981 = load %..string, %..string* %0, align 8
	call void @workbench._imgui_struct_block_field_end(%..string %981, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-108

if.done-108:
	br label %typeswitch.done-109

typeswitch.done-109:
	ret void
}

define void @workbench._imgui_struct_internal.simple_field-0(%..string %name, %..rawptr %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca {%runtime.Type_Info_Pointer, i8}, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %..any, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [1 x %..any], align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca %..any, align 16
	%19 = alloca {%..any*, i64}, align 16
	%20 = alloca [1 x %..any], align 16
	%21 = alloca {%..any*, i64}, align 16
	%22 = alloca %..string, align 16
	%23 = alloca %..any, align 16
	%24 = alloca %..string, align 16
	%25 = alloca %..any, align 16
	%26 = alloca %..any, align 16
	%27 = alloca {%..any*, i64}, align 16
	%28 = alloca [3 x %..any], align 16
	%29 = alloca {%..any*, i64}, align 16
	%30 = alloca {%..any*, i64}, align 16
	%31 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..rawptr %data, %..rawptr* %1
	; value
	%32 = bitcast %..string* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	; is_pointer
	; SelectorExpr
	%34 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 64
	%35 = bitcast %runtime.Type_Info** %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %4
	store %runtime.Type_Info* %34, %runtime.Type_Info** %4
	%37 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	%38 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %37, i64 0
	%39 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %38, i64 0, i32 3
	%40 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, align 8
	; cast - union_cast
	%41 = bitcast {%runtime.Type_Info_Pointer, i8}* %5 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store {%runtime.Type_Info_Pointer, i8} zeroinitializer, {%runtime.Type_Info_Pointer, i8}* %5
	%43 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, i64 0, i32 2 ; UnionTagPtr
	%44 = load i8, i8* %43, align 1
	%45 = icmp eq i8 %44, 10
	br i1 %45, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%46 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 0
	%47 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 1
	%48 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %39 to %runtime.Type_Info_Pointer*
	%49 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %48, align 8
	store %runtime.Type_Info_Pointer %49, %runtime.Type_Info_Pointer* %46
	store i8 1, i8* %47
	br label %union_cast.end-2

union_cast.end-2:
	%50 = load {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, align 8
	%51 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 0
	%52 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 1
	store i8 %52, i8* %3
	; IfStmt
	br i1 0, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	%53 = load %..rawptr, %..rawptr* %1, align 8
	%54 = bitcast %..rawptr %53 to i64*
	%55 = getelementptr inbounds i64, i64* %54, i64 0
	%56 = load i64, i64* %55, align 8
	%57 = bitcast %..string* %6 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$28d, i64 0, i32 0), i64 1}, %..string* %6
	%59 = load %..string, %..string* %6, align 8
	%60 = bitcast %..any* %7 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store %..any zeroinitializer, %..any* %7
	%62 = bitcast %..string* %6 to %..rawptr
	%63 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 0
	store %..rawptr %62, %..rawptr* %63
	%64 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %64
	%65 = load %..any, %..any* %7, align 8
	%66 = bitcast %..any* %8 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 16) noinline
	store %..any zeroinitializer, %..any* %8
	%68 = bitcast i64* %55 to %..rawptr
	%69 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 0
	store %..rawptr %68, %..rawptr* %69
	%70 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 1
	store %..typeid 4683743612465315904, %..typeid* %70
	%71 = load %..any, %..any* %8, align 8
	%72 = bitcast %..string* %9 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$28e, i64 0, i32 0), i64 1}, %..string* %9
	%74 = load %..string, %..string* %9, align 8
	%75 = bitcast %..any* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 16) noinline
	store %..any zeroinitializer, %..any* %10
	%77 = bitcast %..string* %9 to %..rawptr
	%78 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 0
	store %..rawptr %77, %..rawptr* %78
	%79 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %79
	%80 = load %..any, %..any* %10, align 8
	; variadic call argument generation
	%81 = bitcast {%..any*, i64}* %11 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	%83 = bitcast [3 x %..any]* %12 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %12
	%85 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	store %..any %65, %..any* %85
	%86 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 1
	store %..any %71, %..any* %86
	%87 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 2
	store %..any %80, %..any* %87
	%88 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	%89 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 0
	store %..any* %88, %..any** %89
	%90 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 1
	store i64 3, i64* %90
	%91 = load {%..any*, i64}, {%..any*, i64}* %11, align 8
	%92 = bitcast {%..any*, i64}* %13 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	store {%..any*, i64} %91, {%..any*, i64}* %13
	%94 = call %..string @fmt.tprint({%..any*, i64}* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %94, %..string* %2
	br label %if.done-13

if.else-4:
	; IfStmt
	br i1 0, label %if.then-6, label %cmp.or-5

cmp.or-5:
	br i1 0, label %if.then-6, label %if.else-7

if.then-6:
	; AssignStmt
	%95 = load %..rawptr, %..rawptr* %1, align 8
	%96 = bitcast %..rawptr %95 to i64*
	%97 = getelementptr inbounds i64, i64* %96, i64 0
	%98 = load i64, i64* %97, align 8
	%99 = bitcast %..any* %14 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 16) noinline
	store %..any zeroinitializer, %..any* %14
	%101 = bitcast i64* %97 to %..rawptr
	%102 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 0
	store %..rawptr %101, %..rawptr* %102
	%103 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 1
	store %..typeid 4683743612465315904, %..typeid* %103
	%104 = load %..any, %..any* %14, align 8
	; variadic call argument generation
	%105 = bitcast {%..any*, i64}* %15 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	%107 = bitcast [1 x %..any]* %16 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %16
	%109 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	store %..any %104, %..any* %109
	%110 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	%111 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 0
	store %..any* %110, %..any** %111
	%112 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 1
	store i64 1, i64* %112
	%113 = load {%..any*, i64}, {%..any*, i64}* %15, align 8
	%114 = bitcast {%..any*, i64}* %17 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	store {%..any*, i64} %113, {%..any*, i64}* %17
	%116 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$28f, i64 0, i32 0), i64 4}, {%..any*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %116, %..string* %2
	br label %if.done-12

if.else-7:
	; IfStmt
	%117 = load i8, i8* %3, align 1
	%118 = trunc i8 %117 to i1
	br i1 %118, label %cmp.and-8, label %if.else-10

cmp.and-8:
	%119 = load %..rawptr, %..rawptr* %1, align 8
	%120 = bitcast %..rawptr %119 to i8**
	%121 = getelementptr inbounds i8*, i8** %120, i64 0
	%122 = load i8*, i8** %121, align 8
	%123 = icmp eq i8* %122, zeroinitializer
	%124 = zext i1 %123 to i8
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-9, label %if.else-10

if.then-9:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$290, i64 0, i32 0), i64 3}, %..string* %2
	br label %if.done-11

if.else-10:
	; AssignStmt
	%126 = load %..rawptr, %..rawptr* %1, align 8
	%127 = bitcast %..rawptr %126 to i64*
	%128 = getelementptr inbounds i64, i64* %127, i64 0
	%129 = load i64, i64* %128, align 8
	%130 = bitcast %..any* %18 to %..rawptr
	%131 = call %..rawptr @mem.zero(%..rawptr %130, i64 16) noinline
	store %..any zeroinitializer, %..any* %18
	%132 = bitcast i64* %128 to %..rawptr
	%133 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 0
	store %..rawptr %132, %..rawptr* %133
	%134 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 1
	store %..typeid 4683743612465315904, %..typeid* %134
	%135 = load %..any, %..any* %18, align 8
	; variadic call argument generation
	%136 = bitcast {%..any*, i64}* %19 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %19
	%138 = bitcast [1 x %..any]* %20 to %..rawptr
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %20
	%140 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	store %..any %135, %..any* %140
	%141 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	%142 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 0
	store %..any* %141, %..any** %142
	%143 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 1
	store i64 1, i64* %143
	%144 = load {%..any*, i64}, {%..any*, i64}* %19, align 8
	%145 = bitcast {%..any*, i64}* %21 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %21
	store {%..any*, i64} %144, {%..any*, i64}* %21
	%147 = call %..string @fmt.tprint({%..any*, i64}* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %147, %..string* %2
	br label %if.done-11

if.done-11:
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; result
	%148 = load %..string, %..string* %0, align 8
	%149 = load %..string, %..string* %2, align 8
	%150 = bitcast %..any* %23 to %..rawptr
	%151 = call %..rawptr @mem.zero(%..rawptr %150, i64 16) noinline
	store %..any zeroinitializer, %..any* %23
	%152 = bitcast %..string* %0 to %..rawptr
	%153 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 0
	store %..rawptr %152, %..rawptr* %153
	%154 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %154
	%155 = load %..any, %..any* %23, align 8
	%156 = bitcast %..string* %24 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 16) noinline
	store %..string zeroinitializer, %..string* %24
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$291, i64 0, i32 0), i64 3}, %..string* %24
	%158 = load %..string, %..string* %24, align 8
	%159 = bitcast %..any* %25 to %..rawptr
	%160 = call %..rawptr @mem.zero(%..rawptr %159, i64 16) noinline
	store %..any zeroinitializer, %..any* %25
	%161 = bitcast %..string* %24 to %..rawptr
	%162 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 0
	store %..rawptr %161, %..rawptr* %162
	%163 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %163
	%164 = load %..any, %..any* %25, align 8
	%165 = bitcast %..any* %26 to %..rawptr
	%166 = call %..rawptr @mem.zero(%..rawptr %165, i64 16) noinline
	store %..any zeroinitializer, %..any* %26
	%167 = bitcast %..string* %2 to %..rawptr
	%168 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 0
	store %..rawptr %167, %..rawptr* %168
	%169 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %169
	%170 = load %..any, %..any* %26, align 8
	; variadic call argument generation
	%171 = bitcast {%..any*, i64}* %27 to %..rawptr
	%172 = call %..rawptr @mem.zero(%..rawptr %171, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %27
	%173 = bitcast [3 x %..any]* %28 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %28
	%175 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	store %..any %155, %..any* %175
	%176 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 1
	store %..any %164, %..any* %176
	%177 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 2
	store %..any %170, %..any* %177
	%178 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	%179 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 0
	store %..any* %178, %..any** %179
	%180 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 1
	store i64 3, i64* %180
	%181 = load {%..any*, i64}, {%..any*, i64}* %27, align 8
	%182 = bitcast {%..any*, i64}* %29 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %29
	store {%..any*, i64} %181, {%..any*, i64}* %29
	%184 = call %..string @fmt.tprint({%..any*, i64}* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %184, %..string* %22
	; SelectorExpr
	%185 = load %..string, %..string* %22, align 8
	; variadic call argument generation
	%186 = bitcast {%..any*, i64}* %30 to %..rawptr
	%187 = call %..rawptr @mem.zero(%..rawptr %186, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %30
	%188 = load {%..any*, i64}, {%..any*, i64}* %30, align 8
	%189 = bitcast {%..any*, i64}* %31 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %31
	store {%..any*, i64} %188, {%..any*, i64}* %31
	call void @imgui.text(%..string %185, {%..any*, i64}* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @workbench._imgui_struct_internal.simple_field-1(%..string %name, %..rawptr %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca {%runtime.Type_Info_Pointer, i8}, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %..any, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [1 x %..any], align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca %..any, align 16
	%19 = alloca {%..any*, i64}, align 16
	%20 = alloca [1 x %..any], align 16
	%21 = alloca {%..any*, i64}, align 16
	%22 = alloca %..string, align 16
	%23 = alloca %..any, align 16
	%24 = alloca %..string, align 16
	%25 = alloca %..any, align 16
	%26 = alloca %..any, align 16
	%27 = alloca {%..any*, i64}, align 16
	%28 = alloca [3 x %..any], align 16
	%29 = alloca {%..any*, i64}, align 16
	%30 = alloca {%..any*, i64}, align 16
	%31 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..rawptr %data, %..rawptr* %1
	; value
	%32 = bitcast %..string* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	; is_pointer
	; SelectorExpr
	%34 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%35 = bitcast %runtime.Type_Info** %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %4
	store %runtime.Type_Info* %34, %runtime.Type_Info** %4
	%37 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	%38 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %37, i64 0
	%39 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %38, i64 0, i32 3
	%40 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, align 8
	; cast - union_cast
	%41 = bitcast {%runtime.Type_Info_Pointer, i8}* %5 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store {%runtime.Type_Info_Pointer, i8} zeroinitializer, {%runtime.Type_Info_Pointer, i8}* %5
	%43 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, i64 0, i32 2 ; UnionTagPtr
	%44 = load i8, i8* %43, align 1
	%45 = icmp eq i8 %44, 10
	br i1 %45, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%46 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 0
	%47 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 1
	%48 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %39 to %runtime.Type_Info_Pointer*
	%49 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %48, align 8
	store %runtime.Type_Info_Pointer %49, %runtime.Type_Info_Pointer* %46
	store i8 1, i8* %47
	br label %union_cast.end-2

union_cast.end-2:
	%50 = load {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, align 8
	%51 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 0
	%52 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 1
	store i8 %52, i8* %3
	; IfStmt
	br i1 0, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	%53 = load %..rawptr, %..rawptr* %1, align 8
	%54 = bitcast %..rawptr %53 to i32*
	%55 = getelementptr inbounds i32, i32* %54, i64 0
	%56 = load i32, i32* %55, align 4
	%57 = bitcast %..string* %6 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$292, i64 0, i32 0), i64 1}, %..string* %6
	%59 = load %..string, %..string* %6, align 8
	%60 = bitcast %..any* %7 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store %..any zeroinitializer, %..any* %7
	%62 = bitcast %..string* %6 to %..rawptr
	%63 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 0
	store %..rawptr %62, %..rawptr* %63
	%64 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %64
	%65 = load %..any, %..any* %7, align 8
	%66 = bitcast %..any* %8 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 16) noinline
	store %..any zeroinitializer, %..any* %8
	%68 = bitcast i32* %55 to %..rawptr
	%69 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 0
	store %..rawptr %68, %..rawptr* %69
	%70 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 1
	store %..typeid 4683743612465315848, %..typeid* %70
	%71 = load %..any, %..any* %8, align 8
	%72 = bitcast %..string* %9 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$293, i64 0, i32 0), i64 1}, %..string* %9
	%74 = load %..string, %..string* %9, align 8
	%75 = bitcast %..any* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 16) noinline
	store %..any zeroinitializer, %..any* %10
	%77 = bitcast %..string* %9 to %..rawptr
	%78 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 0
	store %..rawptr %77, %..rawptr* %78
	%79 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %79
	%80 = load %..any, %..any* %10, align 8
	; variadic call argument generation
	%81 = bitcast {%..any*, i64}* %11 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	%83 = bitcast [3 x %..any]* %12 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %12
	%85 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	store %..any %65, %..any* %85
	%86 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 1
	store %..any %71, %..any* %86
	%87 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 2
	store %..any %80, %..any* %87
	%88 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	%89 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 0
	store %..any* %88, %..any** %89
	%90 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 1
	store i64 3, i64* %90
	%91 = load {%..any*, i64}, {%..any*, i64}* %11, align 8
	%92 = bitcast {%..any*, i64}* %13 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	store {%..any*, i64} %91, {%..any*, i64}* %13
	%94 = call %..string @fmt.tprint({%..any*, i64}* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %94, %..string* %2
	br label %if.done-13

if.else-4:
	; IfStmt
	br i1 0, label %if.then-6, label %cmp.or-5

cmp.or-5:
	br i1 0, label %if.then-6, label %if.else-7

if.then-6:
	; AssignStmt
	%95 = load %..rawptr, %..rawptr* %1, align 8
	%96 = bitcast %..rawptr %95 to i32*
	%97 = getelementptr inbounds i32, i32* %96, i64 0
	%98 = load i32, i32* %97, align 4
	%99 = bitcast %..any* %14 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 16) noinline
	store %..any zeroinitializer, %..any* %14
	%101 = bitcast i32* %97 to %..rawptr
	%102 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 0
	store %..rawptr %101, %..rawptr* %102
	%103 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 1
	store %..typeid 4683743612465315848, %..typeid* %103
	%104 = load %..any, %..any* %14, align 8
	; variadic call argument generation
	%105 = bitcast {%..any*, i64}* %15 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	%107 = bitcast [1 x %..any]* %16 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %16
	%109 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	store %..any %104, %..any* %109
	%110 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	%111 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 0
	store %..any* %110, %..any** %111
	%112 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 1
	store i64 1, i64* %112
	%113 = load {%..any*, i64}, {%..any*, i64}* %15, align 8
	%114 = bitcast {%..any*, i64}* %17 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	store {%..any*, i64} %113, {%..any*, i64}* %17
	%116 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$294, i64 0, i32 0), i64 4}, {%..any*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %116, %..string* %2
	br label %if.done-12

if.else-7:
	; IfStmt
	%117 = load i8, i8* %3, align 1
	%118 = trunc i8 %117 to i1
	br i1 %118, label %cmp.and-8, label %if.else-10

cmp.and-8:
	%119 = load %..rawptr, %..rawptr* %1, align 8
	%120 = bitcast %..rawptr %119 to i8**
	%121 = getelementptr inbounds i8*, i8** %120, i64 0
	%122 = load i8*, i8** %121, align 8
	%123 = icmp eq i8* %122, zeroinitializer
	%124 = zext i1 %123 to i8
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-9, label %if.else-10

if.then-9:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$295, i64 0, i32 0), i64 3}, %..string* %2
	br label %if.done-11

if.else-10:
	; AssignStmt
	%126 = load %..rawptr, %..rawptr* %1, align 8
	%127 = bitcast %..rawptr %126 to i32*
	%128 = getelementptr inbounds i32, i32* %127, i64 0
	%129 = load i32, i32* %128, align 4
	%130 = bitcast %..any* %18 to %..rawptr
	%131 = call %..rawptr @mem.zero(%..rawptr %130, i64 16) noinline
	store %..any zeroinitializer, %..any* %18
	%132 = bitcast i32* %128 to %..rawptr
	%133 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 0
	store %..rawptr %132, %..rawptr* %133
	%134 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 1
	store %..typeid 4683743612465315848, %..typeid* %134
	%135 = load %..any, %..any* %18, align 8
	; variadic call argument generation
	%136 = bitcast {%..any*, i64}* %19 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %19
	%138 = bitcast [1 x %..any]* %20 to %..rawptr
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %20
	%140 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	store %..any %135, %..any* %140
	%141 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	%142 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 0
	store %..any* %141, %..any** %142
	%143 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 1
	store i64 1, i64* %143
	%144 = load {%..any*, i64}, {%..any*, i64}* %19, align 8
	%145 = bitcast {%..any*, i64}* %21 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %21
	store {%..any*, i64} %144, {%..any*, i64}* %21
	%147 = call %..string @fmt.tprint({%..any*, i64}* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %147, %..string* %2
	br label %if.done-11

if.done-11:
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; result
	%148 = load %..string, %..string* %0, align 8
	%149 = load %..string, %..string* %2, align 8
	%150 = bitcast %..any* %23 to %..rawptr
	%151 = call %..rawptr @mem.zero(%..rawptr %150, i64 16) noinline
	store %..any zeroinitializer, %..any* %23
	%152 = bitcast %..string* %0 to %..rawptr
	%153 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 0
	store %..rawptr %152, %..rawptr* %153
	%154 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %154
	%155 = load %..any, %..any* %23, align 8
	%156 = bitcast %..string* %24 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 16) noinline
	store %..string zeroinitializer, %..string* %24
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$296, i64 0, i32 0), i64 3}, %..string* %24
	%158 = load %..string, %..string* %24, align 8
	%159 = bitcast %..any* %25 to %..rawptr
	%160 = call %..rawptr @mem.zero(%..rawptr %159, i64 16) noinline
	store %..any zeroinitializer, %..any* %25
	%161 = bitcast %..string* %24 to %..rawptr
	%162 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 0
	store %..rawptr %161, %..rawptr* %162
	%163 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %163
	%164 = load %..any, %..any* %25, align 8
	%165 = bitcast %..any* %26 to %..rawptr
	%166 = call %..rawptr @mem.zero(%..rawptr %165, i64 16) noinline
	store %..any zeroinitializer, %..any* %26
	%167 = bitcast %..string* %2 to %..rawptr
	%168 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 0
	store %..rawptr %167, %..rawptr* %168
	%169 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %169
	%170 = load %..any, %..any* %26, align 8
	; variadic call argument generation
	%171 = bitcast {%..any*, i64}* %27 to %..rawptr
	%172 = call %..rawptr @mem.zero(%..rawptr %171, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %27
	%173 = bitcast [3 x %..any]* %28 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %28
	%175 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	store %..any %155, %..any* %175
	%176 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 1
	store %..any %164, %..any* %176
	%177 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 2
	store %..any %170, %..any* %177
	%178 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	%179 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 0
	store %..any* %178, %..any** %179
	%180 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 1
	store i64 3, i64* %180
	%181 = load {%..any*, i64}, {%..any*, i64}* %27, align 8
	%182 = bitcast {%..any*, i64}* %29 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %29
	store {%..any*, i64} %181, {%..any*, i64}* %29
	%184 = call %..string @fmt.tprint({%..any*, i64}* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %184, %..string* %22
	; SelectorExpr
	%185 = load %..string, %..string* %22, align 8
	; variadic call argument generation
	%186 = bitcast {%..any*, i64}* %30 to %..rawptr
	%187 = call %..rawptr @mem.zero(%..rawptr %186, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %30
	%188 = load {%..any*, i64}, {%..any*, i64}* %30, align 8
	%189 = bitcast {%..any*, i64}* %31 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %31
	store {%..any*, i64} %188, {%..any*, i64}* %31
	call void @imgui.text(%..string %185, {%..any*, i64}* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @workbench._imgui_struct_internal.simple_field-2(%..string %name, %..rawptr %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca {%runtime.Type_Info_Pointer, i8}, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %..any, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [1 x %..any], align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca %..any, align 16
	%19 = alloca {%..any*, i64}, align 16
	%20 = alloca [1 x %..any], align 16
	%21 = alloca {%..any*, i64}, align 16
	%22 = alloca %..string, align 16
	%23 = alloca %..any, align 16
	%24 = alloca %..string, align 16
	%25 = alloca %..any, align 16
	%26 = alloca %..any, align 16
	%27 = alloca {%..any*, i64}, align 16
	%28 = alloca [3 x %..any], align 16
	%29 = alloca {%..any*, i64}, align 16
	%30 = alloca {%..any*, i64}, align 16
	%31 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..rawptr %data, %..rawptr* %1
	; value
	%32 = bitcast %..string* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	; is_pointer
	; SelectorExpr
	%34 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 63
	%35 = bitcast %runtime.Type_Info** %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %4
	store %runtime.Type_Info* %34, %runtime.Type_Info** %4
	%37 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	%38 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %37, i64 0
	%39 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %38, i64 0, i32 3
	%40 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, align 8
	; cast - union_cast
	%41 = bitcast {%runtime.Type_Info_Pointer, i8}* %5 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store {%runtime.Type_Info_Pointer, i8} zeroinitializer, {%runtime.Type_Info_Pointer, i8}* %5
	%43 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, i64 0, i32 2 ; UnionTagPtr
	%44 = load i8, i8* %43, align 1
	%45 = icmp eq i8 %44, 10
	br i1 %45, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%46 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 0
	%47 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 1
	%48 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %39 to %runtime.Type_Info_Pointer*
	%49 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %48, align 8
	store %runtime.Type_Info_Pointer %49, %runtime.Type_Info_Pointer* %46
	store i8 1, i8* %47
	br label %union_cast.end-2

union_cast.end-2:
	%50 = load {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, align 8
	%51 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 0
	%52 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 1
	store i8 %52, i8* %3
	; IfStmt
	br i1 0, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	%53 = load %..rawptr, %..rawptr* %1, align 8
	%54 = bitcast %..rawptr %53 to i16*
	%55 = getelementptr inbounds i16, i16* %54, i64 0
	%56 = load i16, i16* %55, align 2
	%57 = bitcast %..string* %6 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$297, i64 0, i32 0), i64 1}, %..string* %6
	%59 = load %..string, %..string* %6, align 8
	%60 = bitcast %..any* %7 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store %..any zeroinitializer, %..any* %7
	%62 = bitcast %..string* %6 to %..rawptr
	%63 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 0
	store %..rawptr %62, %..rawptr* %63
	%64 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %64
	%65 = load %..any, %..any* %7, align 8
	%66 = bitcast %..any* %8 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 16) noinline
	store %..any zeroinitializer, %..any* %8
	%68 = bitcast i16* %55 to %..rawptr
	%69 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 0
	store %..rawptr %68, %..rawptr* %69
	%70 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 1
	store %..typeid 4683743612465315903, %..typeid* %70
	%71 = load %..any, %..any* %8, align 8
	%72 = bitcast %..string* %9 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$298, i64 0, i32 0), i64 1}, %..string* %9
	%74 = load %..string, %..string* %9, align 8
	%75 = bitcast %..any* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 16) noinline
	store %..any zeroinitializer, %..any* %10
	%77 = bitcast %..string* %9 to %..rawptr
	%78 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 0
	store %..rawptr %77, %..rawptr* %78
	%79 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %79
	%80 = load %..any, %..any* %10, align 8
	; variadic call argument generation
	%81 = bitcast {%..any*, i64}* %11 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	%83 = bitcast [3 x %..any]* %12 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %12
	%85 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	store %..any %65, %..any* %85
	%86 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 1
	store %..any %71, %..any* %86
	%87 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 2
	store %..any %80, %..any* %87
	%88 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	%89 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 0
	store %..any* %88, %..any** %89
	%90 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 1
	store i64 3, i64* %90
	%91 = load {%..any*, i64}, {%..any*, i64}* %11, align 8
	%92 = bitcast {%..any*, i64}* %13 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	store {%..any*, i64} %91, {%..any*, i64}* %13
	%94 = call %..string @fmt.tprint({%..any*, i64}* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %94, %..string* %2
	br label %if.done-13

if.else-4:
	; IfStmt
	br i1 0, label %if.then-6, label %cmp.or-5

cmp.or-5:
	br i1 0, label %if.then-6, label %if.else-7

if.then-6:
	; AssignStmt
	%95 = load %..rawptr, %..rawptr* %1, align 8
	%96 = bitcast %..rawptr %95 to i16*
	%97 = getelementptr inbounds i16, i16* %96, i64 0
	%98 = load i16, i16* %97, align 2
	%99 = bitcast %..any* %14 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 16) noinline
	store %..any zeroinitializer, %..any* %14
	%101 = bitcast i16* %97 to %..rawptr
	%102 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 0
	store %..rawptr %101, %..rawptr* %102
	%103 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 1
	store %..typeid 4683743612465315903, %..typeid* %103
	%104 = load %..any, %..any* %14, align 8
	; variadic call argument generation
	%105 = bitcast {%..any*, i64}* %15 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	%107 = bitcast [1 x %..any]* %16 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %16
	%109 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	store %..any %104, %..any* %109
	%110 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	%111 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 0
	store %..any* %110, %..any** %111
	%112 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 1
	store i64 1, i64* %112
	%113 = load {%..any*, i64}, {%..any*, i64}* %15, align 8
	%114 = bitcast {%..any*, i64}* %17 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	store {%..any*, i64} %113, {%..any*, i64}* %17
	%116 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$299, i64 0, i32 0), i64 4}, {%..any*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %116, %..string* %2
	br label %if.done-12

if.else-7:
	; IfStmt
	%117 = load i8, i8* %3, align 1
	%118 = trunc i8 %117 to i1
	br i1 %118, label %cmp.and-8, label %if.else-10

cmp.and-8:
	%119 = load %..rawptr, %..rawptr* %1, align 8
	%120 = bitcast %..rawptr %119 to i8**
	%121 = getelementptr inbounds i8*, i8** %120, i64 0
	%122 = load i8*, i8** %121, align 8
	%123 = icmp eq i8* %122, zeroinitializer
	%124 = zext i1 %123 to i8
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-9, label %if.else-10

if.then-9:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$29a, i64 0, i32 0), i64 3}, %..string* %2
	br label %if.done-11

if.else-10:
	; AssignStmt
	%126 = load %..rawptr, %..rawptr* %1, align 8
	%127 = bitcast %..rawptr %126 to i16*
	%128 = getelementptr inbounds i16, i16* %127, i64 0
	%129 = load i16, i16* %128, align 2
	%130 = bitcast %..any* %18 to %..rawptr
	%131 = call %..rawptr @mem.zero(%..rawptr %130, i64 16) noinline
	store %..any zeroinitializer, %..any* %18
	%132 = bitcast i16* %128 to %..rawptr
	%133 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 0
	store %..rawptr %132, %..rawptr* %133
	%134 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 1
	store %..typeid 4683743612465315903, %..typeid* %134
	%135 = load %..any, %..any* %18, align 8
	; variadic call argument generation
	%136 = bitcast {%..any*, i64}* %19 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %19
	%138 = bitcast [1 x %..any]* %20 to %..rawptr
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %20
	%140 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	store %..any %135, %..any* %140
	%141 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	%142 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 0
	store %..any* %141, %..any** %142
	%143 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 1
	store i64 1, i64* %143
	%144 = load {%..any*, i64}, {%..any*, i64}* %19, align 8
	%145 = bitcast {%..any*, i64}* %21 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %21
	store {%..any*, i64} %144, {%..any*, i64}* %21
	%147 = call %..string @fmt.tprint({%..any*, i64}* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %147, %..string* %2
	br label %if.done-11

if.done-11:
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; result
	%148 = load %..string, %..string* %0, align 8
	%149 = load %..string, %..string* %2, align 8
	%150 = bitcast %..any* %23 to %..rawptr
	%151 = call %..rawptr @mem.zero(%..rawptr %150, i64 16) noinline
	store %..any zeroinitializer, %..any* %23
	%152 = bitcast %..string* %0 to %..rawptr
	%153 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 0
	store %..rawptr %152, %..rawptr* %153
	%154 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %154
	%155 = load %..any, %..any* %23, align 8
	%156 = bitcast %..string* %24 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 16) noinline
	store %..string zeroinitializer, %..string* %24
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$29b, i64 0, i32 0), i64 3}, %..string* %24
	%158 = load %..string, %..string* %24, align 8
	%159 = bitcast %..any* %25 to %..rawptr
	%160 = call %..rawptr @mem.zero(%..rawptr %159, i64 16) noinline
	store %..any zeroinitializer, %..any* %25
	%161 = bitcast %..string* %24 to %..rawptr
	%162 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 0
	store %..rawptr %161, %..rawptr* %162
	%163 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %163
	%164 = load %..any, %..any* %25, align 8
	%165 = bitcast %..any* %26 to %..rawptr
	%166 = call %..rawptr @mem.zero(%..rawptr %165, i64 16) noinline
	store %..any zeroinitializer, %..any* %26
	%167 = bitcast %..string* %2 to %..rawptr
	%168 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 0
	store %..rawptr %167, %..rawptr* %168
	%169 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %169
	%170 = load %..any, %..any* %26, align 8
	; variadic call argument generation
	%171 = bitcast {%..any*, i64}* %27 to %..rawptr
	%172 = call %..rawptr @mem.zero(%..rawptr %171, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %27
	%173 = bitcast [3 x %..any]* %28 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %28
	%175 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	store %..any %155, %..any* %175
	%176 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 1
	store %..any %164, %..any* %176
	%177 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 2
	store %..any %170, %..any* %177
	%178 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	%179 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 0
	store %..any* %178, %..any** %179
	%180 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 1
	store i64 3, i64* %180
	%181 = load {%..any*, i64}, {%..any*, i64}* %27, align 8
	%182 = bitcast {%..any*, i64}* %29 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %29
	store {%..any*, i64} %181, {%..any*, i64}* %29
	%184 = call %..string @fmt.tprint({%..any*, i64}* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %184, %..string* %22
	; SelectorExpr
	%185 = load %..string, %..string* %22, align 8
	; variadic call argument generation
	%186 = bitcast {%..any*, i64}* %30 to %..rawptr
	%187 = call %..rawptr @mem.zero(%..rawptr %186, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %30
	%188 = load {%..any*, i64}, {%..any*, i64}* %30, align 8
	%189 = bitcast {%..any*, i64}* %31 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %31
	store {%..any*, i64} %188, {%..any*, i64}* %31
	call void @imgui.text(%..string %185, {%..any*, i64}* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @workbench._imgui_struct_internal.simple_field-3(%..string %name, %..rawptr %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca {%runtime.Type_Info_Pointer, i8}, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %..any, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [1 x %..any], align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca %..any, align 16
	%19 = alloca {%..any*, i64}, align 16
	%20 = alloca [1 x %..any], align 16
	%21 = alloca {%..any*, i64}, align 16
	%22 = alloca %..string, align 16
	%23 = alloca %..any, align 16
	%24 = alloca %..string, align 16
	%25 = alloca %..any, align 16
	%26 = alloca %..any, align 16
	%27 = alloca {%..any*, i64}, align 16
	%28 = alloca [3 x %..any], align 16
	%29 = alloca {%..any*, i64}, align 16
	%30 = alloca {%..any*, i64}, align 16
	%31 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..rawptr %data, %..rawptr* %1
	; value
	%32 = bitcast %..string* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	; is_pointer
	; SelectorExpr
	%34 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 62
	%35 = bitcast %runtime.Type_Info** %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %4
	store %runtime.Type_Info* %34, %runtime.Type_Info** %4
	%37 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	%38 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %37, i64 0
	%39 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %38, i64 0, i32 3
	%40 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, align 8
	; cast - union_cast
	%41 = bitcast {%runtime.Type_Info_Pointer, i8}* %5 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store {%runtime.Type_Info_Pointer, i8} zeroinitializer, {%runtime.Type_Info_Pointer, i8}* %5
	%43 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, i64 0, i32 2 ; UnionTagPtr
	%44 = load i8, i8* %43, align 1
	%45 = icmp eq i8 %44, 10
	br i1 %45, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%46 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 0
	%47 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 1
	%48 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %39 to %runtime.Type_Info_Pointer*
	%49 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %48, align 8
	store %runtime.Type_Info_Pointer %49, %runtime.Type_Info_Pointer* %46
	store i8 1, i8* %47
	br label %union_cast.end-2

union_cast.end-2:
	%50 = load {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, align 8
	%51 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 0
	%52 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 1
	store i8 %52, i8* %3
	; IfStmt
	br i1 0, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	%53 = load %..rawptr, %..rawptr* %1, align 8
	%54 = bitcast %..rawptr %53 to i8*
	%55 = getelementptr inbounds i8, i8* %54, i64 0
	%56 = load i8, i8* %55, align 1
	%57 = bitcast %..string* %6 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$29c, i64 0, i32 0), i64 1}, %..string* %6
	%59 = load %..string, %..string* %6, align 8
	%60 = bitcast %..any* %7 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store %..any zeroinitializer, %..any* %7
	%62 = bitcast %..string* %6 to %..rawptr
	%63 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 0
	store %..rawptr %62, %..rawptr* %63
	%64 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %64
	%65 = load %..any, %..any* %7, align 8
	%66 = bitcast %..any* %8 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 16) noinline
	store %..any zeroinitializer, %..any* %8
	%68 = bitcast i8* %55 to %..rawptr
	%69 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 0
	store %..rawptr %68, %..rawptr* %69
	%70 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 1
	store %..typeid 4683743612465315902, %..typeid* %70
	%71 = load %..any, %..any* %8, align 8
	%72 = bitcast %..string* %9 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$29d, i64 0, i32 0), i64 1}, %..string* %9
	%74 = load %..string, %..string* %9, align 8
	%75 = bitcast %..any* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 16) noinline
	store %..any zeroinitializer, %..any* %10
	%77 = bitcast %..string* %9 to %..rawptr
	%78 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 0
	store %..rawptr %77, %..rawptr* %78
	%79 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %79
	%80 = load %..any, %..any* %10, align 8
	; variadic call argument generation
	%81 = bitcast {%..any*, i64}* %11 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	%83 = bitcast [3 x %..any]* %12 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %12
	%85 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	store %..any %65, %..any* %85
	%86 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 1
	store %..any %71, %..any* %86
	%87 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 2
	store %..any %80, %..any* %87
	%88 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	%89 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 0
	store %..any* %88, %..any** %89
	%90 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 1
	store i64 3, i64* %90
	%91 = load {%..any*, i64}, {%..any*, i64}* %11, align 8
	%92 = bitcast {%..any*, i64}* %13 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	store {%..any*, i64} %91, {%..any*, i64}* %13
	%94 = call %..string @fmt.tprint({%..any*, i64}* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %94, %..string* %2
	br label %if.done-13

if.else-4:
	; IfStmt
	br i1 0, label %if.then-6, label %cmp.or-5

cmp.or-5:
	br i1 0, label %if.then-6, label %if.else-7

if.then-6:
	; AssignStmt
	%95 = load %..rawptr, %..rawptr* %1, align 8
	%96 = bitcast %..rawptr %95 to i8*
	%97 = getelementptr inbounds i8, i8* %96, i64 0
	%98 = load i8, i8* %97, align 1
	%99 = bitcast %..any* %14 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 16) noinline
	store %..any zeroinitializer, %..any* %14
	%101 = bitcast i8* %97 to %..rawptr
	%102 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 0
	store %..rawptr %101, %..rawptr* %102
	%103 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 1
	store %..typeid 4683743612465315902, %..typeid* %103
	%104 = load %..any, %..any* %14, align 8
	; variadic call argument generation
	%105 = bitcast {%..any*, i64}* %15 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	%107 = bitcast [1 x %..any]* %16 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %16
	%109 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	store %..any %104, %..any* %109
	%110 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	%111 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 0
	store %..any* %110, %..any** %111
	%112 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 1
	store i64 1, i64* %112
	%113 = load {%..any*, i64}, {%..any*, i64}* %15, align 8
	%114 = bitcast {%..any*, i64}* %17 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	store {%..any*, i64} %113, {%..any*, i64}* %17
	%116 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$29e, i64 0, i32 0), i64 4}, {%..any*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %116, %..string* %2
	br label %if.done-12

if.else-7:
	; IfStmt
	%117 = load i8, i8* %3, align 1
	%118 = trunc i8 %117 to i1
	br i1 %118, label %cmp.and-8, label %if.else-10

cmp.and-8:
	%119 = load %..rawptr, %..rawptr* %1, align 8
	%120 = bitcast %..rawptr %119 to i8**
	%121 = getelementptr inbounds i8*, i8** %120, i64 0
	%122 = load i8*, i8** %121, align 8
	%123 = icmp eq i8* %122, zeroinitializer
	%124 = zext i1 %123 to i8
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-9, label %if.else-10

if.then-9:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$29f, i64 0, i32 0), i64 3}, %..string* %2
	br label %if.done-11

if.else-10:
	; AssignStmt
	%126 = load %..rawptr, %..rawptr* %1, align 8
	%127 = bitcast %..rawptr %126 to i8*
	%128 = getelementptr inbounds i8, i8* %127, i64 0
	%129 = load i8, i8* %128, align 1
	%130 = bitcast %..any* %18 to %..rawptr
	%131 = call %..rawptr @mem.zero(%..rawptr %130, i64 16) noinline
	store %..any zeroinitializer, %..any* %18
	%132 = bitcast i8* %128 to %..rawptr
	%133 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 0
	store %..rawptr %132, %..rawptr* %133
	%134 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 1
	store %..typeid 4683743612465315902, %..typeid* %134
	%135 = load %..any, %..any* %18, align 8
	; variadic call argument generation
	%136 = bitcast {%..any*, i64}* %19 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %19
	%138 = bitcast [1 x %..any]* %20 to %..rawptr
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %20
	%140 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	store %..any %135, %..any* %140
	%141 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	%142 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 0
	store %..any* %141, %..any** %142
	%143 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 1
	store i64 1, i64* %143
	%144 = load {%..any*, i64}, {%..any*, i64}* %19, align 8
	%145 = bitcast {%..any*, i64}* %21 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %21
	store {%..any*, i64} %144, {%..any*, i64}* %21
	%147 = call %..string @fmt.tprint({%..any*, i64}* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %147, %..string* %2
	br label %if.done-11

if.done-11:
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; result
	%148 = load %..string, %..string* %0, align 8
	%149 = load %..string, %..string* %2, align 8
	%150 = bitcast %..any* %23 to %..rawptr
	%151 = call %..rawptr @mem.zero(%..rawptr %150, i64 16) noinline
	store %..any zeroinitializer, %..any* %23
	%152 = bitcast %..string* %0 to %..rawptr
	%153 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 0
	store %..rawptr %152, %..rawptr* %153
	%154 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %154
	%155 = load %..any, %..any* %23, align 8
	%156 = bitcast %..string* %24 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 16) noinline
	store %..string zeroinitializer, %..string* %24
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2a0, i64 0, i32 0), i64 3}, %..string* %24
	%158 = load %..string, %..string* %24, align 8
	%159 = bitcast %..any* %25 to %..rawptr
	%160 = call %..rawptr @mem.zero(%..rawptr %159, i64 16) noinline
	store %..any zeroinitializer, %..any* %25
	%161 = bitcast %..string* %24 to %..rawptr
	%162 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 0
	store %..rawptr %161, %..rawptr* %162
	%163 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %163
	%164 = load %..any, %..any* %25, align 8
	%165 = bitcast %..any* %26 to %..rawptr
	%166 = call %..rawptr @mem.zero(%..rawptr %165, i64 16) noinline
	store %..any zeroinitializer, %..any* %26
	%167 = bitcast %..string* %2 to %..rawptr
	%168 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 0
	store %..rawptr %167, %..rawptr* %168
	%169 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %169
	%170 = load %..any, %..any* %26, align 8
	; variadic call argument generation
	%171 = bitcast {%..any*, i64}* %27 to %..rawptr
	%172 = call %..rawptr @mem.zero(%..rawptr %171, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %27
	%173 = bitcast [3 x %..any]* %28 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %28
	%175 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	store %..any %155, %..any* %175
	%176 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 1
	store %..any %164, %..any* %176
	%177 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 2
	store %..any %170, %..any* %177
	%178 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	%179 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 0
	store %..any* %178, %..any** %179
	%180 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 1
	store i64 3, i64* %180
	%181 = load {%..any*, i64}, {%..any*, i64}* %27, align 8
	%182 = bitcast {%..any*, i64}* %29 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %29
	store {%..any*, i64} %181, {%..any*, i64}* %29
	%184 = call %..string @fmt.tprint({%..any*, i64}* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %184, %..string* %22
	; SelectorExpr
	%185 = load %..string, %..string* %22, align 8
	; variadic call argument generation
	%186 = bitcast {%..any*, i64}* %30 to %..rawptr
	%187 = call %..rawptr @mem.zero(%..rawptr %186, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %30
	%188 = load {%..any*, i64}, {%..any*, i64}* %30, align 8
	%189 = bitcast {%..any*, i64}* %31 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %31
	store {%..any*, i64} %188, {%..any*, i64}* %31
	call void @imgui.text(%..string %185, {%..any*, i64}* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @workbench._imgui_struct_internal.simple_field-4(%..string %name, %..rawptr %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca {%runtime.Type_Info_Pointer, i8}, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %..any, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [1 x %..any], align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca %..any, align 16
	%19 = alloca {%..any*, i64}, align 16
	%20 = alloca [1 x %..any], align 16
	%21 = alloca {%..any*, i64}, align 16
	%22 = alloca %..string, align 16
	%23 = alloca %..any, align 16
	%24 = alloca %..string, align 16
	%25 = alloca %..any, align 16
	%26 = alloca %..any, align 16
	%27 = alloca {%..any*, i64}, align 16
	%28 = alloca [3 x %..any], align 16
	%29 = alloca {%..any*, i64}, align 16
	%30 = alloca {%..any*, i64}, align 16
	%31 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..rawptr %data, %..rawptr* %1
	; value
	%32 = bitcast %..string* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	; is_pointer
	; SelectorExpr
	%34 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 7
	%35 = bitcast %runtime.Type_Info** %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %4
	store %runtime.Type_Info* %34, %runtime.Type_Info** %4
	%37 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	%38 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %37, i64 0
	%39 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %38, i64 0, i32 3
	%40 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, align 8
	; cast - union_cast
	%41 = bitcast {%runtime.Type_Info_Pointer, i8}* %5 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store {%runtime.Type_Info_Pointer, i8} zeroinitializer, {%runtime.Type_Info_Pointer, i8}* %5
	%43 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, i64 0, i32 2 ; UnionTagPtr
	%44 = load i8, i8* %43, align 1
	%45 = icmp eq i8 %44, 10
	br i1 %45, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%46 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 0
	%47 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 1
	%48 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %39 to %runtime.Type_Info_Pointer*
	%49 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %48, align 8
	store %runtime.Type_Info_Pointer %49, %runtime.Type_Info_Pointer* %46
	store i8 1, i8* %47
	br label %union_cast.end-2

union_cast.end-2:
	%50 = load {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, align 8
	%51 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 0
	%52 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 1
	store i8 %52, i8* %3
	; IfStmt
	br i1 0, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	%53 = load %..rawptr, %..rawptr* %1, align 8
	%54 = bitcast %..rawptr %53 to i64*
	%55 = getelementptr inbounds i64, i64* %54, i64 0
	%56 = load i64, i64* %55, align 8
	%57 = bitcast %..string* %6 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2a1, i64 0, i32 0), i64 1}, %..string* %6
	%59 = load %..string, %..string* %6, align 8
	%60 = bitcast %..any* %7 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store %..any zeroinitializer, %..any* %7
	%62 = bitcast %..string* %6 to %..rawptr
	%63 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 0
	store %..rawptr %62, %..rawptr* %63
	%64 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %64
	%65 = load %..any, %..any* %7, align 8
	%66 = bitcast %..any* %8 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 16) noinline
	store %..any zeroinitializer, %..any* %8
	%68 = bitcast i64* %55 to %..rawptr
	%69 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 0
	store %..rawptr %68, %..rawptr* %69
	%70 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 1
	store %..typeid 72057594037927943, %..typeid* %70
	%71 = load %..any, %..any* %8, align 8
	%72 = bitcast %..string* %9 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2a2, i64 0, i32 0), i64 1}, %..string* %9
	%74 = load %..string, %..string* %9, align 8
	%75 = bitcast %..any* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 16) noinline
	store %..any zeroinitializer, %..any* %10
	%77 = bitcast %..string* %9 to %..rawptr
	%78 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 0
	store %..rawptr %77, %..rawptr* %78
	%79 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %79
	%80 = load %..any, %..any* %10, align 8
	; variadic call argument generation
	%81 = bitcast {%..any*, i64}* %11 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	%83 = bitcast [3 x %..any]* %12 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %12
	%85 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	store %..any %65, %..any* %85
	%86 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 1
	store %..any %71, %..any* %86
	%87 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 2
	store %..any %80, %..any* %87
	%88 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	%89 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 0
	store %..any* %88, %..any** %89
	%90 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 1
	store i64 3, i64* %90
	%91 = load {%..any*, i64}, {%..any*, i64}* %11, align 8
	%92 = bitcast {%..any*, i64}* %13 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	store {%..any*, i64} %91, {%..any*, i64}* %13
	%94 = call %..string @fmt.tprint({%..any*, i64}* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %94, %..string* %2
	br label %if.done-13

if.else-4:
	; IfStmt
	br i1 0, label %if.then-6, label %cmp.or-5

cmp.or-5:
	br i1 0, label %if.then-6, label %if.else-7

if.then-6:
	; AssignStmt
	%95 = load %..rawptr, %..rawptr* %1, align 8
	%96 = bitcast %..rawptr %95 to i64*
	%97 = getelementptr inbounds i64, i64* %96, i64 0
	%98 = load i64, i64* %97, align 8
	%99 = bitcast %..any* %14 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 16) noinline
	store %..any zeroinitializer, %..any* %14
	%101 = bitcast i64* %97 to %..rawptr
	%102 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 0
	store %..rawptr %101, %..rawptr* %102
	%103 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 1
	store %..typeid 72057594037927943, %..typeid* %103
	%104 = load %..any, %..any* %14, align 8
	; variadic call argument generation
	%105 = bitcast {%..any*, i64}* %15 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	%107 = bitcast [1 x %..any]* %16 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %16
	%109 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	store %..any %104, %..any* %109
	%110 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	%111 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 0
	store %..any* %110, %..any** %111
	%112 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 1
	store i64 1, i64* %112
	%113 = load {%..any*, i64}, {%..any*, i64}* %15, align 8
	%114 = bitcast {%..any*, i64}* %17 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	store {%..any*, i64} %113, {%..any*, i64}* %17
	%116 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2a3, i64 0, i32 0), i64 4}, {%..any*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %116, %..string* %2
	br label %if.done-12

if.else-7:
	; IfStmt
	%117 = load i8, i8* %3, align 1
	%118 = trunc i8 %117 to i1
	br i1 %118, label %cmp.and-8, label %if.else-10

cmp.and-8:
	%119 = load %..rawptr, %..rawptr* %1, align 8
	%120 = bitcast %..rawptr %119 to i8**
	%121 = getelementptr inbounds i8*, i8** %120, i64 0
	%122 = load i8*, i8** %121, align 8
	%123 = icmp eq i8* %122, zeroinitializer
	%124 = zext i1 %123 to i8
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-9, label %if.else-10

if.then-9:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2a4, i64 0, i32 0), i64 3}, %..string* %2
	br label %if.done-11

if.else-10:
	; AssignStmt
	%126 = load %..rawptr, %..rawptr* %1, align 8
	%127 = bitcast %..rawptr %126 to i64*
	%128 = getelementptr inbounds i64, i64* %127, i64 0
	%129 = load i64, i64* %128, align 8
	%130 = bitcast %..any* %18 to %..rawptr
	%131 = call %..rawptr @mem.zero(%..rawptr %130, i64 16) noinline
	store %..any zeroinitializer, %..any* %18
	%132 = bitcast i64* %128 to %..rawptr
	%133 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 0
	store %..rawptr %132, %..rawptr* %133
	%134 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 1
	store %..typeid 72057594037927943, %..typeid* %134
	%135 = load %..any, %..any* %18, align 8
	; variadic call argument generation
	%136 = bitcast {%..any*, i64}* %19 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %19
	%138 = bitcast [1 x %..any]* %20 to %..rawptr
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %20
	%140 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	store %..any %135, %..any* %140
	%141 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	%142 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 0
	store %..any* %141, %..any** %142
	%143 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 1
	store i64 1, i64* %143
	%144 = load {%..any*, i64}, {%..any*, i64}* %19, align 8
	%145 = bitcast {%..any*, i64}* %21 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %21
	store {%..any*, i64} %144, {%..any*, i64}* %21
	%147 = call %..string @fmt.tprint({%..any*, i64}* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %147, %..string* %2
	br label %if.done-11

if.done-11:
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; result
	%148 = load %..string, %..string* %0, align 8
	%149 = load %..string, %..string* %2, align 8
	%150 = bitcast %..any* %23 to %..rawptr
	%151 = call %..rawptr @mem.zero(%..rawptr %150, i64 16) noinline
	store %..any zeroinitializer, %..any* %23
	%152 = bitcast %..string* %0 to %..rawptr
	%153 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 0
	store %..rawptr %152, %..rawptr* %153
	%154 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %154
	%155 = load %..any, %..any* %23, align 8
	%156 = bitcast %..string* %24 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 16) noinline
	store %..string zeroinitializer, %..string* %24
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2a5, i64 0, i32 0), i64 3}, %..string* %24
	%158 = load %..string, %..string* %24, align 8
	%159 = bitcast %..any* %25 to %..rawptr
	%160 = call %..rawptr @mem.zero(%..rawptr %159, i64 16) noinline
	store %..any zeroinitializer, %..any* %25
	%161 = bitcast %..string* %24 to %..rawptr
	%162 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 0
	store %..rawptr %161, %..rawptr* %162
	%163 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %163
	%164 = load %..any, %..any* %25, align 8
	%165 = bitcast %..any* %26 to %..rawptr
	%166 = call %..rawptr @mem.zero(%..rawptr %165, i64 16) noinline
	store %..any zeroinitializer, %..any* %26
	%167 = bitcast %..string* %2 to %..rawptr
	%168 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 0
	store %..rawptr %167, %..rawptr* %168
	%169 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %169
	%170 = load %..any, %..any* %26, align 8
	; variadic call argument generation
	%171 = bitcast {%..any*, i64}* %27 to %..rawptr
	%172 = call %..rawptr @mem.zero(%..rawptr %171, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %27
	%173 = bitcast [3 x %..any]* %28 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %28
	%175 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	store %..any %155, %..any* %175
	%176 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 1
	store %..any %164, %..any* %176
	%177 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 2
	store %..any %170, %..any* %177
	%178 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	%179 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 0
	store %..any* %178, %..any** %179
	%180 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 1
	store i64 3, i64* %180
	%181 = load {%..any*, i64}, {%..any*, i64}* %27, align 8
	%182 = bitcast {%..any*, i64}* %29 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %29
	store {%..any*, i64} %181, {%..any*, i64}* %29
	%184 = call %..string @fmt.tprint({%..any*, i64}* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %184, %..string* %22
	; SelectorExpr
	%185 = load %..string, %..string* %22, align 8
	; variadic call argument generation
	%186 = bitcast {%..any*, i64}* %30 to %..rawptr
	%187 = call %..rawptr @mem.zero(%..rawptr %186, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %30
	%188 = load {%..any*, i64}, {%..any*, i64}* %30, align 8
	%189 = bitcast {%..any*, i64}* %31 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %31
	store {%..any*, i64} %188, {%..any*, i64}* %31
	call void @imgui.text(%..string %185, {%..any*, i64}* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @workbench._imgui_struct_internal.simple_field-5(%..string %name, %..rawptr %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca {%runtime.Type_Info_Pointer, i8}, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %..any, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [1 x %..any], align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca %..any, align 16
	%19 = alloca {%..any*, i64}, align 16
	%20 = alloca [1 x %..any], align 16
	%21 = alloca {%..any*, i64}, align 16
	%22 = alloca %..string, align 16
	%23 = alloca %..any, align 16
	%24 = alloca %..string, align 16
	%25 = alloca %..any, align 16
	%26 = alloca %..any, align 16
	%27 = alloca {%..any*, i64}, align 16
	%28 = alloca [3 x %..any], align 16
	%29 = alloca {%..any*, i64}, align 16
	%30 = alloca {%..any*, i64}, align 16
	%31 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..rawptr %data, %..rawptr* %1
	; value
	%32 = bitcast %..string* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	; is_pointer
	; SelectorExpr
	%34 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 66
	%35 = bitcast %runtime.Type_Info** %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %4
	store %runtime.Type_Info* %34, %runtime.Type_Info** %4
	%37 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	%38 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %37, i64 0
	%39 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %38, i64 0, i32 3
	%40 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, align 8
	; cast - union_cast
	%41 = bitcast {%runtime.Type_Info_Pointer, i8}* %5 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store {%runtime.Type_Info_Pointer, i8} zeroinitializer, {%runtime.Type_Info_Pointer, i8}* %5
	%43 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, i64 0, i32 2 ; UnionTagPtr
	%44 = load i8, i8* %43, align 1
	%45 = icmp eq i8 %44, 10
	br i1 %45, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%46 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 0
	%47 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 1
	%48 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %39 to %runtime.Type_Info_Pointer*
	%49 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %48, align 8
	store %runtime.Type_Info_Pointer %49, %runtime.Type_Info_Pointer* %46
	store i8 1, i8* %47
	br label %union_cast.end-2

union_cast.end-2:
	%50 = load {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, align 8
	%51 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 0
	%52 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 1
	store i8 %52, i8* %3
	; IfStmt
	br i1 0, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	%53 = load %..rawptr, %..rawptr* %1, align 8
	%54 = bitcast %..rawptr %53 to i32*
	%55 = getelementptr inbounds i32, i32* %54, i64 0
	%56 = load i32, i32* %55, align 4
	%57 = bitcast %..string* %6 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2a6, i64 0, i32 0), i64 1}, %..string* %6
	%59 = load %..string, %..string* %6, align 8
	%60 = bitcast %..any* %7 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store %..any zeroinitializer, %..any* %7
	%62 = bitcast %..string* %6 to %..rawptr
	%63 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 0
	store %..rawptr %62, %..rawptr* %63
	%64 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %64
	%65 = load %..any, %..any* %7, align 8
	%66 = bitcast %..any* %8 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 16) noinline
	store %..any zeroinitializer, %..any* %8
	%68 = bitcast i32* %55 to %..rawptr
	%69 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 0
	store %..rawptr %68, %..rawptr* %69
	%70 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 1
	store %..typeid 72057594037928002, %..typeid* %70
	%71 = load %..any, %..any* %8, align 8
	%72 = bitcast %..string* %9 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2a7, i64 0, i32 0), i64 1}, %..string* %9
	%74 = load %..string, %..string* %9, align 8
	%75 = bitcast %..any* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 16) noinline
	store %..any zeroinitializer, %..any* %10
	%77 = bitcast %..string* %9 to %..rawptr
	%78 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 0
	store %..rawptr %77, %..rawptr* %78
	%79 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %79
	%80 = load %..any, %..any* %10, align 8
	; variadic call argument generation
	%81 = bitcast {%..any*, i64}* %11 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	%83 = bitcast [3 x %..any]* %12 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %12
	%85 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	store %..any %65, %..any* %85
	%86 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 1
	store %..any %71, %..any* %86
	%87 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 2
	store %..any %80, %..any* %87
	%88 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	%89 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 0
	store %..any* %88, %..any** %89
	%90 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 1
	store i64 3, i64* %90
	%91 = load {%..any*, i64}, {%..any*, i64}* %11, align 8
	%92 = bitcast {%..any*, i64}* %13 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	store {%..any*, i64} %91, {%..any*, i64}* %13
	%94 = call %..string @fmt.tprint({%..any*, i64}* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %94, %..string* %2
	br label %if.done-13

if.else-4:
	; IfStmt
	br i1 0, label %if.then-6, label %cmp.or-5

cmp.or-5:
	br i1 0, label %if.then-6, label %if.else-7

if.then-6:
	; AssignStmt
	%95 = load %..rawptr, %..rawptr* %1, align 8
	%96 = bitcast %..rawptr %95 to i32*
	%97 = getelementptr inbounds i32, i32* %96, i64 0
	%98 = load i32, i32* %97, align 4
	%99 = bitcast %..any* %14 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 16) noinline
	store %..any zeroinitializer, %..any* %14
	%101 = bitcast i32* %97 to %..rawptr
	%102 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 0
	store %..rawptr %101, %..rawptr* %102
	%103 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 1
	store %..typeid 72057594037928002, %..typeid* %103
	%104 = load %..any, %..any* %14, align 8
	; variadic call argument generation
	%105 = bitcast {%..any*, i64}* %15 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	%107 = bitcast [1 x %..any]* %16 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %16
	%109 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	store %..any %104, %..any* %109
	%110 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	%111 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 0
	store %..any* %110, %..any** %111
	%112 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 1
	store i64 1, i64* %112
	%113 = load {%..any*, i64}, {%..any*, i64}* %15, align 8
	%114 = bitcast {%..any*, i64}* %17 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	store {%..any*, i64} %113, {%..any*, i64}* %17
	%116 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2a8, i64 0, i32 0), i64 4}, {%..any*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %116, %..string* %2
	br label %if.done-12

if.else-7:
	; IfStmt
	%117 = load i8, i8* %3, align 1
	%118 = trunc i8 %117 to i1
	br i1 %118, label %cmp.and-8, label %if.else-10

cmp.and-8:
	%119 = load %..rawptr, %..rawptr* %1, align 8
	%120 = bitcast %..rawptr %119 to i8**
	%121 = getelementptr inbounds i8*, i8** %120, i64 0
	%122 = load i8*, i8** %121, align 8
	%123 = icmp eq i8* %122, zeroinitializer
	%124 = zext i1 %123 to i8
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-9, label %if.else-10

if.then-9:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2a9, i64 0, i32 0), i64 3}, %..string* %2
	br label %if.done-11

if.else-10:
	; AssignStmt
	%126 = load %..rawptr, %..rawptr* %1, align 8
	%127 = bitcast %..rawptr %126 to i32*
	%128 = getelementptr inbounds i32, i32* %127, i64 0
	%129 = load i32, i32* %128, align 4
	%130 = bitcast %..any* %18 to %..rawptr
	%131 = call %..rawptr @mem.zero(%..rawptr %130, i64 16) noinline
	store %..any zeroinitializer, %..any* %18
	%132 = bitcast i32* %128 to %..rawptr
	%133 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 0
	store %..rawptr %132, %..rawptr* %133
	%134 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 1
	store %..typeid 72057594037928002, %..typeid* %134
	%135 = load %..any, %..any* %18, align 8
	; variadic call argument generation
	%136 = bitcast {%..any*, i64}* %19 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %19
	%138 = bitcast [1 x %..any]* %20 to %..rawptr
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %20
	%140 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	store %..any %135, %..any* %140
	%141 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	%142 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 0
	store %..any* %141, %..any** %142
	%143 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 1
	store i64 1, i64* %143
	%144 = load {%..any*, i64}, {%..any*, i64}* %19, align 8
	%145 = bitcast {%..any*, i64}* %21 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %21
	store {%..any*, i64} %144, {%..any*, i64}* %21
	%147 = call %..string @fmt.tprint({%..any*, i64}* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %147, %..string* %2
	br label %if.done-11

if.done-11:
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; result
	%148 = load %..string, %..string* %0, align 8
	%149 = load %..string, %..string* %2, align 8
	%150 = bitcast %..any* %23 to %..rawptr
	%151 = call %..rawptr @mem.zero(%..rawptr %150, i64 16) noinline
	store %..any zeroinitializer, %..any* %23
	%152 = bitcast %..string* %0 to %..rawptr
	%153 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 0
	store %..rawptr %152, %..rawptr* %153
	%154 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %154
	%155 = load %..any, %..any* %23, align 8
	%156 = bitcast %..string* %24 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 16) noinline
	store %..string zeroinitializer, %..string* %24
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2aa, i64 0, i32 0), i64 3}, %..string* %24
	%158 = load %..string, %..string* %24, align 8
	%159 = bitcast %..any* %25 to %..rawptr
	%160 = call %..rawptr @mem.zero(%..rawptr %159, i64 16) noinline
	store %..any zeroinitializer, %..any* %25
	%161 = bitcast %..string* %24 to %..rawptr
	%162 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 0
	store %..rawptr %161, %..rawptr* %162
	%163 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %163
	%164 = load %..any, %..any* %25, align 8
	%165 = bitcast %..any* %26 to %..rawptr
	%166 = call %..rawptr @mem.zero(%..rawptr %165, i64 16) noinline
	store %..any zeroinitializer, %..any* %26
	%167 = bitcast %..string* %2 to %..rawptr
	%168 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 0
	store %..rawptr %167, %..rawptr* %168
	%169 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %169
	%170 = load %..any, %..any* %26, align 8
	; variadic call argument generation
	%171 = bitcast {%..any*, i64}* %27 to %..rawptr
	%172 = call %..rawptr @mem.zero(%..rawptr %171, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %27
	%173 = bitcast [3 x %..any]* %28 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %28
	%175 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	store %..any %155, %..any* %175
	%176 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 1
	store %..any %164, %..any* %176
	%177 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 2
	store %..any %170, %..any* %177
	%178 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	%179 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 0
	store %..any* %178, %..any** %179
	%180 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 1
	store i64 3, i64* %180
	%181 = load {%..any*, i64}, {%..any*, i64}* %27, align 8
	%182 = bitcast {%..any*, i64}* %29 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %29
	store {%..any*, i64} %181, {%..any*, i64}* %29
	%184 = call %..string @fmt.tprint({%..any*, i64}* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %184, %..string* %22
	; SelectorExpr
	%185 = load %..string, %..string* %22, align 8
	; variadic call argument generation
	%186 = bitcast {%..any*, i64}* %30 to %..rawptr
	%187 = call %..rawptr @mem.zero(%..rawptr %186, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %30
	%188 = load {%..any*, i64}, {%..any*, i64}* %30, align 8
	%189 = bitcast {%..any*, i64}* %31 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %31
	store {%..any*, i64} %188, {%..any*, i64}* %31
	call void @imgui.text(%..string %185, {%..any*, i64}* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @workbench._imgui_struct_internal.simple_field-6(%..string %name, %..rawptr %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca {%runtime.Type_Info_Pointer, i8}, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %..any, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [1 x %..any], align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca %..any, align 16
	%19 = alloca {%..any*, i64}, align 16
	%20 = alloca [1 x %..any], align 16
	%21 = alloca {%..any*, i64}, align 16
	%22 = alloca %..string, align 16
	%23 = alloca %..any, align 16
	%24 = alloca %..string, align 16
	%25 = alloca %..any, align 16
	%26 = alloca %..any, align 16
	%27 = alloca {%..any*, i64}, align 16
	%28 = alloca [3 x %..any], align 16
	%29 = alloca {%..any*, i64}, align 16
	%30 = alloca {%..any*, i64}, align 16
	%31 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..rawptr %data, %..rawptr* %1
	; value
	%32 = bitcast %..string* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	; is_pointer
	; SelectorExpr
	%34 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 65
	%35 = bitcast %runtime.Type_Info** %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %4
	store %runtime.Type_Info* %34, %runtime.Type_Info** %4
	%37 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	%38 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %37, i64 0
	%39 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %38, i64 0, i32 3
	%40 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, align 8
	; cast - union_cast
	%41 = bitcast {%runtime.Type_Info_Pointer, i8}* %5 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store {%runtime.Type_Info_Pointer, i8} zeroinitializer, {%runtime.Type_Info_Pointer, i8}* %5
	%43 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, i64 0, i32 2 ; UnionTagPtr
	%44 = load i8, i8* %43, align 1
	%45 = icmp eq i8 %44, 10
	br i1 %45, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%46 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 0
	%47 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 1
	%48 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %39 to %runtime.Type_Info_Pointer*
	%49 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %48, align 8
	store %runtime.Type_Info_Pointer %49, %runtime.Type_Info_Pointer* %46
	store i8 1, i8* %47
	br label %union_cast.end-2

union_cast.end-2:
	%50 = load {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, align 8
	%51 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 0
	%52 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 1
	store i8 %52, i8* %3
	; IfStmt
	br i1 0, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	%53 = load %..rawptr, %..rawptr* %1, align 8
	%54 = bitcast %..rawptr %53 to i16*
	%55 = getelementptr inbounds i16, i16* %54, i64 0
	%56 = load i16, i16* %55, align 2
	%57 = bitcast %..string* %6 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2ab, i64 0, i32 0), i64 1}, %..string* %6
	%59 = load %..string, %..string* %6, align 8
	%60 = bitcast %..any* %7 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store %..any zeroinitializer, %..any* %7
	%62 = bitcast %..string* %6 to %..rawptr
	%63 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 0
	store %..rawptr %62, %..rawptr* %63
	%64 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %64
	%65 = load %..any, %..any* %7, align 8
	%66 = bitcast %..any* %8 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 16) noinline
	store %..any zeroinitializer, %..any* %8
	%68 = bitcast i16* %55 to %..rawptr
	%69 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 0
	store %..rawptr %68, %..rawptr* %69
	%70 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 1
	store %..typeid 72057594037928001, %..typeid* %70
	%71 = load %..any, %..any* %8, align 8
	%72 = bitcast %..string* %9 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2ac, i64 0, i32 0), i64 1}, %..string* %9
	%74 = load %..string, %..string* %9, align 8
	%75 = bitcast %..any* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 16) noinline
	store %..any zeroinitializer, %..any* %10
	%77 = bitcast %..string* %9 to %..rawptr
	%78 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 0
	store %..rawptr %77, %..rawptr* %78
	%79 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %79
	%80 = load %..any, %..any* %10, align 8
	; variadic call argument generation
	%81 = bitcast {%..any*, i64}* %11 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	%83 = bitcast [3 x %..any]* %12 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %12
	%85 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	store %..any %65, %..any* %85
	%86 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 1
	store %..any %71, %..any* %86
	%87 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 2
	store %..any %80, %..any* %87
	%88 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	%89 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 0
	store %..any* %88, %..any** %89
	%90 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 1
	store i64 3, i64* %90
	%91 = load {%..any*, i64}, {%..any*, i64}* %11, align 8
	%92 = bitcast {%..any*, i64}* %13 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	store {%..any*, i64} %91, {%..any*, i64}* %13
	%94 = call %..string @fmt.tprint({%..any*, i64}* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %94, %..string* %2
	br label %if.done-13

if.else-4:
	; IfStmt
	br i1 0, label %if.then-6, label %cmp.or-5

cmp.or-5:
	br i1 0, label %if.then-6, label %if.else-7

if.then-6:
	; AssignStmt
	%95 = load %..rawptr, %..rawptr* %1, align 8
	%96 = bitcast %..rawptr %95 to i16*
	%97 = getelementptr inbounds i16, i16* %96, i64 0
	%98 = load i16, i16* %97, align 2
	%99 = bitcast %..any* %14 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 16) noinline
	store %..any zeroinitializer, %..any* %14
	%101 = bitcast i16* %97 to %..rawptr
	%102 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 0
	store %..rawptr %101, %..rawptr* %102
	%103 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 1
	store %..typeid 72057594037928001, %..typeid* %103
	%104 = load %..any, %..any* %14, align 8
	; variadic call argument generation
	%105 = bitcast {%..any*, i64}* %15 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	%107 = bitcast [1 x %..any]* %16 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %16
	%109 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	store %..any %104, %..any* %109
	%110 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	%111 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 0
	store %..any* %110, %..any** %111
	%112 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 1
	store i64 1, i64* %112
	%113 = load {%..any*, i64}, {%..any*, i64}* %15, align 8
	%114 = bitcast {%..any*, i64}* %17 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	store {%..any*, i64} %113, {%..any*, i64}* %17
	%116 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2ad, i64 0, i32 0), i64 4}, {%..any*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %116, %..string* %2
	br label %if.done-12

if.else-7:
	; IfStmt
	%117 = load i8, i8* %3, align 1
	%118 = trunc i8 %117 to i1
	br i1 %118, label %cmp.and-8, label %if.else-10

cmp.and-8:
	%119 = load %..rawptr, %..rawptr* %1, align 8
	%120 = bitcast %..rawptr %119 to i8**
	%121 = getelementptr inbounds i8*, i8** %120, i64 0
	%122 = load i8*, i8** %121, align 8
	%123 = icmp eq i8* %122, zeroinitializer
	%124 = zext i1 %123 to i8
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-9, label %if.else-10

if.then-9:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2ae, i64 0, i32 0), i64 3}, %..string* %2
	br label %if.done-11

if.else-10:
	; AssignStmt
	%126 = load %..rawptr, %..rawptr* %1, align 8
	%127 = bitcast %..rawptr %126 to i16*
	%128 = getelementptr inbounds i16, i16* %127, i64 0
	%129 = load i16, i16* %128, align 2
	%130 = bitcast %..any* %18 to %..rawptr
	%131 = call %..rawptr @mem.zero(%..rawptr %130, i64 16) noinline
	store %..any zeroinitializer, %..any* %18
	%132 = bitcast i16* %128 to %..rawptr
	%133 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 0
	store %..rawptr %132, %..rawptr* %133
	%134 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 1
	store %..typeid 72057594037928001, %..typeid* %134
	%135 = load %..any, %..any* %18, align 8
	; variadic call argument generation
	%136 = bitcast {%..any*, i64}* %19 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %19
	%138 = bitcast [1 x %..any]* %20 to %..rawptr
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %20
	%140 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	store %..any %135, %..any* %140
	%141 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	%142 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 0
	store %..any* %141, %..any** %142
	%143 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 1
	store i64 1, i64* %143
	%144 = load {%..any*, i64}, {%..any*, i64}* %19, align 8
	%145 = bitcast {%..any*, i64}* %21 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %21
	store {%..any*, i64} %144, {%..any*, i64}* %21
	%147 = call %..string @fmt.tprint({%..any*, i64}* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %147, %..string* %2
	br label %if.done-11

if.done-11:
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; result
	%148 = load %..string, %..string* %0, align 8
	%149 = load %..string, %..string* %2, align 8
	%150 = bitcast %..any* %23 to %..rawptr
	%151 = call %..rawptr @mem.zero(%..rawptr %150, i64 16) noinline
	store %..any zeroinitializer, %..any* %23
	%152 = bitcast %..string* %0 to %..rawptr
	%153 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 0
	store %..rawptr %152, %..rawptr* %153
	%154 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %154
	%155 = load %..any, %..any* %23, align 8
	%156 = bitcast %..string* %24 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 16) noinline
	store %..string zeroinitializer, %..string* %24
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2af, i64 0, i32 0), i64 3}, %..string* %24
	%158 = load %..string, %..string* %24, align 8
	%159 = bitcast %..any* %25 to %..rawptr
	%160 = call %..rawptr @mem.zero(%..rawptr %159, i64 16) noinline
	store %..any zeroinitializer, %..any* %25
	%161 = bitcast %..string* %24 to %..rawptr
	%162 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 0
	store %..rawptr %161, %..rawptr* %162
	%163 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %163
	%164 = load %..any, %..any* %25, align 8
	%165 = bitcast %..any* %26 to %..rawptr
	%166 = call %..rawptr @mem.zero(%..rawptr %165, i64 16) noinline
	store %..any zeroinitializer, %..any* %26
	%167 = bitcast %..string* %2 to %..rawptr
	%168 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 0
	store %..rawptr %167, %..rawptr* %168
	%169 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %169
	%170 = load %..any, %..any* %26, align 8
	; variadic call argument generation
	%171 = bitcast {%..any*, i64}* %27 to %..rawptr
	%172 = call %..rawptr @mem.zero(%..rawptr %171, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %27
	%173 = bitcast [3 x %..any]* %28 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %28
	%175 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	store %..any %155, %..any* %175
	%176 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 1
	store %..any %164, %..any* %176
	%177 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 2
	store %..any %170, %..any* %177
	%178 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	%179 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 0
	store %..any* %178, %..any** %179
	%180 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 1
	store i64 3, i64* %180
	%181 = load {%..any*, i64}, {%..any*, i64}* %27, align 8
	%182 = bitcast {%..any*, i64}* %29 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %29
	store {%..any*, i64} %181, {%..any*, i64}* %29
	%184 = call %..string @fmt.tprint({%..any*, i64}* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %184, %..string* %22
	; SelectorExpr
	%185 = load %..string, %..string* %22, align 8
	; variadic call argument generation
	%186 = bitcast {%..any*, i64}* %30 to %..rawptr
	%187 = call %..rawptr @mem.zero(%..rawptr %186, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %30
	%188 = load {%..any*, i64}, {%..any*, i64}* %30, align 8
	%189 = bitcast {%..any*, i64}* %31 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %31
	store {%..any*, i64} %188, {%..any*, i64}* %31
	call void @imgui.text(%..string %185, {%..any*, i64}* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @workbench._imgui_struct_internal.simple_field-7(%..string %name, %..rawptr %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca {%runtime.Type_Info_Pointer, i8}, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %..any, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [1 x %..any], align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca %..any, align 16
	%19 = alloca {%..any*, i64}, align 16
	%20 = alloca [1 x %..any], align 16
	%21 = alloca {%..any*, i64}, align 16
	%22 = alloca %..string, align 16
	%23 = alloca %..any, align 16
	%24 = alloca %..string, align 16
	%25 = alloca %..any, align 16
	%26 = alloca %..any, align 16
	%27 = alloca {%..any*, i64}, align 16
	%28 = alloca [3 x %..any], align 16
	%29 = alloca {%..any*, i64}, align 16
	%30 = alloca {%..any*, i64}, align 16
	%31 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..rawptr %data, %..rawptr* %1
	; value
	%32 = bitcast %..string* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	; is_pointer
	; SelectorExpr
	%34 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	%35 = bitcast %runtime.Type_Info** %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %4
	store %runtime.Type_Info* %34, %runtime.Type_Info** %4
	%37 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	%38 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %37, i64 0
	%39 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %38, i64 0, i32 3
	%40 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, align 8
	; cast - union_cast
	%41 = bitcast {%runtime.Type_Info_Pointer, i8}* %5 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store {%runtime.Type_Info_Pointer, i8} zeroinitializer, {%runtime.Type_Info_Pointer, i8}* %5
	%43 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, i64 0, i32 2 ; UnionTagPtr
	%44 = load i8, i8* %43, align 1
	%45 = icmp eq i8 %44, 10
	br i1 %45, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%46 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 0
	%47 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 1
	%48 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %39 to %runtime.Type_Info_Pointer*
	%49 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %48, align 8
	store %runtime.Type_Info_Pointer %49, %runtime.Type_Info_Pointer* %46
	store i8 1, i8* %47
	br label %union_cast.end-2

union_cast.end-2:
	%50 = load {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, align 8
	%51 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 0
	%52 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 1
	store i8 %52, i8* %3
	; IfStmt
	br i1 0, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	%53 = load %..rawptr, %..rawptr* %1, align 8
	%54 = bitcast %..rawptr %53 to i8*
	%55 = getelementptr inbounds i8, i8* %54, i64 0
	%56 = load i8, i8* %55, align 1
	%57 = bitcast %..string* %6 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2b0, i64 0, i32 0), i64 1}, %..string* %6
	%59 = load %..string, %..string* %6, align 8
	%60 = bitcast %..any* %7 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store %..any zeroinitializer, %..any* %7
	%62 = bitcast %..string* %6 to %..rawptr
	%63 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 0
	store %..rawptr %62, %..rawptr* %63
	%64 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %64
	%65 = load %..any, %..any* %7, align 8
	%66 = bitcast %..any* %8 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 16) noinline
	store %..any zeroinitializer, %..any* %8
	%68 = bitcast i8* %55 to %..rawptr
	%69 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 0
	store %..rawptr %68, %..rawptr* %69
	%70 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 1
	store %..typeid 72057594037927939, %..typeid* %70
	%71 = load %..any, %..any* %8, align 8
	%72 = bitcast %..string* %9 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2b1, i64 0, i32 0), i64 1}, %..string* %9
	%74 = load %..string, %..string* %9, align 8
	%75 = bitcast %..any* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 16) noinline
	store %..any zeroinitializer, %..any* %10
	%77 = bitcast %..string* %9 to %..rawptr
	%78 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 0
	store %..rawptr %77, %..rawptr* %78
	%79 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %79
	%80 = load %..any, %..any* %10, align 8
	; variadic call argument generation
	%81 = bitcast {%..any*, i64}* %11 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	%83 = bitcast [3 x %..any]* %12 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %12
	%85 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	store %..any %65, %..any* %85
	%86 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 1
	store %..any %71, %..any* %86
	%87 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 2
	store %..any %80, %..any* %87
	%88 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	%89 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 0
	store %..any* %88, %..any** %89
	%90 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 1
	store i64 3, i64* %90
	%91 = load {%..any*, i64}, {%..any*, i64}* %11, align 8
	%92 = bitcast {%..any*, i64}* %13 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	store {%..any*, i64} %91, {%..any*, i64}* %13
	%94 = call %..string @fmt.tprint({%..any*, i64}* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %94, %..string* %2
	br label %if.done-13

if.else-4:
	; IfStmt
	br i1 0, label %if.then-6, label %cmp.or-5

cmp.or-5:
	br i1 0, label %if.then-6, label %if.else-7

if.then-6:
	; AssignStmt
	%95 = load %..rawptr, %..rawptr* %1, align 8
	%96 = bitcast %..rawptr %95 to i8*
	%97 = getelementptr inbounds i8, i8* %96, i64 0
	%98 = load i8, i8* %97, align 1
	%99 = bitcast %..any* %14 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 16) noinline
	store %..any zeroinitializer, %..any* %14
	%101 = bitcast i8* %97 to %..rawptr
	%102 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 0
	store %..rawptr %101, %..rawptr* %102
	%103 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 1
	store %..typeid 72057594037927939, %..typeid* %103
	%104 = load %..any, %..any* %14, align 8
	; variadic call argument generation
	%105 = bitcast {%..any*, i64}* %15 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	%107 = bitcast [1 x %..any]* %16 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %16
	%109 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	store %..any %104, %..any* %109
	%110 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	%111 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 0
	store %..any* %110, %..any** %111
	%112 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 1
	store i64 1, i64* %112
	%113 = load {%..any*, i64}, {%..any*, i64}* %15, align 8
	%114 = bitcast {%..any*, i64}* %17 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	store {%..any*, i64} %113, {%..any*, i64}* %17
	%116 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2b2, i64 0, i32 0), i64 4}, {%..any*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %116, %..string* %2
	br label %if.done-12

if.else-7:
	; IfStmt
	%117 = load i8, i8* %3, align 1
	%118 = trunc i8 %117 to i1
	br i1 %118, label %cmp.and-8, label %if.else-10

cmp.and-8:
	%119 = load %..rawptr, %..rawptr* %1, align 8
	%120 = bitcast %..rawptr %119 to i8**
	%121 = getelementptr inbounds i8*, i8** %120, i64 0
	%122 = load i8*, i8** %121, align 8
	%123 = icmp eq i8* %122, zeroinitializer
	%124 = zext i1 %123 to i8
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-9, label %if.else-10

if.then-9:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2b3, i64 0, i32 0), i64 3}, %..string* %2
	br label %if.done-11

if.else-10:
	; AssignStmt
	%126 = load %..rawptr, %..rawptr* %1, align 8
	%127 = bitcast %..rawptr %126 to i8*
	%128 = getelementptr inbounds i8, i8* %127, i64 0
	%129 = load i8, i8* %128, align 1
	%130 = bitcast %..any* %18 to %..rawptr
	%131 = call %..rawptr @mem.zero(%..rawptr %130, i64 16) noinline
	store %..any zeroinitializer, %..any* %18
	%132 = bitcast i8* %128 to %..rawptr
	%133 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 0
	store %..rawptr %132, %..rawptr* %133
	%134 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 1
	store %..typeid 72057594037927939, %..typeid* %134
	%135 = load %..any, %..any* %18, align 8
	; variadic call argument generation
	%136 = bitcast {%..any*, i64}* %19 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %19
	%138 = bitcast [1 x %..any]* %20 to %..rawptr
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %20
	%140 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	store %..any %135, %..any* %140
	%141 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	%142 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 0
	store %..any* %141, %..any** %142
	%143 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 1
	store i64 1, i64* %143
	%144 = load {%..any*, i64}, {%..any*, i64}* %19, align 8
	%145 = bitcast {%..any*, i64}* %21 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %21
	store {%..any*, i64} %144, {%..any*, i64}* %21
	%147 = call %..string @fmt.tprint({%..any*, i64}* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %147, %..string* %2
	br label %if.done-11

if.done-11:
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; result
	%148 = load %..string, %..string* %0, align 8
	%149 = load %..string, %..string* %2, align 8
	%150 = bitcast %..any* %23 to %..rawptr
	%151 = call %..rawptr @mem.zero(%..rawptr %150, i64 16) noinline
	store %..any zeroinitializer, %..any* %23
	%152 = bitcast %..string* %0 to %..rawptr
	%153 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 0
	store %..rawptr %152, %..rawptr* %153
	%154 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %154
	%155 = load %..any, %..any* %23, align 8
	%156 = bitcast %..string* %24 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 16) noinline
	store %..string zeroinitializer, %..string* %24
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2b4, i64 0, i32 0), i64 3}, %..string* %24
	%158 = load %..string, %..string* %24, align 8
	%159 = bitcast %..any* %25 to %..rawptr
	%160 = call %..rawptr @mem.zero(%..rawptr %159, i64 16) noinline
	store %..any zeroinitializer, %..any* %25
	%161 = bitcast %..string* %24 to %..rawptr
	%162 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 0
	store %..rawptr %161, %..rawptr* %162
	%163 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %163
	%164 = load %..any, %..any* %25, align 8
	%165 = bitcast %..any* %26 to %..rawptr
	%166 = call %..rawptr @mem.zero(%..rawptr %165, i64 16) noinline
	store %..any zeroinitializer, %..any* %26
	%167 = bitcast %..string* %2 to %..rawptr
	%168 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 0
	store %..rawptr %167, %..rawptr* %168
	%169 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %169
	%170 = load %..any, %..any* %26, align 8
	; variadic call argument generation
	%171 = bitcast {%..any*, i64}* %27 to %..rawptr
	%172 = call %..rawptr @mem.zero(%..rawptr %171, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %27
	%173 = bitcast [3 x %..any]* %28 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %28
	%175 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	store %..any %155, %..any* %175
	%176 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 1
	store %..any %164, %..any* %176
	%177 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 2
	store %..any %170, %..any* %177
	%178 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	%179 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 0
	store %..any* %178, %..any** %179
	%180 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 1
	store i64 3, i64* %180
	%181 = load {%..any*, i64}, {%..any*, i64}* %27, align 8
	%182 = bitcast {%..any*, i64}* %29 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %29
	store {%..any*, i64} %181, {%..any*, i64}* %29
	%184 = call %..string @fmt.tprint({%..any*, i64}* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %184, %..string* %22
	; SelectorExpr
	%185 = load %..string, %..string* %22, align 8
	; variadic call argument generation
	%186 = bitcast {%..any*, i64}* %30 to %..rawptr
	%187 = call %..rawptr @mem.zero(%..rawptr %186, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %30
	%188 = load {%..any*, i64}, {%..any*, i64}* %30, align 8
	%189 = bitcast {%..any*, i64}* %31 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %31
	store {%..any*, i64} %188, {%..any*, i64}* %31
	call void @imgui.text(%..string %185, {%..any*, i64}* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @workbench._imgui_struct_internal.simple_field-8(%..string %name, %..rawptr %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca {%runtime.Type_Info_Pointer, i8}, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %..any, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [1 x %..any], align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca %..any, align 16
	%19 = alloca {%..any*, i64}, align 16
	%20 = alloca [1 x %..any], align 16
	%21 = alloca {%..any*, i64}, align 16
	%22 = alloca %..string, align 16
	%23 = alloca %..any, align 16
	%24 = alloca %..string, align 16
	%25 = alloca %..any, align 16
	%26 = alloca %..any, align 16
	%27 = alloca {%..any*, i64}, align 16
	%28 = alloca [3 x %..any], align 16
	%29 = alloca {%..any*, i64}, align 16
	%30 = alloca {%..any*, i64}, align 16
	%31 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..rawptr %data, %..rawptr* %1
	; value
	%32 = bitcast %..string* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	; is_pointer
	; SelectorExpr
	%34 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 84
	%35 = bitcast %runtime.Type_Info** %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %4
	store %runtime.Type_Info* %34, %runtime.Type_Info** %4
	%37 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	%38 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %37, i64 0
	%39 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %38, i64 0, i32 3
	%40 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, align 8
	; cast - union_cast
	%41 = bitcast {%runtime.Type_Info_Pointer, i8}* %5 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store {%runtime.Type_Info_Pointer, i8} zeroinitializer, {%runtime.Type_Info_Pointer, i8}* %5
	%43 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, i64 0, i32 2 ; UnionTagPtr
	%44 = load i8, i8* %43, align 1
	%45 = icmp eq i8 %44, 10
	br i1 %45, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%46 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 0
	%47 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 1
	%48 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %39 to %runtime.Type_Info_Pointer*
	%49 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %48, align 8
	store %runtime.Type_Info_Pointer %49, %runtime.Type_Info_Pointer* %46
	store i8 1, i8* %47
	br label %union_cast.end-2

union_cast.end-2:
	%50 = load {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, align 8
	%51 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 0
	%52 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 1
	store i8 %52, i8* %3
	; IfStmt
	br i1 0, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	%53 = load %..rawptr, %..rawptr* %1, align 8
	%54 = bitcast %..rawptr %53 to double*
	%55 = getelementptr inbounds double, double* %54, i64 0
	%56 = load double, double* %55, align 8
	%57 = bitcast %..string* %6 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2b5, i64 0, i32 0), i64 1}, %..string* %6
	%59 = load %..string, %..string* %6, align 8
	%60 = bitcast %..any* %7 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store %..any zeroinitializer, %..any* %7
	%62 = bitcast %..string* %6 to %..rawptr
	%63 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 0
	store %..rawptr %62, %..rawptr* %63
	%64 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %64
	%65 = load %..any, %..any* %7, align 8
	%66 = bitcast %..any* %8 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 16) noinline
	store %..any zeroinitializer, %..any* %8
	%68 = bitcast double* %55 to %..rawptr
	%69 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 0
	store %..rawptr %68, %..rawptr* %69
	%70 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 1
	store %..typeid 216172782113783892, %..typeid* %70
	%71 = load %..any, %..any* %8, align 8
	%72 = bitcast %..string* %9 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2b6, i64 0, i32 0), i64 1}, %..string* %9
	%74 = load %..string, %..string* %9, align 8
	%75 = bitcast %..any* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 16) noinline
	store %..any zeroinitializer, %..any* %10
	%77 = bitcast %..string* %9 to %..rawptr
	%78 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 0
	store %..rawptr %77, %..rawptr* %78
	%79 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %79
	%80 = load %..any, %..any* %10, align 8
	; variadic call argument generation
	%81 = bitcast {%..any*, i64}* %11 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	%83 = bitcast [3 x %..any]* %12 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %12
	%85 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	store %..any %65, %..any* %85
	%86 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 1
	store %..any %71, %..any* %86
	%87 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 2
	store %..any %80, %..any* %87
	%88 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	%89 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 0
	store %..any* %88, %..any** %89
	%90 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 1
	store i64 3, i64* %90
	%91 = load {%..any*, i64}, {%..any*, i64}* %11, align 8
	%92 = bitcast {%..any*, i64}* %13 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	store {%..any*, i64} %91, {%..any*, i64}* %13
	%94 = call %..string @fmt.tprint({%..any*, i64}* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %94, %..string* %2
	br label %if.done-13

if.else-4:
	; IfStmt
	br i1 0, label %if.then-6, label %cmp.or-5

cmp.or-5:
	br i1 1, label %if.then-6, label %if.else-7

if.then-6:
	; AssignStmt
	%95 = load %..rawptr, %..rawptr* %1, align 8
	%96 = bitcast %..rawptr %95 to double*
	%97 = getelementptr inbounds double, double* %96, i64 0
	%98 = load double, double* %97, align 8
	%99 = bitcast %..any* %14 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 16) noinline
	store %..any zeroinitializer, %..any* %14
	%101 = bitcast double* %97 to %..rawptr
	%102 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 0
	store %..rawptr %101, %..rawptr* %102
	%103 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 1
	store %..typeid 216172782113783892, %..typeid* %103
	%104 = load %..any, %..any* %14, align 8
	; variadic call argument generation
	%105 = bitcast {%..any*, i64}* %15 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	%107 = bitcast [1 x %..any]* %16 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %16
	%109 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	store %..any %104, %..any* %109
	%110 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	%111 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 0
	store %..any* %110, %..any** %111
	%112 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 1
	store i64 1, i64* %112
	%113 = load {%..any*, i64}, {%..any*, i64}* %15, align 8
	%114 = bitcast {%..any*, i64}* %17 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	store {%..any*, i64} %113, {%..any*, i64}* %17
	%116 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2b7, i64 0, i32 0), i64 4}, {%..any*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %116, %..string* %2
	br label %if.done-12

if.else-7:
	; IfStmt
	%117 = load i8, i8* %3, align 1
	%118 = trunc i8 %117 to i1
	br i1 %118, label %cmp.and-8, label %if.else-10

cmp.and-8:
	%119 = load %..rawptr, %..rawptr* %1, align 8
	%120 = bitcast %..rawptr %119 to i8**
	%121 = getelementptr inbounds i8*, i8** %120, i64 0
	%122 = load i8*, i8** %121, align 8
	%123 = icmp eq i8* %122, zeroinitializer
	%124 = zext i1 %123 to i8
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-9, label %if.else-10

if.then-9:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2b8, i64 0, i32 0), i64 3}, %..string* %2
	br label %if.done-11

if.else-10:
	; AssignStmt
	%126 = load %..rawptr, %..rawptr* %1, align 8
	%127 = bitcast %..rawptr %126 to double*
	%128 = getelementptr inbounds double, double* %127, i64 0
	%129 = load double, double* %128, align 8
	%130 = bitcast %..any* %18 to %..rawptr
	%131 = call %..rawptr @mem.zero(%..rawptr %130, i64 16) noinline
	store %..any zeroinitializer, %..any* %18
	%132 = bitcast double* %128 to %..rawptr
	%133 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 0
	store %..rawptr %132, %..rawptr* %133
	%134 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 1
	store %..typeid 216172782113783892, %..typeid* %134
	%135 = load %..any, %..any* %18, align 8
	; variadic call argument generation
	%136 = bitcast {%..any*, i64}* %19 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %19
	%138 = bitcast [1 x %..any]* %20 to %..rawptr
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %20
	%140 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	store %..any %135, %..any* %140
	%141 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	%142 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 0
	store %..any* %141, %..any** %142
	%143 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 1
	store i64 1, i64* %143
	%144 = load {%..any*, i64}, {%..any*, i64}* %19, align 8
	%145 = bitcast {%..any*, i64}* %21 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %21
	store {%..any*, i64} %144, {%..any*, i64}* %21
	%147 = call %..string @fmt.tprint({%..any*, i64}* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %147, %..string* %2
	br label %if.done-11

if.done-11:
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; result
	%148 = load %..string, %..string* %0, align 8
	%149 = load %..string, %..string* %2, align 8
	%150 = bitcast %..any* %23 to %..rawptr
	%151 = call %..rawptr @mem.zero(%..rawptr %150, i64 16) noinline
	store %..any zeroinitializer, %..any* %23
	%152 = bitcast %..string* %0 to %..rawptr
	%153 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 0
	store %..rawptr %152, %..rawptr* %153
	%154 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %154
	%155 = load %..any, %..any* %23, align 8
	%156 = bitcast %..string* %24 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 16) noinline
	store %..string zeroinitializer, %..string* %24
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2b9, i64 0, i32 0), i64 3}, %..string* %24
	%158 = load %..string, %..string* %24, align 8
	%159 = bitcast %..any* %25 to %..rawptr
	%160 = call %..rawptr @mem.zero(%..rawptr %159, i64 16) noinline
	store %..any zeroinitializer, %..any* %25
	%161 = bitcast %..string* %24 to %..rawptr
	%162 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 0
	store %..rawptr %161, %..rawptr* %162
	%163 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %163
	%164 = load %..any, %..any* %25, align 8
	%165 = bitcast %..any* %26 to %..rawptr
	%166 = call %..rawptr @mem.zero(%..rawptr %165, i64 16) noinline
	store %..any zeroinitializer, %..any* %26
	%167 = bitcast %..string* %2 to %..rawptr
	%168 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 0
	store %..rawptr %167, %..rawptr* %168
	%169 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %169
	%170 = load %..any, %..any* %26, align 8
	; variadic call argument generation
	%171 = bitcast {%..any*, i64}* %27 to %..rawptr
	%172 = call %..rawptr @mem.zero(%..rawptr %171, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %27
	%173 = bitcast [3 x %..any]* %28 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %28
	%175 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	store %..any %155, %..any* %175
	%176 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 1
	store %..any %164, %..any* %176
	%177 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 2
	store %..any %170, %..any* %177
	%178 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	%179 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 0
	store %..any* %178, %..any** %179
	%180 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 1
	store i64 3, i64* %180
	%181 = load {%..any*, i64}, {%..any*, i64}* %27, align 8
	%182 = bitcast {%..any*, i64}* %29 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %29
	store {%..any*, i64} %181, {%..any*, i64}* %29
	%184 = call %..string @fmt.tprint({%..any*, i64}* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %184, %..string* %22
	; SelectorExpr
	%185 = load %..string, %..string* %22, align 8
	; variadic call argument generation
	%186 = bitcast {%..any*, i64}* %30 to %..rawptr
	%187 = call %..rawptr @mem.zero(%..rawptr %186, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %30
	%188 = load {%..any*, i64}, {%..any*, i64}* %30, align 8
	%189 = bitcast {%..any*, i64}* %31 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %31
	store {%..any*, i64} %188, {%..any*, i64}* %31
	call void @imgui.text(%..string %185, {%..any*, i64}* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @workbench._imgui_struct_internal.simple_field-9(%..string %name, %..rawptr %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca {%runtime.Type_Info_Pointer, i8}, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %..any, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [1 x %..any], align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca %..any, align 16
	%19 = alloca {%..any*, i64}, align 16
	%20 = alloca [1 x %..any], align 16
	%21 = alloca {%..any*, i64}, align 16
	%22 = alloca %..string, align 16
	%23 = alloca %..any, align 16
	%24 = alloca %..string, align 16
	%25 = alloca %..any, align 16
	%26 = alloca %..any, align 16
	%27 = alloca {%..any*, i64}, align 16
	%28 = alloca [3 x %..any], align 16
	%29 = alloca {%..any*, i64}, align 16
	%30 = alloca {%..any*, i64}, align 16
	%31 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..rawptr %data, %..rawptr* %1
	; value
	%32 = bitcast %..string* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	; is_pointer
	; SelectorExpr
	%34 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%35 = bitcast %runtime.Type_Info** %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %4
	store %runtime.Type_Info* %34, %runtime.Type_Info** %4
	%37 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	%38 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %37, i64 0
	%39 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %38, i64 0, i32 3
	%40 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, align 8
	; cast - union_cast
	%41 = bitcast {%runtime.Type_Info_Pointer, i8}* %5 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store {%runtime.Type_Info_Pointer, i8} zeroinitializer, {%runtime.Type_Info_Pointer, i8}* %5
	%43 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, i64 0, i32 2 ; UnionTagPtr
	%44 = load i8, i8* %43, align 1
	%45 = icmp eq i8 %44, 10
	br i1 %45, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%46 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 0
	%47 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 1
	%48 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %39 to %runtime.Type_Info_Pointer*
	%49 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %48, align 8
	store %runtime.Type_Info_Pointer %49, %runtime.Type_Info_Pointer* %46
	store i8 1, i8* %47
	br label %union_cast.end-2

union_cast.end-2:
	%50 = load {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, align 8
	%51 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 0
	%52 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 1
	store i8 %52, i8* %3
	; IfStmt
	br i1 0, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	%53 = load %..rawptr, %..rawptr* %1, align 8
	%54 = bitcast %..rawptr %53 to float*
	%55 = getelementptr inbounds float, float* %54, i64 0
	%56 = load float, float* %55, align 4
	%57 = bitcast %..string* %6 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2ba, i64 0, i32 0), i64 1}, %..string* %6
	%59 = load %..string, %..string* %6, align 8
	%60 = bitcast %..any* %7 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store %..any zeroinitializer, %..any* %7
	%62 = bitcast %..string* %6 to %..rawptr
	%63 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 0
	store %..rawptr %62, %..rawptr* %63
	%64 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %64
	%65 = load %..any, %..any* %7, align 8
	%66 = bitcast %..any* %8 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 16) noinline
	store %..any zeroinitializer, %..any* %8
	%68 = bitcast float* %55 to %..rawptr
	%69 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 0
	store %..rawptr %68, %..rawptr* %69
	%70 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 1
	store %..typeid 216172782113783891, %..typeid* %70
	%71 = load %..any, %..any* %8, align 8
	%72 = bitcast %..string* %9 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2bb, i64 0, i32 0), i64 1}, %..string* %9
	%74 = load %..string, %..string* %9, align 8
	%75 = bitcast %..any* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 16) noinline
	store %..any zeroinitializer, %..any* %10
	%77 = bitcast %..string* %9 to %..rawptr
	%78 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 0
	store %..rawptr %77, %..rawptr* %78
	%79 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %79
	%80 = load %..any, %..any* %10, align 8
	; variadic call argument generation
	%81 = bitcast {%..any*, i64}* %11 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	%83 = bitcast [3 x %..any]* %12 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %12
	%85 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	store %..any %65, %..any* %85
	%86 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 1
	store %..any %71, %..any* %86
	%87 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 2
	store %..any %80, %..any* %87
	%88 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	%89 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 0
	store %..any* %88, %..any** %89
	%90 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 1
	store i64 3, i64* %90
	%91 = load {%..any*, i64}, {%..any*, i64}* %11, align 8
	%92 = bitcast {%..any*, i64}* %13 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	store {%..any*, i64} %91, {%..any*, i64}* %13
	%94 = call %..string @fmt.tprint({%..any*, i64}* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %94, %..string* %2
	br label %if.done-13

if.else-4:
	; IfStmt
	br i1 1, label %if.then-6, label %cmp.or-5

cmp.or-5:
	br i1 0, label %if.then-6, label %if.else-7

if.then-6:
	; AssignStmt
	%95 = load %..rawptr, %..rawptr* %1, align 8
	%96 = bitcast %..rawptr %95 to float*
	%97 = getelementptr inbounds float, float* %96, i64 0
	%98 = load float, float* %97, align 4
	%99 = bitcast %..any* %14 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 16) noinline
	store %..any zeroinitializer, %..any* %14
	%101 = bitcast float* %97 to %..rawptr
	%102 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 0
	store %..rawptr %101, %..rawptr* %102
	%103 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 1
	store %..typeid 216172782113783891, %..typeid* %103
	%104 = load %..any, %..any* %14, align 8
	; variadic call argument generation
	%105 = bitcast {%..any*, i64}* %15 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	%107 = bitcast [1 x %..any]* %16 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %16
	%109 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	store %..any %104, %..any* %109
	%110 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	%111 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 0
	store %..any* %110, %..any** %111
	%112 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 1
	store i64 1, i64* %112
	%113 = load {%..any*, i64}, {%..any*, i64}* %15, align 8
	%114 = bitcast {%..any*, i64}* %17 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	store {%..any*, i64} %113, {%..any*, i64}* %17
	%116 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2bc, i64 0, i32 0), i64 4}, {%..any*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %116, %..string* %2
	br label %if.done-12

if.else-7:
	; IfStmt
	%117 = load i8, i8* %3, align 1
	%118 = trunc i8 %117 to i1
	br i1 %118, label %cmp.and-8, label %if.else-10

cmp.and-8:
	%119 = load %..rawptr, %..rawptr* %1, align 8
	%120 = bitcast %..rawptr %119 to i8**
	%121 = getelementptr inbounds i8*, i8** %120, i64 0
	%122 = load i8*, i8** %121, align 8
	%123 = icmp eq i8* %122, zeroinitializer
	%124 = zext i1 %123 to i8
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-9, label %if.else-10

if.then-9:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2bd, i64 0, i32 0), i64 3}, %..string* %2
	br label %if.done-11

if.else-10:
	; AssignStmt
	%126 = load %..rawptr, %..rawptr* %1, align 8
	%127 = bitcast %..rawptr %126 to float*
	%128 = getelementptr inbounds float, float* %127, i64 0
	%129 = load float, float* %128, align 4
	%130 = bitcast %..any* %18 to %..rawptr
	%131 = call %..rawptr @mem.zero(%..rawptr %130, i64 16) noinline
	store %..any zeroinitializer, %..any* %18
	%132 = bitcast float* %128 to %..rawptr
	%133 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 0
	store %..rawptr %132, %..rawptr* %133
	%134 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 1
	store %..typeid 216172782113783891, %..typeid* %134
	%135 = load %..any, %..any* %18, align 8
	; variadic call argument generation
	%136 = bitcast {%..any*, i64}* %19 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %19
	%138 = bitcast [1 x %..any]* %20 to %..rawptr
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %20
	%140 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	store %..any %135, %..any* %140
	%141 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	%142 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 0
	store %..any* %141, %..any** %142
	%143 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 1
	store i64 1, i64* %143
	%144 = load {%..any*, i64}, {%..any*, i64}* %19, align 8
	%145 = bitcast {%..any*, i64}* %21 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %21
	store {%..any*, i64} %144, {%..any*, i64}* %21
	%147 = call %..string @fmt.tprint({%..any*, i64}* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %147, %..string* %2
	br label %if.done-11

if.done-11:
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; result
	%148 = load %..string, %..string* %0, align 8
	%149 = load %..string, %..string* %2, align 8
	%150 = bitcast %..any* %23 to %..rawptr
	%151 = call %..rawptr @mem.zero(%..rawptr %150, i64 16) noinline
	store %..any zeroinitializer, %..any* %23
	%152 = bitcast %..string* %0 to %..rawptr
	%153 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 0
	store %..rawptr %152, %..rawptr* %153
	%154 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %154
	%155 = load %..any, %..any* %23, align 8
	%156 = bitcast %..string* %24 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 16) noinline
	store %..string zeroinitializer, %..string* %24
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2be, i64 0, i32 0), i64 3}, %..string* %24
	%158 = load %..string, %..string* %24, align 8
	%159 = bitcast %..any* %25 to %..rawptr
	%160 = call %..rawptr @mem.zero(%..rawptr %159, i64 16) noinline
	store %..any zeroinitializer, %..any* %25
	%161 = bitcast %..string* %24 to %..rawptr
	%162 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 0
	store %..rawptr %161, %..rawptr* %162
	%163 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %163
	%164 = load %..any, %..any* %25, align 8
	%165 = bitcast %..any* %26 to %..rawptr
	%166 = call %..rawptr @mem.zero(%..rawptr %165, i64 16) noinline
	store %..any zeroinitializer, %..any* %26
	%167 = bitcast %..string* %2 to %..rawptr
	%168 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 0
	store %..rawptr %167, %..rawptr* %168
	%169 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %169
	%170 = load %..any, %..any* %26, align 8
	; variadic call argument generation
	%171 = bitcast {%..any*, i64}* %27 to %..rawptr
	%172 = call %..rawptr @mem.zero(%..rawptr %171, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %27
	%173 = bitcast [3 x %..any]* %28 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %28
	%175 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	store %..any %155, %..any* %175
	%176 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 1
	store %..any %164, %..any* %176
	%177 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 2
	store %..any %170, %..any* %177
	%178 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	%179 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 0
	store %..any* %178, %..any** %179
	%180 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 1
	store i64 3, i64* %180
	%181 = load {%..any*, i64}, {%..any*, i64}* %27, align 8
	%182 = bitcast {%..any*, i64}* %29 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %29
	store {%..any*, i64} %181, {%..any*, i64}* %29
	%184 = call %..string @fmt.tprint({%..any*, i64}* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %184, %..string* %22
	; SelectorExpr
	%185 = load %..string, %..string* %22, align 8
	; variadic call argument generation
	%186 = bitcast {%..any*, i64}* %30 to %..rawptr
	%187 = call %..rawptr @mem.zero(%..rawptr %186, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %30
	%188 = load {%..any*, i64}, {%..any*, i64}* %30, align 8
	%189 = bitcast {%..any*, i64}* %31 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %31
	store {%..any*, i64} %188, {%..any*, i64}* %31
	call void @imgui.text(%..string %185, {%..any*, i64}* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @workbench._imgui_struct_internal.simple_field-10(%..string %name, %..rawptr %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca {%runtime.Type_Info_Pointer, i8}, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %..any, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [1 x %..any], align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca %..any, align 16
	%19 = alloca {%..any*, i64}, align 16
	%20 = alloca [1 x %..any], align 16
	%21 = alloca {%..any*, i64}, align 16
	%22 = alloca %..string, align 16
	%23 = alloca %..any, align 16
	%24 = alloca %..string, align 16
	%25 = alloca %..any, align 16
	%26 = alloca %..any, align 16
	%27 = alloca {%..any*, i64}, align 16
	%28 = alloca [3 x %..any], align 16
	%29 = alloca {%..any*, i64}, align 16
	%30 = alloca {%..any*, i64}, align 16
	%31 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..rawptr %data, %..rawptr* %1
	; value
	%32 = bitcast %..string* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	; is_pointer
	; SelectorExpr
	%34 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%35 = bitcast %runtime.Type_Info** %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %4
	store %runtime.Type_Info* %34, %runtime.Type_Info** %4
	%37 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	%38 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %37, i64 0
	%39 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %38, i64 0, i32 3
	%40 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, align 8
	; cast - union_cast
	%41 = bitcast {%runtime.Type_Info_Pointer, i8}* %5 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store {%runtime.Type_Info_Pointer, i8} zeroinitializer, {%runtime.Type_Info_Pointer, i8}* %5
	%43 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, i64 0, i32 2 ; UnionTagPtr
	%44 = load i8, i8* %43, align 1
	%45 = icmp eq i8 %44, 10
	br i1 %45, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%46 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 0
	%47 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 1
	%48 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %39 to %runtime.Type_Info_Pointer*
	%49 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %48, align 8
	store %runtime.Type_Info_Pointer %49, %runtime.Type_Info_Pointer* %46
	store i8 1, i8* %47
	br label %union_cast.end-2

union_cast.end-2:
	%50 = load {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, align 8
	%51 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 0
	%52 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 1
	store i8 %52, i8* %3
	; IfStmt
	br i1 1, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	%53 = load %..rawptr, %..rawptr* %1, align 8
	%54 = bitcast %..rawptr %53 to %..string*
	%55 = getelementptr inbounds %..string, %..string* %54, i64 0
	%56 = load %..string, %..string* %55, align 8
	%57 = bitcast %..string* %6 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2bf, i64 0, i32 0), i64 1}, %..string* %6
	%59 = load %..string, %..string* %6, align 8
	%60 = bitcast %..any* %7 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store %..any zeroinitializer, %..any* %7
	%62 = bitcast %..string* %6 to %..rawptr
	%63 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 0
	store %..rawptr %62, %..rawptr* %63
	%64 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %64
	%65 = load %..any, %..any* %7, align 8
	%66 = bitcast %..any* %8 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 16) noinline
	store %..any zeroinitializer, %..any* %8
	%68 = bitcast %..string* %55 to %..rawptr
	%69 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 0
	store %..rawptr %68, %..rawptr* %69
	%70 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %70
	%71 = load %..any, %..any* %8, align 8
	%72 = bitcast %..string* %9 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2c0, i64 0, i32 0), i64 1}, %..string* %9
	%74 = load %..string, %..string* %9, align 8
	%75 = bitcast %..any* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 16) noinline
	store %..any zeroinitializer, %..any* %10
	%77 = bitcast %..string* %9 to %..rawptr
	%78 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 0
	store %..rawptr %77, %..rawptr* %78
	%79 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %79
	%80 = load %..any, %..any* %10, align 8
	; variadic call argument generation
	%81 = bitcast {%..any*, i64}* %11 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	%83 = bitcast [3 x %..any]* %12 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %12
	%85 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	store %..any %65, %..any* %85
	%86 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 1
	store %..any %71, %..any* %86
	%87 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 2
	store %..any %80, %..any* %87
	%88 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	%89 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 0
	store %..any* %88, %..any** %89
	%90 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 1
	store i64 3, i64* %90
	%91 = load {%..any*, i64}, {%..any*, i64}* %11, align 8
	%92 = bitcast {%..any*, i64}* %13 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	store {%..any*, i64} %91, {%..any*, i64}* %13
	%94 = call %..string @fmt.tprint({%..any*, i64}* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %94, %..string* %2
	br label %if.done-13

if.else-4:
	; IfStmt
	br i1 0, label %if.then-6, label %cmp.or-5

cmp.or-5:
	br i1 0, label %if.then-6, label %if.else-7

if.then-6:
	; AssignStmt
	%95 = load %..rawptr, %..rawptr* %1, align 8
	%96 = bitcast %..rawptr %95 to %..string*
	%97 = getelementptr inbounds %..string, %..string* %96, i64 0
	%98 = load %..string, %..string* %97, align 8
	%99 = bitcast %..any* %14 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 16) noinline
	store %..any zeroinitializer, %..any* %14
	%101 = bitcast %..string* %97 to %..rawptr
	%102 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 0
	store %..rawptr %101, %..rawptr* %102
	%103 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %103
	%104 = load %..any, %..any* %14, align 8
	; variadic call argument generation
	%105 = bitcast {%..any*, i64}* %15 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	%107 = bitcast [1 x %..any]* %16 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %16
	%109 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	store %..any %104, %..any* %109
	%110 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	%111 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 0
	store %..any* %110, %..any** %111
	%112 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 1
	store i64 1, i64* %112
	%113 = load {%..any*, i64}, {%..any*, i64}* %15, align 8
	%114 = bitcast {%..any*, i64}* %17 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	store {%..any*, i64} %113, {%..any*, i64}* %17
	%116 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2c1, i64 0, i32 0), i64 4}, {%..any*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %116, %..string* %2
	br label %if.done-12

if.else-7:
	; IfStmt
	%117 = load i8, i8* %3, align 1
	%118 = trunc i8 %117 to i1
	br i1 %118, label %cmp.and-8, label %if.else-10

cmp.and-8:
	%119 = load %..rawptr, %..rawptr* %1, align 8
	%120 = bitcast %..rawptr %119 to i8**
	%121 = getelementptr inbounds i8*, i8** %120, i64 0
	%122 = load i8*, i8** %121, align 8
	%123 = icmp eq i8* %122, zeroinitializer
	%124 = zext i1 %123 to i8
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-9, label %if.else-10

if.then-9:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2c2, i64 0, i32 0), i64 3}, %..string* %2
	br label %if.done-11

if.else-10:
	; AssignStmt
	%126 = load %..rawptr, %..rawptr* %1, align 8
	%127 = bitcast %..rawptr %126 to %..string*
	%128 = getelementptr inbounds %..string, %..string* %127, i64 0
	%129 = load %..string, %..string* %128, align 8
	%130 = bitcast %..any* %18 to %..rawptr
	%131 = call %..rawptr @mem.zero(%..rawptr %130, i64 16) noinline
	store %..any zeroinitializer, %..any* %18
	%132 = bitcast %..string* %128 to %..rawptr
	%133 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 0
	store %..rawptr %132, %..rawptr* %133
	%134 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %134
	%135 = load %..any, %..any* %18, align 8
	; variadic call argument generation
	%136 = bitcast {%..any*, i64}* %19 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %19
	%138 = bitcast [1 x %..any]* %20 to %..rawptr
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %20
	%140 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	store %..any %135, %..any* %140
	%141 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	%142 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 0
	store %..any* %141, %..any** %142
	%143 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 1
	store i64 1, i64* %143
	%144 = load {%..any*, i64}, {%..any*, i64}* %19, align 8
	%145 = bitcast {%..any*, i64}* %21 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %21
	store {%..any*, i64} %144, {%..any*, i64}* %21
	%147 = call %..string @fmt.tprint({%..any*, i64}* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %147, %..string* %2
	br label %if.done-11

if.done-11:
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; result
	%148 = load %..string, %..string* %0, align 8
	%149 = load %..string, %..string* %2, align 8
	%150 = bitcast %..any* %23 to %..rawptr
	%151 = call %..rawptr @mem.zero(%..rawptr %150, i64 16) noinline
	store %..any zeroinitializer, %..any* %23
	%152 = bitcast %..string* %0 to %..rawptr
	%153 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 0
	store %..rawptr %152, %..rawptr* %153
	%154 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %154
	%155 = load %..any, %..any* %23, align 8
	%156 = bitcast %..string* %24 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 16) noinline
	store %..string zeroinitializer, %..string* %24
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2c3, i64 0, i32 0), i64 3}, %..string* %24
	%158 = load %..string, %..string* %24, align 8
	%159 = bitcast %..any* %25 to %..rawptr
	%160 = call %..rawptr @mem.zero(%..rawptr %159, i64 16) noinline
	store %..any zeroinitializer, %..any* %25
	%161 = bitcast %..string* %24 to %..rawptr
	%162 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 0
	store %..rawptr %161, %..rawptr* %162
	%163 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %163
	%164 = load %..any, %..any* %25, align 8
	%165 = bitcast %..any* %26 to %..rawptr
	%166 = call %..rawptr @mem.zero(%..rawptr %165, i64 16) noinline
	store %..any zeroinitializer, %..any* %26
	%167 = bitcast %..string* %2 to %..rawptr
	%168 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 0
	store %..rawptr %167, %..rawptr* %168
	%169 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %169
	%170 = load %..any, %..any* %26, align 8
	; variadic call argument generation
	%171 = bitcast {%..any*, i64}* %27 to %..rawptr
	%172 = call %..rawptr @mem.zero(%..rawptr %171, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %27
	%173 = bitcast [3 x %..any]* %28 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %28
	%175 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	store %..any %155, %..any* %175
	%176 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 1
	store %..any %164, %..any* %176
	%177 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 2
	store %..any %170, %..any* %177
	%178 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	%179 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 0
	store %..any* %178, %..any** %179
	%180 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 1
	store i64 3, i64* %180
	%181 = load {%..any*, i64}, {%..any*, i64}* %27, align 8
	%182 = bitcast {%..any*, i64}* %29 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %29
	store {%..any*, i64} %181, {%..any*, i64}* %29
	%184 = call %..string @fmt.tprint({%..any*, i64}* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %184, %..string* %22
	; SelectorExpr
	%185 = load %..string, %..string* %22, align 8
	; variadic call argument generation
	%186 = bitcast {%..any*, i64}* %30 to %..rawptr
	%187 = call %..rawptr @mem.zero(%..rawptr %186, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %30
	%188 = load {%..any*, i64}, {%..any*, i64}* %30, align 8
	%189 = bitcast {%..any*, i64}* %31 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %31
	store {%..any*, i64} %188, {%..any*, i64}* %31
	call void @imgui.text(%..string %185, {%..any*, i64}* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @workbench._imgui_struct_internal.simple_field-11(%..string %name, %..rawptr %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca {%runtime.Type_Info_Pointer, i8}, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %..any, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [1 x %..any], align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca %..any, align 16
	%19 = alloca {%..any*, i64}, align 16
	%20 = alloca [1 x %..any], align 16
	%21 = alloca {%..any*, i64}, align 16
	%22 = alloca %..string, align 16
	%23 = alloca %..any, align 16
	%24 = alloca %..string, align 16
	%25 = alloca %..any, align 16
	%26 = alloca %..any, align 16
	%27 = alloca {%..any*, i64}, align 16
	%28 = alloca [3 x %..any], align 16
	%29 = alloca {%..any*, i64}, align 16
	%30 = alloca {%..any*, i64}, align 16
	%31 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..rawptr %data, %..rawptr* %1
	; value
	%32 = bitcast %..string* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	; is_pointer
	; SelectorExpr
	%34 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	%35 = bitcast %runtime.Type_Info** %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %4
	store %runtime.Type_Info* %34, %runtime.Type_Info** %4
	%37 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	%38 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %37, i64 0
	%39 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %38, i64 0, i32 3
	%40 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, align 8
	; cast - union_cast
	%41 = bitcast {%runtime.Type_Info_Pointer, i8}* %5 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store {%runtime.Type_Info_Pointer, i8} zeroinitializer, {%runtime.Type_Info_Pointer, i8}* %5
	%43 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, i64 0, i32 2 ; UnionTagPtr
	%44 = load i8, i8* %43, align 1
	%45 = icmp eq i8 %44, 10
	br i1 %45, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%46 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 0
	%47 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 1
	%48 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %39 to %runtime.Type_Info_Pointer*
	%49 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %48, align 8
	store %runtime.Type_Info_Pointer %49, %runtime.Type_Info_Pointer* %46
	store i8 1, i8* %47
	br label %union_cast.end-2

union_cast.end-2:
	%50 = load {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, align 8
	%51 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 0
	%52 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 1
	store i8 %52, i8* %3
	; IfStmt
	br i1 0, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	%53 = load %..rawptr, %..rawptr* %1, align 8
	%54 = bitcast %..rawptr %53 to i8*
	%55 = getelementptr inbounds i8, i8* %54, i64 0
	%56 = load i8, i8* %55, align 1
	%57 = bitcast %..string* %6 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2c4, i64 0, i32 0), i64 1}, %..string* %6
	%59 = load %..string, %..string* %6, align 8
	%60 = bitcast %..any* %7 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store %..any zeroinitializer, %..any* %7
	%62 = bitcast %..string* %6 to %..rawptr
	%63 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 0
	store %..rawptr %62, %..rawptr* %63
	%64 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %64
	%65 = load %..any, %..any* %7, align 8
	%66 = bitcast %..any* %8 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 16) noinline
	store %..any zeroinitializer, %..any* %8
	%68 = bitcast i8* %55 to %..rawptr
	%69 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 0
	store %..rawptr %68, %..rawptr* %69
	%70 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 1
	store %..typeid 432345564227567636, %..typeid* %70
	%71 = load %..any, %..any* %8, align 8
	%72 = bitcast %..string* %9 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2c5, i64 0, i32 0), i64 1}, %..string* %9
	%74 = load %..string, %..string* %9, align 8
	%75 = bitcast %..any* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 16) noinline
	store %..any zeroinitializer, %..any* %10
	%77 = bitcast %..string* %9 to %..rawptr
	%78 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 0
	store %..rawptr %77, %..rawptr* %78
	%79 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %79
	%80 = load %..any, %..any* %10, align 8
	; variadic call argument generation
	%81 = bitcast {%..any*, i64}* %11 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	%83 = bitcast [3 x %..any]* %12 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %12
	%85 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	store %..any %65, %..any* %85
	%86 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 1
	store %..any %71, %..any* %86
	%87 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 2
	store %..any %80, %..any* %87
	%88 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	%89 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 0
	store %..any* %88, %..any** %89
	%90 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 1
	store i64 3, i64* %90
	%91 = load {%..any*, i64}, {%..any*, i64}* %11, align 8
	%92 = bitcast {%..any*, i64}* %13 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	store {%..any*, i64} %91, {%..any*, i64}* %13
	%94 = call %..string @fmt.tprint({%..any*, i64}* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %94, %..string* %2
	br label %if.done-13

if.else-4:
	; IfStmt
	br i1 0, label %if.then-6, label %cmp.or-5

cmp.or-5:
	br i1 0, label %if.then-6, label %if.else-7

if.then-6:
	; AssignStmt
	%95 = load %..rawptr, %..rawptr* %1, align 8
	%96 = bitcast %..rawptr %95 to i8*
	%97 = getelementptr inbounds i8, i8* %96, i64 0
	%98 = load i8, i8* %97, align 1
	%99 = bitcast %..any* %14 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 16) noinline
	store %..any zeroinitializer, %..any* %14
	%101 = bitcast i8* %97 to %..rawptr
	%102 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 0
	store %..rawptr %101, %..rawptr* %102
	%103 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 1
	store %..typeid 432345564227567636, %..typeid* %103
	%104 = load %..any, %..any* %14, align 8
	; variadic call argument generation
	%105 = bitcast {%..any*, i64}* %15 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	%107 = bitcast [1 x %..any]* %16 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %16
	%109 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	store %..any %104, %..any* %109
	%110 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	%111 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 0
	store %..any* %110, %..any** %111
	%112 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 1
	store i64 1, i64* %112
	%113 = load {%..any*, i64}, {%..any*, i64}* %15, align 8
	%114 = bitcast {%..any*, i64}* %17 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	store {%..any*, i64} %113, {%..any*, i64}* %17
	%116 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2c6, i64 0, i32 0), i64 4}, {%..any*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %116, %..string* %2
	br label %if.done-12

if.else-7:
	; IfStmt
	%117 = load i8, i8* %3, align 1
	%118 = trunc i8 %117 to i1
	br i1 %118, label %cmp.and-8, label %if.else-10

cmp.and-8:
	%119 = load %..rawptr, %..rawptr* %1, align 8
	%120 = bitcast %..rawptr %119 to i8**
	%121 = getelementptr inbounds i8*, i8** %120, i64 0
	%122 = load i8*, i8** %121, align 8
	%123 = icmp eq i8* %122, zeroinitializer
	%124 = zext i1 %123 to i8
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-9, label %if.else-10

if.then-9:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2c7, i64 0, i32 0), i64 3}, %..string* %2
	br label %if.done-11

if.else-10:
	; AssignStmt
	%126 = load %..rawptr, %..rawptr* %1, align 8
	%127 = bitcast %..rawptr %126 to i8*
	%128 = getelementptr inbounds i8, i8* %127, i64 0
	%129 = load i8, i8* %128, align 1
	%130 = bitcast %..any* %18 to %..rawptr
	%131 = call %..rawptr @mem.zero(%..rawptr %130, i64 16) noinline
	store %..any zeroinitializer, %..any* %18
	%132 = bitcast i8* %128 to %..rawptr
	%133 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 0
	store %..rawptr %132, %..rawptr* %133
	%134 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 1
	store %..typeid 432345564227567636, %..typeid* %134
	%135 = load %..any, %..any* %18, align 8
	; variadic call argument generation
	%136 = bitcast {%..any*, i64}* %19 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %19
	%138 = bitcast [1 x %..any]* %20 to %..rawptr
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %20
	%140 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	store %..any %135, %..any* %140
	%141 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	%142 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 0
	store %..any* %141, %..any** %142
	%143 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 1
	store i64 1, i64* %143
	%144 = load {%..any*, i64}, {%..any*, i64}* %19, align 8
	%145 = bitcast {%..any*, i64}* %21 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %21
	store {%..any*, i64} %144, {%..any*, i64}* %21
	%147 = call %..string @fmt.tprint({%..any*, i64}* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %147, %..string* %2
	br label %if.done-11

if.done-11:
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; result
	%148 = load %..string, %..string* %0, align 8
	%149 = load %..string, %..string* %2, align 8
	%150 = bitcast %..any* %23 to %..rawptr
	%151 = call %..rawptr @mem.zero(%..rawptr %150, i64 16) noinline
	store %..any zeroinitializer, %..any* %23
	%152 = bitcast %..string* %0 to %..rawptr
	%153 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 0
	store %..rawptr %152, %..rawptr* %153
	%154 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %154
	%155 = load %..any, %..any* %23, align 8
	%156 = bitcast %..string* %24 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 16) noinline
	store %..string zeroinitializer, %..string* %24
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2c8, i64 0, i32 0), i64 3}, %..string* %24
	%158 = load %..string, %..string* %24, align 8
	%159 = bitcast %..any* %25 to %..rawptr
	%160 = call %..rawptr @mem.zero(%..rawptr %159, i64 16) noinline
	store %..any zeroinitializer, %..any* %25
	%161 = bitcast %..string* %24 to %..rawptr
	%162 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 0
	store %..rawptr %161, %..rawptr* %162
	%163 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %163
	%164 = load %..any, %..any* %25, align 8
	%165 = bitcast %..any* %26 to %..rawptr
	%166 = call %..rawptr @mem.zero(%..rawptr %165, i64 16) noinline
	store %..any zeroinitializer, %..any* %26
	%167 = bitcast %..string* %2 to %..rawptr
	%168 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 0
	store %..rawptr %167, %..rawptr* %168
	%169 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %169
	%170 = load %..any, %..any* %26, align 8
	; variadic call argument generation
	%171 = bitcast {%..any*, i64}* %27 to %..rawptr
	%172 = call %..rawptr @mem.zero(%..rawptr %171, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %27
	%173 = bitcast [3 x %..any]* %28 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %28
	%175 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	store %..any %155, %..any* %175
	%176 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 1
	store %..any %164, %..any* %176
	%177 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 2
	store %..any %170, %..any* %177
	%178 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	%179 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 0
	store %..any* %178, %..any** %179
	%180 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 1
	store i64 3, i64* %180
	%181 = load {%..any*, i64}, {%..any*, i64}* %27, align 8
	%182 = bitcast {%..any*, i64}* %29 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %29
	store {%..any*, i64} %181, {%..any*, i64}* %29
	%184 = call %..string @fmt.tprint({%..any*, i64}* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %184, %..string* %22
	; SelectorExpr
	%185 = load %..string, %..string* %22, align 8
	; variadic call argument generation
	%186 = bitcast {%..any*, i64}* %30 to %..rawptr
	%187 = call %..rawptr @mem.zero(%..rawptr %186, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %30
	%188 = load {%..any*, i64}, {%..any*, i64}* %30, align 8
	%189 = bitcast {%..any*, i64}* %31 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %31
	store {%..any*, i64} %188, {%..any*, i64}* %31
	call void @imgui.text(%..string %185, {%..any*, i64}* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @workbench._imgui_struct_internal.simple_field-12(%..string %name, %..rawptr %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca {%runtime.Type_Info_Pointer, i8}, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %..any, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [1 x %..any], align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca %..any, align 16
	%19 = alloca {%..any*, i64}, align 16
	%20 = alloca [1 x %..any], align 16
	%21 = alloca {%..any*, i64}, align 16
	%22 = alloca %..string, align 16
	%23 = alloca %..any, align 16
	%24 = alloca %..string, align 16
	%25 = alloca %..any, align 16
	%26 = alloca %..any, align 16
	%27 = alloca {%..any*, i64}, align 16
	%28 = alloca [3 x %..any], align 16
	%29 = alloca {%..any*, i64}, align 16
	%30 = alloca {%..any*, i64}, align 16
	%31 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..rawptr %data, %..rawptr* %1
	; value
	%32 = bitcast %..string* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	; is_pointer
	; SelectorExpr
	%34 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 5
	%35 = bitcast %runtime.Type_Info** %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %4
	store %runtime.Type_Info* %34, %runtime.Type_Info** %4
	%37 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	%38 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %37, i64 0
	%39 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %38, i64 0, i32 3
	%40 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, align 8
	; cast - union_cast
	%41 = bitcast {%runtime.Type_Info_Pointer, i8}* %5 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store {%runtime.Type_Info_Pointer, i8} zeroinitializer, {%runtime.Type_Info_Pointer, i8}* %5
	%43 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %39, i64 0, i32 2 ; UnionTagPtr
	%44 = load i8, i8* %43, align 1
	%45 = icmp eq i8 %44, 10
	br i1 %45, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%46 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 0
	%47 = getelementptr inbounds {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, i64 0, i32 1
	%48 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %39 to %runtime.Type_Info_Pointer*
	%49 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %48, align 8
	store %runtime.Type_Info_Pointer %49, %runtime.Type_Info_Pointer* %46
	store i8 1, i8* %47
	br label %union_cast.end-2

union_cast.end-2:
	%50 = load {%runtime.Type_Info_Pointer, i8}, {%runtime.Type_Info_Pointer, i8}* %5, align 8
	%51 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 0
	%52 = extractvalue {%runtime.Type_Info_Pointer, i8} %50, 1
	store i8 %52, i8* %3
	; IfStmt
	br i1 0, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	%53 = load %..rawptr, %..rawptr* %1, align 8
	%54 = bitcast %..rawptr %53 to i8**
	%55 = getelementptr inbounds i8*, i8** %54, i64 0
	%56 = load i8*, i8** %55, align 8
	%57 = bitcast %..string* %6 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2c9, i64 0, i32 0), i64 1}, %..string* %6
	%59 = load %..string, %..string* %6, align 8
	%60 = bitcast %..any* %7 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store %..any zeroinitializer, %..any* %7
	%62 = bitcast %..string* %6 to %..rawptr
	%63 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 0
	store %..rawptr %62, %..rawptr* %63
	%64 = getelementptr inbounds %..any, %..any* %7, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %64
	%65 = load %..any, %..any* %7, align 8
	%66 = bitcast %..any* %8 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 16) noinline
	store %..any zeroinitializer, %..any* %8
	%68 = bitcast i8** %55 to %..rawptr
	%69 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 0
	store %..rawptr %68, %..rawptr* %69
	%70 = getelementptr inbounds %..any, %..any* %8, i64 0, i32 1
	store %..typeid 648518346341351429, %..typeid* %70
	%71 = load %..any, %..any* %8, align 8
	%72 = bitcast %..string* %9 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2ca, i64 0, i32 0), i64 1}, %..string* %9
	%74 = load %..string, %..string* %9, align 8
	%75 = bitcast %..any* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 16) noinline
	store %..any zeroinitializer, %..any* %10
	%77 = bitcast %..string* %9 to %..rawptr
	%78 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 0
	store %..rawptr %77, %..rawptr* %78
	%79 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %79
	%80 = load %..any, %..any* %10, align 8
	; variadic call argument generation
	%81 = bitcast {%..any*, i64}* %11 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %11
	%83 = bitcast [3 x %..any]* %12 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %12
	%85 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	store %..any %65, %..any* %85
	%86 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 1
	store %..any %71, %..any* %86
	%87 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 2
	store %..any %80, %..any* %87
	%88 = getelementptr inbounds [3 x %..any], [3 x %..any]* %12, i64 0, i32 0
	%89 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 0
	store %..any* %88, %..any** %89
	%90 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %11, i64 0, i32 1
	store i64 3, i64* %90
	%91 = load {%..any*, i64}, {%..any*, i64}* %11, align 8
	%92 = bitcast {%..any*, i64}* %13 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	store {%..any*, i64} %91, {%..any*, i64}* %13
	%94 = call %..string @fmt.tprint({%..any*, i64}* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %94, %..string* %2
	br label %if.done-13

if.else-4:
	; IfStmt
	br i1 0, label %if.then-6, label %cmp.or-5

cmp.or-5:
	br i1 0, label %if.then-6, label %if.else-7

if.then-6:
	; AssignStmt
	%95 = load %..rawptr, %..rawptr* %1, align 8
	%96 = bitcast %..rawptr %95 to i8**
	%97 = getelementptr inbounds i8*, i8** %96, i64 0
	%98 = load i8*, i8** %97, align 8
	%99 = bitcast %..any* %14 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 16) noinline
	store %..any zeroinitializer, %..any* %14
	%101 = bitcast i8** %97 to %..rawptr
	%102 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 0
	store %..rawptr %101, %..rawptr* %102
	%103 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 1
	store %..typeid 648518346341351429, %..typeid* %103
	%104 = load %..any, %..any* %14, align 8
	; variadic call argument generation
	%105 = bitcast {%..any*, i64}* %15 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	%107 = bitcast [1 x %..any]* %16 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %16
	%109 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	store %..any %104, %..any* %109
	%110 = getelementptr inbounds [1 x %..any], [1 x %..any]* %16, i64 0, i32 0
	%111 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 0
	store %..any* %110, %..any** %111
	%112 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 1
	store i64 1, i64* %112
	%113 = load {%..any*, i64}, {%..any*, i64}* %15, align 8
	%114 = bitcast {%..any*, i64}* %17 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	store {%..any*, i64} %113, {%..any*, i64}* %17
	%116 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2cb, i64 0, i32 0), i64 4}, {%..any*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %116, %..string* %2
	br label %if.done-12

if.else-7:
	; IfStmt
	%117 = load i8, i8* %3, align 1
	%118 = trunc i8 %117 to i1
	br i1 %118, label %cmp.and-8, label %if.else-10

cmp.and-8:
	%119 = load %..rawptr, %..rawptr* %1, align 8
	%120 = bitcast %..rawptr %119 to i8**
	%121 = getelementptr inbounds i8*, i8** %120, i64 0
	%122 = load i8*, i8** %121, align 8
	%123 = icmp eq i8* %122, zeroinitializer
	%124 = zext i1 %123 to i8
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-9, label %if.else-10

if.then-9:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2cc, i64 0, i32 0), i64 3}, %..string* %2
	br label %if.done-11

if.else-10:
	; AssignStmt
	%126 = load %..rawptr, %..rawptr* %1, align 8
	%127 = bitcast %..rawptr %126 to i8**
	%128 = getelementptr inbounds i8*, i8** %127, i64 0
	%129 = load i8*, i8** %128, align 8
	%130 = bitcast %..any* %18 to %..rawptr
	%131 = call %..rawptr @mem.zero(%..rawptr %130, i64 16) noinline
	store %..any zeroinitializer, %..any* %18
	%132 = bitcast i8** %128 to %..rawptr
	%133 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 0
	store %..rawptr %132, %..rawptr* %133
	%134 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 1
	store %..typeid 648518346341351429, %..typeid* %134
	%135 = load %..any, %..any* %18, align 8
	; variadic call argument generation
	%136 = bitcast {%..any*, i64}* %19 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %19
	%138 = bitcast [1 x %..any]* %20 to %..rawptr
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %20
	%140 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	store %..any %135, %..any* %140
	%141 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	%142 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 0
	store %..any* %141, %..any** %142
	%143 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 1
	store i64 1, i64* %143
	%144 = load {%..any*, i64}, {%..any*, i64}* %19, align 8
	%145 = bitcast {%..any*, i64}* %21 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %21
	store {%..any*, i64} %144, {%..any*, i64}* %21
	%147 = call %..string @fmt.tprint({%..any*, i64}* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %147, %..string* %2
	br label %if.done-11

if.done-11:
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; result
	%148 = load %..string, %..string* %0, align 8
	%149 = load %..string, %..string* %2, align 8
	%150 = bitcast %..any* %23 to %..rawptr
	%151 = call %..rawptr @mem.zero(%..rawptr %150, i64 16) noinline
	store %..any zeroinitializer, %..any* %23
	%152 = bitcast %..string* %0 to %..rawptr
	%153 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 0
	store %..rawptr %152, %..rawptr* %153
	%154 = getelementptr inbounds %..any, %..any* %23, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %154
	%155 = load %..any, %..any* %23, align 8
	%156 = bitcast %..string* %24 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 16) noinline
	store %..string zeroinitializer, %..string* %24
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2cd, i64 0, i32 0), i64 3}, %..string* %24
	%158 = load %..string, %..string* %24, align 8
	%159 = bitcast %..any* %25 to %..rawptr
	%160 = call %..rawptr @mem.zero(%..rawptr %159, i64 16) noinline
	store %..any zeroinitializer, %..any* %25
	%161 = bitcast %..string* %24 to %..rawptr
	%162 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 0
	store %..rawptr %161, %..rawptr* %162
	%163 = getelementptr inbounds %..any, %..any* %25, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %163
	%164 = load %..any, %..any* %25, align 8
	%165 = bitcast %..any* %26 to %..rawptr
	%166 = call %..rawptr @mem.zero(%..rawptr %165, i64 16) noinline
	store %..any zeroinitializer, %..any* %26
	%167 = bitcast %..string* %2 to %..rawptr
	%168 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 0
	store %..rawptr %167, %..rawptr* %168
	%169 = getelementptr inbounds %..any, %..any* %26, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %169
	%170 = load %..any, %..any* %26, align 8
	; variadic call argument generation
	%171 = bitcast {%..any*, i64}* %27 to %..rawptr
	%172 = call %..rawptr @mem.zero(%..rawptr %171, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %27
	%173 = bitcast [3 x %..any]* %28 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %28
	%175 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	store %..any %155, %..any* %175
	%176 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 1
	store %..any %164, %..any* %176
	%177 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 2
	store %..any %170, %..any* %177
	%178 = getelementptr inbounds [3 x %..any], [3 x %..any]* %28, i64 0, i32 0
	%179 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 0
	store %..any* %178, %..any** %179
	%180 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %27, i64 0, i32 1
	store i64 3, i64* %180
	%181 = load {%..any*, i64}, {%..any*, i64}* %27, align 8
	%182 = bitcast {%..any*, i64}* %29 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %29
	store {%..any*, i64} %181, {%..any*, i64}* %29
	%184 = call %..string @fmt.tprint({%..any*, i64}* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %184, %..string* %22
	; SelectorExpr
	%185 = load %..string, %..string* %22, align 8
	; variadic call argument generation
	%186 = bitcast {%..any*, i64}* %30 to %..rawptr
	%187 = call %..rawptr @mem.zero(%..rawptr %186, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %30
	%188 = load {%..any*, i64}, {%..any*, i64}* %30, align 8
	%189 = bitcast {%..any*, i64}* %31 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %31
	store {%..any*, i64} %188, {%..any*, i64}* %31
	call void @imgui.text(%..string %185, {%..any*, i64}* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @workbench._update_ui(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %workbench.IMGUI_Rect*, align 16
	%3 = alloca %"workbench.Rect-1229.Rect\28f32\29", align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca [2 x float], align 16
	; AssignStmt
	store i64 -1, i64* @workbench.previously_hot
	; IfStmt
	%7 = call i8 @workbench.get_mouse_up(i32 0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%8 = trunc i8 %7 to i1
	br i1 %8, label %if.then-1, label %if.done-4

if.then-1:
	; IfStmt
	%9 = load i64, i64* @workbench.hot, align 8
	%10 = icmp ne i64 %9, -1
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-2, label %if.done-3

if.then-2:
	; AssignStmt
	%13 = load i64, i64* @workbench.hot, align 8
	store i64 %13, i64* @workbench.previously_hot
	; AssignStmt
	store i64 -1, i64* @workbench.hot
	br label %if.done-3

if.done-3:
	br label %if.done-4

if.done-4:
	; AssignStmt
	store i64 -1, i64* @workbench.previously_warm
	; old_warm
	%14 = load i64, i64* @workbench.warm, align 8
	store i64 %14, i64* %0
	; AssignStmt
	store i64 -1, i64* @workbench.warm
	; i
	%15 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.all_imgui_rects, align 8
	%16 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %15, 1
	%17 = sub i64 %16, 1
	store i64 %17, i64* %1
	; ForStmt
	br label %for.loop-5

for.loop-5:
	%18 = load i64, i64* %1, align 8
	%19 = icmp sge i64 %18, 0
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %for.body-6, label %for.done-17

for.body-6:
	; DeferStmt
	; rect
	; IndexExpr
	%22 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.all_imgui_rects, align 8
	%23 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %22, 0
	%24 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %22, 1
	%25 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2ce, i64 0, i32 0), i64 60}, i64 59, i64 28, i64 %25, i64 %24)
	%26 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %23, i64 %25
	store %workbench.IMGUI_Rect* %26, %workbench.IMGUI_Rect** %2
	; IfStmt
	; SelectorExpr
	%27 = load %workbench.IMGUI_Rect*, %workbench.IMGUI_Rect** %2, align 8
	%28 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %27, i64 0
	%29 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %28, i64 0, i32 1
	%30 = load i64, i64* %29, align 8
	%31 = call i8 @workbench._update_ui.can_be_hot_or_warm-1(i64 %30, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%32 = trunc i8 %31 to i1
	br i1 %32, label %if.then-7, label %if.done-16

if.then-7:
	; IfStmt
	%33 = load i64, i64* @workbench.warm, align 8
	%34 = icmp eq i64 %33, -1
	%35 = zext i1 %34 to i8
	%36 = trunc i8 %35 to i1
	br i1 %36, label %if.then-8, label %if.done-11

if.then-8:
	; IfStmt
	; SelectorExpr
	%37 = load %workbench.IMGUI_Rect*, %workbench.IMGUI_Rect** %2, align 8
	%38 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %37, i64 0
	%39 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %38, i64 0, i32 4
	%40 = load %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %39, align 4
	%41 = bitcast %"workbench.Rect-1229.Rect\28f32\29"* %3 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store %"workbench.Rect-1229.Rect\28f32\29" zeroinitializer, %"workbench.Rect-1229.Rect\28f32\29"* %3
	store %"workbench.Rect-1229.Rect\28f32\29" %40, %"workbench.Rect-1229.Rect\28f32\29"* %3
	%43 = call i8 @workbench._update_ui.mouse_in_rect-0(%"workbench.Rect-1229.Rect\28f32\29"* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%44 = trunc i8 %43 to i1
	br i1 %44, label %if.then-9, label %if.done-10

if.then-9:
	; AssignStmt
	; SelectorExpr
	%45 = load %workbench.IMGUI_Rect*, %workbench.IMGUI_Rect** %2, align 8
	%46 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %45, i64 0
	%47 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %46, i64 0, i32 0
	%48 = load i64, i64* %47, align 8
	store i64 %48, i64* @workbench.warm
	br label %if.done-10

if.done-10:
	br label %if.done-11

if.done-11:
	; IfStmt
	%49 = load i64, i64* @workbench.warm, align 8
	; SelectorExpr
	%50 = load %workbench.IMGUI_Rect*, %workbench.IMGUI_Rect** %2, align 8
	%51 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %50, i64 0
	%52 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %51, i64 0, i32 0
	%53 = load i64, i64* %52, align 8
	%54 = icmp eq i64 %49, %53
	%55 = zext i1 %54 to i8
	%56 = trunc i8 %55 to i1
	br i1 %56, label %if.then-12, label %if.done-15

if.then-12:
	; IfStmt
	%57 = call i8 @workbench.get_mouse_down(i32 0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%58 = trunc i8 %57 to i1
	br i1 %58, label %if.then-13, label %if.done-14

if.then-13:
	; AssignStmt
	; SelectorExpr
	%59 = load %workbench.IMGUI_Rect*, %workbench.IMGUI_Rect** %2, align 8
	%60 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %59, i64 0
	%61 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %60, i64 0, i32 0
	%62 = load i64, i64* %61, align 8
	store i64 %62, i64* @workbench.hot
	; AssignStmt
	%63 = load [2 x float], [2 x float]* @workbench.cursor_screen_position, align 4
	store [2 x float] %63, [2 x float]* @workbench.cursor_pixel_position_on_clicked
	br label %if.done-14

if.done-14:
	br label %if.done-15

if.done-15:
	br label %if.done-16

if.done-16:
	; defer
	; AssignStmt
	%64 = load i64, i64* %1, align 8
	%65 = sub i64 %64, 1
	store i64 %65, i64* %1
	br label %for.loop-5

for.done-17:
	; IfStmt
	%66 = load i64, i64* @workbench.warm, align 8
	%67 = load i64, i64* %0, align 8
	%68 = icmp ne i64 %66, %67
	%69 = zext i1 %68 to i8
	%70 = trunc i8 %69 to i1
	br i1 %70, label %if.then-18, label %if.done-19

if.then-18:
	; AssignStmt
	%71 = load i64, i64* %0, align 8
	store i64 %71, i64* @workbench.previously_warm
	br label %if.done-19

if.done-19:
	call void @runtime.clear_map-18409({{i64*, i64}, {{%runtime.Map_Key, i64, i64}*, i64, i64, %mem.Allocator}}* @workbench.id_counts)
	%72 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.ui_rect_stack, align 8
	%73 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %72, 1
	%74 = icmp eq i64 %73, 0
	%75 = zext i1 %74 to i8
	%76 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.ui_rect_stack, align 8
	%77 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %logical.cmp.done-21, label %logical.cmp.rhs-20

logical.cmp.rhs-20:
	%81 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.ui_rect_stack, align 8
	%82 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %81, 1
	%83 = icmp eq i64 %82, 1
	%84 = zext i1 %83 to i8
	br label %logical.cmp.done-21

logical.cmp.done-21:
	%85 = phi i8 [ 1, %if.done-19 ], [ %84, %logical.cmp.rhs-20 ]
	%86 = trunc i8 %85 to i1
	%87 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	%88 = call %..rawptr @mem.zero(%..rawptr %87, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2cf, i64 0, i32 0), i64 60}, i64 85, i64 2, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$2d0, i64 0, i32 0), i64 10}}, %runtime.Source_Code_Location* %4
	%89 = call i8 @runtime.assert(i1 %86, %..string zeroinitializer, %runtime.Source_Code_Location* %4)
	call void @runtime.clear_dynamic_array-18427({%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.ui_rect_stack)
	call void @runtime.clear_dynamic_array-18427({%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.new_imgui_rects)
	; AssignStmt
	store %"workbench.Rect-1229.Rect\28int\29" zeroinitializer, %"workbench.Rect-1229.Rect\28int\29"* @workbench.ui_current_rect_pixels
	; AssignStmt
	store %"workbench.Rect-1229.Rect\28f32\29" zeroinitializer, %"workbench.Rect-1229.Rect\28f32\29"* @workbench.ui_current_rect_unit
	%90 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	%91 = call %..rawptr @mem.zero(%..rawptr %90, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2d1, i64 0, i32 0), i64 60}, i64 91, i64 2, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$2d2, i64 0, i32 0), i64 10}}, %runtime.Source_Code_Location* %5
	%92 = bitcast [2 x float]* %6 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %6
	store [2 x float] [float 0x3fe0000000000000, float 0x3fe0000000000000], [2 x float]* %6
	%94 = call %workbench.IMGUI_Rect @workbench.ui_push_rect(float 0x0000000000000000, float 0x0000000000000000, float 0x3ff0000000000000, float 0x3ff0000000000000, i64 0, i64 0, i64 0, i64 0, i64 0, %runtime.Source_Code_Location* %5, [2 x float]* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define i8 @workbench._update_ui.mouse_in_rect-0(%"workbench.Rect-1229.Rect\28f32\29"* %unit_rect, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i8, align 16
	%1 = load %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %unit_rect, align 4
	; cursor_in_rect
	; SelectorExpr
	%2 = getelementptr inbounds [2 x float], [2 x float]* @workbench.cursor_unit_position, i64 0, i32 1
	%3 = load float, float* %2, align 4
	; SelectorExpr
	%4 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %unit_rect, i64 0, i32 3
	%5 = load float, float* %4, align 4
	%6 = fcmp olt float %3, %5
	%7 = zext i1 %6 to i8
	; SelectorExpr
	%8 = getelementptr inbounds [2 x float], [2 x float]* @workbench.cursor_unit_position, i64 0, i32 1
	%9 = load float, float* %8, align 4
	; SelectorExpr
	%10 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %unit_rect, i64 0, i32 3
	%11 = load float, float* %10, align 4
	%12 = fcmp olt float %9, %11
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %logical.cmp.rhs-1, label %logical.cmp.done-2

logical.cmp.rhs-1:
	; SelectorExpr
	%15 = getelementptr inbounds [2 x float], [2 x float]* @workbench.cursor_unit_position, i64 0, i32 1
	%16 = load float, float* %15, align 4
	; SelectorExpr
	%17 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %unit_rect, i64 0, i32 1
	%18 = load float, float* %17, align 4
	%19 = fcmp ogt float %16, %18
	%20 = zext i1 %19 to i8
	br label %logical.cmp.done-2

logical.cmp.done-2:
	%21 = phi i8 [ 0, %decls-0 ], [ %20, %logical.cmp.rhs-1 ]
	; SelectorExpr
	%22 = getelementptr inbounds [2 x float], [2 x float]* @workbench.cursor_unit_position, i64 0, i32 1
	%23 = load float, float* %22, align 4
	; SelectorExpr
	%24 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %unit_rect, i64 0, i32 3
	%25 = load float, float* %24, align 4
	%26 = fcmp olt float %23, %25
	%27 = zext i1 %26 to i8
	%28 = trunc i8 %27 to i1
	br i1 %28, label %cmp.and-3, label %logical.cmp.done-5

cmp.and-3:
	; SelectorExpr
	%29 = getelementptr inbounds [2 x float], [2 x float]* @workbench.cursor_unit_position, i64 0, i32 1
	%30 = load float, float* %29, align 4
	; SelectorExpr
	%31 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %unit_rect, i64 0, i32 1
	%32 = load float, float* %31, align 4
	%33 = fcmp ogt float %30, %32
	%34 = zext i1 %33 to i8
	%35 = trunc i8 %34 to i1
	br i1 %35, label %logical.cmp.rhs-4, label %logical.cmp.done-5

logical.cmp.rhs-4:
	; SelectorExpr
	%36 = getelementptr inbounds [2 x float], [2 x float]* @workbench.cursor_unit_position, i64 0, i32 0
	%37 = load float, float* %36, align 4
	; SelectorExpr
	%38 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %unit_rect, i64 0, i32 2
	%39 = load float, float* %38, align 4
	%40 = fcmp olt float %37, %39
	%41 = zext i1 %40 to i8
	br label %logical.cmp.done-5

logical.cmp.done-5:
	%42 = phi i8 [ 0, %logical.cmp.done-2 ], [ 0, %cmp.and-3 ], [ %41, %logical.cmp.rhs-4 ]
	; SelectorExpr
	%43 = getelementptr inbounds [2 x float], [2 x float]* @workbench.cursor_unit_position, i64 0, i32 1
	%44 = load float, float* %43, align 4
	; SelectorExpr
	%45 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %unit_rect, i64 0, i32 3
	%46 = load float, float* %45, align 4
	%47 = fcmp olt float %44, %46
	%48 = zext i1 %47 to i8
	%49 = trunc i8 %48 to i1
	br i1 %49, label %cmp.and-6, label %logical.cmp.done-9

cmp.and-6:
	; SelectorExpr
	%50 = getelementptr inbounds [2 x float], [2 x float]* @workbench.cursor_unit_position, i64 0, i32 1
	%51 = load float, float* %50, align 4
	; SelectorExpr
	%52 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %unit_rect, i64 0, i32 1
	%53 = load float, float* %52, align 4
	%54 = fcmp ogt float %51, %53
	%55 = zext i1 %54 to i8
	%56 = trunc i8 %55 to i1
	br i1 %56, label %cmp.and-7, label %logical.cmp.done-9

cmp.and-7:
	; SelectorExpr
	%57 = getelementptr inbounds [2 x float], [2 x float]* @workbench.cursor_unit_position, i64 0, i32 0
	%58 = load float, float* %57, align 4
	; SelectorExpr
	%59 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %unit_rect, i64 0, i32 2
	%60 = load float, float* %59, align 4
	%61 = fcmp olt float %58, %60
	%62 = zext i1 %61 to i8
	%63 = trunc i8 %62 to i1
	br i1 %63, label %logical.cmp.rhs-8, label %logical.cmp.done-9

logical.cmp.rhs-8:
	; SelectorExpr
	%64 = getelementptr inbounds [2 x float], [2 x float]* @workbench.cursor_unit_position, i64 0, i32 0
	%65 = load float, float* %64, align 4
	; SelectorExpr
	%66 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %unit_rect, i64 0, i32 0
	%67 = load float, float* %66, align 4
	%68 = fcmp ogt float %65, %67
	%69 = zext i1 %68 to i8
	br label %logical.cmp.done-9

logical.cmp.done-9:
	%70 = phi i8 [ 0, %logical.cmp.done-5 ], [ 0, %cmp.and-6 ], [ 0, %cmp.and-7 ], [ %69, %logical.cmp.rhs-8 ]
	store i8 %70, i8* %0
	; ReturnStmt
	%71 = load i8, i8* %0, align 1
	ret i8 %71
}

define i8 @workbench._update_ui.can_be_hot_or_warm-1(i64 %kind, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %..string, align 16
	%2 = alloca %..any, align 16
	%3 = alloca %..any, align 16
	%4 = alloca {%..any*, i64}, align 16
	%5 = alloca [2 x %..any], align 16
	%6 = alloca {%..any*, i64}, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	store i64 %kind, i64* %0
	; SwitchStmt
	%8 = load i64, i64* %0, align 8
	%9 = icmp eq i64 %8, 3
	br i1 %9, label %switch.case.body-3, label %switch.case.next-1

switch.case.next-1:
	%10 = icmp eq i64 %8, 5
	br i1 %10, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%11 = icmp eq i64 %8, 0
	br i1 %11, label %switch.fall.body-9, label %switch.case.next-4

switch.case.body-3:
	; ReturnStmt
	ret i8 1

switch.case.next-4:
	%12 = icmp eq i64 %8, 6
	br i1 %12, label %switch.fall.body-9, label %switch.case.next-5

switch.case.next-5:
	%13 = icmp eq i64 %8, 1
	br i1 %13, label %switch.fall.body-9, label %switch.case.next-6

switch.case.next-6:
	%14 = icmp eq i64 %8, 2
	br i1 %14, label %switch.fall.body-9, label %switch.case.next-7

switch.case.next-7:
	%15 = icmp eq i64 %8, 4
	br i1 %15, label %switch.fall.body-9, label %switch.case.next-8

switch.case.next-8:
	%16 = load i64, i64* %0, align 8
	%17 = bitcast %..string* %1 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 16) noinline
	store %..string zeroinitializer, %..string* %1
	store %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$2d3, i64 0, i32 0), i64 18}, %..string* %1
	%19 = load %..string, %..string* %1, align 8
	%20 = bitcast %..any* %2 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 16) noinline
	store %..any zeroinitializer, %..any* %2
	%22 = bitcast %..string* %1 to %..rawptr
	%23 = getelementptr inbounds %..any, %..any* %2, i64 0, i32 0
	store %..rawptr %22, %..rawptr* %23
	%24 = getelementptr inbounds %..any, %..any* %2, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %24
	%25 = load %..any, %..any* %2, align 8
	%26 = bitcast %..any* %3 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 16) noinline
	store %..any zeroinitializer, %..any* %3
	%28 = bitcast i64* %0 to %..rawptr
	%29 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	store %..rawptr %28, %..rawptr* %29
	%30 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	store %..typeid 3530822107858468979, %..typeid* %30
	%31 = load %..any, %..any* %3, align 8
	; variadic call argument generation
	%32 = bitcast {%..any*, i64}* %4 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %4
	%34 = bitcast [2 x %..any]* %5 to %..rawptr
	%35 = call %..rawptr @mem.zero(%..rawptr %34, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %5
	%36 = getelementptr inbounds [2 x %..any], [2 x %..any]* %5, i64 0, i32 0
	store %..any %25, %..any* %36
	%37 = getelementptr inbounds [2 x %..any], [2 x %..any]* %5, i64 0, i32 1
	store %..any %31, %..any* %37
	%38 = getelementptr inbounds [2 x %..any], [2 x %..any]* %5, i64 0, i32 0
	%39 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %4, i64 0, i32 0
	store %..any* %38, %..any** %39
	%40 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %4, i64 0, i32 1
	store i64 2, i64* %40
	%41 = load {%..any*, i64}, {%..any*, i64}* %4, align 8
	%42 = bitcast {%..any*, i64}* %6 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %6
	store {%..any*, i64} %41, {%..any*, i64}* %6
	%44 = call %..string @fmt.tprint({%..any*, i64}* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%45 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2d4, i64 0, i32 0), i64 60}, i64 53, i64 11, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$2d5, i64 0, i32 0), i64 18}}, %runtime.Source_Code_Location* %7
	call void @runtime.panic(%..string %44, %runtime.Source_Code_Location* %7) noreturn alwaysinline
	; ReturnStmt
	ret i8 0

switch.fall.body-9:
	; ReturnStmt
	ret i8 0
}

define void @workbench._late_update_ui(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %workbench._late_update_ui.UI_Debug_Info-1465, align 16
	%1 = alloca %workbench._late_update_ui.UI_Debug_Info-1465, align 16
	%2 = alloca %workbench.IMGUI_Rect, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %..string, align 16
	%5 = alloca i8, align 16
	%6 = alloca %workbench.IMGUI_Rect, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca %..any, align 16
	%11 = alloca %..string, align 16
	%12 = alloca %..any, align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca [2 x %..any], align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [2 x float], align 16
	%17 = alloca [2 x float], align 16
	%18 = alloca [2 x float], align 16
	%19 = alloca [2 x float], align 16
	%20 = alloca [2 x float], align 16
	%21 = alloca [2 x float], align 16
	%22 = alloca [3 x float], align 16
	%23 = alloca [3 x float], align 16
	%24 = alloca %workbench.Colorf, align 16
	%25 = alloca %runtime.Source_Code_Location, align 16
	%26 = alloca [2 x float], align 16
	%27 = alloca %runtime.Source_Code_Location, align 16
	; AssignStmt
	%28 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.new_imgui_rects, align 8
	%29 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.all_imgui_rects, align 8
	store {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %28, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.all_imgui_rects
	store {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %29, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.new_imgui_rects
	call void @runtime.clear_dynamic_array-18427({%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.new_imgui_rects)
	; IfStmt
	%30 = load i8, i8* @workbench.debugging_ui, align 1
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-1, label %if.done-15

if.then-1:
	; IfStmt
	; SelectorExpr
	%32 = call i8 @imgui.begin(%..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$2d6, i64 0, i32 0), i64 9}, i8* zeroinitializer, i32 0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%33 = trunc i8 %32 to i1
	br i1 %33, label %if.then-2, label %if.done-14

if.then-2:
	; DeferStmt
	; IfStmt
	%34 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.all_imgui_rects, align 8
	%35 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %34, 1
	%36 = icmp sgt i64 %35, 0
	%37 = zext i1 %36 to i8
	%38 = trunc i8 %37 to i1
	br i1 %38, label %if.then-3, label %if.done-13

if.then-3:
	; debug
	; CompoundLit
	%39 = bitcast %workbench._late_update_ui.UI_Debug_Info-1465* %1 to %..rawptr
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 4) noinline
	store %workbench._late_update_ui.UI_Debug_Info-1465 zeroinitializer, %workbench._late_update_ui.UI_Debug_Info-1465* %1
	store %workbench._late_update_ui.UI_Debug_Info-1465 {i32 zeroinitializer}, %workbench._late_update_ui.UI_Debug_Info-1465* %1
	%41 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.all_imgui_rects, align 8
	%42 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %41, 1
	%43 = trunc i64 %42 to i32
	%44 = getelementptr inbounds %workbench._late_update_ui.UI_Debug_Info-1465, %workbench._late_update_ui.UI_Debug_Info-1465* %1, i64 0, i32 0
	store i32 %43, i32* %44
	%45 = load %workbench._late_update_ui.UI_Debug_Info-1465, %workbench._late_update_ui.UI_Debug_Info-1465* %1, align 4
	store %workbench._late_update_ui.UI_Debug_Info-1465 %45, %workbench._late_update_ui.UI_Debug_Info-1465* %0
	call void @workbench.imgui_struct-18489(%workbench._late_update_ui.UI_Debug_Info-1465* %0, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$2d7, i64 0, i32 0), i64 13}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; rect
	; IndexExpr
	%46 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.all_imgui_rects, align 8
	%47 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %46, 0
	%48 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %46, 1
	%49 = load i64, i64* @workbench.ui_debug_cur_idx, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2d8, i64 0, i32 0), i64 60}, i64 110, i64 29, i64 %49, i64 %48)
	%50 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %47, i64 %49
	%51 = load %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %50, align 8
	store %workbench.IMGUI_Rect %51, %workbench.IMGUI_Rect* %2
	; SelectorExpr
	%52 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %2, i64 0, i32 2
	%53 = load %..string, %..string* %52, align 8
	%54 = call i8 @runtime.string_eq(%..string %53, %..string zeroinitializer)
	%55 = trunc i8 %54 to i1
	%56 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%57 = call %..rawptr @mem.zero(%..rawptr %56, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2d9, i64 0, i32 0), i64 60}, i64 111, i64 5, %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$2da, i64 0, i32 0), i64 15}}, %runtime.Source_Code_Location* %3
	%58 = call i8 @runtime.assert(i1 %55, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; text
	; ok
	; SelectorExpr
	; SelectorExpr
	%59 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %2, i64 0, i32 3
	%60 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %59, i64 0, i32 0
	%61 = load %..string, %..string* %60, align 8
	; SelectorExpr
	; SelectorExpr
	%62 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %2, i64 0, i32 3
	%63 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %62, i64 0, i32 1
	%64 = load i64, i64* %63, align 8
	%65 = call {%..string, i8} @workbench.ui_debug_get_file_line(%..string %61, i64 %64, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%66 = extractvalue {%..string, i8} %65, 0
	%67 = extractvalue {%..string, i8} %65, 1
	store %..string %66, %..string* %4
	store i8 %67, i8* %5
	; AssignStmt
	; SelectorExpr
	%68 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %2, i64 0, i32 2
	%69 = load %..string, %..string* %4, align 8
	%70 = call %..string @workbench.trim_whitespace(%..string %69, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %70, %..string* %68
	call void @workbench.imgui_struct-18496(%workbench.IMGUI_Rect* %2, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$2db, i64 0, i32 0), i64 10}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; rect
	%71 = bitcast %workbench.IMGUI_Rect* %6 to %..rawptr
	%72 = call %..rawptr @mem.zero(%..rawptr %71, i64 176) noinline
	store %workbench.IMGUI_Rect zeroinitializer, %workbench.IMGUI_Rect* %6
	; i
	%73 = bitcast i64* %7 to %..rawptr
	%74 = call %..rawptr @mem.zero(%..rawptr %73, i64 8) noinline
	store i64 zeroinitializer, i64* %7
	%75 = getelementptr inbounds {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.all_imgui_rects, i64 0, i32 1
	%76 = bitcast i64* %8 to %..rawptr
	%77 = call %..rawptr @mem.zero(%..rawptr %76, i64 8) noinline
	store i64 zeroinitializer, i64* %8
	store i64 -1, i64* %8
	br label %for.index.loop-4

for.index.loop-4:
	%78 = load i64, i64* %8, align 8
	%79 = add i64 %78, 1
	store i64 %79, i64* %8
	%80 = load i64, i64* %75, align 8
	%81 = icmp slt i64 %79, %80
	br i1 %81, label %for.index.body-5, label %for.index.done-12

for.index.body-5:
	%82 = load i64, i64* %8, align 8
	%83 = getelementptr inbounds {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.all_imgui_rects, i64 0, i32 0
	%84 = load %workbench.IMGUI_Rect*, %workbench.IMGUI_Rect** %83, align 8
	%85 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %84, i64 %82
	%86 = load %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %85, align 8
	store %workbench.IMGUI_Rect %86, %workbench.IMGUI_Rect* %6
	store i64 %82, i64* %7
	; IfStmt
	%87 = load i64, i64* @workbench.ui_debug_cur_idx, align 8
	%88 = load i64, i64* %7, align 8
	%89 = icmp eq i64 %87, %88
	%90 = zext i1 %89 to i8
	%91 = trunc i8 %90 to i1
	br i1 %91, label %if.then-6, label %if.done-7

if.then-6:
	; SelectorExpr
	call ccc void @igBullet()
	br label %if.done-7

if.done-7:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%92 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %6, i64 0, i32 3
	%93 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %92, align 8
	%94 = bitcast %runtime.Source_Code_Location* %9 to %..rawptr
	%95 = call %..rawptr @mem.zero(%..rawptr %94, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %9
	store %runtime.Source_Code_Location %93, %runtime.Source_Code_Location* %9
	%96 = call %..string @workbench.pretty_location(%runtime.Source_Code_Location* %9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%97 = load i64, i64* %7, align 8
	%98 = bitcast %..any* %10 to %..rawptr
	%99 = call %..rawptr @mem.zero(%..rawptr %98, i64 16) noinline
	store %..any zeroinitializer, %..any* %10
	%100 = bitcast %..string* %11 to %..rawptr
	%101 = call %..rawptr @mem.zero(%..rawptr %100, i64 16) noinline
	store %..string zeroinitializer, %..string* %11
	store %..string %96, %..string* %11
	%102 = bitcast %..string* %11 to %..rawptr
	%103 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 0
	store %..rawptr %102, %..rawptr* %103
	%104 = getelementptr inbounds %..any, %..any* %10, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %104
	%105 = load %..any, %..any* %10, align 8
	%106 = bitcast %..any* %12 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 16) noinline
	store %..any zeroinitializer, %..any* %12
	%108 = bitcast i64* %7 to %..rawptr
	%109 = getelementptr inbounds %..any, %..any* %12, i64 0, i32 0
	store %..rawptr %108, %..rawptr* %109
	%110 = getelementptr inbounds %..any, %..any* %12, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %110
	%111 = load %..any, %..any* %12, align 8
	; variadic call argument generation
	%112 = bitcast {%..any*, i64}* %13 to %..rawptr
	%113 = call %..rawptr @mem.zero(%..rawptr %112, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	%114 = bitcast [2 x %..any]* %14 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %14
	%116 = getelementptr inbounds [2 x %..any], [2 x %..any]* %14, i64 0, i32 0
	store %..any %105, %..any* %116
	%117 = getelementptr inbounds [2 x %..any], [2 x %..any]* %14, i64 0, i32 1
	store %..any %111, %..any* %117
	%118 = getelementptr inbounds [2 x %..any], [2 x %..any]* %14, i64 0, i32 0
	%119 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %13, i64 0, i32 0
	store %..any* %118, %..any** %119
	%120 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %13, i64 0, i32 1
	store i64 2, i64* %120
	%121 = load {%..any*, i64}, {%..any*, i64}* %13, align 8
	%122 = bitcast {%..any*, i64}* %15 to %..rawptr
	%123 = call %..rawptr @mem.zero(%..rawptr %122, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	store {%..any*, i64} %121, {%..any*, i64}* %15
	%124 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$2dc, i64 0, i32 0), i64 6}, {%..any*, i64}* %15, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%125 = call i8 @imgui.small_button(%..string %124, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%126 = trunc i8 %125 to i1
	br i1 %126, label %if.then-8, label %if.done-9

if.then-8:
	; AssignStmt
	%127 = load i64, i64* %7, align 8
	store i64 %127, i64* @workbench.ui_debug_cur_idx
	br label %if.done-9

if.done-9:
	; IfStmt
	%128 = load i64, i64* @workbench.ui_debug_cur_idx, align 8
	%129 = load i64, i64* %7, align 8
	%130 = icmp eq i64 %128, %129
	%131 = zext i1 %130 to i8
	%132 = trunc i8 %131 to i1
	br i1 %132, label %if.then-10, label %if.done-11

if.then-10:
	; min
	; CompoundLit
	%133 = bitcast [2 x float]* %17 to %..rawptr
	%134 = call %..rawptr @mem.zero(%..rawptr %133, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %17
	store [2 x float] [float zeroinitializer, float zeroinitializer], [2 x float]* %17
	; SelectorExpr
	; SelectorExpr
	%135 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %6, i64 0, i32 5
	%136 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %135, i64 0, i32 0
	%137 = load i64, i64* %136, align 8
	%138 = sitofp i64 %137 to float
	%139 = getelementptr inbounds [2 x float], [2 x float]* %17, i64 0, i32 0
	store float %138, float* %139
	; SelectorExpr
	; SelectorExpr
	%140 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %6, i64 0, i32 5
	%141 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %140, i64 0, i32 1
	%142 = load i64, i64* %141, align 8
	%143 = sitofp i64 %142 to float
	%144 = getelementptr inbounds [2 x float], [2 x float]* %17, i64 0, i32 1
	store float %143, float* %144
	%145 = load [2 x float], [2 x float]* %17, align 4
	store [2 x float] %145, [2 x float]* %16
	; max
	; CompoundLit
	%146 = bitcast [2 x float]* %19 to %..rawptr
	%147 = call %..rawptr @mem.zero(%..rawptr %146, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %19
	store [2 x float] [float zeroinitializer, float zeroinitializer], [2 x float]* %19
	; SelectorExpr
	; SelectorExpr
	%148 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %6, i64 0, i32 5
	%149 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %148, i64 0, i32 2
	%150 = load i64, i64* %149, align 8
	%151 = sitofp i64 %150 to float
	%152 = getelementptr inbounds [2 x float], [2 x float]* %19, i64 0, i32 0
	store float %151, float* %152
	; SelectorExpr
	; SelectorExpr
	%153 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %6, i64 0, i32 5
	%154 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %153, i64 0, i32 3
	%155 = load i64, i64* %154, align 8
	%156 = sitofp i64 %155 to float
	%157 = getelementptr inbounds [2 x float], [2 x float]* %19, i64 0, i32 1
	store float %156, float* %157
	%158 = load [2 x float], [2 x float]* %19, align 4
	store [2 x float] %158, [2 x float]* %18
	%159 = load [2 x float], [2 x float]* %16, align 4
	%160 = bitcast [2 x float]* %20 to %..rawptr
	%161 = call %..rawptr @mem.zero(%..rawptr %160, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %20
	store [2 x float] %159, [2 x float]* %20
	%162 = call [3 x float] @workbench.to_vec3-17032([2 x float]* %20, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%163 = load [2 x float], [2 x float]* %18, align 4
	%164 = bitcast [2 x float]* %21 to %..rawptr
	%165 = call %..rawptr @mem.zero(%..rawptr %164, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %21
	store [2 x float] %163, [2 x float]* %21
	%166 = call [3 x float] @workbench.to_vec3-17032([2 x float]* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%167 = load %workbench.Colorf, %workbench.Colorf* @workbench.COLOR_GREEN, align 4
	%168 = bitcast void (%runtime.Context*)* @workbench.rendermode_pixel to void (%runtime.Context*)*
	%169 = bitcast [3 x float]* %22 to %..rawptr
	%170 = call %..rawptr @mem.zero(%..rawptr %169, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %22
	store [3 x float] %162, [3 x float]* %22
	%171 = bitcast [3 x float]* %23 to %..rawptr
	%172 = call %..rawptr @mem.zero(%..rawptr %171, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %23
	store [3 x float] %166, [3 x float]* %23
	%173 = bitcast %workbench.Colorf* %24 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %24
	store %workbench.Colorf %167, %workbench.Colorf* %24
	call void @workbench.push_debug_box_min_max(void (%runtime.Context*)* %168, [3 x float]* %22, [3 x float]* %23, %workbench.Colorf* %24, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%175 = bitcast %runtime.Source_Code_Location* %25 to %..rawptr
	%176 = call %..rawptr @mem.zero(%..rawptr %175, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %25
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2dd, i64 0, i32 0), i64 60}, i64 130, i64 7, %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$2de, i64 0, i32 0), i64 15}}, %runtime.Source_Code_Location* %25
	%177 = bitcast [2 x float]* %26 to %..rawptr
	%178 = call %..rawptr @mem.zero(%..rawptr %177, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %26
	store [2 x float] [float 0x3fe0000000000000, float 0x3fe0000000000000], [2 x float]* %26
	%179 = call %workbench.IMGUI_Rect @workbench.ui_push_rect(float 0x0000000000000000, float 0x3fa9999980000000, float 0x3ff0000000000000, float 0x3fc3333320000000, i64 0, i64 0, i64 0, i64 0, i64 0, %runtime.Source_Code_Location* %25, [2 x float]* %26, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	; defer
	%180 = bitcast %runtime.Source_Code_Location* %27 to %..rawptr
	%181 = call %..rawptr @mem.zero(%..rawptr %180, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %27
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2df, i64 0, i32 0), i64 60}, i64 131, i64 13, %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$2e0, i64 0, i32 0), i64 15}}, %runtime.Source_Code_Location* %27
	%182 = call %workbench.IMGUI_Rect @workbench.ui_pop_rect(%runtime.Source_Code_Location* %27, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-11

if.done-11:
	br label %for.index.loop-4

for.index.done-12:
	br label %if.done-13

if.done-13:
	; defer
	; SelectorExpr
	call ccc void @igEnd()
	br label %if.done-14

if.done-14:
	br label %if.done-15

if.done-15:
	ret void
}

define i64 @workbench.get_imgui_id_from_location(%runtime.Source_Code_Location* %loc, %runtime.Source_Code_Location* %loc2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i8, align 16
	%2 = alloca {i64, i8}, align 16
	%3 = alloca %runtime.Map_Header, align 16
	%4 = alloca %runtime.Map_Key, align 16
	%5 = alloca %runtime.Map_Header, align 16
	%6 = alloca %runtime.Map_Key, align 16
	%7 = alloca %runtime.Map_Header, align 16
	%8 = alloca %runtime.Map_Key, align 16
	%9 = alloca i64, align 16
	%10 = alloca %runtime.Map_Header, align 16
	%11 = alloca %runtime.Map_Key, align 16
	%12 = alloca %runtime.Source_Code_Location, align 16
	%13 = alloca %runtime.Map_Header, align 16
	%14 = alloca %runtime.Map_Key, align 16
	%15 = alloca i64, align 16
	%16 = alloca %runtime.Map_Header, align 16
	%17 = alloca %runtime.Map_Key, align 16
	%18 = alloca %runtime.Source_Code_Location, align 16
	%19 = alloca %workbench.Location_ID_Mapping, align 16
	%20 = alloca i64, align 16
	%21 = alloca i64, align 16
	%22 = alloca i64, align 16
	%23 = alloca %workbench.Location_ID_Mapping, align 16
	%24 = alloca %workbench.Location_ID_Mapping, align 16
	%25 = alloca %workbench.Location_ID_Mapping, align 16
	%26 = alloca %runtime.Source_Code_Location, align 16
	%27 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%28 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc2, align 8
	; count
	; ok
	; IndexExpr
	; SelectorExpr
	%29 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, i64 0, i32 0
	%30 = load %..string, %..string* %29, align 8
	%31 = bitcast {i64, i8}* %2 to %..rawptr
	%32 = call %..rawptr @mem.zero(%..rawptr %31, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %2
	%33 = bitcast %runtime.Map_Header* %3 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %3
	%35 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %3, i64 0, i32 0
	%36 = bitcast {{i64*, i64}, {{%runtime.Map_Key, i64, i64}*, i64, i64, %mem.Allocator}}* @workbench.id_counts to %mem.Raw_Map*
	store %mem.Raw_Map* %36, %mem.Raw_Map** %35
	%37 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %3, i64 0, i32 1
	store i8 1, i8* %37
	%38 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %3, i64 0, i32 2
	store i64 40, i64* %38
	%39 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %3, i64 0, i32 3
	store i64 8, i64* %39
	%40 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %3, i64 0, i32 4
	store i64 32, i64* %40
	%41 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %3, i64 0, i32 5
	store i64 8, i64* %41
	%42 = load %runtime.Map_Header, %runtime.Map_Header* %3, align 8
	%43 = bitcast %runtime.Map_Key* %4 to %..rawptr
	%44 = call %..rawptr @mem.zero(%..rawptr %43, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %4
	%45 = call i64 @runtime.default_hash_string(%..string %30, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%46 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %4, i64 0, i32 0
	store i64 %45, i64* %46
	%47 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %4, i64 0, i32 1
	store %..string %30, %..string* %47
	%48 = load %runtime.Map_Key, %runtime.Map_Key* %4, align 8
	%49 = bitcast %runtime.Map_Header* %5 to %..rawptr
	%50 = call %..rawptr @mem.zero(%..rawptr %49, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %5
	store %runtime.Map_Header %42, %runtime.Map_Header* %5
	%51 = bitcast %runtime.Map_Key* %6 to %..rawptr
	%52 = call %..rawptr @mem.zero(%..rawptr %51, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %6
	store %runtime.Map_Key %48, %runtime.Map_Key* %6
	%53 = call %..rawptr @runtime.__dynamic_map_get(%runtime.Map_Header* %5, %runtime.Map_Key* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%54 = icmp ne %..rawptr %53, null
	%55 = zext i1 %54 to i8
	%56 = getelementptr inbounds {i64, i8}, {i64, i8}* %2, i64 0, i32 1
	store i8 %55, i8* %56
	%57 = trunc i8 %55 to i1
	br i1 %57, label %map.get.then-1, label %map.get.done-2

map.get.then-1:
	%58 = getelementptr inbounds {i64, i8}, {i64, i8}* %2, i64 0, i32 0
	%59 = bitcast %..rawptr %53 to i64*
	%60 = load i64, i64* %59, align 8
	store i64 %60, i64* %58
	br label %map.get.done-2

map.get.done-2:
	%61 = load {i64, i8}, {i64, i8}* %2, align 8
	%62 = extractvalue {i64, i8} %61, 0
	%63 = extractvalue {i64, i8} %61, 1
	store i64 %62, i64* %0
	store i8 %63, i8* %1
	; IfStmt
	%64 = load i8, i8* %1, align 1
	%65 = trunc i8 %64 to i1
	br i1 %65, label %if.else-4, label %if.then-3

if.then-3:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%66 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, i64 0, i32 0
	%67 = load %..string, %..string* %66, align 8
	%68 = bitcast %runtime.Map_Header* %7 to %..rawptr
	%69 = call %..rawptr @mem.zero(%..rawptr %68, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %7
	%70 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %7, i64 0, i32 0
	%71 = bitcast {{i64*, i64}, {{%runtime.Map_Key, i64, i64}*, i64, i64, %mem.Allocator}}* @workbench.id_counts to %mem.Raw_Map*
	store %mem.Raw_Map* %71, %mem.Raw_Map** %70
	%72 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %7, i64 0, i32 1
	store i8 1, i8* %72
	%73 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %7, i64 0, i32 2
	store i64 40, i64* %73
	%74 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %7, i64 0, i32 3
	store i64 8, i64* %74
	%75 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %7, i64 0, i32 4
	store i64 32, i64* %75
	%76 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %7, i64 0, i32 5
	store i64 8, i64* %76
	%77 = load %runtime.Map_Header, %runtime.Map_Header* %7, align 8
	%78 = bitcast %runtime.Map_Key* %8 to %..rawptr
	%79 = call %..rawptr @mem.zero(%..rawptr %78, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %8
	%80 = call i64 @runtime.default_hash_string(%..string %67, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%81 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %8, i64 0, i32 0
	store i64 %80, i64* %81
	%82 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %8, i64 0, i32 1
	store %..string %67, %..string* %82
	%83 = load %runtime.Map_Key, %runtime.Map_Key* %8, align 8
	%84 = bitcast i64* %9 to %..rawptr
	%85 = call %..rawptr @mem.zero(%..rawptr %84, i64 8) noinline
	store i64 zeroinitializer, i64* %9
	store i64 0, i64* %9
	%86 = bitcast i64* %9 to %..rawptr
	%87 = bitcast %runtime.Map_Header* %10 to %..rawptr
	%88 = call %..rawptr @mem.zero(%..rawptr %87, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %10
	store %runtime.Map_Header %77, %runtime.Map_Header* %10
	%89 = bitcast %runtime.Map_Key* %11 to %..rawptr
	%90 = call %..rawptr @mem.zero(%..rawptr %89, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %11
	store %runtime.Map_Key %83, %runtime.Map_Key* %11
	%91 = bitcast %runtime.Source_Code_Location* %12 to %..rawptr
	%92 = call %..rawptr @mem.zero(%..rawptr %91, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %12
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 0, i64 0, %..string {i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$2e1, i64 0, i32 0), i64 26}}, %runtime.Source_Code_Location* %12
	call void @runtime.__dynamic_map_set(%runtime.Map_Header* %10, %runtime.Map_Key* %11, %..rawptr %86, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	store i64 0, i64* %0
	br label %if.done-5

if.else-4:
	; AssignStmt
	%93 = load i64, i64* %0, align 8
	%94 = add i64 %93, 1
	store i64 %94, i64* %0
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%95 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, i64 0, i32 0
	%96 = load %..string, %..string* %95, align 8
	%97 = load i64, i64* %0, align 8
	%98 = bitcast %runtime.Map_Header* %13 to %..rawptr
	%99 = call %..rawptr @mem.zero(%..rawptr %98, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %13
	%100 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %13, i64 0, i32 0
	%101 = bitcast {{i64*, i64}, {{%runtime.Map_Key, i64, i64}*, i64, i64, %mem.Allocator}}* @workbench.id_counts to %mem.Raw_Map*
	store %mem.Raw_Map* %101, %mem.Raw_Map** %100
	%102 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %13, i64 0, i32 1
	store i8 1, i8* %102
	%103 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %13, i64 0, i32 2
	store i64 40, i64* %103
	%104 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %13, i64 0, i32 3
	store i64 8, i64* %104
	%105 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %13, i64 0, i32 4
	store i64 32, i64* %105
	%106 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %13, i64 0, i32 5
	store i64 8, i64* %106
	%107 = load %runtime.Map_Header, %runtime.Map_Header* %13, align 8
	%108 = bitcast %runtime.Map_Key* %14 to %..rawptr
	%109 = call %..rawptr @mem.zero(%..rawptr %108, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %14
	%110 = call i64 @runtime.default_hash_string(%..string %96, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%111 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %14, i64 0, i32 0
	store i64 %110, i64* %111
	%112 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %14, i64 0, i32 1
	store %..string %96, %..string* %112
	%113 = load %runtime.Map_Key, %runtime.Map_Key* %14, align 8
	%114 = bitcast i64* %15 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 8) noinline
	store i64 zeroinitializer, i64* %15
	store i64 %97, i64* %15
	%116 = bitcast i64* %15 to %..rawptr
	%117 = bitcast %runtime.Map_Header* %16 to %..rawptr
	%118 = call %..rawptr @mem.zero(%..rawptr %117, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %16
	store %runtime.Map_Header %107, %runtime.Map_Header* %16
	%119 = bitcast %runtime.Map_Key* %17 to %..rawptr
	%120 = call %..rawptr @mem.zero(%..rawptr %119, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %17
	store %runtime.Map_Key %113, %runtime.Map_Key* %17
	%121 = bitcast %runtime.Source_Code_Location* %18 to %..rawptr
	%122 = call %..rawptr @mem.zero(%..rawptr %121, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %18
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 0, i64 0, %..string {i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$2e2, i64 0, i32 0), i64 26}}, %runtime.Source_Code_Location* %18
	call void @runtime.__dynamic_map_set(%runtime.Map_Header* %16, %runtime.Map_Key* %17, %..rawptr %116, %runtime.Source_Code_Location* %18, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-5

if.done-5:
	; RangeStmt
	; val
	%123 = bitcast %workbench.Location_ID_Mapping* %19 to %..rawptr
	%124 = call %..rawptr @mem.zero(%..rawptr %123, i64 64) noinline
	store %workbench.Location_ID_Mapping zeroinitializer, %workbench.Location_ID_Mapping* %19
	; idx
	%125 = bitcast i64* %20 to %..rawptr
	%126 = call %..rawptr @mem.zero(%..rawptr %125, i64 8) noinline
	store i64 zeroinitializer, i64* %20
	%127 = getelementptr inbounds {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* @workbench.all_imgui_mappings, i64 0, i32 1
	%128 = bitcast i64* %21 to %..rawptr
	%129 = call %..rawptr @mem.zero(%..rawptr %128, i64 8) noinline
	store i64 zeroinitializer, i64* %21
	store i64 -1, i64* %21
	br label %for.index.loop-6

for.index.loop-6:
	%130 = load i64, i64* %21, align 8
	%131 = add i64 %130, 1
	store i64 %131, i64* %21
	%132 = load i64, i64* %127, align 8
	%133 = icmp slt i64 %131, %132
	br i1 %133, label %for.index.body-7, label %for.index.done-16

for.index.body-7:
	%134 = load i64, i64* %21, align 8
	%135 = getelementptr inbounds {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* @workbench.all_imgui_mappings, i64 0, i32 0
	%136 = load %workbench.Location_ID_Mapping*, %workbench.Location_ID_Mapping** %135, align 8
	%137 = getelementptr inbounds %workbench.Location_ID_Mapping, %workbench.Location_ID_Mapping* %136, i64 %134
	%138 = load %workbench.Location_ID_Mapping, %workbench.Location_ID_Mapping* %137, align 8
	store %workbench.Location_ID_Mapping %138, %workbench.Location_ID_Mapping* %19
	store i64 %134, i64* %20
	; IfStmt
	; SelectorExpr
	%139 = getelementptr inbounds %workbench.Location_ID_Mapping, %workbench.Location_ID_Mapping* %19, i64 0, i32 1
	%140 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %139, i64 0, i32 1
	%141 = load i64, i64* %140, align 8
	; SelectorExpr
	%142 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, i64 0, i32 1
	%143 = load i64, i64* %142, align 8
	%144 = icmp ne i64 %141, %143
	%145 = zext i1 %144 to i8
	%146 = trunc i8 %145 to i1
	br i1 %146, label %if.then-8, label %if.done-9

if.then-8:
	; continue
	br label %for.index.loop-6

if.done-9:
	; IfStmt
	; SelectorExpr
	%147 = getelementptr inbounds %workbench.Location_ID_Mapping, %workbench.Location_ID_Mapping* %19, i64 0, i32 1
	%148 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %147, i64 0, i32 2
	%149 = load i64, i64* %148, align 8
	; SelectorExpr
	%150 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, i64 0, i32 2
	%151 = load i64, i64* %150, align 8
	%152 = icmp ne i64 %149, %151
	%153 = zext i1 %152 to i8
	%154 = trunc i8 %153 to i1
	br i1 %154, label %if.then-10, label %if.done-11

if.then-10:
	; continue
	br label %for.index.loop-6

if.done-11:
	; IfStmt
	; SelectorExpr
	%155 = getelementptr inbounds %workbench.Location_ID_Mapping, %workbench.Location_ID_Mapping* %19, i64 0, i32 2
	%156 = load i64, i64* %155, align 8
	%157 = load i64, i64* %0, align 8
	%158 = icmp ne i64 %156, %157
	%159 = zext i1 %158 to i8
	%160 = trunc i8 %159 to i1
	br i1 %160, label %if.then-12, label %if.done-13

if.then-12:
	; continue
	br label %for.index.loop-6

if.done-13:
	; IfStmt
	; SelectorExpr
	%161 = getelementptr inbounds %workbench.Location_ID_Mapping, %workbench.Location_ID_Mapping* %19, i64 0, i32 1
	%162 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %161, i64 0, i32 0
	%163 = load %..string, %..string* %162, align 8
	; SelectorExpr
	%164 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, i64 0, i32 0
	%165 = load %..string, %..string* %164, align 8
	%166 = call i8 @runtime.string_ne(%..string %163, %..string %165)
	%167 = trunc i8 %166 to i1
	br i1 %167, label %if.then-14, label %if.done-15

if.then-14:
	; continue
	br label %for.index.loop-6

if.done-15:
	; ReturnStmt
	; SelectorExpr
	%168 = getelementptr inbounds %workbench.Location_ID_Mapping, %workbench.Location_ID_Mapping* %19, i64 0, i32 0
	%169 = load i64, i64* %168, align 8
	ret i64 %169

for.index.done-16:
	; id
	%170 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* @workbench.all_imgui_mappings, align 8
	%171 = extractvalue {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator} %170, 1
	store i64 %171, i64* %22
	; mapping
	; CompoundLit
	%172 = bitcast %workbench.Location_ID_Mapping* %24 to %..rawptr
	%173 = call %..rawptr @mem.zero(%..rawptr %172, i64 64) noinline
	store %workbench.Location_ID_Mapping zeroinitializer, %workbench.Location_ID_Mapping* %24
	store %workbench.Location_ID_Mapping {i64 zeroinitializer, %runtime.Source_Code_Location zeroinitializer, i64 zeroinitializer}, %workbench.Location_ID_Mapping* %24
	%174 = load i64, i64* %22, align 8
	%175 = getelementptr inbounds %workbench.Location_ID_Mapping, %workbench.Location_ID_Mapping* %24, i64 0, i32 0
	store i64 %174, i64* %175
	%176 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%177 = getelementptr inbounds %workbench.Location_ID_Mapping, %workbench.Location_ID_Mapping* %24, i64 0, i32 1
	store %runtime.Source_Code_Location %176, %runtime.Source_Code_Location* %177
	%178 = load i64, i64* %0, align 8
	%179 = getelementptr inbounds %workbench.Location_ID_Mapping, %workbench.Location_ID_Mapping* %24, i64 0, i32 2
	store i64 %178, i64* %179
	%180 = load %workbench.Location_ID_Mapping, %workbench.Location_ID_Mapping* %24, align 8
	store %workbench.Location_ID_Mapping %180, %workbench.Location_ID_Mapping* %23
	%181 = load %workbench.Location_ID_Mapping, %workbench.Location_ID_Mapping* %23, align 8
	%182 = bitcast %workbench.Location_ID_Mapping* %25 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 64) noinline
	store %workbench.Location_ID_Mapping zeroinitializer, %workbench.Location_ID_Mapping* %25
	store %workbench.Location_ID_Mapping %181, %workbench.Location_ID_Mapping* %25
	%184 = bitcast %runtime.Source_Code_Location* %26 to %..rawptr
	%185 = call %..rawptr @mem.zero(%..rawptr %184, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %26
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2e3, i64 0, i32 0), i64 60}, i64 168, i64 2, %..string {i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$2e4, i64 0, i32 0), i64 26}}, %runtime.Source_Code_Location* %26
	%186 = call i64 @runtime.append_elem-18531({%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* @workbench.all_imgui_mappings, %workbench.Location_ID_Mapping* %25, %runtime.Source_Code_Location* %26, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	; SelectorExpr
	%187 = getelementptr inbounds %workbench.Location_ID_Mapping, %workbench.Location_ID_Mapping* %23, i64 0, i32 0
	%188 = load i64, i64* %187, align 8
	ret i64 %188
}

define %workbench.IMGUI_Rect @workbench.ui_push_rect(float %x1, float %y1, float %x2, float %y2, i64 %top, i64 %right, i64 %bottom, i64 %left, i64 %rect_kind, %runtime.Source_Code_Location* %loc, [2 x float]* %pivot, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca float, align 16
	%1 = alloca float, align 16
	%2 = alloca float, align 16
	%3 = alloca float, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, align 16
	%10 = alloca %workbench.IMGUI_Rect*, align 16
	%11 = alloca %"workbench.Rect-1229.Rect\28f32\29", align 16
	%12 = alloca float, align 16
	%13 = alloca float, align 16
	%14 = alloca float, align 16
	%15 = alloca float, align 16
	%16 = alloca float, align 16
	%17 = alloca float, align 16
	%18 = alloca %"workbench.Rect-1229.Rect\28f32\29", align 16
	%19 = alloca float, align 16
	%20 = alloca float, align 16
	%21 = alloca %"workbench.Rect-1229.Rect\28int\29", align 16
	%22 = alloca %workbench.IMGUI_Rect, align 16
	%23 = alloca %workbench.IMGUI_Rect, align 16
	%24 = alloca %runtime.Source_Code_Location, align 16
	%25 = alloca %runtime.Source_Code_Location, align 16
	%26 = alloca %workbench.IMGUI_Rect, align 16
	%27 = alloca %runtime.Source_Code_Location, align 16
	%28 = alloca %workbench.IMGUI_Rect, align 16
	%29 = alloca %runtime.Source_Code_Location, align 16
	%30 = alloca %"workbench.Rect-1229.Rect\28int\29"*, align 16
	store float %x1, float* %0
	store float %y1, float* %1
	store float %x2, float* %2
	store float %y2, float* %3
	store i64 %top, i64* %4
	store i64 %right, i64* %5
	store i64 %bottom, i64* %6
	store i64 %left, i64* %7
	store i64 %rect_kind, i64* %8
	%31 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%32 = load [2 x float], [2 x float]* %pivot, align 4
	; IfStmt
	%33 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.ui_rect_stack, align 8
	%34 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %33, 1
	%35 = icmp sgt i64 %34, 0
	%36 = zext i1 %35 to i8
	%37 = trunc i8 %36 to i1
	br i1 %37, label %cmp.and-1, label %if.done-3

cmp.and-1:
	; SelectorExpr
	%38 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.ui_rect_stack, align 8
	%39 = bitcast {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %9 to %..rawptr
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 40) noinline
	store {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} zeroinitializer, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %9
	store {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %38, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %9
	%41 = call %workbench.IMGUI_Rect* @workbench.last_dyn-18557({%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%42 = bitcast %workbench.IMGUI_Rect** %10 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 8) noinline
	store %workbench.IMGUI_Rect* zeroinitializer, %workbench.IMGUI_Rect** %10
	store %workbench.IMGUI_Rect* %41, %workbench.IMGUI_Rect** %10
	%44 = load %workbench.IMGUI_Rect*, %workbench.IMGUI_Rect** %10, align 8
	%45 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %44, i64 0
	%46 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %45, i64 0, i32 1
	%47 = load i64, i64* %46, align 8
	%48 = icmp eq i64 %47, 5
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-2, label %if.done-3

if.then-2:
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%51 = load %workbench.Scroll_View*, %workbench.Scroll_View** @workbench.current_scroll_view, align 8
	%52 = getelementptr inbounds %workbench.Scroll_View, %workbench.Scroll_View* %51, i64 0
	%53 = getelementptr inbounds %workbench.Scroll_View, %workbench.Scroll_View* %52, i64 0, i32 2
	%54 = getelementptr inbounds [2 x float], [2 x float]* %53, i64 0, i32 1
	%55 = load float, float* %54, align 4
	%56 = fptosi float %55 to i64
	%57 = load i64, i64* %4, align 8
	%58 = sub i64 %57, %56
	store i64 %58, i64* %4
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%59 = load %workbench.Scroll_View*, %workbench.Scroll_View** @workbench.current_scroll_view, align 8
	%60 = getelementptr inbounds %workbench.Scroll_View, %workbench.Scroll_View* %59, i64 0
	%61 = getelementptr inbounds %workbench.Scroll_View, %workbench.Scroll_View* %60, i64 0, i32 2
	%62 = getelementptr inbounds [2 x float], [2 x float]* %61, i64 0, i32 0
	%63 = load float, float* %62, align 4
	%64 = fptosi float %63 to i64
	%65 = load i64, i64* %5, align 8
	%66 = sub i64 %65, %64
	store i64 %66, i64* %5
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%67 = load %workbench.Scroll_View*, %workbench.Scroll_View** @workbench.current_scroll_view, align 8
	%68 = getelementptr inbounds %workbench.Scroll_View, %workbench.Scroll_View* %67, i64 0
	%69 = getelementptr inbounds %workbench.Scroll_View, %workbench.Scroll_View* %68, i64 0, i32 2
	%70 = getelementptr inbounds [2 x float], [2 x float]* %69, i64 0, i32 1
	%71 = load float, float* %70, align 4
	%72 = fptosi float %71 to i64
	%73 = load i64, i64* %6, align 8
	%74 = add i64 %73, %72
	store i64 %74, i64* %6
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%75 = load %workbench.Scroll_View*, %workbench.Scroll_View** @workbench.current_scroll_view, align 8
	%76 = getelementptr inbounds %workbench.Scroll_View, %workbench.Scroll_View* %75, i64 0
	%77 = getelementptr inbounds %workbench.Scroll_View, %workbench.Scroll_View* %76, i64 0, i32 2
	%78 = getelementptr inbounds [2 x float], [2 x float]* %77, i64 0, i32 0
	%79 = load float, float* %78, align 4
	%80 = fptosi float %79 to i64
	%81 = load i64, i64* %7, align 8
	%82 = add i64 %81, %80
	store i64 %82, i64* %7
	br label %if.done-3

if.done-3:
	; current_rect
	%83 = bitcast %"workbench.Rect-1229.Rect\28f32\29"* %11 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 16) noinline
	store %"workbench.Rect-1229.Rect\28f32\29" zeroinitializer, %"workbench.Rect-1229.Rect\28f32\29"* %11
	; IfStmt
	%85 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.ui_rect_stack, align 8
	%86 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %85, 1
	%87 = icmp eq i64 %86, 0
	%88 = zext i1 %87 to i8
	%89 = trunc i8 %88 to i1
	br i1 %89, label %if.then-4, label %if.else-5

if.then-4:
	; AssignStmt
	store %"workbench.Rect-1229.Rect\28f32\29" {float 0x0000000000000000, float 0x0000000000000000, float 0x3ff0000000000000, float 0x3ff0000000000000}, %"workbench.Rect-1229.Rect\28f32\29"* %11
	br label %if.done-6

if.else-5:
	; AssignStmt
	%90 = load %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* @workbench.ui_current_rect_unit, align 4
	store %"workbench.Rect-1229.Rect\28f32\29" %90, %"workbench.Rect-1229.Rect\28f32\29"* %11
	br label %if.done-6

if.done-6:
	; cur_w
	; SelectorExpr
	%91 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %11, i64 0, i32 2
	%92 = load float, float* %91, align 4
	; SelectorExpr
	%93 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %11, i64 0, i32 0
	%94 = load float, float* %93, align 4
	%95 = fsub float %92, %94
	store float %95, float* %12
	; cur_h
	; SelectorExpr
	%96 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %11, i64 0, i32 3
	%97 = load float, float* %96, align 4
	; SelectorExpr
	%98 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %11, i64 0, i32 1
	%99 = load float, float* %98, align 4
	%100 = fsub float %97, %99
	store float %100, float* %13
	; new_x1
	; SelectorExpr
	%101 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %11, i64 0, i32 0
	%102 = load float, float* %101, align 4
	%103 = load float, float* %12, align 4
	%104 = load float, float* %0, align 4
	%105 = fmul float %103, %104
	%106 = fadd float %102, %105
	%107 = load i64, i64* %7, align 8
	%108 = sitofp i64 %107 to float
	%109 = load float, float* @workbench.current_window_width, align 4
	%110 = fdiv float %108, %109
	%111 = fadd float %106, %110
	store float %111, float* %14
	; new_y1
	; SelectorExpr
	%112 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %11, i64 0, i32 1
	%113 = load float, float* %112, align 4
	%114 = load float, float* %13, align 4
	%115 = load float, float* %1, align 4
	%116 = fmul float %114, %115
	%117 = fadd float %113, %116
	%118 = load i64, i64* %6, align 8
	%119 = sitofp i64 %118 to float
	%120 = load float, float* @workbench.current_window_height, align 4
	%121 = fdiv float %119, %120
	%122 = fadd float %117, %121
	store float %122, float* %15
	; new_x2
	; SelectorExpr
	%123 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %11, i64 0, i32 2
	%124 = load float, float* %123, align 4
	%125 = load float, float* %12, align 4
	%126 = load float, float* %2, align 4
	%127 = fsub float 0x3ff0000000000000, %126
	%128 = fmul float %125, %127
	%129 = fsub float %124, %128
	%130 = load i64, i64* %5, align 8
	%131 = sitofp i64 %130 to float
	%132 = load float, float* @workbench.current_window_width, align 4
	%133 = fdiv float %131, %132
	%134 = fsub float %129, %133
	store float %134, float* %16
	; new_y2
	; SelectorExpr
	%135 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %11, i64 0, i32 3
	%136 = load float, float* %135, align 4
	%137 = load float, float* %13, align 4
	%138 = load float, float* %3, align 4
	%139 = fsub float 0x3ff0000000000000, %138
	%140 = fmul float %137, %139
	%141 = fsub float %136, %140
	%142 = load i64, i64* %4, align 8
	%143 = sitofp i64 %142 to float
	%144 = load float, float* @workbench.current_window_height, align 4
	%145 = fdiv float %143, %144
	%146 = fsub float %141, %145
	store float %146, float* %17
	; AssignStmt
	; CompoundLit
	%147 = bitcast %"workbench.Rect-1229.Rect\28f32\29"* %18 to %..rawptr
	%148 = call %..rawptr @mem.zero(%..rawptr %147, i64 16) noinline
	store %"workbench.Rect-1229.Rect\28f32\29" zeroinitializer, %"workbench.Rect-1229.Rect\28f32\29"* %18
	store %"workbench.Rect-1229.Rect\28f32\29" {float zeroinitializer, float zeroinitializer, float zeroinitializer, float zeroinitializer}, %"workbench.Rect-1229.Rect\28f32\29"* %18
	%149 = load float, float* %14, align 4
	%150 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %18, i64 0, i32 0
	store float %149, float* %150
	%151 = load float, float* %15, align 4
	%152 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %18, i64 0, i32 1
	store float %151, float* %152
	%153 = load float, float* %16, align 4
	%154 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %18, i64 0, i32 2
	store float %153, float* %154
	%155 = load float, float* %17, align 4
	%156 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %18, i64 0, i32 3
	store float %155, float* %156
	%157 = load %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %18, align 4
	store %"workbench.Rect-1229.Rect\28f32\29" %157, %"workbench.Rect-1229.Rect\28f32\29"* @workbench.ui_current_rect_unit
	; cww
	%158 = load float, float* @workbench.current_window_width, align 4
	store float %158, float* %19
	; cwh
	%159 = load float, float* @workbench.current_window_height, align 4
	store float %159, float* %20
	; AssignStmt
	; CompoundLit
	%160 = bitcast %"workbench.Rect-1229.Rect\28int\29"* %21 to %..rawptr
	%161 = call %..rawptr @mem.zero(%..rawptr %160, i64 32) noinline
	store %"workbench.Rect-1229.Rect\28int\29" zeroinitializer, %"workbench.Rect-1229.Rect\28int\29"* %21
	store %"workbench.Rect-1229.Rect\28int\29" {i64 zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i64 zeroinitializer}, %"workbench.Rect-1229.Rect\28int\29"* %21
	; SelectorExpr
	%162 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* @workbench.ui_current_rect_unit, i64 0, i32 0
	%163 = load float, float* %162, align 4
	%164 = load float, float* %19, align 4
	%165 = fmul float %163, %164
	%166 = fptosi float %165 to i64
	%167 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %21, i64 0, i32 0
	store i64 %166, i64* %167
	; SelectorExpr
	%168 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* @workbench.ui_current_rect_unit, i64 0, i32 1
	%169 = load float, float* %168, align 4
	%170 = load float, float* %20, align 4
	%171 = fmul float %169, %170
	%172 = fptosi float %171 to i64
	%173 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %21, i64 0, i32 1
	store i64 %172, i64* %173
	; SelectorExpr
	%174 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* @workbench.ui_current_rect_unit, i64 0, i32 2
	%175 = load float, float* %174, align 4
	%176 = load float, float* %19, align 4
	%177 = fmul float %175, %176
	%178 = fptosi float %177 to i64
	%179 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %21, i64 0, i32 2
	store i64 %178, i64* %179
	; SelectorExpr
	%180 = getelementptr inbounds %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* @workbench.ui_current_rect_unit, i64 0, i32 3
	%181 = load float, float* %180, align 4
	%182 = load float, float* %20, align 4
	%183 = fmul float %181, %182
	%184 = fptosi float %183 to i64
	%185 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %21, i64 0, i32 3
	store i64 %184, i64* %185
	%186 = load %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %21, align 8
	store %"workbench.Rect-1229.Rect\28int\29" %186, %"workbench.Rect-1229.Rect\28int\29"* @workbench.ui_current_rect_pixels
	; rect
	; CompoundLit
	%187 = bitcast %workbench.IMGUI_Rect* %23 to %..rawptr
	%188 = call %..rawptr @mem.zero(%..rawptr %187, i64 176) noinline
	store %workbench.IMGUI_Rect zeroinitializer, %workbench.IMGUI_Rect* %23
	store %workbench.IMGUI_Rect {i64 zeroinitializer, i64 zeroinitializer, %..string zeroinitializer, %runtime.Source_Code_Location zeroinitializer, %"workbench.Rect-1229.Rect\28f32\29" zeroinitializer, %"workbench.Rect-1229.Rect\28int\29" zeroinitializer, float zeroinitializer, float zeroinitializer, float zeroinitializer, float zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i64 zeroinitializer}, %workbench.IMGUI_Rect* %23
	%189 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%190 = bitcast %runtime.Source_Code_Location* %24 to %..rawptr
	%191 = call %..rawptr @mem.zero(%..rawptr %190, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %24
	store %runtime.Source_Code_Location %189, %runtime.Source_Code_Location* %24
	%192 = bitcast %runtime.Source_Code_Location* %25 to %..rawptr
	%193 = call %..rawptr @mem.zero(%..rawptr %192, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %25
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2e5, i64 0, i32 0), i64 60}, i64 242, i64 21, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$2e6, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %25
	%194 = call i64 @workbench.get_imgui_id_from_location(%runtime.Source_Code_Location* %24, %runtime.Source_Code_Location* %25, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%195 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %23, i64 0, i32 0
	store i64 %194, i64* %195
	%196 = load i64, i64* %8, align 8
	%197 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %23, i64 0, i32 1
	store i64 %196, i64* %197
	%198 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%199 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %23, i64 0, i32 3
	store %runtime.Source_Code_Location %198, %runtime.Source_Code_Location* %199
	%200 = load %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* @workbench.ui_current_rect_unit, align 4
	%201 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %23, i64 0, i32 4
	store %"workbench.Rect-1229.Rect\28f32\29" %200, %"workbench.Rect-1229.Rect\28f32\29"* %201
	%202 = load %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* @workbench.ui_current_rect_pixels, align 8
	%203 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %23, i64 0, i32 5
	store %"workbench.Rect-1229.Rect\28int\29" %202, %"workbench.Rect-1229.Rect\28int\29"* %203
	%204 = load float, float* %0, align 4
	%205 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %23, i64 0, i32 6
	store float %204, float* %205
	%206 = load float, float* %1, align 4
	%207 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %23, i64 0, i32 7
	store float %206, float* %207
	%208 = load float, float* %2, align 4
	%209 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %23, i64 0, i32 8
	store float %208, float* %209
	%210 = load float, float* %3, align 4
	%211 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %23, i64 0, i32 9
	store float %210, float* %211
	%212 = load i64, i64* %4, align 8
	%213 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %23, i64 0, i32 10
	store i64 %212, i64* %213
	%214 = load i64, i64* %5, align 8
	%215 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %23, i64 0, i32 11
	store i64 %214, i64* %215
	%216 = load i64, i64* %6, align 8
	%217 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %23, i64 0, i32 12
	store i64 %216, i64* %217
	%218 = load i64, i64* %7, align 8
	%219 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %23, i64 0, i32 13
	store i64 %218, i64* %219
	%220 = load %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %23, align 8
	store %workbench.IMGUI_Rect %220, %workbench.IMGUI_Rect* %22
	%221 = load %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %22, align 8
	%222 = bitcast %workbench.IMGUI_Rect* %26 to %..rawptr
	%223 = call %..rawptr @mem.zero(%..rawptr %222, i64 176) noinline
	store %workbench.IMGUI_Rect zeroinitializer, %workbench.IMGUI_Rect* %26
	store %workbench.IMGUI_Rect %221, %workbench.IMGUI_Rect* %26
	%224 = bitcast %runtime.Source_Code_Location* %27 to %..rawptr
	%225 = call %..rawptr @mem.zero(%..rawptr %224, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %27
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2e7, i64 0, i32 0), i64 60}, i64 243, i64 2, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$2e8, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %27
	%226 = call i64 @runtime.append_elem-18594({%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.ui_rect_stack, %workbench.IMGUI_Rect* %26, %runtime.Source_Code_Location* %27, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%227 = load %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %22, align 8
	%228 = bitcast %workbench.IMGUI_Rect* %28 to %..rawptr
	%229 = call %..rawptr @mem.zero(%..rawptr %228, i64 176) noinline
	store %workbench.IMGUI_Rect zeroinitializer, %workbench.IMGUI_Rect* %28
	store %workbench.IMGUI_Rect %227, %workbench.IMGUI_Rect* %28
	%230 = bitcast %runtime.Source_Code_Location* %29 to %..rawptr
	%231 = call %..rawptr @mem.zero(%..rawptr %230, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %29
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2e9, i64 0, i32 0), i64 60}, i64 244, i64 2, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$2ea, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %29
	%232 = call i64 @runtime.append_elem-18594({%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.new_imgui_rects, %workbench.IMGUI_Rect* %28, %runtime.Source_Code_Location* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	%233 = load %workbench.Scroll_View*, %workbench.Scroll_View** @workbench.current_scroll_view, align 8
	%234 = icmp ne %workbench.Scroll_View* %233, zeroinitializer
	%235 = zext i1 %234 to i8
	%236 = trunc i8 %235 to i1
	br i1 %236, label %if.then-7, label %if.done-8

if.then-7:
	; r
	; SelectorExpr
	%237 = load %workbench.Scroll_View*, %workbench.Scroll_View** @workbench.current_scroll_view, align 8
	%238 = getelementptr inbounds %workbench.Scroll_View, %workbench.Scroll_View* %237, i64 0
	%239 = getelementptr inbounds %workbench.Scroll_View, %workbench.Scroll_View* %238, i64 0, i32 0
	store %"workbench.Rect-1229.Rect\28int\29"* %239, %"workbench.Rect-1229.Rect\28int\29"** %30
	; AssignStmt
	; SelectorExpr
	%240 = load %"workbench.Rect-1229.Rect\28int\29"*, %"workbench.Rect-1229.Rect\28int\29"** %30, align 8
	%241 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %240, i64 0
	%242 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %241, i64 0, i32 0
	; min
	; SelectorExpr
	%243 = load %"workbench.Rect-1229.Rect\28int\29"*, %"workbench.Rect-1229.Rect\28int\29"** %30, align 8
	%244 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %243, i64 0
	%245 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %244, i64 0, i32 0
	%246 = load i64, i64* %245, align 8
	; SelectorExpr
	%247 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* @workbench.ui_current_rect_pixels, i64 0, i32 0
	%248 = load i64, i64* %247, align 8
	%249 = icmp slt i64 %246, %248
	%250 = select i1 %249, i64 %246, i64 %248
	store i64 %250, i64* %242
	; AssignStmt
	; SelectorExpr
	%251 = load %"workbench.Rect-1229.Rect\28int\29"*, %"workbench.Rect-1229.Rect\28int\29"** %30, align 8
	%252 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %251, i64 0
	%253 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %252, i64 0, i32 1
	; min
	; SelectorExpr
	%254 = load %"workbench.Rect-1229.Rect\28int\29"*, %"workbench.Rect-1229.Rect\28int\29"** %30, align 8
	%255 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %254, i64 0
	%256 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %255, i64 0, i32 1
	%257 = load i64, i64* %256, align 8
	; SelectorExpr
	%258 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* @workbench.ui_current_rect_pixels, i64 0, i32 1
	%259 = load i64, i64* %258, align 8
	%260 = icmp slt i64 %257, %259
	%261 = select i1 %260, i64 %257, i64 %259
	store i64 %261, i64* %253
	; AssignStmt
	; SelectorExpr
	%262 = load %"workbench.Rect-1229.Rect\28int\29"*, %"workbench.Rect-1229.Rect\28int\29"** %30, align 8
	%263 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %262, i64 0
	%264 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %263, i64 0, i32 2
	; max
	; SelectorExpr
	%265 = load %"workbench.Rect-1229.Rect\28int\29"*, %"workbench.Rect-1229.Rect\28int\29"** %30, align 8
	%266 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %265, i64 0
	%267 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %266, i64 0, i32 2
	%268 = load i64, i64* %267, align 8
	; SelectorExpr
	%269 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* @workbench.ui_current_rect_pixels, i64 0, i32 2
	%270 = load i64, i64* %269, align 8
	%271 = icmp sgt i64 %268, %270
	%272 = select i1 %271, i64 %268, i64 %270
	store i64 %272, i64* %264
	; AssignStmt
	; SelectorExpr
	%273 = load %"workbench.Rect-1229.Rect\28int\29"*, %"workbench.Rect-1229.Rect\28int\29"** %30, align 8
	%274 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %273, i64 0
	%275 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %274, i64 0, i32 3
	; max
	; SelectorExpr
	%276 = load %"workbench.Rect-1229.Rect\28int\29"*, %"workbench.Rect-1229.Rect\28int\29"** %30, align 8
	%277 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %276, i64 0
	%278 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %277, i64 0, i32 3
	%279 = load i64, i64* %278, align 8
	; SelectorExpr
	%280 = getelementptr inbounds %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* @workbench.ui_current_rect_pixels, i64 0, i32 3
	%281 = load i64, i64* %280, align 8
	%282 = icmp sgt i64 %279, %281
	%283 = select i1 %282, i64 %279, i64 %281
	store i64 %283, i64* %275
	br label %if.done-8

if.done-8:
	; ReturnStmt
	%284 = load %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %22, align 8
	ret %workbench.IMGUI_Rect %284
}

define %workbench.IMGUI_Rect @workbench.ui_pop_rect(%runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %workbench.IMGUI_Rect, align 16
	%1 = alloca %workbench.IMGUI_Rect, align 16
	%2 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; popped_rect
	%3 = call %workbench.IMGUI_Rect @runtime.pop-18650({%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.ui_rect_stack)
	store %workbench.IMGUI_Rect %3, %workbench.IMGUI_Rect* %0
	; rect
	; IndexExpr
	%4 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.ui_rect_stack, align 8
	%5 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %4, 0
	%6 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %4, 1
	%7 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* @workbench.ui_rect_stack, align 8
	%8 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %7, 1
	%9 = sub i64 %8, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2eb, i64 0, i32 0), i64 60}, i64 259, i64 24, i64 %9, i64 %6)
	%10 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %5, i64 %9
	%11 = load %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %10, align 8
	store %workbench.IMGUI_Rect %11, %workbench.IMGUI_Rect* %1
	; AssignStmt
	; SelectorExpr
	%12 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %1, i64 0, i32 5
	%13 = load %"workbench.Rect-1229.Rect\28int\29", %"workbench.Rect-1229.Rect\28int\29"* %12, align 8
	store %"workbench.Rect-1229.Rect\28int\29" %13, %"workbench.Rect-1229.Rect\28int\29"* @workbench.ui_current_rect_pixels
	; AssignStmt
	; SelectorExpr
	%14 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %1, i64 0, i32 4
	%15 = load %"workbench.Rect-1229.Rect\28f32\29", %"workbench.Rect-1229.Rect\28f32\29"* %14, align 4
	store %"workbench.Rect-1229.Rect\28f32\29" %15, %"workbench.Rect-1229.Rect\28f32\29"* @workbench.ui_current_rect_unit
	; ReturnStmt
	%16 = load %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %0, align 8
	ret %workbench.IMGUI_Rect %16
}

define {%..string, i8} @workbench.ui_debug_get_file_line(%..string %file_path, i64 %line, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca %workbench.UI_Debug_File_Line, align 16
	%3 = alloca i64, align 16
	%4 = alloca {%..string, i8}, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca i8, align 16
	%7 = alloca {%..string, i8}, align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	%10 = alloca i8, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca %..string, align 16
	%15 = alloca {i8*, i64}, align 16
	%16 = alloca %..string, align 16
	%17 = alloca %workbench.UI_Debug_File_Line, align 16
	%18 = alloca %workbench.UI_Debug_File_Line, align 16
	%19 = alloca %workbench.UI_Debug_File_Line, align 16
	%20 = alloca %runtime.Source_Code_Location, align 16
	%21 = alloca {%..string, i8}, align 16
	%22 = alloca {i8*, i64}, align 16
	%23 = alloca %mem.Allocator, align 16
	%24 = alloca %runtime.Source_Code_Location, align 16
	%25 = alloca {%..string, i8}, align 16
	%26 = alloca {i8*, i64}, align 16
	%27 = alloca %mem.Allocator, align 16
	%28 = alloca %runtime.Source_Code_Location, align 16
	%29 = alloca {i8*, i64}, align 16
	%30 = alloca %mem.Allocator, align 16
	%31 = alloca %runtime.Source_Code_Location, align 16
	store %..string %file_path, %..string* %0
	store i64 %line, i64* %1
	; RangeStmt
	; fl
	%32 = bitcast %workbench.UI_Debug_File_Line* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 40) noinline
	store %workbench.UI_Debug_File_Line zeroinitializer, %workbench.UI_Debug_File_Line* %2
	%34 = getelementptr inbounds {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* @workbench.all_ui_debug_file_lines, i64 0, i32 1
	%35 = bitcast i64* %3 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	store i64 -1, i64* %3
	br label %for.index.loop-1

for.index.loop-1:
	%37 = load i64, i64* %3, align 8
	%38 = add i64 %37, 1
	store i64 %38, i64* %3
	%39 = load i64, i64* %34, align 8
	%40 = icmp slt i64 %38, %39
	br i1 %40, label %for.index.body-2, label %for.index.done-6

for.index.body-2:
	%41 = load i64, i64* %3, align 8
	%42 = getelementptr inbounds {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* @workbench.all_ui_debug_file_lines, i64 0, i32 0
	%43 = load %workbench.UI_Debug_File_Line*, %workbench.UI_Debug_File_Line** %42, align 8
	%44 = getelementptr inbounds %workbench.UI_Debug_File_Line, %workbench.UI_Debug_File_Line* %43, i64 %41
	%45 = load %workbench.UI_Debug_File_Line, %workbench.UI_Debug_File_Line* %44, align 8
	store %workbench.UI_Debug_File_Line %45, %workbench.UI_Debug_File_Line* %2
	; IfStmt
	; SelectorExpr
	%46 = getelementptr inbounds %workbench.UI_Debug_File_Line, %workbench.UI_Debug_File_Line* %2, i64 0, i32 1
	%47 = load i64, i64* %46, align 8
	%48 = load i64, i64* %1, align 8
	%49 = icmp eq i64 %47, %48
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %cmp.and-3, label %if.done-5

cmp.and-3:
	; SelectorExpr
	%52 = getelementptr inbounds %workbench.UI_Debug_File_Line, %workbench.UI_Debug_File_Line* %2, i64 0, i32 0
	%53 = load %..string, %..string* %52, align 8
	%54 = load %..string, %..string* %0, align 8
	%55 = call i8 @runtime.string_eq(%..string %53, %..string %54)
	%56 = trunc i8 %55 to i1
	br i1 %56, label %if.then-4, label %if.done-5

if.then-4:
	; ReturnStmt
	; SelectorExpr
	%57 = getelementptr inbounds %workbench.UI_Debug_File_Line, %workbench.UI_Debug_File_Line* %2, i64 0, i32 2
	%58 = load %..string, %..string* %57, align 8
	%59 = bitcast {%..string, i8}* %4 to %..rawptr
	%60 = call %..rawptr @mem.zero(%..rawptr %59, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %4
	%61 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %4, i64 0, i32 0
	store %..string %58, %..string* %61
	%62 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %4, i64 0, i32 1
	store i8 1, i8* %62
	%63 = load {%..string, i8}, {%..string, i8}* %4, align 8
	ret {%..string, i8} %63

if.done-5:
	br label %for.index.loop-1

for.index.done-6:
	; data
	; ok
	; SelectorExpr
	%64 = load %..string, %..string* %0, align 8
	%65 = call {{i8*, i64}, i8} @os.read_entire_file(%..string %64, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%66 = extractvalue {{i8*, i64}, i8} %65, 0
	%67 = extractvalue {{i8*, i64}, i8} %65, 1
	store {i8*, i64} %66, {i8*, i64}* %5
	store i8 %67, i8* %6
	; IfStmt
	%68 = load i8, i8* %6, align 1
	%69 = trunc i8 %68 to i1
	br i1 %69, label %if.done-8, label %if.then-7

if.then-7:
	; ReturnStmt
	%70 = bitcast {%..string, i8}* %7 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %7
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %7, i64 0, i32 0
	store %..string zeroinitializer, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %7, i64 0, i32 1
	store i8 0, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %7, align 8
	ret {%..string, i8} %74

if.done-8:
	; DeferStmt
	; cur_line
	store i64 1, i64* %8
	; line_start
	store i64 -1, i64* %9
	; RangeStmt
	; b
	%75 = bitcast i8* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 1) noinline
	store i8 zeroinitializer, i8* %10
	; i
	%77 = bitcast i64* %11 to %..rawptr
	%78 = call %..rawptr @mem.zero(%..rawptr %77, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	%79 = load {i8*, i64}, {i8*, i64}* %5, align 8
	%80 = bitcast i64* %12 to %..rawptr
	%81 = call %..rawptr @mem.zero(%..rawptr %80, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%82 = extractvalue {i8*, i64} %79, 1
	store i64 %82, i64* %12
	%83 = bitcast i64* %13 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-9

for.index.loop-9:
	%85 = load i64, i64* %13, align 8
	%86 = add i64 %85, 1
	store i64 %86, i64* %13
	%87 = load i64, i64* %12, align 8
	%88 = icmp slt i64 %86, %87
	br i1 %88, label %for.index.body-10, label %for.index.done-18

for.index.body-10:
	%89 = load i64, i64* %13, align 8
	%90 = extractvalue {i8*, i64} %79, 0
	%91 = getelementptr inbounds i8, i8* %90, i64 %89
	%92 = load i8, i8* %91, align 1
	store i8 %92, i8* %10
	store i64 %89, i64* %11
	; IfStmt
	%93 = load i8, i8* %10, align 1
	%94 = icmp eq i8 %93, 10
	%95 = zext i1 %94 to i8
	%96 = trunc i8 %95 to i1
	br i1 %96, label %if.then-11, label %if.done-17

if.then-11:
	; AssignStmt
	%97 = load i64, i64* %8, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %8
	; IfStmt
	%99 = load i64, i64* %8, align 8
	%100 = load i64, i64* %1, align 8
	%101 = icmp eq i64 %99, %100
	%102 = zext i1 %101 to i8
	%103 = trunc i8 %102 to i1
	br i1 %103, label %if.then-12, label %if.else-13

if.then-12:
	; AssignStmt
	%104 = load i64, i64* %11, align 8
	store i64 %104, i64* %9
	br label %if.done-16

if.else-13:
	; IfStmt
	%105 = load i64, i64* %8, align 8
	%106 = load i64, i64* %1, align 8
	%107 = add i64 %106, 1
	%108 = icmp eq i64 %105, %107
	%109 = zext i1 %108 to i8
	%110 = trunc i8 %109 to i1
	br i1 %110, label %if.then-14, label %if.done-15

if.then-14:
	; text
	; SelectorExpr
	; SliceExpr
	%111 = load i64, i64* %9, align 8
	%112 = load i64, i64* %11, align 8
	%113 = load {i8*, i64}, {i8*, i64}* %5, align 8
	%114 = extractvalue {i8*, i64} %113, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2ec, i64 0, i32 0), i64 60}, i64 672, i64 48, i64 %111, i64 %112, i64 %114)
	%115 = extractvalue {i8*, i64} %113, 0
	%116 = getelementptr inbounds i8, i8* %115, i64 %111
	%117 = sub i64 %112, %111
	%118 = bitcast {i8*, i64}* %15 to %..rawptr
	%119 = call %..rawptr @mem.zero(%..rawptr %118, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %15
	%120 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %15, i64 0, i32 0
	store i8* %116, i8** %120
	%121 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %15, i64 0, i32 1
	store i64 %117, i64* %121
	%122 = load {i8*, i64}, {i8*, i64}* %15, align 8
	%123 = extractvalue {i8*, i64} %122, 0
	%124 = extractvalue {i8*, i64} %122, 1
	%125 = bitcast %..string* %16 to %..rawptr
	%126 = call %..rawptr @mem.zero(%..rawptr %125, i64 16) noinline
	store %..string zeroinitializer, %..string* %16
	%127 = getelementptr inbounds %..string, %..string* %16, i64 0, i32 0
	store i8* %123, i8** %127
	%128 = getelementptr inbounds %..string, %..string* %16, i64 0, i32 1
	store i64 %124, i64* %128
	%129 = load %..string, %..string* %16, align 8
	%130 = call %..string @strings.new_string(%..string %129, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %130, %..string* %14
	; fl
	; CompoundLit
	%131 = bitcast %workbench.UI_Debug_File_Line* %18 to %..rawptr
	%132 = call %..rawptr @mem.zero(%..rawptr %131, i64 40) noinline
	store %workbench.UI_Debug_File_Line zeroinitializer, %workbench.UI_Debug_File_Line* %18
	store %workbench.UI_Debug_File_Line {%..string zeroinitializer, i64 zeroinitializer, %..string zeroinitializer}, %workbench.UI_Debug_File_Line* %18
	%133 = load %..string, %..string* %0, align 8
	%134 = getelementptr inbounds %workbench.UI_Debug_File_Line, %workbench.UI_Debug_File_Line* %18, i64 0, i32 0
	store %..string %133, %..string* %134
	%135 = load i64, i64* %1, align 8
	%136 = getelementptr inbounds %workbench.UI_Debug_File_Line, %workbench.UI_Debug_File_Line* %18, i64 0, i32 1
	store i64 %135, i64* %136
	%137 = load %..string, %..string* %14, align 8
	%138 = getelementptr inbounds %workbench.UI_Debug_File_Line, %workbench.UI_Debug_File_Line* %18, i64 0, i32 2
	store %..string %137, %..string* %138
	%139 = load %workbench.UI_Debug_File_Line, %workbench.UI_Debug_File_Line* %18, align 8
	store %workbench.UI_Debug_File_Line %139, %workbench.UI_Debug_File_Line* %17
	%140 = load %workbench.UI_Debug_File_Line, %workbench.UI_Debug_File_Line* %17, align 8
	%141 = bitcast %workbench.UI_Debug_File_Line* %19 to %..rawptr
	%142 = call %..rawptr @mem.zero(%..rawptr %141, i64 40) noinline
	store %workbench.UI_Debug_File_Line zeroinitializer, %workbench.UI_Debug_File_Line* %19
	store %workbench.UI_Debug_File_Line %140, %workbench.UI_Debug_File_Line* %19
	%143 = bitcast %runtime.Source_Code_Location* %20 to %..rawptr
	%144 = call %..rawptr @mem.zero(%..rawptr %143, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %20
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2ed, i64 0, i32 0), i64 60}, i64 674, i64 5, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$2ee, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %20
	%145 = call i64 @runtime.append_elem-18904({%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* @workbench.all_ui_debug_file_lines, %workbench.UI_Debug_File_Line* %19, %runtime.Source_Code_Location* %20, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%146 = load %..string, %..string* %14, align 8
	%147 = bitcast {%..string, i8}* %21 to %..rawptr
	%148 = call %..rawptr @mem.zero(%..rawptr %147, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %21
	%149 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %21, i64 0, i32 0
	store %..string %146, %..string* %149
	%150 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %21, i64 0, i32 1
	store i8 1, i8* %150
	%151 = load {%..string, i8}, {%..string, i8}* %21, align 8
	; defer
	%152 = load {i8*, i64}, {i8*, i64}* %5, align 8
	; SelectorExpr
	%153 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%154 = load %mem.Allocator, %mem.Allocator* %153, align 8
	%155 = bitcast {i8*, i64}* %22 to %..rawptr
	%156 = call %..rawptr @mem.zero(%..rawptr %155, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %22
	store {i8*, i64} %152, {i8*, i64}* %22
	%157 = bitcast %mem.Allocator* %23 to %..rawptr
	%158 = call %..rawptr @mem.zero(%..rawptr %157, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %23
	store %mem.Allocator %154, %mem.Allocator* %23
	%159 = bitcast %runtime.Source_Code_Location* %24 to %..rawptr
	%160 = call %..rawptr @mem.zero(%..rawptr %159, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %24
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2ef, i64 0, i32 0), i64 60}, i64 661, i64 8, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$2f0, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %24
	call void @mem.delete_slice-14873({i8*, i64}* %22, %mem.Allocator* %23, %runtime.Source_Code_Location* %24, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {%..string, i8} %151

if.done-15:
	br label %if.done-16

if.done-16:
	br label %if.done-17

if.done-17:
	br label %for.index.loop-9

for.index.done-18:
	; ReturnStmt
	%161 = bitcast {%..string, i8}* %25 to %..rawptr
	%162 = call %..rawptr @mem.zero(%..rawptr %161, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %25
	%163 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %25, i64 0, i32 0
	store %..string zeroinitializer, %..string* %163
	%164 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %25, i64 0, i32 1
	store i8 0, i8* %164
	%165 = load {%..string, i8}, {%..string, i8}* %25, align 8
	; defer
	%166 = load {i8*, i64}, {i8*, i64}* %5, align 8
	; SelectorExpr
	%167 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%168 = load %mem.Allocator, %mem.Allocator* %167, align 8
	%169 = bitcast {i8*, i64}* %26 to %..rawptr
	%170 = call %..rawptr @mem.zero(%..rawptr %169, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %26
	store {i8*, i64} %166, {i8*, i64}* %26
	%171 = bitcast %mem.Allocator* %27 to %..rawptr
	%172 = call %..rawptr @mem.zero(%..rawptr %171, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %27
	store %mem.Allocator %168, %mem.Allocator* %27
	%173 = bitcast %runtime.Source_Code_Location* %28 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %28
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$2f1, i64 0, i32 0), i64 60}, i64 661, i64 8, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$2f2, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %28
	call void @mem.delete_slice-14873({i8*, i64}* %26, %mem.Allocator* %27, %runtime.Source_Code_Location* %28, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {%..string, i8} %165
}

define %..string @strconv.append_float({i8*, i64}* %buf, double %f, i8 %fmt, i64 %prec, i64 %bit_size, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca double, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca {i8*, i64}, align 16
	%5 = alloca %..string, align 16
	%6 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	store double %f, double* %0
	store i8 %fmt, i8* %1
	store i64 %prec, i64* %2
	store i64 %bit_size, i64* %3
	; ReturnStmt
	%7 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%8 = load double, double* %0, align 8
	%9 = load i8, i8* %1, align 1
	%10 = load i64, i64* %2, align 8
	%11 = load i64, i64* %3, align 8
	%12 = bitcast {i8*, i64}* %4 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %4
	store {i8*, i64} %7, {i8*, i64}* %4
	%14 = call {i8*, i64} @strconv.generic_ftoa({i8*, i64}* %4, double %8, i8 %9, i64 %10, i64 %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = extractvalue {i8*, i64} %14, 0
	%16 = extractvalue {i8*, i64} %14, 1
	%17 = bitcast %..string* %5 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 16) noinline
	store %..string zeroinitializer, %..string* %5
	%19 = getelementptr inbounds %..string, %..string* %5, i64 0, i32 0
	store i8* %15, i8** %19
	%20 = getelementptr inbounds %..string, %..string* %5, i64 0, i32 1
	store i64 %16, i64* %20
	%21 = load %..string, %..string* %5, align 8
	ret %..string %21
}

define {i8*, i64} @strconv.generic_ftoa({i8*, i64}* %buf, double %val, i8 %fmt, i64 %prec, i64 %bit_size, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca double, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca %strconv.FloatInfo*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca i8, align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	%10 = alloca %..string, align 16
	%11 = alloca i64, align 16
	%12 = alloca i8*, align 16
	%13 = alloca {i8*, i64}, align 16
	%14 = alloca {i8*, i64}, align 16
	%15 = alloca {i8*, i64}, align 16
	%16 = alloca {i8*, i64}, align 16
	%17 = alloca %decimal.Decimal, align 16
	%18 = alloca %decimal.Decimal*, align 16
	%19 = alloca %strconv.DecimalSlice, align 16
	%20 = alloca i8, align 16
	%21 = alloca %strconv.DecimalSlice, align 16
	%22 = alloca {i8*, i64}, align 16
	%23 = alloca %strconv.DecimalSlice, align 16
	%24 = alloca {i8*, i64}, align 16
	%25 = alloca {i8*, i64}, align 16
	%26 = alloca %strconv.DecimalSlice, align 16
	%27 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	store double %val, double* %0
	store i8 %fmt, i8* %1
	store i64 %prec, i64* %2
	store i64 %bit_size, i64* %3
	; bits
	%28 = bitcast i64* %4 to %..rawptr
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	; flt
	%30 = bitcast %strconv.FloatInfo** %5 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store %strconv.FloatInfo* zeroinitializer, %strconv.FloatInfo** %5
	; SwitchStmt
	%32 = load i64, i64* %3, align 8
	%33 = icmp eq i64 %32, 32
	br i1 %33, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%34 = icmp eq i64 %32, 64
	br i1 %34, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	; AssignStmt
	%35 = load double, double* %0, align 8
	%36 = fptrunc double %35 to float
	%37 = bitcast float %36 to i32
	%38 = zext i32 %37 to i64
	store i64 %38, i64* %4
	; AssignStmt
	store %strconv.FloatInfo* @strconv._f32_info, %strconv.FloatInfo** %5
	br label %switch.done-5

switch.case.next-3:
	%39 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$2f3, i64 0, i32 0), i64 61}, i64 246, i64 3, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$2f4, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %6
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$2f5, i64 0, i32 0), i64 25}, %runtime.Source_Code_Location* %6) noreturn
	br label %switch.done-5

switch.fall.body-4:
	; AssignStmt
	%41 = load double, double* %0, align 8
	%42 = bitcast double %41 to i64
	store i64 %42, i64* %4
	; AssignStmt
	store %strconv.FloatInfo* @strconv._f64_info, %strconv.FloatInfo** %5
	br label %switch.done-5

switch.done-5:
	; neg
	%43 = load i64, i64* %4, align 8
	; SelectorExpr
	%44 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%45 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %44, i64 0
	%46 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %45, i64 0, i32 1
	%47 = load i64, i64* %46, align 8
	; SelectorExpr
	%48 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%49 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %48, i64 0
	%50 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %49, i64 0, i32 0
	%51 = load i64, i64* %50, align 8
	%52 = add i64 %47, %51
	%53 = bitcast i64 %52 to i64
	%54 = lshr i64 %43, %53
	%55 = icmp ne i64 %54, 0
	%56 = zext i1 %55 to i8
	store i8 %56, i8* %7
	; exp
	%57 = load i64, i64* %4, align 8
	; SelectorExpr
	%58 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%59 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %58, i64 0
	%60 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %59, i64 0, i32 0
	%61 = load i64, i64* %60, align 8
	%62 = bitcast i64 %61 to i64
	%63 = lshr i64 %57, %62
	%64 = bitcast i64 %63 to i64
	; SelectorExpr
	%65 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%66 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %65, i64 0
	%67 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %66, i64 0, i32 1
	%68 = load i64, i64* %67, align 8
	%69 = bitcast i64 %68 to i64
	%70 = shl i64 1, %69
	%71 = sub i64 %70, 1
	%72 = and i64 %64, %71
	store i64 %72, i64* %8
	; mant
	%73 = load i64, i64* %4, align 8
	; SelectorExpr
	%74 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%75 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %74, i64 0
	%76 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %75, i64 0, i32 0
	%77 = load i64, i64* %76, align 8
	%78 = bitcast i64 %77 to i64
	%79 = shl i64 1, %78
	%80 = sub i64 %79, 1
	%81 = and i64 %73, %80
	store i64 %81, i64* %9
	; SwitchStmt
	%82 = load i64, i64* %8, align 8
	; SelectorExpr
	%83 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%84 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %83, i64 0
	%85 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %84, i64 0, i32 1
	%86 = load i64, i64* %85, align 8
	%87 = bitcast i64 %86 to i64
	%88 = shl i64 1, %87
	%89 = sub i64 %88, 1
	%90 = icmp eq i64 %82, %89
	br i1 %90, label %switch.case.body-7, label %switch.case.next-6

switch.case.next-6:
	%91 = icmp eq i64 %82, 0
	br i1 %91, label %switch.fall.body-15, label %switch.case.next-14

switch.case.body-7:
	; s
	%92 = bitcast %..string* %10 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store %..string zeroinitializer, %..string* %10
	; IfStmt
	%94 = load i64, i64* %9, align 8
	%95 = icmp ne i64 %94, 0
	%96 = zext i1 %95 to i8
	%97 = trunc i8 %96 to i1
	br i1 %97, label %if.then-8, label %if.else-9

if.then-8:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2f6, i64 0, i32 0), i64 3}, %..string* %10
	br label %if.done-13

if.else-9:
	; IfStmt
	%98 = load i8, i8* %7, align 1
	%99 = trunc i8 %98 to i1
	br i1 %99, label %if.then-10, label %if.else-11

if.then-10:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2f7, i64 0, i32 0), i64 4}, %..string* %10
	br label %if.done-12

if.else-11:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2f8, i64 0, i32 0), i64 4}, %..string* %10
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; n
	%100 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%101 = load %..string, %..string* %10, align 8
	%102 = extractvalue %..string %101, 0
	%103 = bitcast i8** %12 to %..rawptr
	%104 = call %..rawptr @mem.zero(%..rawptr %103, i64 8) noinline
	store i8* zeroinitializer, i8** %12
	store i8* %102, i8** %12
	%105 = extractvalue %..string %101, 1
	%106 = sub i64 %105, 0
	%107 = load i8*, i8** %12, align 8
	%108 = getelementptr inbounds i8, i8* %107, i64 0
	%109 = bitcast {i8*, i64}* %13 to %..rawptr
	%110 = call %..rawptr @mem.zero(%..rawptr %109, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %13
	%111 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %13, i64 0, i32 0
	store i8* %108, i8** %111
	%112 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %13, i64 0, i32 1
	store i64 %106, i64* %112
	%113 = load {i8*, i64}, {i8*, i64}* %13, align 8
	%114 = bitcast {i8*, i64}* %14 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %14
	store {i8*, i64} %100, {i8*, i64}* %14
	%116 = bitcast {i8*, i64}* %15 to %..rawptr
	%117 = call %..rawptr @mem.zero(%..rawptr %116, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %15
	store {i8*, i64} %113, {i8*, i64}* %15
	%118 = call i64 @runtime.copy-18955({i8*, i64}* %14, {i8*, i64}* %15)
	store i64 %118, i64* %11
	; ReturnStmt
	; SliceExpr
	%119 = load i64, i64* %11, align 8
	%120 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%121 = extractvalue {i8*, i64} %120, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$2f9, i64 0, i32 0), i64 61}, i64 264, i64 13, i64 0, i64 %119, i64 %121)
	%122 = extractvalue {i8*, i64} %120, 0
	%123 = getelementptr inbounds i8, i8* %122, i64 0
	%124 = sub i64 %119, 0
	%125 = bitcast {i8*, i64}* %16 to %..rawptr
	%126 = call %..rawptr @mem.zero(%..rawptr %125, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %16
	%127 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i64 0, i32 0
	store i8* %123, i8** %127
	%128 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i64 0, i32 1
	store i64 %124, i64* %128
	%129 = load {i8*, i64}, {i8*, i64}* %16, align 8
	ret {i8*, i64} %129

switch.case.next-14:
	; AssignStmt
	; SelectorExpr
	%130 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%131 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %130, i64 0
	%132 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %131, i64 0, i32 0
	%133 = load i64, i64* %132, align 8
	%134 = bitcast i64 %133 to i64
	%135 = shl i64 1, %134
	%136 = load i64, i64* %9, align 8
	%137 = or i64 %136, %135
	store i64 %137, i64* %9
	br label %switch.done-16

switch.fall.body-15:
	; AssignStmt
	%138 = load i64, i64* %8, align 8
	%139 = add i64 %138, 1
	store i64 %139, i64* %8
	br label %switch.done-16

switch.done-16:
	; AssignStmt
	; SelectorExpr
	%140 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%141 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %140, i64 0
	%142 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %141, i64 0, i32 2
	%143 = load i64, i64* %142, align 8
	%144 = load i64, i64* %8, align 8
	%145 = add i64 %144, %143
	store i64 %145, i64* %8
	; d_
	%146 = bitcast %decimal.Decimal* %17 to %..rawptr
	%147 = call %..rawptr @mem.zero(%..rawptr %146, i64 408) noinline
	store %decimal.Decimal zeroinitializer, %decimal.Decimal* %17
	; d
	store %decimal.Decimal* %17, %decimal.Decimal** %18
	%148 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%149 = load i64, i64* %9, align 8
	call void @decimal.assign(%decimal.Decimal* %148, i64 %149, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%150 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%151 = load i64, i64* %8, align 8
	; SelectorExpr
	%152 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%153 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %152, i64 0
	%154 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %153, i64 0, i32 0
	%155 = load i64, i64* %154, align 8
	%156 = bitcast i64 %155 to i64
	%157 = sub i64 %151, %156
	call void @decimal.shift(%decimal.Decimal* %150, i64 %157, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; digs
	%158 = bitcast %strconv.DecimalSlice* %19 to %..rawptr
	%159 = call %..rawptr @mem.zero(%..rawptr %158, i64 40) noinline
	store %strconv.DecimalSlice zeroinitializer, %strconv.DecimalSlice* %19
	; shortest
	%160 = load i64, i64* %2, align 8
	%161 = icmp slt i64 %160, 0
	%162 = zext i1 %161 to i8
	store i8 %162, i8* %20
	; IfStmt
	%163 = load i8, i8* %20, align 1
	%164 = trunc i8 %163 to i1
	br i1 %164, label %if.then-17, label %if.else-28

if.then-17:
	%165 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%166 = load i64, i64* %9, align 8
	%167 = load i64, i64* %8, align 8
	%168 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	call void @strconv.round_shortest(%decimal.Decimal* %165, i64 %166, i64 %167, %strconv.FloatInfo* %168, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	; CompoundLit
	%169 = bitcast %strconv.DecimalSlice* %21 to %..rawptr
	%170 = call %..rawptr @mem.zero(%..rawptr %169, i64 40) noinline
	store %strconv.DecimalSlice zeroinitializer, %strconv.DecimalSlice* %21
	store %strconv.DecimalSlice {{i8*, i64} zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i8 zeroinitializer}, %strconv.DecimalSlice* %21
	; SliceExpr
	; SelectorExpr
	%171 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%172 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %171, i64 0
	%173 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %172, i64 0, i32 0
	%174 = load [384 x i8], [384 x i8]* %173, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$2fa, i64 0, i32 0), i64 61}, i64 283, i64 40, i64 0, i64 384, i64 384)
	%175 = getelementptr inbounds [384 x i8], [384 x i8]* %173, i64 0, i32 0
	%176 = getelementptr inbounds i8, i8* %175, i64 0
	%177 = sub i64 384, 0
	%178 = bitcast {i8*, i64}* %22 to %..rawptr
	%179 = call %..rawptr @mem.zero(%..rawptr %178, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %22
	%180 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %22, i64 0, i32 0
	store i8* %176, i8** %180
	%181 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %22, i64 0, i32 1
	store i64 %177, i64* %181
	%182 = load {i8*, i64}, {i8*, i64}* %22, align 8
	%183 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %21, i64 0, i32 0
	store {i8*, i64} %182, {i8*, i64}* %183
	; SelectorExpr
	%184 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%185 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %184, i64 0
	%186 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %185, i64 0, i32 1
	%187 = load i64, i64* %186, align 8
	%188 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %21, i64 0, i32 1
	store i64 %187, i64* %188
	; SelectorExpr
	%189 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%190 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %189, i64 0
	%191 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %190, i64 0, i32 2
	%192 = load i64, i64* %191, align 8
	%193 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %21, i64 0, i32 2
	store i64 %192, i64* %193
	%194 = load %strconv.DecimalSlice, %strconv.DecimalSlice* %21, align 8
	store %strconv.DecimalSlice %194, %strconv.DecimalSlice* %19
	; SwitchStmt
	%195 = load i8, i8* %1, align 1
	%196 = icmp eq i8 %195, 101
	br i1 %196, label %switch.case.body-20, label %switch.case.next-18

switch.case.next-18:
	%197 = icmp eq i8 %195, 69
	br i1 %197, label %switch.case.body-20, label %switch.case.next-19

switch.case.next-19:
	%198 = icmp eq i8 %195, 102
	br i1 %198, label %switch.fall.body-23, label %switch.case.next-21

switch.case.body-20:
	; AssignStmt
	; SelectorExpr
	%199 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %19, i64 0, i32 1
	%200 = load i64, i64* %199, align 8
	%201 = sub i64 %200, 1
	store i64 %201, i64* %2
	br label %switch.done-27

switch.case.next-21:
	%202 = icmp eq i8 %195, 70
	br i1 %202, label %switch.fall.body-23, label %switch.case.next-22

switch.case.next-22:
	%203 = icmp eq i8 %195, 103
	br i1 %203, label %switch.fall.body-26, label %switch.case.next-24

switch.fall.body-23:
	; AssignStmt
	; max
	; SelectorExpr
	%204 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %19, i64 0, i32 1
	%205 = load i64, i64* %204, align 8
	; SelectorExpr
	%206 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %19, i64 0, i32 2
	%207 = load i64, i64* %206, align 8
	%208 = sub i64 %205, %207
	%209 = icmp sgt i64 %208, 0
	%210 = select i1 %209, i64 %208, i64 0
	store i64 %210, i64* %2
	br label %switch.done-27

switch.case.next-24:
	%211 = icmp eq i8 %195, 71
	br i1 %211, label %switch.fall.body-26, label %switch.case.next-25

switch.case.next-25:
	br label %switch.done-27

switch.fall.body-26:
	; AssignStmt
	; SelectorExpr
	%212 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %19, i64 0, i32 1
	%213 = load i64, i64* %212, align 8
	store i64 %213, i64* %2
	br label %switch.done-27

switch.done-27:
	br label %if.done-41

if.else-28:
	; SwitchStmt
	%214 = load i8, i8* %1, align 1
	%215 = icmp eq i8 %214, 101
	br i1 %215, label %switch.case.body-31, label %switch.case.next-29

switch.case.next-29:
	%216 = icmp eq i8 %214, 69
	br i1 %216, label %switch.case.body-31, label %switch.case.next-30

switch.case.next-30:
	%217 = icmp eq i8 %214, 102
	br i1 %217, label %switch.fall.body-34, label %switch.case.next-32

switch.case.body-31:
	%218 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%219 = load i64, i64* %2, align 8
	%220 = add i64 %219, 1
	call void @decimal.round(%decimal.Decimal* %218, i64 %220, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-40

switch.case.next-32:
	%221 = icmp eq i8 %214, 70
	br i1 %221, label %switch.fall.body-34, label %switch.case.next-33

switch.case.next-33:
	%222 = icmp eq i8 %214, 103
	br i1 %222, label %switch.fall.body-37, label %switch.case.next-35

switch.fall.body-34:
	%223 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	; SelectorExpr
	%224 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%225 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %224, i64 0
	%226 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %225, i64 0, i32 2
	%227 = load i64, i64* %226, align 8
	%228 = load i64, i64* %2, align 8
	%229 = add i64 %227, %228
	call void @decimal.round(%decimal.Decimal* %223, i64 %229, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-40

switch.case.next-35:
	%230 = icmp eq i8 %214, 71
	br i1 %230, label %switch.fall.body-37, label %switch.case.next-36

switch.case.next-36:
	br label %switch.done-40

switch.fall.body-37:
	; IfStmt
	%231 = load i64, i64* %2, align 8
	%232 = icmp eq i64 %231, 0
	%233 = zext i1 %232 to i8
	%234 = trunc i8 %233 to i1
	br i1 %234, label %if.then-38, label %if.done-39

if.then-38:
	; AssignStmt
	store i64 1, i64* %2
	br label %if.done-39

if.done-39:
	%235 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%236 = load i64, i64* %2, align 8
	call void @decimal.round(%decimal.Decimal* %235, i64 %236, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-40

switch.done-40:
	; AssignStmt
	; CompoundLit
	%237 = bitcast %strconv.DecimalSlice* %23 to %..rawptr
	%238 = call %..rawptr @mem.zero(%..rawptr %237, i64 40) noinline
	store %strconv.DecimalSlice zeroinitializer, %strconv.DecimalSlice* %23
	store %strconv.DecimalSlice {{i8*, i64} zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i8 zeroinitializer}, %strconv.DecimalSlice* %23
	; SliceExpr
	; SelectorExpr
	%239 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%240 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %239, i64 0
	%241 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %240, i64 0, i32 0
	%242 = load [384 x i8], [384 x i8]* %241, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$2fb, i64 0, i32 0), i64 61}, i64 300, i64 40, i64 0, i64 384, i64 384)
	%243 = getelementptr inbounds [384 x i8], [384 x i8]* %241, i64 0, i32 0
	%244 = getelementptr inbounds i8, i8* %243, i64 0
	%245 = sub i64 384, 0
	%246 = bitcast {i8*, i64}* %24 to %..rawptr
	%247 = call %..rawptr @mem.zero(%..rawptr %246, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %24
	%248 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %24, i64 0, i32 0
	store i8* %244, i8** %248
	%249 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %24, i64 0, i32 1
	store i64 %245, i64* %249
	%250 = load {i8*, i64}, {i8*, i64}* %24, align 8
	%251 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %23, i64 0, i32 0
	store {i8*, i64} %250, {i8*, i64}* %251
	; SelectorExpr
	%252 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%253 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %252, i64 0
	%254 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %253, i64 0, i32 1
	%255 = load i64, i64* %254, align 8
	%256 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %23, i64 0, i32 1
	store i64 %255, i64* %256
	; SelectorExpr
	%257 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%258 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %257, i64 0
	%259 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %258, i64 0, i32 2
	%260 = load i64, i64* %259, align 8
	%261 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %23, i64 0, i32 2
	store i64 %260, i64* %261
	%262 = load %strconv.DecimalSlice, %strconv.DecimalSlice* %23, align 8
	store %strconv.DecimalSlice %262, %strconv.DecimalSlice* %19
	br label %if.done-41

if.done-41:
	; ReturnStmt
	%263 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%264 = load i8, i8* %20, align 1
	%265 = load i8, i8* %7, align 1
	%266 = load %strconv.DecimalSlice, %strconv.DecimalSlice* %19, align 8
	%267 = load i64, i64* %2, align 8
	%268 = load i8, i8* %1, align 1
	%269 = bitcast {i8*, i64}* %25 to %..rawptr
	%270 = call %..rawptr @mem.zero(%..rawptr %269, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %25
	store {i8*, i64} %263, {i8*, i64}* %25
	%271 = trunc i8 %264 to i1
	%272 = trunc i8 %265 to i1
	%273 = bitcast %strconv.DecimalSlice* %26 to %..rawptr
	%274 = call %..rawptr @mem.zero(%..rawptr %273, i64 40) noinline
	store %strconv.DecimalSlice zeroinitializer, %strconv.DecimalSlice* %26
	store %strconv.DecimalSlice %266, %strconv.DecimalSlice* %26
	%275 = call {i8*, i64} @strconv.format_digits({i8*, i64}* %25, i1 %271, i1 %272, %strconv.DecimalSlice* %26, i64 %267, i8 %268, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i8*, i64} %275
}

define {i8*, i64} @strconv.format_digits({i8*, i64}* %buf, i1 %shortest, i1 %neg, %strconv.DecimalSlice* %digs, i64 %prec, i8 %fmt, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i8, align 16
	%4 = alloca %strconv.format_digits.Buffer-1466, align 16
	%5 = alloca %strconv.format_digits.Buffer-1466, align 16
	%6 = alloca {i8*, i64}, align 16
	%7 = alloca [1 x i8], align 16
	%8 = alloca {i8*, i64}, align 16
	%9 = alloca i64, align 16
	%10 = alloca {i8*, i64}, align 16
	%11 = alloca {i8*, i64}, align 16
	%12 = alloca {i8*, i64}, align 16
	%13 = alloca [1 x i8], align 16
	%14 = alloca {i8*, i64}, align 16
	%15 = alloca {i8*, i64}, align 16
	%16 = alloca [1 x i8], align 16
	%17 = alloca {i8*, i64}, align 16
	%18 = alloca {i8*, i64}, align 16
	%19 = alloca [1 x i8], align 16
	%20 = alloca {i8*, i64}, align 16
	%21 = alloca i64, align 16
	%22 = alloca i64, align 16
	%23 = alloca i64, align 16
	%24 = alloca i8, align 16
	%25 = alloca i64, align 16
	%26 = alloca {i8*, i64}, align 16
	%27 = alloca [1 x i8], align 16
	%28 = alloca {i8*, i64}, align 16
	%29 = alloca %strconv.format_digits.Buffer-1466, align 16
	%30 = alloca %runtime.Source_Code_Location, align 16
	%31 = alloca %strconv.format_digits.Buffer-1466, align 16
	%32 = alloca %runtime.Source_Code_Location, align 16
	%33 = alloca %strconv.format_digits.Buffer-1466, align 16
	%34 = alloca {i8*, i64}, align 16
	%35 = alloca [2 x i8], align 16
	%36 = alloca {i8*, i64}, align 16
	%37 = alloca %strconv.format_digits.Buffer-1466, align 16
	%38 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%39 = zext i1 %shortest to i8
	store i8 %39, i8* %0
	%40 = zext i1 %neg to i8
	store i8 %40, i8* %1
	%41 = load %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, align 8
	store i64 %prec, i64* %2
	store i8 %fmt, i8* %3
	; b
	; CompoundLit
	%42 = bitcast %strconv.format_digits.Buffer-1466* %5 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 24) noinline
	store %strconv.format_digits.Buffer-1466 zeroinitializer, %strconv.format_digits.Buffer-1466* %5
	store %strconv.format_digits.Buffer-1466 {{i8*, i64} zeroinitializer, i64 zeroinitializer}, %strconv.format_digits.Buffer-1466* %5
	%44 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%45 = getelementptr inbounds %strconv.format_digits.Buffer-1466, %strconv.format_digits.Buffer-1466* %5, i64 0, i32 0
	store {i8*, i64} %44, {i8*, i64}* %45
	%46 = load %strconv.format_digits.Buffer-1466, %strconv.format_digits.Buffer-1466* %5, align 8
	store %strconv.format_digits.Buffer-1466 %46, %strconv.format_digits.Buffer-1466* %4
	; SwitchStmt
	%47 = load i8, i8* %3, align 1
	%48 = icmp eq i8 %47, 102
	br i1 %48, label %switch.case.body-3, label %switch.case.next-1

switch.case.next-1:
	%49 = icmp eq i8 %47, 70
	br i1 %49, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%50 = icmp eq i8 %47, 101
	br i1 %50, label %switch.fall.body-23, label %switch.case.next-21

switch.case.body-3:
	; TernaryExpr
	%51 = load i8, i8* %1, align 1
	%52 = trunc i8 %51 to i1
	br i1 %52, label %if.then-4, label %if.else-5

if.then-4:
	br label %if.done-6

if.else-5:
	br label %if.done-6

if.done-6:
	%53 = phi i32 [ 45, %if.then-4 ], [ 43, %if.else-5 ]
	%54 = trunc i32 %53 to i8
	; variadic call argument generation
	%55 = bitcast {i8*, i64}* %6 to %..rawptr
	%56 = call %..rawptr @mem.zero(%..rawptr %55, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	%57 = bitcast [1 x i8]* %7 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 1) noinline
	store [1 x i8] zeroinitializer, [1 x i8]* %7
	%59 = getelementptr inbounds [1 x i8], [1 x i8]* %7, i64 0, i32 0
	store i8 %54, i8* %59
	%60 = getelementptr inbounds [1 x i8], [1 x i8]* %7, i64 0, i32 0
	%61 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %6, i64 0, i32 0
	store i8* %60, i8** %61
	%62 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %6, i64 0, i32 1
	store i64 1, i64* %62
	%63 = load {i8*, i64}, {i8*, i64}* %6, align 8
	%64 = bitcast {i8*, i64}* %8 to %..rawptr
	%65 = call %..rawptr @mem.zero(%..rawptr %64, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %8
	store {i8*, i64} %63, {i8*, i64}* %8
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-1466* %4, {i8*, i64}* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%66 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 2
	%67 = load i64, i64* %66, align 8
	%68 = icmp sgt i64 %67, 0
	%69 = zext i1 %68 to i8
	%70 = trunc i8 %69 to i1
	br i1 %70, label %if.then-7, label %if.else-11

if.then-7:
	; m
	; min
	; SelectorExpr
	%71 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 1
	%72 = load i64, i64* %71, align 8
	; SelectorExpr
	%73 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 2
	%74 = load i64, i64* %73, align 8
	%75 = icmp slt i64 %72, %74
	%76 = select i1 %75, i64 %72, i64 %74
	store i64 %76, i64* %9
	; SliceExpr
	%77 = load i64, i64* %9, align 8
	; SelectorExpr
	%78 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 0
	%79 = load {i8*, i64}, {i8*, i64}* %78, align 8
	%80 = extractvalue {i8*, i64} %79, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$2fc, i64 0, i32 0), i64 61}, i64 327, i64 31, i64 0, i64 %77, i64 %80)
	%81 = extractvalue {i8*, i64} %79, 0
	%82 = getelementptr inbounds i8, i8* %81, i64 0
	%83 = sub i64 %77, 0
	%84 = bitcast {i8*, i64}* %10 to %..rawptr
	%85 = call %..rawptr @mem.zero(%..rawptr %84, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %10
	%86 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %10, i64 0, i32 0
	store i8* %82, i8** %86
	%87 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %10, i64 0, i32 1
	store i64 %83, i64* %87
	%88 = load {i8*, i64}, {i8*, i64}* %10, align 8
	%89 = bitcast {i8*, i64}* %11 to %..rawptr
	%90 = call %..rawptr @mem.zero(%..rawptr %89, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %11
	store {i8*, i64} %88, {i8*, i64}* %11
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-1466* %4, {i8*, i64}* %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ForStmt
	br label %for.loop-8

for.loop-8:
	%91 = load i64, i64* %9, align 8
	; SelectorExpr
	%92 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 2
	%93 = load i64, i64* %92, align 8
	%94 = icmp slt i64 %91, %93
	%95 = zext i1 %94 to i8
	%96 = trunc i8 %95 to i1
	br i1 %96, label %for.body-9, label %for.done-10

for.body-9:
	; variadic call argument generation
	%97 = bitcast {i8*, i64}* %12 to %..rawptr
	%98 = call %..rawptr @mem.zero(%..rawptr %97, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %12
	%99 = bitcast [1 x i8]* %13 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 1) noinline
	store [1 x i8] zeroinitializer, [1 x i8]* %13
	%101 = getelementptr inbounds [1 x i8], [1 x i8]* %13, i64 0, i32 0
	store i8 48, i8* %101
	%102 = getelementptr inbounds [1 x i8], [1 x i8]* %13, i64 0, i32 0
	%103 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %12, i64 0, i32 0
	store i8* %102, i8** %103
	%104 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %12, i64 0, i32 1
	store i64 1, i64* %104
	%105 = load {i8*, i64}, {i8*, i64}* %12, align 8
	%106 = bitcast {i8*, i64}* %14 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %14
	store {i8*, i64} %105, {i8*, i64}* %14
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-1466* %4, {i8*, i64}* %14, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	%108 = load i64, i64* %9, align 8
	%109 = add i64 %108, 1
	store i64 %109, i64* %9
	br label %for.loop-8

for.done-10:
	br label %if.done-12

if.else-11:
	; variadic call argument generation
	%110 = bitcast {i8*, i64}* %15 to %..rawptr
	%111 = call %..rawptr @mem.zero(%..rawptr %110, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %15
	%112 = bitcast [1 x i8]* %16 to %..rawptr
	%113 = call %..rawptr @mem.zero(%..rawptr %112, i64 1) noinline
	store [1 x i8] zeroinitializer, [1 x i8]* %16
	%114 = getelementptr inbounds [1 x i8], [1 x i8]* %16, i64 0, i32 0
	store i8 48, i8* %114
	%115 = getelementptr inbounds [1 x i8], [1 x i8]* %16, i64 0, i32 0
	%116 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %15, i64 0, i32 0
	store i8* %115, i8** %116
	%117 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %15, i64 0, i32 1
	store i64 1, i64* %117
	%118 = load {i8*, i64}, {i8*, i64}* %15, align 8
	%119 = bitcast {i8*, i64}* %17 to %..rawptr
	%120 = call %..rawptr @mem.zero(%..rawptr %119, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %17
	store {i8*, i64} %118, {i8*, i64}* %17
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-1466* %4, {i8*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-12

if.done-12:
	; IfStmt
	%121 = load i64, i64* %2, align 8
	%122 = icmp sgt i64 %121, 0
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-13, label %if.done-20

if.then-13:
	; variadic call argument generation
	%125 = bitcast {i8*, i64}* %18 to %..rawptr
	%126 = call %..rawptr @mem.zero(%..rawptr %125, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %18
	%127 = bitcast [1 x i8]* %19 to %..rawptr
	%128 = call %..rawptr @mem.zero(%..rawptr %127, i64 1) noinline
	store [1 x i8] zeroinitializer, [1 x i8]* %19
	%129 = getelementptr inbounds [1 x i8], [1 x i8]* %19, i64 0, i32 0
	store i8 46, i8* %129
	%130 = getelementptr inbounds [1 x i8], [1 x i8]* %19, i64 0, i32 0
	%131 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %18, i64 0, i32 0
	store i8* %130, i8** %131
	%132 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %18, i64 0, i32 1
	store i64 1, i64* %132
	%133 = load {i8*, i64}, {i8*, i64}* %18, align 8
	%134 = bitcast {i8*, i64}* %20 to %..rawptr
	%135 = call %..rawptr @mem.zero(%..rawptr %134, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %20
	store {i8*, i64} %133, {i8*, i64}* %20
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-1466* %4, {i8*, i64}* %20, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; i
	%136 = bitcast i64* %21 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 8) noinline
	store i64 zeroinitializer, i64* %21
	%138 = bitcast i64* %22 to %..rawptr
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 8) noinline
	store i64 zeroinitializer, i64* %22
	store i64 0, i64* %22
	%140 = bitcast i64* %23 to %..rawptr
	%141 = call %..rawptr @mem.zero(%..rawptr %140, i64 8) noinline
	store i64 zeroinitializer, i64* %23
	store i64 0, i64* %23
	br label %for.interval.loop-14

for.interval.loop-14:
	%142 = load i64, i64* %2, align 8
	%143 = sub i64 %142, 1
	%144 = load i64, i64* %22, align 8
	%145 = icmp sle i64 %144, %143
	br i1 %145, label %for.interval.body-15, label %for.interval.done-19

for.interval.body-15:
	%146 = load i64, i64* %22, align 8
	%147 = load i64, i64* %23, align 8
	%148 = load i64, i64* %22, align 8
	%149 = add i64 %148, 1
	store i64 %149, i64* %22
	%150 = load i64, i64* %23, align 8
	%151 = add i64 %150, 1
	store i64 %151, i64* %23
	store i64 %146, i64* %21
	; c
	store i8 48, i8* %24
	; IfStmt
	; j
	; SelectorExpr
	%152 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 2
	%153 = load i64, i64* %152, align 8
	%154 = load i64, i64* %21, align 8
	%155 = add i64 %153, %154
	store i64 %155, i64* %25
	%156 = load i64, i64* %25, align 8
	%157 = icmp sle i64 0, %156
	%158 = zext i1 %157 to i8
	%159 = trunc i8 %158 to i1
	br i1 %159, label %cmp.and-16, label %if.done-18

cmp.and-16:
	%160 = load i64, i64* %25, align 8
	; SelectorExpr
	%161 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 1
	%162 = load i64, i64* %161, align 8
	%163 = icmp slt i64 %160, %162
	%164 = zext i1 %163 to i8
	%165 = trunc i8 %164 to i1
	br i1 %165, label %if.then-17, label %if.done-18

if.then-17:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%166 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 0
	%167 = load {i8*, i64}, {i8*, i64}* %166, align 8
	%168 = extractvalue {i8*, i64} %167, 0
	%169 = load i64, i64* %25, align 8
	%170 = extractvalue {i8*, i64} %167, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$2fd, i64 0, i32 0), i64 61}, i64 342, i64 22, i64 %169, i64 %170)
	%171 = getelementptr inbounds i8, i8* %168, i64 %169
	%172 = load i8, i8* %171, align 1
	store i8 %172, i8* %24
	br label %if.done-18

if.done-18:
	%173 = load i8, i8* %24, align 1
	; variadic call argument generation
	%174 = bitcast {i8*, i64}* %26 to %..rawptr
	%175 = call %..rawptr @mem.zero(%..rawptr %174, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %26
	%176 = bitcast [1 x i8]* %27 to %..rawptr
	%177 = call %..rawptr @mem.zero(%..rawptr %176, i64 1) noinline
	store [1 x i8] zeroinitializer, [1 x i8]* %27
	%178 = getelementptr inbounds [1 x i8], [1 x i8]* %27, i64 0, i32 0
	store i8 %173, i8* %178
	%179 = getelementptr inbounds [1 x i8], [1 x i8]* %27, i64 0, i32 0
	%180 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %26, i64 0, i32 0
	store i8* %179, i8** %180
	%181 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %26, i64 0, i32 1
	store i64 1, i64* %181
	%182 = load {i8*, i64}, {i8*, i64}* %26, align 8
	%183 = bitcast {i8*, i64}* %28 to %..rawptr
	%184 = call %..rawptr @mem.zero(%..rawptr %183, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %28
	store {i8*, i64} %182, {i8*, i64}* %28
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-1466* %4, {i8*, i64}* %28, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-14

for.interval.done-19:
	br label %if.done-20

if.done-20:
	; ReturnStmt
	%185 = load %strconv.format_digits.Buffer-1466, %strconv.format_digits.Buffer-1466* %4, align 8
	%186 = bitcast %strconv.format_digits.Buffer-1466* %29 to %..rawptr
	%187 = call %..rawptr @mem.zero(%..rawptr %186, i64 24) noinline
	store %strconv.format_digits.Buffer-1466 zeroinitializer, %strconv.format_digits.Buffer-1466* %29
	store %strconv.format_digits.Buffer-1466 %185, %strconv.format_digits.Buffer-1466* %29
	%188 = call {i8*, i64} @strconv.format_digits.to_bytes-0(%strconv.format_digits.Buffer-1466* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i8*, i64} %188

switch.case.next-21:
	%189 = icmp eq i8 %47, 69
	br i1 %189, label %switch.fall.body-23, label %switch.case.next-22

switch.case.next-22:
	%190 = icmp eq i8 %47, 103
	br i1 %190, label %switch.fall.body-26, label %switch.case.next-24

switch.fall.body-23:
	%191 = bitcast %runtime.Source_Code_Location* %30 to %..rawptr
	%192 = call %..rawptr @mem.zero(%..rawptr %191, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %30
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$2fe, i64 0, i32 0), i64 61}, i64 350, i64 3, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$2ff, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %30
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([49 x i8], [49 x i8]* @str$300, i64 0, i32 0), i64 48}, %runtime.Source_Code_Location* %30) noreturn
	; ReturnStmt
	%193 = load %strconv.format_digits.Buffer-1466, %strconv.format_digits.Buffer-1466* %4, align 8
	%194 = bitcast %strconv.format_digits.Buffer-1466* %31 to %..rawptr
	%195 = call %..rawptr @mem.zero(%..rawptr %194, i64 24) noinline
	store %strconv.format_digits.Buffer-1466 zeroinitializer, %strconv.format_digits.Buffer-1466* %31
	store %strconv.format_digits.Buffer-1466 %193, %strconv.format_digits.Buffer-1466* %31
	%196 = call {i8*, i64} @strconv.format_digits.to_bytes-0(%strconv.format_digits.Buffer-1466* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i8*, i64} %196

switch.case.next-24:
	%197 = icmp eq i8 %47, 71
	br i1 %197, label %switch.fall.body-26, label %switch.case.next-25

switch.case.next-25:
	%198 = load i8, i8* %3, align 1
	; variadic call argument generation
	%199 = bitcast {i8*, i64}* %34 to %..rawptr
	%200 = call %..rawptr @mem.zero(%..rawptr %199, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %34
	%201 = bitcast [2 x i8]* %35 to %..rawptr
	%202 = call %..rawptr @mem.zero(%..rawptr %201, i64 2) noinline
	store [2 x i8] zeroinitializer, [2 x i8]* %35
	%203 = getelementptr inbounds [2 x i8], [2 x i8]* %35, i64 0, i32 0
	store i8 37, i8* %203
	%204 = getelementptr inbounds [2 x i8], [2 x i8]* %35, i64 0, i32 1
	store i8 %198, i8* %204
	%205 = getelementptr inbounds [2 x i8], [2 x i8]* %35, i64 0, i32 0
	%206 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %34, i64 0, i32 0
	store i8* %205, i8** %206
	%207 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %34, i64 0, i32 1
	store i64 2, i64* %207
	%208 = load {i8*, i64}, {i8*, i64}* %34, align 8
	%209 = bitcast {i8*, i64}* %36 to %..rawptr
	%210 = call %..rawptr @mem.zero(%..rawptr %209, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %36
	store {i8*, i64} %208, {i8*, i64}* %36
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-1466* %4, {i8*, i64}* %36, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%211 = load %strconv.format_digits.Buffer-1466, %strconv.format_digits.Buffer-1466* %4, align 8
	%212 = bitcast %strconv.format_digits.Buffer-1466* %37 to %..rawptr
	%213 = call %..rawptr @mem.zero(%..rawptr %212, i64 24) noinline
	store %strconv.format_digits.Buffer-1466 zeroinitializer, %strconv.format_digits.Buffer-1466* %37
	store %strconv.format_digits.Buffer-1466 %211, %strconv.format_digits.Buffer-1466* %37
	%214 = call {i8*, i64} @strconv.format_digits.to_bytes-0(%strconv.format_digits.Buffer-1466* %37, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i8*, i64} %214

switch.fall.body-26:
	%215 = bitcast %runtime.Source_Code_Location* %32 to %..rawptr
	%216 = call %..rawptr @mem.zero(%..rawptr %215, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %32
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$301, i64 0, i32 0), i64 61}, i64 354, i64 3, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$302, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %32
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([49 x i8], [49 x i8]* @str$303, i64 0, i32 0), i64 48}, %runtime.Source_Code_Location* %32) noreturn
	; ReturnStmt
	%217 = load %strconv.format_digits.Buffer-1466, %strconv.format_digits.Buffer-1466* %4, align 8
	%218 = bitcast %strconv.format_digits.Buffer-1466* %33 to %..rawptr
	%219 = call %..rawptr @mem.zero(%..rawptr %218, i64 24) noinline
	store %strconv.format_digits.Buffer-1466 zeroinitializer, %strconv.format_digits.Buffer-1466* %33
	store %strconv.format_digits.Buffer-1466 %217, %strconv.format_digits.Buffer-1466* %33
	%220 = call {i8*, i64} @strconv.format_digits.to_bytes-0(%strconv.format_digits.Buffer-1466* %33, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i8*, i64} %220
}

define {i8*, i64} @strconv.format_digits.to_bytes-0(%strconv.format_digits.Buffer-1466* %b, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64}, align 16
	%1 = load %strconv.format_digits.Buffer-1466, %strconv.format_digits.Buffer-1466* %b, align 8
	; ReturnStmt
	; SliceExpr
	; SelectorExpr
	%2 = getelementptr inbounds %strconv.format_digits.Buffer-1466, %strconv.format_digits.Buffer-1466* %b, i64 0, i32 1
	%3 = load i64, i64* %2, align 8
	; SelectorExpr
	%4 = getelementptr inbounds %strconv.format_digits.Buffer-1466, %strconv.format_digits.Buffer-1466* %b, i64 0, i32 0
	%5 = load {i8*, i64}, {i8*, i64}* %4, align 8
	%6 = extractvalue {i8*, i64} %5, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$304, i64 0, i32 0), i64 61}, i64 313, i64 53, i64 0, i64 %3, i64 %6)
	%7 = extractvalue {i8*, i64} %5, 0
	%8 = getelementptr inbounds i8, i8* %7, i64 0
	%9 = sub i64 %3, 0
	%10 = bitcast {i8*, i64}* %0 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %0
	%12 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %0, i64 0, i32 0
	store i8* %8, i8** %12
	%13 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %0, i64 0, i32 1
	store i64 %9, i64* %13
	%14 = load {i8*, i64}, {i8*, i64}* %0, align 8
	ret {i8*, i64} %14
}

define void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-1466* %buf, {i8*, i64}* %bytes, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %strconv.format_digits.Buffer-1466*, align 16
	%1 = alloca {i8*, i64}, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca {i8*, i64}, align 16
	store %strconv.format_digits.Buffer-1466* %buf, %strconv.format_digits.Buffer-1466** %0
	%4 = load {i8*, i64}, {i8*, i64}* %bytes, align 8
	; AssignStmt
	; SelectorExpr
	%5 = load %strconv.format_digits.Buffer-1466*, %strconv.format_digits.Buffer-1466** %0, align 8
	%6 = getelementptr inbounds %strconv.format_digits.Buffer-1466, %strconv.format_digits.Buffer-1466* %5, i64 0
	%7 = getelementptr inbounds %strconv.format_digits.Buffer-1466, %strconv.format_digits.Buffer-1466* %6, i64 0, i32 1
	; SliceExpr
	; SelectorExpr
	%8 = load %strconv.format_digits.Buffer-1466*, %strconv.format_digits.Buffer-1466** %0, align 8
	%9 = getelementptr inbounds %strconv.format_digits.Buffer-1466, %strconv.format_digits.Buffer-1466* %8, i64 0
	%10 = getelementptr inbounds %strconv.format_digits.Buffer-1466, %strconv.format_digits.Buffer-1466* %9, i64 0, i32 1
	%11 = load i64, i64* %10, align 8
	; SelectorExpr
	%12 = load %strconv.format_digits.Buffer-1466*, %strconv.format_digits.Buffer-1466** %0, align 8
	%13 = getelementptr inbounds %strconv.format_digits.Buffer-1466, %strconv.format_digits.Buffer-1466* %12, i64 0
	%14 = getelementptr inbounds %strconv.format_digits.Buffer-1466, %strconv.format_digits.Buffer-1466* %13, i64 0, i32 0
	%15 = load {i8*, i64}, {i8*, i64}* %14, align 8
	%16 = extractvalue {i8*, i64} %15, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$305, i64 0, i32 0), i64 61}, i64 315, i64 22, i64 %11, i64 %16, i64 %16)
	%17 = extractvalue {i8*, i64} %15, 0
	%18 = getelementptr inbounds i8, i8* %17, i64 %11
	%19 = sub i64 %16, %11
	%20 = bitcast {i8*, i64}* %1 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %1
	%22 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1, i64 0, i32 0
	store i8* %18, i8** %22
	%23 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1, i64 0, i32 1
	store i64 %19, i64* %23
	%24 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%25 = load {i8*, i64}, {i8*, i64}* %bytes, align 8
	%26 = bitcast {i8*, i64}* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %2
	store {i8*, i64} %24, {i8*, i64}* %2
	%28 = bitcast {i8*, i64}* %3 to %..rawptr
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %3
	store {i8*, i64} %25, {i8*, i64}* %3
	%30 = call i64 @runtime.copy-18955({i8*, i64}* %2, {i8*, i64}* %3)
	%31 = load i64, i64* %7, align 8
	%32 = add i64 %31, %30
	store i64 %32, i64* %7
	ret void
}

define void @strconv.round_shortest(%decimal.Decimal* %d, i64 %mant, i64 %exp, %strconv.FloatInfo* %flt, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %strconv.FloatInfo*, align 16
	%4 = alloca i64, align 16
	%5 = alloca %decimal.Decimal, align 16
	%6 = alloca %decimal.Decimal*, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca %decimal.Decimal, align 16
	%10 = alloca %decimal.Decimal*, align 16
	%11 = alloca i8, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca i8, align 16
	%17 = alloca i8, align 16
	%18 = alloca i8, align 16
	%19 = alloca i8, align 16
	store %decimal.Decimal* %d, %decimal.Decimal** %0
	store i64 %mant, i64* %1
	store i64 %exp, i64* %2
	store %strconv.FloatInfo* %flt, %strconv.FloatInfo** %3
	; IfStmt
	%20 = load i64, i64* %1, align 8
	%21 = icmp eq i64 %20, 0
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; SelectorExpr
	%24 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%25 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %24, i64 0
	%26 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %25, i64 0, i32 1
	store i64 0, i64* %26
	; ReturnStmt
	ret void

if.done-2:
	; minexp
	; SelectorExpr
	%27 = load %strconv.FloatInfo*, %strconv.FloatInfo** %3, align 8
	%28 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %27, i64 0
	%29 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %28, i64 0, i32 2
	%30 = load i64, i64* %29, align 8
	%31 = add i64 %30, 1
	store i64 %31, i64* %4
	; IfStmt
	%32 = load i64, i64* %2, align 8
	%33 = load i64, i64* %4, align 8
	%34 = icmp sgt i64 %32, %33
	%35 = zext i1 %34 to i8
	%36 = trunc i8 %35 to i1
	br i1 %36, label %cmp.and-3, label %if.done-5

cmp.and-3:
	; SelectorExpr
	%37 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%38 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %37, i64 0
	%39 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %38, i64 0, i32 2
	%40 = load i64, i64* %39, align 8
	; SelectorExpr
	%41 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%42 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %41, i64 0
	%43 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %42, i64 0, i32 1
	%44 = load i64, i64* %43, align 8
	%45 = sub i64 %40, %44
	%46 = mul i64 332, %45
	%47 = load i64, i64* %2, align 8
	; SelectorExpr
	%48 = load %strconv.FloatInfo*, %strconv.FloatInfo** %3, align 8
	%49 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %48, i64 0
	%50 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %49, i64 0, i32 0
	%51 = load i64, i64* %50, align 8
	%52 = bitcast i64 %51 to i64
	%53 = sub i64 %47, %52
	%54 = mul i64 100, %53
	%55 = icmp sge i64 %46, %54
	%56 = zext i1 %55 to i8
	%57 = trunc i8 %56 to i1
	br i1 %57, label %if.then-4, label %if.done-5

if.then-4:
	; ReturnStmt
	ret void

if.done-5:
	; upper_
	%58 = bitcast %decimal.Decimal* %5 to %..rawptr
	%59 = call %..rawptr @mem.zero(%..rawptr %58, i64 408) noinline
	store %decimal.Decimal zeroinitializer, %decimal.Decimal* %5
	; upper
	store %decimal.Decimal* %5, %decimal.Decimal** %6
	%60 = load %decimal.Decimal*, %decimal.Decimal** %6, align 8
	%61 = load i64, i64* %1, align 8
	%62 = mul i64 2, %61
	%63 = sub i64 %62, 1
	call void @decimal.assign(%decimal.Decimal* %60, i64 %63, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%64 = load %decimal.Decimal*, %decimal.Decimal** %6, align 8
	%65 = load i64, i64* %2, align 8
	; SelectorExpr
	%66 = load %strconv.FloatInfo*, %strconv.FloatInfo** %3, align 8
	%67 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %66, i64 0
	%68 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %67, i64 0, i32 0
	%69 = load i64, i64* %68, align 8
	%70 = bitcast i64 %69 to i64
	%71 = sub i64 %65, %70
	%72 = sub i64 %71, 1
	call void @decimal.shift(%decimal.Decimal* %64, i64 %72, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; mantlo
	%73 = bitcast i64* %7 to %..rawptr
	%74 = call %..rawptr @mem.zero(%..rawptr %73, i64 8) noinline
	store i64 zeroinitializer, i64* %7
	; explo
	%75 = bitcast i64* %8 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 8) noinline
	store i64 zeroinitializer, i64* %8
	; IfStmt
	%77 = load i64, i64* %1, align 8
	; SelectorExpr
	%78 = load %strconv.FloatInfo*, %strconv.FloatInfo** %3, align 8
	%79 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %78, i64 0
	%80 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %79, i64 0, i32 0
	%81 = load i64, i64* %80, align 8
	%82 = bitcast i64 %81 to i64
	%83 = shl i64 1, %82
	%84 = bitcast i64 %83 to i64
	%85 = icmp ugt i64 %77, %84
	%86 = zext i1 %85 to i8
	%87 = trunc i8 %86 to i1
	br i1 %87, label %if.then-7, label %cmp.or-6

cmp.or-6:
	%88 = load i64, i64* %2, align 8
	%89 = load i64, i64* %4, align 8
	%90 = icmp eq i64 %88, %89
	%91 = zext i1 %90 to i8
	%92 = trunc i8 %91 to i1
	br i1 %92, label %if.then-7, label %if.else-8

if.then-7:
	; AssignStmt
	%93 = load i64, i64* %1, align 8
	%94 = sub i64 %93, 1
	store i64 %94, i64* %7
	; AssignStmt
	%95 = load i64, i64* %2, align 8
	store i64 %95, i64* %8
	br label %if.done-9

if.else-8:
	; AssignStmt
	%96 = load i64, i64* %1, align 8
	%97 = mul i64 2, %96
	%98 = sub i64 %97, 1
	store i64 %98, i64* %7
	; AssignStmt
	%99 = load i64, i64* %2, align 8
	%100 = sub i64 %99, 1
	store i64 %100, i64* %8
	br label %if.done-9

if.done-9:
	; lower_
	%101 = bitcast %decimal.Decimal* %9 to %..rawptr
	%102 = call %..rawptr @mem.zero(%..rawptr %101, i64 408) noinline
	store %decimal.Decimal zeroinitializer, %decimal.Decimal* %9
	; lower
	store %decimal.Decimal* %9, %decimal.Decimal** %10
	%103 = load %decimal.Decimal*, %decimal.Decimal** %10, align 8
	%104 = load i64, i64* %7, align 8
	%105 = mul i64 2, %104
	%106 = add i64 %105, 1
	call void @decimal.assign(%decimal.Decimal* %103, i64 %106, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%107 = load %decimal.Decimal*, %decimal.Decimal** %10, align 8
	%108 = load i64, i64* %8, align 8
	; SelectorExpr
	%109 = load %strconv.FloatInfo*, %strconv.FloatInfo** %3, align 8
	%110 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %109, i64 0
	%111 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %110, i64 0, i32 0
	%112 = load i64, i64* %111, align 8
	%113 = bitcast i64 %112 to i64
	%114 = sub i64 %108, %113
	%115 = sub i64 %114, 1
	call void @decimal.shift(%decimal.Decimal* %107, i64 %115, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; inclusive
	%116 = load i64, i64* %1, align 8
	%117 = urem i64 %116, 2
	%118 = icmp eq i64 %117, 0
	%119 = zext i1 %118 to i8
	store i8 %119, i8* %11
	; RangeStmt
	; i
	%120 = bitcast i64* %12 to %..rawptr
	%121 = call %..rawptr @mem.zero(%..rawptr %120, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%122 = bitcast i64* %13 to %..rawptr
	%123 = call %..rawptr @mem.zero(%..rawptr %122, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 0, i64* %13
	%124 = bitcast i64* %14 to %..rawptr
	%125 = call %..rawptr @mem.zero(%..rawptr %124, i64 8) noinline
	store i64 zeroinitializer, i64* %14
	store i64 0, i64* %14
	br label %for.interval.loop-10

for.interval.loop-10:
	; SelectorExpr
	%126 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%127 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %126, i64 0
	%128 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %127, i64 0, i32 1
	%129 = load i64, i64* %128, align 8
	%130 = sub i64 %129, 1
	%131 = load i64, i64* %13, align 8
	%132 = icmp sle i64 %131, %130
	br i1 %132, label %for.interval.body-11, label %for.interval.done-34

for.interval.body-11:
	%133 = load i64, i64* %13, align 8
	%134 = load i64, i64* %14, align 8
	%135 = load i64, i64* %13, align 8
	%136 = add i64 %135, 1
	store i64 %136, i64* %13
	%137 = load i64, i64* %14, align 8
	%138 = add i64 %137, 1
	store i64 %138, i64* %14
	store i64 %133, i64* %12
	; l
	store i8 48, i8* %15
	; IfStmt
	%139 = load i64, i64* %12, align 8
	; SelectorExpr
	%140 = load %decimal.Decimal*, %decimal.Decimal** %10, align 8
	%141 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %140, i64 0
	%142 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %141, i64 0, i32 1
	%143 = load i64, i64* %142, align 8
	%144 = icmp slt i64 %139, %143
	%145 = zext i1 %144 to i8
	%146 = trunc i8 %145 to i1
	br i1 %146, label %if.then-12, label %if.done-13

if.then-12:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%147 = load %decimal.Decimal*, %decimal.Decimal** %10, align 8
	%148 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %147, i64 0
	%149 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %148, i64 0, i32 0
	%150 = load i64, i64* %12, align 8
	%151 = trunc i64 %150 to i32
	%152 = getelementptr inbounds [384 x i8], [384 x i8]* %149, i64 0, i32 %151
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$306, i64 0, i32 0), i64 61}, i64 405, i64 21, i64 %150, i64 384)
	%153 = load i8, i8* %152, align 1
	store i8 %153, i8* %15
	br label %if.done-13

if.done-13:
	; m
	; IndexExpr
	; SelectorExpr
	%154 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%155 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %154, i64 0
	%156 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %155, i64 0, i32 0
	%157 = load i64, i64* %12, align 8
	%158 = trunc i64 %157 to i32
	%159 = getelementptr inbounds [384 x i8], [384 x i8]* %156, i64 0, i32 %158
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$307, i64 0, i32 0), i64 61}, i64 407, i64 17, i64 %157, i64 384)
	%160 = load i8, i8* %159, align 1
	store i8 %160, i8* %16
	; u
	store i8 48, i8* %17
	; IfStmt
	%161 = load i64, i64* %12, align 8
	; SelectorExpr
	%162 = load %decimal.Decimal*, %decimal.Decimal** %6, align 8
	%163 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %162, i64 0
	%164 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %163, i64 0, i32 1
	%165 = load i64, i64* %164, align 8
	%166 = icmp slt i64 %161, %165
	%167 = zext i1 %166 to i8
	%168 = trunc i8 %167 to i1
	br i1 %168, label %if.then-14, label %if.done-15

if.then-14:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%169 = load %decimal.Decimal*, %decimal.Decimal** %6, align 8
	%170 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %169, i64 0
	%171 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %170, i64 0, i32 0
	%172 = load i64, i64* %12, align 8
	%173 = trunc i64 %172 to i32
	%174 = getelementptr inbounds [384 x i8], [384 x i8]* %171, i64 0, i32 %173
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$308, i64 0, i32 0), i64 61}, i64 410, i64 21, i64 %172, i64 384)
	%175 = load i8, i8* %174, align 1
	store i8 %175, i8* %17
	br label %if.done-15

if.done-15:
	; ok_round_down
	%176 = load i8, i8* %15, align 1
	%177 = load i8, i8* %16, align 1
	%178 = icmp ne i8 %176, %177
	%179 = zext i1 %178 to i8
	%180 = load i8, i8* %15, align 1
	%181 = load i8, i8* %16, align 1
	%182 = icmp ne i8 %180, %181
	%183 = zext i1 %182 to i8
	%184 = trunc i8 %183 to i1
	br i1 %184, label %logical.cmp.done-19, label %logical.cmp.rhs-16

logical.cmp.rhs-16:
	%185 = load i8, i8* %11, align 1
	%186 = load i8, i8* %11, align 1
	%187 = trunc i8 %186 to i1
	br i1 %187, label %logical.cmp.rhs-17, label %logical.cmp.done-18

logical.cmp.rhs-17:
	%188 = load i64, i64* %12, align 8
	%189 = add i64 %188, 1
	; SelectorExpr
	%190 = load %decimal.Decimal*, %decimal.Decimal** %10, align 8
	%191 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %190, i64 0
	%192 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %191, i64 0, i32 1
	%193 = load i64, i64* %192, align 8
	%194 = icmp eq i64 %189, %193
	%195 = zext i1 %194 to i8
	br label %logical.cmp.done-18

logical.cmp.done-18:
	%196 = phi i8 [ 0, %logical.cmp.rhs-16 ], [ %195, %logical.cmp.rhs-17 ]
	br label %logical.cmp.done-19

logical.cmp.done-19:
	%197 = phi i8 [ 1, %if.done-15 ], [ %196, %logical.cmp.done-18 ]
	store i8 %197, i8* %18
	; ok_round_up
	%198 = load i8, i8* %16, align 1
	%199 = load i8, i8* %17, align 1
	%200 = icmp ne i8 %198, %199
	%201 = zext i1 %200 to i8
	%202 = load i8, i8* %16, align 1
	%203 = load i8, i8* %17, align 1
	%204 = icmp ne i8 %202, %203
	%205 = zext i1 %204 to i8
	%206 = trunc i8 %205 to i1
	br i1 %206, label %logical.cmp.rhs-20, label %logical.cmp.done-26

logical.cmp.rhs-20:
	%207 = load i8, i8* %11, align 1
	%208 = load i8, i8* %11, align 1
	%209 = trunc i8 %208 to i1
	br i1 %209, label %logical.cmp.done-22, label %logical.cmp.rhs-21

logical.cmp.rhs-21:
	%210 = load i8, i8* %16, align 1
	%211 = add i8 %210, 1
	%212 = load i8, i8* %17, align 1
	%213 = icmp ult i8 %211, %212
	%214 = zext i1 %213 to i8
	br label %logical.cmp.done-22

logical.cmp.done-22:
	%215 = phi i8 [ 1, %logical.cmp.rhs-20 ], [ %214, %logical.cmp.rhs-21 ]
	%216 = load i8, i8* %11, align 1
	%217 = trunc i8 %216 to i1
	br i1 %217, label %logical.cmp.done-25, label %cmp.or-23

cmp.or-23:
	%218 = load i8, i8* %16, align 1
	%219 = add i8 %218, 1
	%220 = load i8, i8* %17, align 1
	%221 = icmp ult i8 %219, %220
	%222 = zext i1 %221 to i8
	%223 = trunc i8 %222 to i1
	br i1 %223, label %logical.cmp.done-25, label %logical.cmp.rhs-24

logical.cmp.rhs-24:
	%224 = load i64, i64* %12, align 8
	%225 = add i64 %224, 1
	; SelectorExpr
	%226 = load %decimal.Decimal*, %decimal.Decimal** %6, align 8
	%227 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %226, i64 0
	%228 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %227, i64 0, i32 1
	%229 = load i64, i64* %228, align 8
	%230 = icmp slt i64 %225, %229
	%231 = zext i1 %230 to i8
	br label %logical.cmp.done-25

logical.cmp.done-25:
	%232 = phi i8 [ 1, %logical.cmp.done-22 ], [ 1, %cmp.or-23 ], [ %231, %logical.cmp.rhs-24 ]
	br label %logical.cmp.done-26

logical.cmp.done-26:
	%233 = phi i8 [ 0, %logical.cmp.done-19 ], [ %232, %logical.cmp.done-25 ]
	store i8 %233, i8* %19
	; IfStmt
	%234 = load i8, i8* %18, align 1
	%235 = trunc i8 %234 to i1
	br i1 %235, label %cmp.and-27, label %if.done-29

cmp.and-27:
	%236 = load i8, i8* %19, align 1
	%237 = trunc i8 %236 to i1
	br i1 %237, label %if.then-28, label %if.done-29

if.then-28:
	%238 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%239 = load i64, i64* %12, align 8
	%240 = add i64 %239, 1
	call void @decimal.round(%decimal.Decimal* %238, i64 %240, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-29:
	; IfStmt
	%241 = load i8, i8* %18, align 1
	%242 = trunc i8 %241 to i1
	br i1 %242, label %if.then-30, label %if.done-31

if.then-30:
	%243 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%244 = load i64, i64* %12, align 8
	%245 = add i64 %244, 1
	call void @decimal.round_down(%decimal.Decimal* %243, i64 %245, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-31:
	; IfStmt
	%246 = load i8, i8* %19, align 1
	%247 = trunc i8 %246 to i1
	br i1 %247, label %if.then-32, label %if.done-33

if.then-32:
	%248 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%249 = load i64, i64* %12, align 8
	%250 = add i64 %249, 1
	call void @decimal.round_up(%decimal.Decimal* %248, i64 %250, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-33:
	br label %for.interval.loop-10

for.interval.done-34:
	ret void
}

define {i64, i8} @strconv.is_integer_negative(i64 %u, i1 %is_signed, i64 %bit_size, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i8, align 16
	%5 = alloca i8, align 16
	%6 = alloca i16, align 16
	%7 = alloca i32, align 16
	%8 = alloca i64, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca {i64, i8}, align 16
	store i64 %u, i64* %0
	%11 = zext i1 %is_signed to i8
	store i8 %11, i8* %1
	store i64 %bit_size, i64* %2
	%12 = bitcast i64* %3 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%14 = bitcast i8* %4 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 1) noinline
	store i8 zeroinitializer, i8* %4
	; IfStmt
	%16 = load i8, i8* %1, align 1
	%17 = trunc i8 %16 to i1
	br i1 %17, label %if.then-1, label %if.done-11

if.then-1:
	; SwitchStmt
	%18 = load i64, i64* %2, align 8
	%19 = icmp eq i64 %18, 8
	br i1 %19, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%20 = icmp eq i64 %18, 16
	br i1 %20, label %switch.fall.body-5, label %switch.case.next-4

switch.case.body-3:
	; i
	%21 = load i64, i64* %0, align 8
	%22 = trunc i64 %21 to i8
	store i8 %22, i8* %5
	; AssignStmt
	%23 = load i8, i8* %5, align 1
	%24 = icmp slt i8 %23, 0
	%25 = zext i1 %24 to i8
	store i8 %25, i8* %4
	; AssignStmt
	%26 = load i8, i8* %5, align 1
	; abs
	%27 = icmp slt i8 %26, 0
	%28 = sub i8 0, %26
	%29 = select i1 %27, i8 %28, i8 %26
	%30 = sext i8 %29 to i64
	store i64 %30, i64* %0
	br label %switch.done-10

switch.case.next-4:
	%31 = icmp eq i64 %18, 32
	br i1 %31, label %switch.fall.body-7, label %switch.case.next-6

switch.fall.body-5:
	; i
	%32 = load i64, i64* %0, align 8
	%33 = trunc i64 %32 to i16
	store i16 %33, i16* %6
	; AssignStmt
	%34 = load i16, i16* %6, align 2
	%35 = icmp slt i16 %34, 0
	%36 = zext i1 %35 to i8
	store i8 %36, i8* %4
	; AssignStmt
	%37 = load i16, i16* %6, align 2
	; abs
	%38 = icmp slt i16 %37, 0
	%39 = sub i16 0, %37
	%40 = select i1 %38, i16 %39, i16 %37
	%41 = sext i16 %40 to i64
	store i64 %41, i64* %0
	br label %switch.done-10

switch.case.next-6:
	%42 = icmp eq i64 %18, 64
	br i1 %42, label %switch.fall.body-9, label %switch.case.next-8

switch.fall.body-7:
	; i
	%43 = load i64, i64* %0, align 8
	%44 = trunc i64 %43 to i32
	store i32 %44, i32* %7
	; AssignStmt
	%45 = load i32, i32* %7, align 4
	%46 = icmp slt i32 %45, 0
	%47 = zext i1 %46 to i8
	store i8 %47, i8* %4
	; AssignStmt
	%48 = load i32, i32* %7, align 4
	; abs
	%49 = icmp slt i32 %48, 0
	%50 = sub i32 0, %48
	%51 = select i1 %49, i32 %50, i32 %48
	%52 = sext i32 %51 to i64
	store i64 %52, i64* %0
	br label %switch.done-10

switch.case.next-8:
	%53 = bitcast %runtime.Source_Code_Location* %9 to %..rawptr
	%54 = call %..rawptr @mem.zero(%..rawptr %53, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %9
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$309, i64 0, i32 0), i64 61}, i64 456, i64 4, %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$30a, i64 0, i32 0), i64 19}}, %runtime.Source_Code_Location* %9
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([42 x i8], [42 x i8]* @str$30b, i64 0, i32 0), i64 41}, %runtime.Source_Code_Location* %9) noreturn
	br label %switch.done-10

switch.fall.body-9:
	; i
	%55 = load i64, i64* %0, align 8
	%56 = bitcast i64 %55 to i64
	store i64 %56, i64* %8
	; AssignStmt
	%57 = load i64, i64* %8, align 8
	%58 = icmp slt i64 %57, 0
	%59 = zext i1 %58 to i8
	store i8 %59, i8* %4
	; AssignStmt
	%60 = load i64, i64* %8, align 8
	; abs
	%61 = icmp slt i64 %60, 0
	%62 = sub i64 0, %60
	%63 = select i1 %61, i64 %62, i64 %60
	%64 = bitcast i64 %63 to i64
	store i64 %64, i64* %0
	br label %switch.done-10

switch.done-10:
	br label %if.done-11

if.done-11:
	; ReturnStmt
	%65 = load i64, i64* %0, align 8
	%66 = load i8, i8* %4, align 1
	%67 = bitcast {i64, i8}* %10 to %..rawptr
	%68 = call %..rawptr @mem.zero(%..rawptr %67, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %10
	%69 = getelementptr inbounds {i64, i8}, {i64, i8}* %10, i64 0, i32 0
	store i64 %65, i64* %69
	%70 = getelementptr inbounds {i64, i8}, {i64, i8}* %10, i64 0, i32 1
	store i8 %66, i8* %70
	%71 = load {i64, i8}, {i64, i8}* %10, align 8
	ret {i64, i8} %71
}

define %..string @strconv.append_bits({i8*, i64}* %buf, i64 %u, i64 %base, i1 %is_signed, i64 %bit_size, %..string %digits, i8 %flags, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..string, align 16
	%5 = alloca i8, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca i8, align 16
	%8 = alloca [129 x i8], align 16
	%9 = alloca i64, align 16
	%10 = alloca i64, align 16
	%11 = alloca i8, align 16
	%12 = alloca {i8*, i64}, align 16
	%13 = alloca {i8*, i64}, align 16
	%14 = alloca {i8*, i64}, align 16
	%15 = alloca {i8*, i64}, align 16
	%16 = alloca {i8*, i64}, align 16
	%17 = alloca %..string, align 16
	%18 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	store i64 %u, i64* %0
	store i64 %base, i64* %1
	%19 = zext i1 %is_signed to i8
	store i8 %19, i8* %2
	store i64 %bit_size, i64* %3
	store %..string %digits, %..string* %4
	store i8 %flags, i8* %5
	; IfStmt
	%20 = load i64, i64* %1, align 8
	%21 = icmp slt i64 %20, 2
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%24 = load i64, i64* %1, align 8
	%25 = icmp sgt i64 %24, 32
	%26 = zext i1 %25 to i8
	%27 = trunc i8 %26 to i1
	br i1 %27, label %if.then-2, label %if.done-3

if.then-2:
	%28 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$30c, i64 0, i32 0), i64 61}, i64 464, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$30d, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([44 x i8], [44 x i8]* @str$30e, i64 0, i32 0), i64 43}, %runtime.Source_Code_Location* %6) noreturn
	br label %if.done-3

if.done-3:
	; neg
	%30 = bitcast i8* %7 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 1) noinline
	store i8 zeroinitializer, i8* %7
	; a
	%32 = bitcast [129 x i8]* %8 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 129) noinline
	store [129 x i8] zeroinitializer, [129 x i8]* %8
	; i
	store i64 129, i64* %9
	; AssignStmt
	%34 = load i64, i64* %0, align 8
	%35 = load i8, i8* %2, align 1
	%36 = load i64, i64* %3, align 8
	%37 = trunc i8 %35 to i1
	%38 = call {i64, i8} @strconv.is_integer_negative(i64 %34, i1 %37, i64 %36, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%39 = extractvalue {i64, i8} %38, 0
	%40 = extractvalue {i64, i8} %38, 1
	store i64 %39, i64* %0
	store i8 %40, i8* %7
	; b
	%41 = load i64, i64* %1, align 8
	%42 = bitcast i64 %41 to i64
	store i64 %42, i64* %10
	; ForStmt
	br label %for.loop-4

for.loop-4:
	%43 = load i64, i64* %0, align 8
	%44 = load i64, i64* %10, align 8
	%45 = icmp uge i64 %43, %44
	%46 = zext i1 %45 to i8
	%47 = trunc i8 %46 to i1
	br i1 %47, label %for.body-5, label %for.done-6

for.body-5:
	; AssignStmt
	%48 = load i64, i64* %9, align 8
	%49 = sub i64 %48, 1
	store i64 %49, i64* %9
	; AssignStmt
	; IndexExpr
	%50 = load i64, i64* %9, align 8
	%51 = trunc i64 %50 to i32
	%52 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %51
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$30f, i64 0, i32 0), i64 61}, i64 473, i64 11, i64 %50, i64 129)
	; IndexExpr
	%53 = load %..string, %..string* %4, align 8
	%54 = extractvalue %..string %53, 0
	%55 = extractvalue %..string %53, 1
	%56 = load i64, i64* %0, align 8
	%57 = load i64, i64* %10, align 8
	%58 = urem i64 %56, %57
	%59 = bitcast i64 %58 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$310, i64 0, i32 0), i64 61}, i64 473, i64 23, i64 %59, i64 %55)
	%60 = getelementptr inbounds i8, i8* %54, i64 %59
	%61 = load i8, i8* %60, align 1
	store i8 %61, i8* %52
	; AssignStmt
	%62 = load i64, i64* %10, align 8
	%63 = load i64, i64* %0, align 8
	%64 = udiv i64 %63, %62
	store i64 %64, i64* %0
	br label %for.loop-4

for.done-6:
	; AssignStmt
	%65 = load i64, i64* %9, align 8
	%66 = sub i64 %65, 1
	store i64 %66, i64* %9
	; AssignStmt
	; IndexExpr
	%67 = load i64, i64* %9, align 8
	%68 = trunc i64 %67 to i32
	%69 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %68
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$311, i64 0, i32 0), i64 61}, i64 476, i64 10, i64 %67, i64 129)
	; IndexExpr
	%70 = load %..string, %..string* %4, align 8
	%71 = extractvalue %..string %70, 0
	%72 = extractvalue %..string %70, 1
	%73 = load i64, i64* %0, align 8
	%74 = load i64, i64* %10, align 8
	%75 = urem i64 %73, %74
	%76 = bitcast i64 %75 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$312, i64 0, i32 0), i64 61}, i64 476, i64 22, i64 %76, i64 %72)
	%77 = getelementptr inbounds i8, i8* %71, i64 %76
	%78 = load i8, i8* %77, align 1
	store i8 %78, i8* %69
	; IfStmt
	%79 = load i8, i8* %5, align 1
	; bit_set in
	%80 = sub i8 0, 0
	%81 = shl i8 1, %80
	%82 = bitcast i8 %79 to i8
	%83 = and i8 %82, %81
	%84 = icmp ne i8 %83, 0
	%85 = zext i1 %84 to i8
	%86 = trunc i8 %85 to i1
	br i1 %86, label %if.then-7, label %if.done-21

if.then-7:
	; ok
	store i8 1, i8* %11
	; SwitchStmt
	%87 = load i64, i64* %1, align 8
	%88 = icmp eq i64 %87, 2
	br i1 %88, label %switch.case.body-9, label %switch.case.next-8

switch.case.next-8:
	%89 = icmp eq i64 %87, 8
	br i1 %89, label %switch.fall.body-11, label %switch.case.next-10

switch.case.body-9:
	; AssignStmt
	%90 = load i64, i64* %9, align 8
	%91 = sub i64 %90, 1
	store i64 %91, i64* %9
	; AssignStmt
	; IndexExpr
	%92 = load i64, i64* %9, align 8
	%93 = trunc i64 %92 to i32
	%94 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %93
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$313, i64 0, i32 0), i64 61}, i64 481, i64 20, i64 %92, i64 129)
	store i8 98, i8* %94
	br label %switch.done-18

switch.case.next-10:
	%95 = icmp eq i64 %87, 10
	br i1 %95, label %switch.fall.body-13, label %switch.case.next-12

switch.fall.body-11:
	; AssignStmt
	%96 = load i64, i64* %9, align 8
	%97 = sub i64 %96, 1
	store i64 %97, i64* %9
	; AssignStmt
	; IndexExpr
	%98 = load i64, i64* %9, align 8
	%99 = trunc i64 %98 to i32
	%100 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %99
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$314, i64 0, i32 0), i64 61}, i64 482, i64 20, i64 %98, i64 129)
	store i8 111, i8* %100
	br label %switch.done-18

switch.case.next-12:
	%101 = icmp eq i64 %87, 12
	br i1 %101, label %switch.fall.body-15, label %switch.case.next-14

switch.fall.body-13:
	; AssignStmt
	%102 = load i64, i64* %9, align 8
	%103 = sub i64 %102, 1
	store i64 %103, i64* %9
	; AssignStmt
	; IndexExpr
	%104 = load i64, i64* %9, align 8
	%105 = trunc i64 %104 to i32
	%106 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %105
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$315, i64 0, i32 0), i64 61}, i64 483, i64 20, i64 %104, i64 129)
	store i8 100, i8* %106
	br label %switch.done-18

switch.case.next-14:
	%107 = icmp eq i64 %87, 16
	br i1 %107, label %switch.fall.body-17, label %switch.case.next-16

switch.fall.body-15:
	; AssignStmt
	%108 = load i64, i64* %9, align 8
	%109 = sub i64 %108, 1
	store i64 %109, i64* %9
	; AssignStmt
	; IndexExpr
	%110 = load i64, i64* %9, align 8
	%111 = trunc i64 %110 to i32
	%112 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %111
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$316, i64 0, i32 0), i64 61}, i64 484, i64 20, i64 %110, i64 129)
	store i8 122, i8* %112
	br label %switch.done-18

switch.case.next-16:
	; AssignStmt
	store i8 0, i8* %11
	br label %switch.done-18

switch.fall.body-17:
	; AssignStmt
	%113 = load i64, i64* %9, align 8
	%114 = sub i64 %113, 1
	store i64 %114, i64* %9
	; AssignStmt
	; IndexExpr
	%115 = load i64, i64* %9, align 8
	%116 = trunc i64 %115 to i32
	%117 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %116
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$317, i64 0, i32 0), i64 61}, i64 485, i64 20, i64 %115, i64 129)
	store i8 120, i8* %117
	br label %switch.done-18

switch.done-18:
	; IfStmt
	%118 = load i8, i8* %11, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %if.then-19, label %if.done-20

if.then-19:
	; AssignStmt
	%120 = load i64, i64* %9, align 8
	%121 = sub i64 %120, 1
	store i64 %121, i64* %9
	; AssignStmt
	; IndexExpr
	%122 = load i64, i64* %9, align 8
	%123 = trunc i64 %122 to i32
	%124 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %123
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$318, i64 0, i32 0), i64 61}, i64 489, i64 12, i64 %122, i64 129)
	store i8 48, i8* %124
	br label %if.done-20

if.done-20:
	br label %if.done-21

if.done-21:
	; SwitchStmt
	%125 = load i8, i8* %7, align 1
	%126 = icmp eq i8 1, %125
	br i1 %126, label %switch.case.body-23, label %switch.case.next-22

switch.case.next-22:
	%127 = load i8, i8* %5, align 1
	; bit_set in
	%128 = sub i8 1, 0
	%129 = shl i8 1, %128
	%130 = bitcast i8 %127 to i8
	%131 = and i8 %130, %129
	%132 = icmp ne i8 %131, 0
	%133 = zext i1 %132 to i8
	%134 = icmp eq i8 1, %133
	br i1 %134, label %switch.fall.body-25, label %switch.case.next-24

switch.case.body-23:
	; AssignStmt
	%135 = load i64, i64* %9, align 8
	%136 = sub i64 %135, 1
	store i64 %136, i64* %9
	; AssignStmt
	; IndexExpr
	%137 = load i64, i64* %9, align 8
	%138 = trunc i64 %137 to i32
	%139 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %138
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$319, i64 0, i32 0), i64 61}, i64 495, i64 11, i64 %137, i64 129)
	store i8 45, i8* %139
	br label %switch.done-28

switch.case.next-24:
	%140 = load i8, i8* %5, align 1
	; bit_set in
	%141 = sub i8 2, 0
	%142 = shl i8 1, %141
	%143 = bitcast i8 %140 to i8
	%144 = and i8 %143, %142
	%145 = icmp ne i8 %144, 0
	%146 = zext i1 %145 to i8
	%147 = icmp eq i8 1, %146
	br i1 %147, label %switch.fall.body-27, label %switch.case.next-26

switch.fall.body-25:
	; AssignStmt
	%148 = load i64, i64* %9, align 8
	%149 = sub i64 %148, 1
	store i64 %149, i64* %9
	; AssignStmt
	; IndexExpr
	%150 = load i64, i64* %9, align 8
	%151 = trunc i64 %150 to i32
	%152 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %151
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$31a, i64 0, i32 0), i64 61}, i64 497, i64 11, i64 %150, i64 129)
	store i8 43, i8* %152
	br label %switch.done-28

switch.case.next-26:
	br label %switch.done-28

switch.fall.body-27:
	; AssignStmt
	%153 = load i64, i64* %9, align 8
	%154 = sub i64 %153, 1
	store i64 %154, i64* %9
	; AssignStmt
	; IndexExpr
	%155 = load i64, i64* %9, align 8
	%156 = trunc i64 %155 to i32
	%157 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %156
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$31b, i64 0, i32 0), i64 61}, i64 499, i64 11, i64 %155, i64 129)
	store i8 32, i8* %157
	br label %switch.done-28

switch.done-28:
	; out
	; SliceExpr
	%158 = load i64, i64* %9, align 8
	%159 = load [129 x i8], [129 x i8]* %8, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$31c, i64 0, i32 0), i64 61}, i64 502, i64 10, i64 %158, i64 129, i64 129)
	%160 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 0
	%161 = getelementptr inbounds i8, i8* %160, i64 %158
	%162 = sub i64 129, %158
	%163 = bitcast {i8*, i64}* %13 to %..rawptr
	%164 = call %..rawptr @mem.zero(%..rawptr %163, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %13
	%165 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %13, i64 0, i32 0
	store i8* %161, i8** %165
	%166 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %13, i64 0, i32 1
	store i64 %162, i64* %166
	%167 = load {i8*, i64}, {i8*, i64}* %13, align 8
	store {i8*, i64} %167, {i8*, i64}* %12
	%168 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%169 = load {i8*, i64}, {i8*, i64}* %12, align 8
	%170 = bitcast {i8*, i64}* %14 to %..rawptr
	%171 = call %..rawptr @mem.zero(%..rawptr %170, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %14
	store {i8*, i64} %168, {i8*, i64}* %14
	%172 = bitcast {i8*, i64}* %15 to %..rawptr
	%173 = call %..rawptr @mem.zero(%..rawptr %172, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %15
	store {i8*, i64} %169, {i8*, i64}* %15
	%174 = call i64 @runtime.copy-18955({i8*, i64}* %14, {i8*, i64}* %15)
	; ReturnStmt
	; SliceExpr
	%175 = load {i8*, i64}, {i8*, i64}* %12, align 8
	%176 = extractvalue {i8*, i64} %175, 1
	%177 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%178 = extractvalue {i8*, i64} %177, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$31d, i64 0, i32 0), i64 61}, i64 504, i64 19, i64 0, i64 %176, i64 %178)
	%179 = extractvalue {i8*, i64} %177, 0
	%180 = getelementptr inbounds i8, i8* %179, i64 0
	%181 = sub i64 %176, 0
	%182 = bitcast {i8*, i64}* %16 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %16
	%184 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i64 0, i32 0
	store i8* %180, i8** %184
	%185 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i64 0, i32 1
	store i64 %181, i64* %185
	%186 = load {i8*, i64}, {i8*, i64}* %16, align 8
	%187 = extractvalue {i8*, i64} %186, 0
	%188 = extractvalue {i8*, i64} %186, 1
	%189 = bitcast %..string* %17 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 16) noinline
	store %..string zeroinitializer, %..string* %17
	%191 = getelementptr inbounds %..string, %..string* %17, i64 0, i32 0
	store i8* %187, i8** %191
	%192 = getelementptr inbounds %..string, %..string* %17, i64 0, i32 1
	store i64 %188, i64* %192
	%193 = load %..string, %..string* %17, align 8
	ret %..string %193
}

define %..rawptr @glfw.CreateWindow(i32 %width, i32 %height, %..string %title, %..rawptr %monitor, %..rawptr %share, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i32, align 16
	%2 = alloca %..string, align 16
	%3 = alloca %..rawptr, align 16
	%4 = alloca %..rawptr, align 16
	store i32 %width, i32* %0
	store i32 %height, i32* %1
	store %..string %title, %..string* %2
	store %..rawptr %monitor, %..rawptr* %3
	store %..rawptr %share, %..rawptr* %4
	; ReturnStmt
	%5 = load i32, i32* %0, align 4
	%6 = load i32, i32* %1, align 4
	; IndexExpr
	%7 = load %..string, %..string* %2, align 8
	%8 = extractvalue %..string %7, 0
	%9 = extractvalue %..string %7, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$31e, i64 0, i32 0), i64 67}, i64 204, i64 59, i64 0, i64 %9) alwaysinline
	%10 = getelementptr inbounds i8, i8* %8, i64 0
	%11 = bitcast i8* %10 to i8*
	%12 = load %..rawptr, %..rawptr* %3, align 8
	%13 = load %..rawptr, %..rawptr* %4, align 8
	%14 = call ccc %..rawptr @glfwCreateWindow(i32 %5, i32 %6, i8* %11, %..rawptr %12, %..rawptr %13) alwaysinline
	ret %..rawptr %14
}

define {double, double} @glfw.GetCursorPos(%..rawptr %window, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca double, align 16
	%2 = alloca double, align 16
	%3 = alloca {double, double}, align 16
	store %..rawptr %window, %..rawptr* %0
	%4 = bitcast double* %1 to %..rawptr
	%5 = call %..rawptr @mem.zero(%..rawptr %4, i64 8) noinline
	store double zeroinitializer, double* %1
	%6 = bitcast double* %2 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 8) noinline
	store double zeroinitializer, double* %2
	%8 = load %..rawptr, %..rawptr* %0, align 8
	call ccc void @glfwGetCursorPos(%..rawptr %8, double* %1, double* %2)
	; ReturnStmt
	%9 = load double, double* %1, align 8
	%10 = load double, double* %2, align 8
	%11 = bitcast {double, double}* %3 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 16) noinline
	store {double, double} zeroinitializer, {double, double}* %3
	%13 = getelementptr inbounds {double, double}, {double, double}* %3, i64 0, i32 0
	store double %9, double* %13
	%14 = getelementptr inbounds {double, double}, {double, double}* %3, i64 0, i32 1
	store double %10, double* %14
	%15 = load {double, double}, {double, double}* %3, align 8
	ret {double, double} %15
}

define i8 @glfw.WindowShouldClose(%..rawptr %window, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	store %..rawptr %window, %..rawptr* %0
	; ReturnStmt
	%1 = load %..rawptr, %..rawptr* %0, align 8
	%2 = call ccc i32 @glfwWindowShouldClose(%..rawptr %1)
	%3 = icmp eq i32 %2, 1
	%4 = zext i1 %3 to i8
	ret i8 %4
}

define i8 @glfw.JoystickPresent(i32 %joy, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	store i32 %joy, i32* %0
	; ReturnStmt
	%1 = load i32, i32* %0, align 4
	%2 = call ccc i32 @glfwJoystickPresent(i32 %1)
	%3 = icmp ne i32 %2, 0
	%4 = zext i1 %3 to i8
	ret i8 %4
}
declare ccc i32 @glfwJoystickPresent(i32) #0 

define {float*, i64} @glfw.GetJoystickAxes(i32 %joy, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i32, align 16
	%2 = alloca float*, align 16
	store i32 %joy, i32* %0
	; count
	%3 = bitcast i32* %1 to %..rawptr
	%4 = call %..rawptr @mem.zero(%..rawptr %3, i64 4) noinline
	store i32 zeroinitializer, i32* %1
	; data
	%5 = load i32, i32* %0, align 4
	%6 = call ccc float* @glfwGetJoystickAxes(i32 %5, i32* %1)
	store float* %6, float** %2
	; ReturnStmt
	; SelectorExpr
	%7 = load float*, float** %2, align 8
	%8 = load i32, i32* %1, align 4
	%9 = sext i32 %8 to i64
	%10 = call {float*, i64} @mem.slice_ptr-19071(float* %7, i64 %9)
	ret {float*, i64} %10
}

define {i8*, i64} @glfw.GetJoystickButtons(i32 %joy, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i32, align 16
	%2 = alloca i8*, align 16
	store i32 %joy, i32* %0
	; count
	%3 = bitcast i32* %1 to %..rawptr
	%4 = call %..rawptr @mem.zero(%..rawptr %3, i64 4) noinline
	store i32 zeroinitializer, i32* %1
	; data
	%5 = load i32, i32* %0, align 4
	%6 = call ccc i8* @glfwGetJoystickButtons(i32 %5, i32* %1)
	store i8* %6, i8** %2
	; ReturnStmt
	; SelectorExpr
	%7 = load i8*, i8** %2, align 8
	%8 = load i32, i32* %1, align 4
	%9 = sext i32 %8 to i64
	%10 = call {i8*, i64} @mem.slice_ptr-17810(i8* %7, i64 %9)
	ret {i8*, i64} %10
}

define i8* @imgui._make_text_string(%..string %fmt_, {%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca {i8*, i64}, align 16
	%4 = alloca {%..any*, i64}, align 16
	store %..string %fmt_, %..string* %0
	%5 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; IfStmt
	%6 = load %..string, %..string* %0, align 8
	%7 = call i8 @runtime.string_eq(%..string %6, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$31f, i64 0, i32 0), i64 1})
	%8 = trunc i8 %7 to i1
	br i1 %8, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8* zeroinitializer

if.done-2:
	; s
	; SelectorExpr
	; SliceExpr
	%9 = load [8192 x i8], [8192 x i8]* @imgui._text_buf, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$320, i64 0, i32 0), i64 69}, i64 522, i64 31, i64 0, i64 8192, i64 8192)
	%10 = getelementptr inbounds [8192 x i8], [8192 x i8]* @imgui._text_buf, i64 0, i32 0
	%11 = getelementptr inbounds i8, i8* %10, i64 0
	%12 = sub i64 8192, 0
	%13 = bitcast {i8*, i64}* %2 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %2
	%15 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 0
	store i8* %11, i8** %15
	%16 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 1
	store i64 %12, i64* %16
	%17 = load {i8*, i64}, {i8*, i64}* %2, align 8
	%18 = load %..string, %..string* %0, align 8
	%19 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%20 = bitcast {i8*, i64}* %3 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %3
	store {i8*, i64} %17, {i8*, i64}* %3
	%22 = bitcast {%..any*, i64}* %4 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %4
	store {%..any*, i64} %19, {%..any*, i64}* %4
	%24 = call %..string @fmt.bprintf({i8*, i64}* %3, %..string %18, {%..any*, i64}* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %24, %..string* %1
	; AssignStmt
	; IndexExpr
	%25 = load %..string, %..string* %1, align 8
	%26 = extractvalue %..string %25, 1
	%27 = trunc i64 %26 to i32
	%28 = getelementptr inbounds [8192 x i8], [8192 x i8]* @imgui._text_buf, i64 0, i32 %27
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$321, i64 0, i32 0), i64 69}, i64 523, i64 15, i64 %26, i64 8192)
	store i8 0, i8* %28
	; ReturnStmt
	; IndexExpr
	%29 = getelementptr inbounds [8192 x i8], [8192 x i8]* @imgui._text_buf, i64 0, i32 0
	%30 = bitcast i8* %29 to i8*
	ret i8* %30
}

define i8* @imgui._make_label_string(%..string %label, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca %..any, align 16
	%4 = alloca {%..any*, i64}, align 16
	%5 = alloca [1 x %..any], align 16
	%6 = alloca {i8*, i64}, align 16
	%7 = alloca {%..any*, i64}, align 16
	store %..string %label, %..string* %0
	; IfStmt
	%8 = load %..string, %..string* %0, align 8
	%9 = call i8 @runtime.string_eq(%..string %8, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$322, i64 0, i32 0), i64 1})
	%10 = trunc i8 %9 to i1
	br i1 %10, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8* zeroinitializer

if.done-2:
	; s
	; SelectorExpr
	; SliceExpr
	%11 = load [4096 x i8], [4096 x i8]* @imgui._label_buf, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$323, i64 0, i32 0), i64 69}, i64 529, i64 31, i64 0, i64 4096, i64 4096)
	%12 = getelementptr inbounds [4096 x i8], [4096 x i8]* @imgui._label_buf, i64 0, i32 0
	%13 = getelementptr inbounds i8, i8* %12, i64 0
	%14 = sub i64 4096, 0
	%15 = bitcast {i8*, i64}* %2 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %2
	%17 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 0
	store i8* %13, i8** %17
	%18 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 1
	store i64 %14, i64* %18
	%19 = load {i8*, i64}, {i8*, i64}* %2, align 8
	%20 = load %..string, %..string* %0, align 8
	%21 = bitcast %..any* %3 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 16) noinline
	store %..any zeroinitializer, %..any* %3
	%23 = bitcast %..string* %0 to %..rawptr
	%24 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	store %..rawptr %23, %..rawptr* %24
	%25 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %25
	%26 = load %..any, %..any* %3, align 8
	; variadic call argument generation
	%27 = bitcast {%..any*, i64}* %4 to %..rawptr
	%28 = call %..rawptr @mem.zero(%..rawptr %27, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %4
	%29 = bitcast [1 x %..any]* %5 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %5
	%31 = getelementptr inbounds [1 x %..any], [1 x %..any]* %5, i64 0, i32 0
	store %..any %26, %..any* %31
	%32 = getelementptr inbounds [1 x %..any], [1 x %..any]* %5, i64 0, i32 0
	%33 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %4, i64 0, i32 0
	store %..any* %32, %..any** %33
	%34 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %4, i64 0, i32 1
	store i64 1, i64* %34
	%35 = load {%..any*, i64}, {%..any*, i64}* %4, align 8
	%36 = bitcast {i8*, i64}* %6 to %..rawptr
	%37 = call %..rawptr @mem.zero(%..rawptr %36, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	store {i8*, i64} %19, {i8*, i64}* %6
	%38 = bitcast {%..any*, i64}* %7 to %..rawptr
	%39 = call %..rawptr @mem.zero(%..rawptr %38, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %7
	store {%..any*, i64} %35, {%..any*, i64}* %7
	%40 = call %..string @fmt.bprint({i8*, i64}* %6, {%..any*, i64}* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %40, %..string* %1
	; AssignStmt
	; IndexExpr
	%41 = load %..string, %..string* %1, align 8
	%42 = extractvalue %..string %41, 1
	%43 = trunc i64 %42 to i32
	%44 = getelementptr inbounds [4096 x i8], [4096 x i8]* @imgui._label_buf, i64 0, i32 %43
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$324, i64 0, i32 0), i64 69}, i64 530, i64 16, i64 %42, i64 4096)
	store i8 0, i8* %44
	; ReturnStmt
	; IndexExpr
	%45 = getelementptr inbounds [4096 x i8], [4096 x i8]* @imgui._label_buf, i64 0, i32 0
	%46 = bitcast i8* %45 to i8*
	ret i8* %46
}

define i8* @imgui._make_misc_string(%..string %misc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca %..any, align 16
	%4 = alloca {%..any*, i64}, align 16
	%5 = alloca [1 x %..any], align 16
	%6 = alloca {i8*, i64}, align 16
	%7 = alloca {%..any*, i64}, align 16
	store %..string %misc, %..string* %0
	; IfStmt
	%8 = load %..string, %..string* %0, align 8
	%9 = call i8 @runtime.string_eq(%..string %8, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$325, i64 0, i32 0), i64 1})
	%10 = trunc i8 %9 to i1
	br i1 %10, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8* zeroinitializer

if.done-2:
	; s
	; SelectorExpr
	; SliceExpr
	%11 = load [1024 x i8], [1024 x i8]* @imgui._misc_buf, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$326, i64 0, i32 0), i64 69}, i64 543, i64 30, i64 0, i64 1024, i64 1024)
	%12 = getelementptr inbounds [1024 x i8], [1024 x i8]* @imgui._misc_buf, i64 0, i32 0
	%13 = getelementptr inbounds i8, i8* %12, i64 0
	%14 = sub i64 1024, 0
	%15 = bitcast {i8*, i64}* %2 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %2
	%17 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 0
	store i8* %13, i8** %17
	%18 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 1
	store i64 %14, i64* %18
	%19 = load {i8*, i64}, {i8*, i64}* %2, align 8
	%20 = load %..string, %..string* %0, align 8
	%21 = bitcast %..any* %3 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 16) noinline
	store %..any zeroinitializer, %..any* %3
	%23 = bitcast %..string* %0 to %..rawptr
	%24 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	store %..rawptr %23, %..rawptr* %24
	%25 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %25
	%26 = load %..any, %..any* %3, align 8
	; variadic call argument generation
	%27 = bitcast {%..any*, i64}* %4 to %..rawptr
	%28 = call %..rawptr @mem.zero(%..rawptr %27, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %4
	%29 = bitcast [1 x %..any]* %5 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %5
	%31 = getelementptr inbounds [1 x %..any], [1 x %..any]* %5, i64 0, i32 0
	store %..any %26, %..any* %31
	%32 = getelementptr inbounds [1 x %..any], [1 x %..any]* %5, i64 0, i32 0
	%33 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %4, i64 0, i32 0
	store %..any* %32, %..any** %33
	%34 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %4, i64 0, i32 1
	store i64 1, i64* %34
	%35 = load {%..any*, i64}, {%..any*, i64}* %4, align 8
	%36 = bitcast {i8*, i64}* %6 to %..rawptr
	%37 = call %..rawptr @mem.zero(%..rawptr %36, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	store {i8*, i64} %19, {i8*, i64}* %6
	%38 = bitcast {%..any*, i64}* %7 to %..rawptr
	%39 = call %..rawptr @mem.zero(%..rawptr %38, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %7
	store {%..any*, i64} %35, {%..any*, i64}* %7
	%40 = call %..string @fmt.bprint({i8*, i64}* %6, {%..any*, i64}* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %40, %..string* %1
	; AssignStmt
	; IndexExpr
	%41 = load %..string, %..string* %1, align 8
	%42 = extractvalue %..string %41, 1
	%43 = trunc i64 %42 to i32
	%44 = getelementptr inbounds [1024 x i8], [1024 x i8]* @imgui._misc_buf, i64 0, i32 %43
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$327, i64 0, i32 0), i64 69}, i64 544, i64 15, i64 %42, i64 1024)
	store i8 0, i8* %44
	; ReturnStmt
	; IndexExpr
	%45 = getelementptr inbounds [1024 x i8], [1024 x i8]* @imgui._misc_buf, i64 0, i32 0
	%46 = bitcast i8* %45 to i8*
	ret i8* %46
}

define i8 @imgui.begin(%..string %name, i8* %open, i32 %flags, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i8*, align 16
	%2 = alloca i32, align 16
	store %..string %name, %..string* %0
	store i8* %open, i8** %1
	store i32 %flags, i32* %2
	; ReturnStmt
	%3 = load %..string, %..string* %0, align 8
	%4 = call i8* @imgui._make_label_string(%..string %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load i8*, i8** %1, align 8
	%6 = load i32, i32* %2, align 4
	%7 = call ccc i8 @igBegin(i8* %4, i8* %5, i32 %6)
	ret i8 %7
}

define void @imgui.push_id_str(%..string %str_id, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	store %..string %str_id, %..string* %0
	%1 = load %..string, %..string* %0, align 8
	%2 = call i8* @imgui._make_label_string(%..string %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call ccc void @igPushIDStr(i8* %2)
	ret void
}

define void @imgui.text(%..string %fmt_, {%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca {%..any*, i64}, align 16
	store %..string %fmt_, %..string* %0
	%2 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%3 = load %..string, %..string* %0, align 8
	%4 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%5 = bitcast {%..any*, i64}* %1 to %..rawptr
	%6 = call %..rawptr @mem.zero(%..rawptr %5, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %1
	store {%..any*, i64} %4, {%..any*, i64}* %1
	%7 = call i8* @imgui._make_text_string(%..string %3, {%..any*, i64}* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call ccc void @igTextUnformatted(i8* %7, i8* zeroinitializer)
	ret void
}

define i8 @imgui.small_button(%..string %label, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	store %..string %label, %..string* %0
	; ReturnStmt
	%1 = load %..string, %..string* %0, align 8
	%2 = call i8* @imgui._make_label_string(%..string %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = call ccc i8 @igSmallButton(i8* %2)
	ret i8 %3
}

define i8 @imgui.checkbox(%..string %label, i8* %v, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i8*, align 16
	store %..string %label, %..string* %0
	store i8* %v, i8** %1
	; ReturnStmt
	%2 = load %..string, %..string* %0, align 8
	%3 = call i8* @imgui._make_label_string(%..string %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%4 = load i8*, i8** %1, align 8
	%5 = call ccc i8 @igCheckbox(i8* %3, i8* %4)
	ret i8 %5
}

define i8 @imgui.collapsing_header_(%..string %label, i32 %flags, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i32, align 16
	store %..string %label, %..string* %0
	store i32 %flags, i32* %1
	; ReturnStmt
	%2 = load %..string, %..string* %0, align 8
	%3 = call i8* @imgui._make_label_string(%..string %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%4 = load i32, i32* %1, align 4
	%5 = call ccc i8 @igCollapsingHeader(i8* %3, i32 %4)
	ret i8 %5
}

define %imgui.Font* @imgui.font_atlas_add_font_from_file_ttf(%imgui.FontAtlas* %atlas, %..string %filename, float %size_pixels, %imgui.FontConfig* %font_cfg, {i16*, i64}* %glyph_ranges, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %imgui.FontAtlas*, align 16
	%1 = alloca %..string, align 16
	%2 = alloca float, align 16
	%3 = alloca %imgui.FontConfig*, align 16
	store %imgui.FontAtlas* %atlas, %imgui.FontAtlas** %0
	store %..string %filename, %..string* %1
	store float %size_pixels, float* %2
	store %imgui.FontConfig* %font_cfg, %imgui.FontConfig** %3
	%4 = load {i16*, i64}, {i16*, i64}* %glyph_ranges, align 8
	; ReturnStmt
	%5 = load %imgui.FontAtlas*, %imgui.FontAtlas** %0, align 8
	%6 = load %..string, %..string* %1, align 8
	%7 = call i8* @imgui._make_misc_string(%..string %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%8 = load float, float* %2, align 4
	%9 = load %imgui.FontConfig*, %imgui.FontConfig** %3, align 8
	; TernaryExpr
	%10 = load {i16*, i64}, {i16*, i64}* %glyph_ranges, align 8
	%11 = extractvalue {i16*, i64} %10, 0
	%12 = extractvalue {i16*, i64} %10, 1
	%13 = bitcast %..rawptr null to i16*
	%14 = icmp eq i16* %11, %13
	%15 = icmp eq i64 %12, 0
	%16 = zext i1 %14 to i8
	%17 = zext i1 %15 to i8
	%18 = or i8 %16, %17
	%19 = trunc i8 %18 to i1
	br i1 %19, label %if.then-1, label %if.else-2

if.then-1:
	br label %if.done-3

if.else-2:
	; IndexExpr
	%20 = load {i16*, i64}, {i16*, i64}* %glyph_ranges, align 8
	%21 = extractvalue {i16*, i64} %20, 0
	%22 = extractvalue {i16*, i64} %20, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$328, i64 0, i32 0), i64 69}, i64 1236, i64 317, i64 0, i64 %22)
	%23 = getelementptr inbounds i16, i16* %21, i64 0
	br label %if.done-3

if.done-3:
	%24 = phi i16* [ zeroinitializer, %if.then-1 ], [ %23, %if.else-2 ]
	%25 = call ccc %imgui.Font* @ImFontAtlas_AddFontFromFileTTF(%imgui.FontAtlas* %5, i8* %7, float %8, %imgui.FontConfig* %9, i16* %24)
	ret %imgui.Font* %25
}

define %..string @strings.new_string(%..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca {i8*, i64}, align 16
	%2 = alloca %mem.Allocator, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i8*, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca {i8*, i64}, align 16
	%7 = alloca {i8*, i64}, align 16
	%8 = alloca {i8*, i64}, align 16
	%9 = alloca %..string, align 16
	store %..string %s, %..string* %0
	; c
	%10 = load %..string, %..string* %0, align 8
	%11 = extractvalue %..string %10, 1
	%12 = add i64 %11, 1
	; SelectorExpr
	%13 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%14 = load %mem.Allocator, %mem.Allocator* %13, align 8
	%15 = bitcast %mem.Allocator* %2 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %2
	store %mem.Allocator %14, %mem.Allocator* %2
	%17 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$329, i64 0, i32 0), i64 61}, i64 6, i64 7, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$32a, i64 0, i32 0), i64 10}}, %runtime.Source_Code_Location* %3
	%19 = call {i8*, i64} @mem.make_slice-14353(i64 %12, %mem.Allocator* %2, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64} %19, {i8*, i64}* %1
	%20 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%21 = load %..string, %..string* %0, align 8
	%22 = extractvalue %..string %21, 0
	%23 = bitcast i8** %4 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 8) noinline
	store i8* zeroinitializer, i8** %4
	store i8* %22, i8** %4
	%25 = extractvalue %..string %21, 1
	%26 = sub i64 %25, 0
	%27 = load i8*, i8** %4, align 8
	%28 = getelementptr inbounds i8, i8* %27, i64 0
	%29 = bitcast {i8*, i64}* %5 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	%31 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 0
	store i8* %28, i8** %31
	%32 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 1
	store i64 %26, i64* %32
	%33 = load {i8*, i64}, {i8*, i64}* %5, align 8
	%34 = bitcast {i8*, i64}* %6 to %..rawptr
	%35 = call %..rawptr @mem.zero(%..rawptr %34, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	store {i8*, i64} %20, {i8*, i64}* %6
	%36 = bitcast {i8*, i64}* %7 to %..rawptr
	%37 = call %..rawptr @mem.zero(%..rawptr %36, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %7
	store {i8*, i64} %33, {i8*, i64}* %7
	%38 = call i64 @runtime.copy-18955({i8*, i64}* %6, {i8*, i64}* %7)
	; AssignStmt
	; IndexExpr
	%39 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%40 = extractvalue {i8*, i64} %39, 0
	%41 = load %..string, %..string* %0, align 8
	%42 = extractvalue %..string %41, 1
	%43 = extractvalue {i8*, i64} %39, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$32b, i64 0, i32 0), i64 61}, i64 8, i64 4, i64 %42, i64 %43)
	%44 = getelementptr inbounds i8, i8* %40, i64 %42
	store i8 0, i8* %44
	; ReturnStmt
	; SliceExpr
	%45 = load %..string, %..string* %0, align 8
	%46 = extractvalue %..string %45, 1
	%47 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%48 = extractvalue {i8*, i64} %47, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$32c, i64 0, i32 0), i64 61}, i64 9, i64 17, i64 0, i64 %46, i64 %48)
	%49 = extractvalue {i8*, i64} %47, 0
	%50 = getelementptr inbounds i8, i8* %49, i64 0
	%51 = sub i64 %46, 0
	%52 = bitcast {i8*, i64}* %8 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %8
	%54 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %8, i64 0, i32 0
	store i8* %50, i8** %54
	%55 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %8, i64 0, i32 1
	store i64 %51, i64* %55
	%56 = load {i8*, i64}, {i8*, i64}* %8, align 8
	%57 = extractvalue {i8*, i64} %56, 0
	%58 = extractvalue {i8*, i64} %56, 1
	%59 = bitcast %..string* %9 to %..rawptr
	%60 = call %..rawptr @mem.zero(%..rawptr %59, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	%61 = getelementptr inbounds %..string, %..string* %9, i64 0, i32 0
	store i8* %57, i8** %61
	%62 = getelementptr inbounds %..string, %..string* %9, i64 0, i32 1
	store i64 %58, i64* %62
	%63 = load %..string, %..string* %9, align 8
	ret %..string %63
}

define i8* @strings.new_cstring(%..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca {i8*, i64}, align 16
	%2 = alloca %mem.Allocator, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i8*, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca {i8*, i64}, align 16
	%7 = alloca {i8*, i64}, align 16
	store %..string %s, %..string* %0
	; c
	%8 = load %..string, %..string* %0, align 8
	%9 = extractvalue %..string %8, 1
	%10 = add i64 %9, 1
	; SelectorExpr
	%11 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%12 = load %mem.Allocator, %mem.Allocator* %11, align 8
	%13 = bitcast %mem.Allocator* %2 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %2
	store %mem.Allocator %12, %mem.Allocator* %2
	%15 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$32d, i64 0, i32 0), i64 61}, i64 13, i64 7, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$32e, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %3
	%17 = call {i8*, i64} @mem.make_slice-14353(i64 %10, %mem.Allocator* %2, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64} %17, {i8*, i64}* %1
	%18 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%19 = load %..string, %..string* %0, align 8
	%20 = extractvalue %..string %19, 0
	%21 = bitcast i8** %4 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 8) noinline
	store i8* zeroinitializer, i8** %4
	store i8* %20, i8** %4
	%23 = extractvalue %..string %19, 1
	%24 = sub i64 %23, 0
	%25 = load i8*, i8** %4, align 8
	%26 = getelementptr inbounds i8, i8* %25, i64 0
	%27 = bitcast {i8*, i64}* %5 to %..rawptr
	%28 = call %..rawptr @mem.zero(%..rawptr %27, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	%29 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 0
	store i8* %26, i8** %29
	%30 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 1
	store i64 %24, i64* %30
	%31 = load {i8*, i64}, {i8*, i64}* %5, align 8
	%32 = bitcast {i8*, i64}* %6 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	store {i8*, i64} %18, {i8*, i64}* %6
	%34 = bitcast {i8*, i64}* %7 to %..rawptr
	%35 = call %..rawptr @mem.zero(%..rawptr %34, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %7
	store {i8*, i64} %31, {i8*, i64}* %7
	%36 = call i64 @runtime.copy-18955({i8*, i64}* %6, {i8*, i64}* %7)
	; AssignStmt
	; IndexExpr
	%37 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%38 = extractvalue {i8*, i64} %37, 0
	%39 = load %..string, %..string* %0, align 8
	%40 = extractvalue %..string %39, 1
	%41 = extractvalue {i8*, i64} %37, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$32f, i64 0, i32 0), i64 61}, i64 15, i64 4, i64 %40, i64 %41)
	%42 = getelementptr inbounds i8, i8* %38, i64 %40
	store i8 0, i8* %42
	; ReturnStmt
	; IndexExpr
	%43 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%44 = extractvalue {i8*, i64} %43, 0
	%45 = extractvalue {i8*, i64} %43, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$330, i64 0, i32 0), i64 61}, i64 16, i64 20, i64 0, i64 %45)
	%46 = getelementptr inbounds i8, i8* %44, i64 0
	%47 = bitcast i8* %46 to i8*
	ret i8* %47
}

define void @rand.init(%rand.Rand* %r, i64 %seed, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %rand.Rand*, align 16
	%1 = alloca i64, align 16
	store %rand.Rand* %r, %rand.Rand** %0
	store i64 %seed, i64* %1
	; AssignStmt
	; SelectorExpr
	%2 = load %rand.Rand*, %rand.Rand** %0, align 8
	%3 = getelementptr inbounds %rand.Rand, %rand.Rand* %2, i64 0
	%4 = getelementptr inbounds %rand.Rand, %rand.Rand* %3, i64 0, i32 0
	store i64 0, i64* %4
	; AssignStmt
	; SelectorExpr
	%5 = load %rand.Rand*, %rand.Rand** %0, align 8
	%6 = getelementptr inbounds %rand.Rand, %rand.Rand* %5, i64 0
	%7 = getelementptr inbounds %rand.Rand, %rand.Rand* %6, i64 0, i32 1
	%8 = load i64, i64* %1, align 8
	%9 = shl i64 %8, 1
	%10 = or i64 %9, 1
	store i64 %10, i64* %7
	%11 = load %rand.Rand*, %rand.Rand** %0, align 8
	%12 = call i32 @rand._random(%rand.Rand* %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	; SelectorExpr
	%13 = load %rand.Rand*, %rand.Rand** %0, align 8
	%14 = getelementptr inbounds %rand.Rand, %rand.Rand* %13, i64 0
	%15 = getelementptr inbounds %rand.Rand, %rand.Rand* %14, i64 0, i32 0
	%16 = load i64, i64* %1, align 8
	%17 = load i64, i64* %15, align 8
	%18 = add i64 %17, %16
	store i64 %18, i64* %15
	%19 = load %rand.Rand*, %rand.Rand** %0, align 8
	%20 = call i32 @rand._random(%rand.Rand* %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define i32 @rand._random(%rand.Rand* %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %rand.Rand*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i32, align 16
	%3 = alloca i32, align 16
	store %rand.Rand* %r, %rand.Rand** %0
	; old_state
	; SelectorExpr
	%4 = load %rand.Rand*, %rand.Rand** %0, align 8
	%5 = getelementptr inbounds %rand.Rand, %rand.Rand* %4, i64 0
	%6 = getelementptr inbounds %rand.Rand, %rand.Rand* %5, i64 0, i32 0
	%7 = load i64, i64* %6, align 8
	store i64 %7, i64* %1
	; AssignStmt
	; SelectorExpr
	%8 = load %rand.Rand*, %rand.Rand** %0, align 8
	%9 = getelementptr inbounds %rand.Rand, %rand.Rand* %8, i64 0
	%10 = getelementptr inbounds %rand.Rand, %rand.Rand* %9, i64 0, i32 0
	%11 = load i64, i64* %1, align 8
	%12 = mul i64 %11, 6364136223846793005
	; SelectorExpr
	%13 = load %rand.Rand*, %rand.Rand** %0, align 8
	%14 = getelementptr inbounds %rand.Rand, %rand.Rand* %13, i64 0
	%15 = getelementptr inbounds %rand.Rand, %rand.Rand* %14, i64 0, i32 1
	%16 = load i64, i64* %15, align 8
	%17 = or i64 %16, 1
	%18 = add i64 %12, %17
	store i64 %18, i64* %10
	; xor_shifted
	%19 = load i64, i64* %1, align 8
	%20 = lshr i64 %19, 18
	%21 = load i64, i64* %1, align 8
	%22 = xor i64 %20, %21
	%23 = lshr i64 %22, 27
	%24 = trunc i64 %23 to i32
	store i32 %24, i32* %2
	; rot
	%25 = load i64, i64* %1, align 8
	%26 = lshr i64 %25, 59
	%27 = trunc i64 %26 to i32
	store i32 %27, i32* %3
	; ReturnStmt
	%28 = load i32, i32* %2, align 4
	%29 = load i32, i32* %3, align 4
	%30 = lshr i32 %28, %29
	%31 = load i32, i32* %2, align 4
	%32 = load i32, i32* %3, align 4
	%33 = sub i32 0, %32
	%34 = and i32 %33, 31
	%35 = shl i32 %31, %34
	%36 = or i32 %30, %35
	ret i32 %36
}

define i64 @rand.uint64(%rand.Rand* %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %rand.Rand*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %rand.Rand* %r, %rand.Rand** %0
	; a
	%3 = load %rand.Rand*, %rand.Rand** %0, align 8
	%4 = call i32 @rand._random(%rand.Rand* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = zext i32 %4 to i64
	store i64 %5, i64* %1
	; b
	%6 = load %rand.Rand*, %rand.Rand** %0, align 8
	%7 = call i32 @rand._random(%rand.Rand* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%8 = zext i32 %7 to i64
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %1, align 8
	%10 = shl i64 %9, 32
	%11 = load i64, i64* %2, align 8
	%12 = or i64 %10, %11
	ret i64 %12
}

define i64 @rand.int63(%rand.Rand* %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %rand.Rand*, align 16
	store %rand.Rand* %r, %rand.Rand** %0
	; ReturnStmt
	%1 = load %rand.Rand*, %rand.Rand** %0, align 8
	%2 = call i64 @rand.uint64(%rand.Rand* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = shl i64 %2, 1
	%4 = lshr i64 %3, 1
	%5 = bitcast i64 %4 to i64
	ret i64 %5
}

define i64 @rand.int63_max(%rand.Rand* %r, i64 %n, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %rand.Rand*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	store %rand.Rand* %r, %rand.Rand** %0
	store i64 %n, i64* %1
	; IfStmt
	%5 = load i64, i64* %1, align 8
	%6 = icmp sle i64 %5, 0
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	br i1 %8, label %if.then-1, label %if.done-2

if.then-1:
	%9 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([61 x i8], [61 x i8]* @str$331, i64 0, i32 0), i64 60}, i64 49, i64 15, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$332, i64 0, i32 0), i64 9}}, %runtime.Source_Code_Location* %2
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$333, i64 0, i32 0), i64 29}, %runtime.Source_Code_Location* %2) noreturn
	br label %if.done-2

if.done-2:
	; IfStmt
	%11 = load i64, i64* %1, align 8
	%12 = load i64, i64* %1, align 8
	%13 = sub i64 %12, 1
	%14 = and i64 %11, %13
	%15 = icmp eq i64 %14, 0
	%16 = zext i1 %15 to i8
	%17 = trunc i8 %16 to i1
	br i1 %17, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	%18 = load %rand.Rand*, %rand.Rand** %0, align 8
	%19 = call i64 @rand.int63(%rand.Rand* %18, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%20 = load i64, i64* %1, align 8
	%21 = sub i64 %20, 1
	%22 = and i64 %19, %21
	ret i64 %22

if.done-4:
	; max
	%23 = load i64, i64* %1, align 8
	%24 = bitcast i64 %23 to i64
	%25 = and i64 -9223372036854775808, %24
	%26 = sub i64 9223372036854775807, %25
	%27 = bitcast i64 %26 to i64
	store i64 %27, i64* %3
	; v
	%28 = load %rand.Rand*, %rand.Rand** %0, align 8
	%29 = call i64 @rand.int63(%rand.Rand* %28, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %29, i64* %4
	; ForStmt
	br label %for.loop-5

for.loop-5:
	%30 = load i64, i64* %4, align 8
	%31 = load i64, i64* %3, align 8
	%32 = icmp sgt i64 %30, %31
	%33 = zext i1 %32 to i8
	%34 = trunc i8 %33 to i1
	br i1 %34, label %for.body-6, label %for.done-7

for.body-6:
	; AssignStmt
	%35 = load %rand.Rand*, %rand.Rand** %0, align 8
	%36 = call i64 @rand.int63(%rand.Rand* %35, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %36, i64* %4
	br label %for.loop-5

for.done-7:
	; ReturnStmt
	%37 = load i64, i64* %4, align 8
	%38 = load i64, i64* %1, align 8
	%39 = srem i64 %37, %38
	ret i64 %39
}

define double @rand.float64(%rand.Rand* %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %rand.Rand*, align 16
	store %rand.Rand* %r, %rand.Rand** %0
	; ReturnStmt
	%1 = load %rand.Rand*, %rand.Rand** %0, align 8
	%2 = call i64 @rand.int63_max(%rand.Rand* %1, i64 9007199254740992, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = sitofp i64 %2 to double
	%4 = fdiv double %3, 0x4340000000000000
	ret double %4
}

define float @rand.float32(%rand.Rand* %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %rand.Rand*, align 16
	store %rand.Rand* %r, %rand.Rand** %0
	; ReturnStmt
	%1 = load %rand.Rand*, %rand.Rand** %0, align 8
	%2 = call double @rand.float64(%rand.Rand* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = fptrunc double %2 to float
	ret float %3
}

define void @gl.load_up_to(i64 %major, i64 %minor, void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store i64 %major, i64* %0
	store i64 %minor, i64* %1
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %2
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$334, i64 0, i32 0), i64 3}, %..string* @gl.loaded_up_to
	; AssignStmt
	; IndexExpr
	%3 = load %..string, %..string* @gl.loaded_up_to, align 8
	%4 = extractvalue %..string %3, 0
	%5 = extractvalue %..string %3, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$335, i64 0, i32 0), i64 58}, i64 11, i64 18, i64 0, i64 %5)
	%6 = getelementptr inbounds i8, i8* %4, i64 0
	%7 = load i64, i64* %0, align 8
	%8 = trunc i64 %7 to i8
	%9 = add i8 48, %8
	store i8 %9, i8* %6
	; AssignStmt
	; IndexExpr
	%10 = load %..string, %..string* @gl.loaded_up_to, align 8
	%11 = extractvalue %..string %10, 0
	%12 = extractvalue %..string %10, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$336, i64 0, i32 0), i64 58}, i64 12, i64 18, i64 2, i64 %12)
	%13 = getelementptr inbounds i8, i8* %11, i64 2
	%14 = load i64, i64* %1, align 8
	%15 = trunc i64 %14 to i8
	%16 = add i8 48, %15
	store i8 %16, i8* %13
	; AssignStmt
	%17 = load i64, i64* %0, align 8
	store i64 %17, i64* @gl.loaded_up_to_major
	; AssignStmt
	%18 = load i64, i64* %1, align 8
	store i64 %18, i64* @gl.loaded_up_to_minor
	; SwitchStmt
	%19 = load i64, i64* %0, align 8
	%20 = mul i64 %19, 10
	%21 = load i64, i64* %1, align 8
	%22 = add i64 %20, %21
	%23 = icmp eq i64 %22, 46
	br i1 %23, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%24 = icmp eq i64 %22, 45
	br i1 %24, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	%25 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_4_6(void (%..rawptr, i8*, %runtime.Context*)* %25, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-4

switch.case.next-3:
	%26 = icmp eq i64 %22, 44
	br i1 %26, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	%27 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_4_5(void (%..rawptr, i8*, %runtime.Context*)* %27, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-6

switch.case.next-5:
	%28 = icmp eq i64 %22, 43
	br i1 %28, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	%29 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_4_4(void (%..rawptr, i8*, %runtime.Context*)* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-8

switch.case.next-7:
	%30 = icmp eq i64 %22, 42
	br i1 %30, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	%31 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_4_3(void (%..rawptr, i8*, %runtime.Context*)* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-10

switch.case.next-9:
	%32 = icmp eq i64 %22, 41
	br i1 %32, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	%33 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_4_2(void (%..rawptr, i8*, %runtime.Context*)* %33, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-12

switch.case.next-11:
	%34 = icmp eq i64 %22, 40
	br i1 %34, label %switch.fall.body-14, label %switch.case.next-13

switch.fall.body-12:
	%35 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_4_1(void (%..rawptr, i8*, %runtime.Context*)* %35, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-14

switch.case.next-13:
	%36 = icmp eq i64 %22, 33
	br i1 %36, label %switch.fall.body-16, label %switch.case.next-15

switch.fall.body-14:
	%37 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_4_0(void (%..rawptr, i8*, %runtime.Context*)* %37, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-16

switch.case.next-15:
	%38 = icmp eq i64 %22, 32
	br i1 %38, label %switch.fall.body-18, label %switch.case.next-17

switch.fall.body-16:
	%39 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_3_3(void (%..rawptr, i8*, %runtime.Context*)* %39, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-18

switch.case.next-17:
	%40 = icmp eq i64 %22, 31
	br i1 %40, label %switch.fall.body-20, label %switch.case.next-19

switch.fall.body-18:
	%41 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_3_2(void (%..rawptr, i8*, %runtime.Context*)* %41, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-20

switch.case.next-19:
	%42 = icmp eq i64 %22, 30
	br i1 %42, label %switch.fall.body-22, label %switch.case.next-21

switch.fall.body-20:
	%43 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_3_1(void (%..rawptr, i8*, %runtime.Context*)* %43, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-22

switch.case.next-21:
	%44 = icmp eq i64 %22, 21
	br i1 %44, label %switch.fall.body-24, label %switch.case.next-23

switch.fall.body-22:
	%45 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_3_0(void (%..rawptr, i8*, %runtime.Context*)* %45, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-24

switch.case.next-23:
	%46 = icmp eq i64 %22, 20
	br i1 %46, label %switch.fall.body-26, label %switch.case.next-25

switch.fall.body-24:
	%47 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_2_1(void (%..rawptr, i8*, %runtime.Context*)* %47, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-26

switch.case.next-25:
	%48 = icmp eq i64 %22, 15
	br i1 %48, label %switch.fall.body-28, label %switch.case.next-27

switch.fall.body-26:
	%49 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_2_0(void (%..rawptr, i8*, %runtime.Context*)* %49, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-28

switch.case.next-27:
	%50 = icmp eq i64 %22, 14
	br i1 %50, label %switch.fall.body-30, label %switch.case.next-29

switch.fall.body-28:
	%51 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_1_5(void (%..rawptr, i8*, %runtime.Context*)* %51, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-30

switch.case.next-29:
	%52 = icmp eq i64 %22, 13
	br i1 %52, label %switch.fall.body-32, label %switch.case.next-31

switch.fall.body-30:
	%53 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_1_4(void (%..rawptr, i8*, %runtime.Context*)* %53, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-32

switch.case.next-31:
	%54 = icmp eq i64 %22, 12
	br i1 %54, label %switch.fall.body-34, label %switch.case.next-33

switch.fall.body-32:
	%55 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_1_3(void (%..rawptr, i8*, %runtime.Context*)* %55, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-34

switch.case.next-33:
	%56 = icmp eq i64 %22, 11
	br i1 %56, label %switch.fall.body-36, label %switch.case.next-35

switch.fall.body-34:
	%57 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_1_2(void (%..rawptr, i8*, %runtime.Context*)* %57, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-36

switch.case.next-35:
	%58 = icmp eq i64 %22, 10
	br i1 %58, label %switch.fall.body-38, label %switch.case.next-37

switch.fall.body-36:
	%59 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_1_1(void (%..rawptr, i8*, %runtime.Context*)* %59, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; fallthrough
	br label %switch.fall.body-38

switch.case.next-37:
	br label %switch.done-39

switch.fall.body-38:
	%60 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %2, align 8
	call void @gl.load_1_0(void (%..rawptr, i8*, %runtime.Context*)* %60, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-39

switch.done-39:
	ret void
}

define void @gl.load_1_0(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32)** @gl.CullFace to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$337, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32)** @gl.FrontFace to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$338, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32)** @gl.Hint to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$339, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (float)** @gl.LineWidth to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$33a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (float)** @gl.PointSize to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$33b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast void (i32, i32)** @gl.PolygonMode to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$33c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast void (i32, i32, i32, i32)** @gl.Scissor to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$33d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void (i32, i32, float)** @gl.TexParameterf to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$33e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast void (i32, i32, float*)** @gl.TexParameterfv to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$33f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%20 = bitcast void (i32, i32, i32)** @gl.TexParameteri to %..rawptr
	call void %19(%..rawptr %20, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$340, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%22 = bitcast void (i32, i32, i32*)** @gl.TexParameteriv to %..rawptr
	call void %21(%..rawptr %22, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$341, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%24 = bitcast void (i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.TexImage1D to %..rawptr
	call void %23(%..rawptr %24, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$342, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%25 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%26 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.TexImage2D to %..rawptr
	call void %25(%..rawptr %26, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$343, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%27 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%28 = bitcast void (i32)** @gl.DrawBuffer to %..rawptr
	call void %27(%..rawptr %28, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$344, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%29 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%30 = bitcast void (i32)** @gl.Clear to %..rawptr
	call void %29(%..rawptr %30, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$345, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%31 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%32 = bitcast void (float, float, float, float)** @gl.ClearColor to %..rawptr
	call void %31(%..rawptr %32, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$346, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%33 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%34 = bitcast void (i32)** @gl.ClearStencil to %..rawptr
	call void %33(%..rawptr %34, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$347, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%35 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%36 = bitcast void (double)** @gl.ClearDepth to %..rawptr
	call void %35(%..rawptr %36, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$348, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%37 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%38 = bitcast void (i32)** @gl.StencilMask to %..rawptr
	call void %37(%..rawptr %38, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$349, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%39 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%40 = bitcast void (i8, i8, i8, i8)** @gl.ColorMask to %..rawptr
	call void %39(%..rawptr %40, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$34a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%41 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%42 = bitcast void (i8)** @gl.DepthMask to %..rawptr
	call void %41(%..rawptr %42, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$34b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%43 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%44 = bitcast void (i32)** @gl.Disable to %..rawptr
	call void %43(%..rawptr %44, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$34c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%45 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%46 = bitcast void (i32)** @gl.Enable to %..rawptr
	call void %45(%..rawptr %46, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$34d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%47 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%48 = bitcast void ()** @gl.Finish to %..rawptr
	call void %47(%..rawptr %48, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$34e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%49 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%50 = bitcast void ()** @gl.Flush to %..rawptr
	call void %49(%..rawptr %50, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$34f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%51 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%52 = bitcast void (i32, i32)** @gl.BlendFunc to %..rawptr
	call void %51(%..rawptr %52, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$350, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%53 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%54 = bitcast void (i32)** @gl.LogicOp to %..rawptr
	call void %53(%..rawptr %54, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$351, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%55 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%56 = bitcast void (i32, i32, i32)** @gl.StencilFunc to %..rawptr
	call void %55(%..rawptr %56, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$352, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%57 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%58 = bitcast void (i32, i32, i32)** @gl.StencilOp to %..rawptr
	call void %57(%..rawptr %58, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$353, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%59 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%60 = bitcast void (i32)** @gl.DepthFunc to %..rawptr
	call void %59(%..rawptr %60, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$354, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%61 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%62 = bitcast void (i32, float)** @gl.PixelStoref to %..rawptr
	call void %61(%..rawptr %62, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$355, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%63 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%64 = bitcast void (i32, i32)** @gl.PixelStorei to %..rawptr
	call void %63(%..rawptr %64, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$356, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%65 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%66 = bitcast void (i32)** @gl.ReadBuffer to %..rawptr
	call void %65(%..rawptr %66, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$357, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%67 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%68 = bitcast void (i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.ReadPixels to %..rawptr
	call void %67(%..rawptr %68, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$358, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%69 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%70 = bitcast void (i32, i8*)** @gl.GetBooleanv to %..rawptr
	call void %69(%..rawptr %70, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$359, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%71 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%72 = bitcast void (i32, double*)** @gl.GetDoublev to %..rawptr
	call void %71(%..rawptr %72, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$35a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%73 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%74 = bitcast i32 ()** @gl.GetError to %..rawptr
	call void %73(%..rawptr %74, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$35b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%75 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%76 = bitcast void (i32, float*)** @gl.GetFloatv to %..rawptr
	call void %75(%..rawptr %76, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$35c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%77 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%78 = bitcast void (i32, i32*)** @gl.GetIntegerv to %..rawptr
	call void %77(%..rawptr %78, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$35d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%79 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%80 = bitcast i8* (i32)** @gl.GetString to %..rawptr
	call void %79(%..rawptr %80, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$35e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%81 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%82 = bitcast void (i32, i32, i32, i32, %..rawptr)** @gl.GetTexImage to %..rawptr
	call void %81(%..rawptr %82, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$35f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%83 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%84 = bitcast void (i32, i32, float*)** @gl.GetTexParameterfv to %..rawptr
	call void %83(%..rawptr %84, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$360, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%85 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%86 = bitcast void (i32, i32, i32*)** @gl.GetTexParameteriv to %..rawptr
	call void %85(%..rawptr %86, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$361, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%87 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%88 = bitcast void (i32, i32, i32, float*)** @gl.GetTexLevelParameterfv to %..rawptr
	call void %87(%..rawptr %88, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$362, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%89 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%90 = bitcast void (i32, i32, i32, i32*)** @gl.GetTexLevelParameteriv to %..rawptr
	call void %89(%..rawptr %90, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$363, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%91 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%92 = bitcast i8 (i32)** @gl.IsEnabled to %..rawptr
	call void %91(%..rawptr %92, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$364, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%93 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%94 = bitcast void (double, double)** @gl.DepthRange to %..rawptr
	call void %93(%..rawptr %94, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$365, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%95 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%96 = bitcast void (i32, i32, i32, i32)** @gl.Viewport to %..rawptr
	call void %95(%..rawptr %96, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$366, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_1_1(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32, i32, i32)** @gl.DrawArrays to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$367, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, i32, i32, %..rawptr)** @gl.DrawElements to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$368, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (float, float)** @gl.PolygonOffset to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$369, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i32, i32, i32, i32, i32, i32, i32)** @gl.CopyTexImage1D to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$36a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32)** @gl.CopyTexImage2D to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$36b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast void (i32, i32, i32, i32, i32, i32)** @gl.CopyTexSubImage1D to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$36c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32)** @gl.CopyTexSubImage2D to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$36d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void (i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.TexSubImage1D to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$36e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.TexSubImage2D to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$36f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%20 = bitcast void (i32, i32)** @gl.BindTexture to %..rawptr
	call void %19(%..rawptr %20, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$370, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%22 = bitcast void (i32, i32*)** @gl.DeleteTextures to %..rawptr
	call void %21(%..rawptr %22, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$371, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%24 = bitcast void (i32, i32*)** @gl.GenTextures to %..rawptr
	call void %23(%..rawptr %24, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$372, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%25 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%26 = bitcast i8 (i32)** @gl.IsTexture to %..rawptr
	call void %25(%..rawptr %26, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$373, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_1_2(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32, i32, i32, i32, i32, %..rawptr)** @gl.DrawRangeElements to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$374, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.TexImage3D to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$375, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.TexSubImage3D to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$376, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, i32)** @gl.CopyTexSubImage3D to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$377, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_1_3(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32)** @gl.ActiveTexture to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$378, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (float, i8)** @gl.SampleCoverage to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$379, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.CompressedTexImage3D to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$37a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.CompressedTexImage2D to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$37b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.CompressedTexImage1D to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$37c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.CompressedTexSubImage3D to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$37d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.CompressedTexSubImage2D to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$37e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void (i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.CompressedTexSubImage1D to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$37f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast void (i32, i32, %..rawptr)** @gl.GetCompressedTexImage to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$380, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_1_4(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32, i32, i32, i32)** @gl.BlendFuncSeparate to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$381, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, i32*, i32*, i32)** @gl.MultiDrawArrays to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$382, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32*, i32, %..rawptr*, i32)** @gl.MultiDrawElements to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$383, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i32, float)** @gl.PointParameterf to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$384, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (i32, float*)** @gl.PointParameterfv to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$385, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast void (i32, i32)** @gl.PointParameteri to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$386, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast void (i32, i32*)** @gl.PointParameteriv to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$387, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void (float, float, float, float)** @gl.BlendColor to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$388, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast void (i32)** @gl.BlendEquation to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$389, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_1_5(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32, i32*)** @gl.GenQueries to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$38a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, i32*)** @gl.DeleteQueries to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$38b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast i8 (i32)** @gl.IsQuery to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$38c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i32, i32)** @gl.BeginQuery to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$38d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (i32)** @gl.EndQuery to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$38e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast void (i32, i32, i32*)** @gl.GetQueryiv to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$38f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast void (i32, i32, i32*)** @gl.GetQueryObjectiv to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$390, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void (i32, i32, i32*)** @gl.GetQueryObjectuiv to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$391, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast void (i32, i32)** @gl.BindBuffer to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$392, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%20 = bitcast void (i32, i32*)** @gl.DeleteBuffers to %..rawptr
	call void %19(%..rawptr %20, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$393, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%22 = bitcast void (i32, i32*)** @gl.GenBuffers to %..rawptr
	call void %21(%..rawptr %22, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$394, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%24 = bitcast i8 (i32)** @gl.IsBuffer to %..rawptr
	call void %23(%..rawptr %24, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$395, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%25 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%26 = bitcast void (i32, i64, %..rawptr, i32)** @gl.BufferData to %..rawptr
	call void %25(%..rawptr %26, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$396, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%27 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%28 = bitcast void (i32, i64, i64, %..rawptr)** @gl.BufferSubData to %..rawptr
	call void %27(%..rawptr %28, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$397, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%29 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%30 = bitcast void (i32, i64, i64, %..rawptr)** @gl.GetBufferSubData to %..rawptr
	call void %29(%..rawptr %30, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$398, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%31 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%32 = bitcast %..rawptr (i32, i32)** @gl.MapBuffer to %..rawptr
	call void %31(%..rawptr %32, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$399, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%33 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%34 = bitcast i8 (i32)** @gl.UnmapBuffer to %..rawptr
	call void %33(%..rawptr %34, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$39a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%35 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%36 = bitcast void (i32, i32, i32*)** @gl.GetBufferParameteriv to %..rawptr
	call void %35(%..rawptr %36, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$39b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%37 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%38 = bitcast void (i32, i32, %..rawptr*)** @gl.GetBufferPointerv to %..rawptr
	call void %37(%..rawptr %38, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$39c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_2_0(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32, i32)** @gl.BlendEquationSeparate to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$39d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, i32*)** @gl.DrawBuffers to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$39e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32, i32, i32)** @gl.StencilOpSeparate to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$39f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i32, i32, i32, i32)** @gl.StencilFuncSeparate to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$3a0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (i32, i32)** @gl.StencilMaskSeparate to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$3a1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast void (i32, i32)** @gl.AttachShader to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$3a2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast void (i32, i32, i8*)** @gl.BindAttribLocation to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$3a3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void (i32)** @gl.CompileShader to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$3a4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast i32 ()** @gl.CreateProgram to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$3a5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%20 = bitcast i32 (i32)** @gl.CreateShader to %..rawptr
	call void %19(%..rawptr %20, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$3a6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%22 = bitcast void (i32)** @gl.DeleteProgram to %..rawptr
	call void %21(%..rawptr %22, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$3a7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%24 = bitcast void (i32)** @gl.DeleteShader to %..rawptr
	call void %23(%..rawptr %24, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$3a8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%25 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%26 = bitcast void (i32, i32)** @gl.DetachShader to %..rawptr
	call void %25(%..rawptr %26, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$3a9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%27 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%28 = bitcast void (i32)** @gl.DisableVertexAttribArray to %..rawptr
	call void %27(%..rawptr %28, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$3aa, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%29 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%30 = bitcast void (i32)** @gl.EnableVertexAttribArray to %..rawptr
	call void %29(%..rawptr %30, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$3ab, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%31 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%32 = bitcast void (i32, i32, i32, i32*, i32*, i32*, i8*)** @gl.GetActiveAttrib to %..rawptr
	call void %31(%..rawptr %32, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3ac, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%33 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%34 = bitcast void (i32, i32, i32, i32*, i32*, i32*, i8*)** @gl.GetActiveUniform to %..rawptr
	call void %33(%..rawptr %34, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$3ad, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%35 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%36 = bitcast void (i32, i32, i32*, i32*)** @gl.GetAttachedShaders to %..rawptr
	call void %35(%..rawptr %36, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$3ae, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%37 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%38 = bitcast i32 (i32, i8*)** @gl.GetAttribLocation to %..rawptr
	call void %37(%..rawptr %38, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$3af, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%39 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%40 = bitcast void (i32, i32, i32*)** @gl.GetProgramiv to %..rawptr
	call void %39(%..rawptr %40, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$3b0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%41 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%42 = bitcast void (i32, i32, i32*, i8*)** @gl.GetProgramInfoLog to %..rawptr
	call void %41(%..rawptr %42, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$3b1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%43 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%44 = bitcast void (i32, i32, i32*)** @gl.GetShaderiv to %..rawptr
	call void %43(%..rawptr %44, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$3b2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%45 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%46 = bitcast void (i32, i32, i32*, i8*)** @gl.GetShaderInfoLog to %..rawptr
	call void %45(%..rawptr %46, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$3b3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%47 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%48 = bitcast void (i32, i32, i32*, i8*)** @gl.GetShaderSource to %..rawptr
	call void %47(%..rawptr %48, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3b4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%49 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%50 = bitcast i32 (i32, i8*)** @gl.GetUniformLocation to %..rawptr
	call void %49(%..rawptr %50, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$3b5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%51 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%52 = bitcast void (i32, i32, float*)** @gl.GetUniformfv to %..rawptr
	call void %51(%..rawptr %52, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$3b6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%53 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%54 = bitcast void (i32, i32, i32*)** @gl.GetUniformiv to %..rawptr
	call void %53(%..rawptr %54, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$3b7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%55 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%56 = bitcast void (i32, i32, double*)** @gl.GetVertexAttribdv to %..rawptr
	call void %55(%..rawptr %56, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$3b8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%57 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%58 = bitcast void (i32, i32, float*)** @gl.GetVertexAttribfv to %..rawptr
	call void %57(%..rawptr %58, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$3b9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%59 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%60 = bitcast void (i32, i32, i32*)** @gl.GetVertexAttribiv to %..rawptr
	call void %59(%..rawptr %60, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$3ba, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%61 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%62 = bitcast void (i32, i32, %..rawptr*)** @gl.GetVertexAttribPointerv to %..rawptr
	call void %61(%..rawptr %62, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$3bb, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%63 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%64 = bitcast i8 (i32)** @gl.IsProgram to %..rawptr
	call void %63(%..rawptr %64, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$3bc, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%65 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%66 = bitcast i8 (i32)** @gl.IsShader to %..rawptr
	call void %65(%..rawptr %66, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$3bd, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%67 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%68 = bitcast void (i32)** @gl.LinkProgram to %..rawptr
	call void %67(%..rawptr %68, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$3be, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%69 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%70 = bitcast void (i32, i32, i8**, i32*)** @gl.ShaderSource to %..rawptr
	call void %69(%..rawptr %70, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$3bf, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%71 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%72 = bitcast void (i32)** @gl.UseProgram to %..rawptr
	call void %71(%..rawptr %72, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$3c0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%73 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%74 = bitcast void (i32, float)** @gl.Uniform1f to %..rawptr
	call void %73(%..rawptr %74, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$3c1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%75 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%76 = bitcast void (i32, float, float)** @gl.Uniform2f to %..rawptr
	call void %75(%..rawptr %76, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$3c2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%77 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%78 = bitcast void (i32, float, float, float)** @gl.Uniform3f to %..rawptr
	call void %77(%..rawptr %78, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$3c3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%79 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%80 = bitcast void (i32, float, float, float, float)** @gl.Uniform4f to %..rawptr
	call void %79(%..rawptr %80, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$3c4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%81 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%82 = bitcast void (i32, i32)** @gl.Uniform1i to %..rawptr
	call void %81(%..rawptr %82, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$3c5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%83 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%84 = bitcast void (i32, i32, i32)** @gl.Uniform2i to %..rawptr
	call void %83(%..rawptr %84, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$3c6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%85 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%86 = bitcast void (i32, i32, i32, i32)** @gl.Uniform3i to %..rawptr
	call void %85(%..rawptr %86, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$3c7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%87 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%88 = bitcast void (i32, i32, i32, i32, i32)** @gl.Uniform4i to %..rawptr
	call void %87(%..rawptr %88, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$3c8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%89 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%90 = bitcast void (i32, i32, float*)** @gl.Uniform1fv to %..rawptr
	call void %89(%..rawptr %90, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$3c9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%91 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%92 = bitcast void (i32, i32, float*)** @gl.Uniform2fv to %..rawptr
	call void %91(%..rawptr %92, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$3ca, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%93 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%94 = bitcast void (i32, i32, float*)** @gl.Uniform3fv to %..rawptr
	call void %93(%..rawptr %94, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$3cb, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%95 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%96 = bitcast void (i32, i32, float*)** @gl.Uniform4fv to %..rawptr
	call void %95(%..rawptr %96, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$3cc, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%97 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%98 = bitcast void (i32, i32, i32*)** @gl.Uniform1iv to %..rawptr
	call void %97(%..rawptr %98, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$3cd, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%99 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%100 = bitcast void (i32, i32, i32*)** @gl.Uniform2iv to %..rawptr
	call void %99(%..rawptr %100, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$3ce, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%101 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%102 = bitcast void (i32, i32, i32*)** @gl.Uniform3iv to %..rawptr
	call void %101(%..rawptr %102, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$3cf, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%103 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%104 = bitcast void (i32, i32, i32*)** @gl.Uniform4iv to %..rawptr
	call void %103(%..rawptr %104, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$3d0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%105 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%106 = bitcast void (i32, i32, i8, float*)** @gl.UniformMatrix2fv to %..rawptr
	call void %105(%..rawptr %106, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$3d1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%107 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%108 = bitcast void (i32, i32, i8, float*)** @gl.UniformMatrix3fv to %..rawptr
	call void %107(%..rawptr %108, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$3d2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%109 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%110 = bitcast void (i32, i32, i8, float*)** @gl.UniformMatrix4fv to %..rawptr
	call void %109(%..rawptr %110, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$3d3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%111 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%112 = bitcast void (i32)** @gl.ValidateProgram to %..rawptr
	call void %111(%..rawptr %112, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3d4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%113 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%114 = bitcast void (i32, double)** @gl.VertexAttrib1d to %..rawptr
	call void %113(%..rawptr %114, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$3d5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%115 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%116 = bitcast void (i32, double*)** @gl.VertexAttrib1dv to %..rawptr
	call void %115(%..rawptr %116, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3d6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%117 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%118 = bitcast void (i32, float)** @gl.VertexAttrib1f to %..rawptr
	call void %117(%..rawptr %118, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$3d7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%119 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%120 = bitcast void (i32, float*)** @gl.VertexAttrib1fv to %..rawptr
	call void %119(%..rawptr %120, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3d8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%121 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%122 = bitcast void (i32, i16)** @gl.VertexAttrib1s to %..rawptr
	call void %121(%..rawptr %122, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$3d9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%123 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%124 = bitcast void (i32, i16*)** @gl.VertexAttrib1sv to %..rawptr
	call void %123(%..rawptr %124, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3da, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%125 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%126 = bitcast void (i32, double, double)** @gl.VertexAttrib2d to %..rawptr
	call void %125(%..rawptr %126, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$3db, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%127 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%128 = bitcast void (i32, double*)** @gl.VertexAttrib2dv to %..rawptr
	call void %127(%..rawptr %128, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3dc, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%129 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%130 = bitcast void (i32, float, float)** @gl.VertexAttrib2f to %..rawptr
	call void %129(%..rawptr %130, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$3dd, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%131 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%132 = bitcast void (i32, float*)** @gl.VertexAttrib2fv to %..rawptr
	call void %131(%..rawptr %132, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3de, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%133 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%134 = bitcast void (i32, i16, i16)** @gl.VertexAttrib2s to %..rawptr
	call void %133(%..rawptr %134, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$3df, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%135 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%136 = bitcast void (i32, i16*)** @gl.VertexAttrib2sv to %..rawptr
	call void %135(%..rawptr %136, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3e0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%137 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%138 = bitcast void (i32, double, double, double)** @gl.VertexAttrib3d to %..rawptr
	call void %137(%..rawptr %138, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$3e1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%139 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%140 = bitcast void (i32, double*)** @gl.VertexAttrib3dv to %..rawptr
	call void %139(%..rawptr %140, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3e2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%141 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%142 = bitcast void (i32, float, float, float)** @gl.VertexAttrib3f to %..rawptr
	call void %141(%..rawptr %142, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$3e3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%143 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%144 = bitcast void (i32, float*)** @gl.VertexAttrib3fv to %..rawptr
	call void %143(%..rawptr %144, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3e4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%145 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%146 = bitcast void (i32, i16, i16, i16)** @gl.VertexAttrib3s to %..rawptr
	call void %145(%..rawptr %146, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$3e5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%147 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%148 = bitcast void (i32, i16*)** @gl.VertexAttrib3sv to %..rawptr
	call void %147(%..rawptr %148, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3e6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%149 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%150 = bitcast void (i32, i8*)** @gl.VertexAttrib4Nbv to %..rawptr
	call void %149(%..rawptr %150, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$3e7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%151 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%152 = bitcast void (i32, i32*)** @gl.VertexAttrib4Niv to %..rawptr
	call void %151(%..rawptr %152, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$3e8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%153 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%154 = bitcast void (i32, i16*)** @gl.VertexAttrib4Nsv to %..rawptr
	call void %153(%..rawptr %154, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$3e9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%155 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%156 = bitcast void (i32, i8, i8, i8, i8)** @gl.VertexAttrib4Nub to %..rawptr
	call void %155(%..rawptr %156, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$3ea, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%157 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%158 = bitcast void (i32, i8*)** @gl.VertexAttrib4Nubv to %..rawptr
	call void %157(%..rawptr %158, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$3eb, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%159 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%160 = bitcast void (i32, i32*)** @gl.VertexAttrib4Nuiv to %..rawptr
	call void %159(%..rawptr %160, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$3ec, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%161 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%162 = bitcast void (i32, i16*)** @gl.VertexAttrib4Nusv to %..rawptr
	call void %161(%..rawptr %162, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$3ed, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%163 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%164 = bitcast void (i32, i8*)** @gl.VertexAttrib4bv to %..rawptr
	call void %163(%..rawptr %164, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3ee, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%165 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%166 = bitcast void (i32, double, double, double, double)** @gl.VertexAttrib4d to %..rawptr
	call void %165(%..rawptr %166, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$3ef, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%167 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%168 = bitcast void (i32, double*)** @gl.VertexAttrib4dv to %..rawptr
	call void %167(%..rawptr %168, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3f0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%169 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%170 = bitcast void (i32, float, float, float, float)** @gl.VertexAttrib4f to %..rawptr
	call void %169(%..rawptr %170, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$3f1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%171 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%172 = bitcast void (i32, float*)** @gl.VertexAttrib4fv to %..rawptr
	call void %171(%..rawptr %172, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3f2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%173 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%174 = bitcast void (i32, i32*)** @gl.VertexAttrib4iv to %..rawptr
	call void %173(%..rawptr %174, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3f3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%175 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%176 = bitcast void (i32, i16, i16, i16, i16)** @gl.VertexAttrib4s to %..rawptr
	call void %175(%..rawptr %176, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$3f4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%177 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%178 = bitcast void (i32, i16*)** @gl.VertexAttrib4sv to %..rawptr
	call void %177(%..rawptr %178, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$3f5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%179 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%180 = bitcast void (i32, i8*)** @gl.VertexAttrib4ubv to %..rawptr
	call void %179(%..rawptr %180, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$3f6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%181 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%182 = bitcast void (i32, i32*)** @gl.VertexAttrib4uiv to %..rawptr
	call void %181(%..rawptr %182, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$3f7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%183 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%184 = bitcast void (i32, i16*)** @gl.VertexAttrib4usv to %..rawptr
	call void %183(%..rawptr %184, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$3f8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%185 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%186 = bitcast void (i32, i32, i32, i8, i32, %..rawptr)** @gl.VertexAttribPointer to %..rawptr
	call void %185(%..rawptr %186, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$3f9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_2_1(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32, i32, i8, float*)** @gl.UniformMatrix2x3fv to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$3fa, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, i32, i8, float*)** @gl.UniformMatrix3x2fv to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$3fb, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32, i8, float*)** @gl.UniformMatrix2x4fv to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$3fc, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i32, i32, i8, float*)** @gl.UniformMatrix4x2fv to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$3fd, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (i32, i32, i8, float*)** @gl.UniformMatrix3x4fv to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$3fe, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast void (i32, i32, i8, float*)** @gl.UniformMatrix4x3fv to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$3ff, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_3_0(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32, i8, i8, i8, i8)** @gl.ColorMaski to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$400, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, i32, i8*)** @gl.GetBooleani_v to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$401, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32, i32*)** @gl.GetIntegeri_v to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$402, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i32, i32)** @gl.Enablei to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$403, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (i32, i32)** @gl.Disablei to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$404, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast i8 (i32, i32)** @gl.IsEnabledi to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$405, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast void (i32)** @gl.BeginTransformFeedback to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$406, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void ()** @gl.EndTransformFeedback to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$407, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast void (i32, i32, i32, i64, i64)** @gl.BindBufferRange to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$408, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%20 = bitcast void (i32, i32, i32)** @gl.BindBufferBase to %..rawptr
	call void %19(%..rawptr %20, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$409, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%22 = bitcast void (i32, i32, i8*, i32)** @gl.TransformFeedbackVaryings to %..rawptr
	call void %21(%..rawptr %22, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$40a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%24 = bitcast void (i32, i32, i32, i32*, i32*, i32*, i8*)** @gl.GetTransformFeedbackVarying to %..rawptr
	call void %23(%..rawptr %24, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$40b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%25 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%26 = bitcast void (i32, i32)** @gl.ClampColor to %..rawptr
	call void %25(%..rawptr %26, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$40c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%27 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%28 = bitcast void (i32, i32)** @gl.BeginConditionalRender to %..rawptr
	call void %27(%..rawptr %28, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$40d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%29 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%30 = bitcast void ()** @gl.EndConditionalRender to %..rawptr
	call void %29(%..rawptr %30, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$40e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%31 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%32 = bitcast void (i32, i32, i32, i32, %..rawptr)** @gl.VertexAttribIPointer to %..rawptr
	call void %31(%..rawptr %32, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$40f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%33 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%34 = bitcast void (i32, i32, i32*)** @gl.GetVertexAttribIiv to %..rawptr
	call void %33(%..rawptr %34, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$410, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%35 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%36 = bitcast void (i32, i32, i32*)** @gl.GetVertexAttribIuiv to %..rawptr
	call void %35(%..rawptr %36, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$411, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%37 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%38 = bitcast void (i32, i32)** @gl.VertexAttribI1i to %..rawptr
	call void %37(%..rawptr %38, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$412, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%39 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%40 = bitcast void (i32, i32, i32)** @gl.VertexAttribI2i to %..rawptr
	call void %39(%..rawptr %40, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$413, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%41 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%42 = bitcast void (i32, i32, i32, i32)** @gl.VertexAttribI3i to %..rawptr
	call void %41(%..rawptr %42, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$414, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%43 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%44 = bitcast void (i32, i32, i32, i32, i32)** @gl.VertexAttribI4i to %..rawptr
	call void %43(%..rawptr %44, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$415, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%45 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%46 = bitcast void (i32, i32)** @gl.VertexAttribI1ui to %..rawptr
	call void %45(%..rawptr %46, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$416, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%47 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%48 = bitcast void (i32, i32, i32)** @gl.VertexAttribI2ui to %..rawptr
	call void %47(%..rawptr %48, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$417, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%49 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%50 = bitcast void (i32, i32, i32, i32)** @gl.VertexAttribI3ui to %..rawptr
	call void %49(%..rawptr %50, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$418, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%51 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%52 = bitcast void (i32, i32, i32, i32, i32)** @gl.VertexAttribI4ui to %..rawptr
	call void %51(%..rawptr %52, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$419, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%53 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%54 = bitcast void (i32, i32*)** @gl.VertexAttribI1iv to %..rawptr
	call void %53(%..rawptr %54, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$41a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%55 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%56 = bitcast void (i32, i32*)** @gl.VertexAttribI2iv to %..rawptr
	call void %55(%..rawptr %56, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$41b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%57 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%58 = bitcast void (i32, i32*)** @gl.VertexAttribI3iv to %..rawptr
	call void %57(%..rawptr %58, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$41c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%59 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%60 = bitcast void (i32, i32*)** @gl.VertexAttribI4iv to %..rawptr
	call void %59(%..rawptr %60, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$41d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%61 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%62 = bitcast void (i32, i32*)** @gl.VertexAttribI1uiv to %..rawptr
	call void %61(%..rawptr %62, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$41e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%63 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%64 = bitcast void (i32, i32*)** @gl.VertexAttribI2uiv to %..rawptr
	call void %63(%..rawptr %64, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$41f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%65 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%66 = bitcast void (i32, i32*)** @gl.VertexAttribI3uiv to %..rawptr
	call void %65(%..rawptr %66, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$420, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%67 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%68 = bitcast void (i32, i32*)** @gl.VertexAttribI4uiv to %..rawptr
	call void %67(%..rawptr %68, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$421, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%69 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%70 = bitcast void (i32, i8*)** @gl.VertexAttribI4bv to %..rawptr
	call void %69(%..rawptr %70, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$422, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%71 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%72 = bitcast void (i32, i16*)** @gl.VertexAttribI4sv to %..rawptr
	call void %71(%..rawptr %72, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$423, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%73 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%74 = bitcast void (i32, i8*)** @gl.VertexAttribI4ubv to %..rawptr
	call void %73(%..rawptr %74, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$424, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%75 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%76 = bitcast void (i32, i16*)** @gl.VertexAttribI4usv to %..rawptr
	call void %75(%..rawptr %76, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$425, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%77 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%78 = bitcast void (i32, i32, i32*)** @gl.GetUniformuiv to %..rawptr
	call void %77(%..rawptr %78, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$426, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%79 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%80 = bitcast void (i32, i32, i8*)** @gl.BindFragDataLocation to %..rawptr
	call void %79(%..rawptr %80, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$427, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%81 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%82 = bitcast i32 (i32, i8*)** @gl.GetFragDataLocation to %..rawptr
	call void %81(%..rawptr %82, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$428, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%83 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%84 = bitcast void (i32, i32)** @gl.Uniform1ui to %..rawptr
	call void %83(%..rawptr %84, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$429, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%85 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%86 = bitcast void (i32, i32, i32)** @gl.Uniform2ui to %..rawptr
	call void %85(%..rawptr %86, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$42a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%87 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%88 = bitcast void (i32, i32, i32, i32)** @gl.Uniform3ui to %..rawptr
	call void %87(%..rawptr %88, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$42b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%89 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%90 = bitcast void (i32, i32, i32, i32, i32)** @gl.Uniform4ui to %..rawptr
	call void %89(%..rawptr %90, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$42c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%91 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%92 = bitcast void (i32, i32, i32*)** @gl.Uniform1uiv to %..rawptr
	call void %91(%..rawptr %92, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$42d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%93 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%94 = bitcast void (i32, i32, i32*)** @gl.Uniform2uiv to %..rawptr
	call void %93(%..rawptr %94, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$42e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%95 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%96 = bitcast void (i32, i32, i32*)** @gl.Uniform3uiv to %..rawptr
	call void %95(%..rawptr %96, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$42f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%97 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%98 = bitcast void (i32, i32, i32*)** @gl.Uniform4uiv to %..rawptr
	call void %97(%..rawptr %98, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$430, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%99 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%100 = bitcast void (i32, i32, i32*)** @gl.TexParameterIiv to %..rawptr
	call void %99(%..rawptr %100, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$431, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%101 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%102 = bitcast void (i32, i32, i32*)** @gl.TexParameterIuiv to %..rawptr
	call void %101(%..rawptr %102, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$432, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%103 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%104 = bitcast void (i32, i32, i32*)** @gl.GetTexParameterIiv to %..rawptr
	call void %103(%..rawptr %104, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$433, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%105 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%106 = bitcast void (i32, i32, i32*)** @gl.GetTexParameterIuiv to %..rawptr
	call void %105(%..rawptr %106, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$434, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%107 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%108 = bitcast void (i32, i32, i32*)** @gl.ClearBufferiv to %..rawptr
	call void %107(%..rawptr %108, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$435, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%109 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%110 = bitcast void (i32, i32, i32*)** @gl.ClearBufferuiv to %..rawptr
	call void %109(%..rawptr %110, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$436, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%111 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%112 = bitcast void (i32, i32, float*)** @gl.ClearBufferfv to %..rawptr
	call void %111(%..rawptr %112, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$437, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%113 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%114 = bitcast %..rawptr (i32, i32, float, i32)** @gl.ClearBufferfi to %..rawptr
	call void %113(%..rawptr %114, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$438, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%115 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%116 = bitcast i8 (i32, i32)** @gl.GetStringi to %..rawptr
	call void %115(%..rawptr %116, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$439, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%117 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%118 = bitcast i8 (i32)** @gl.IsRenderbuffer to %..rawptr
	call void %117(%..rawptr %118, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$43a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%119 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%120 = bitcast void (i32, i32)** @gl.BindRenderbuffer to %..rawptr
	call void %119(%..rawptr %120, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$43b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%121 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%122 = bitcast void (i32, i32*)** @gl.DeleteRenderbuffers to %..rawptr
	call void %121(%..rawptr %122, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$43c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%123 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%124 = bitcast void (i32, i32*)** @gl.GenRenderbuffers to %..rawptr
	call void %123(%..rawptr %124, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$43d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%125 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%126 = bitcast void (i32, i32, i32, i32)** @gl.RenderbufferStorage to %..rawptr
	call void %125(%..rawptr %126, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$43e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%127 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%128 = bitcast void (i32, i32, i32*)** @gl.GetRenderbufferParameteriv to %..rawptr
	call void %127(%..rawptr %128, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @str$43f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%129 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%130 = bitcast i8 (i32)** @gl.IsFramebuffer to %..rawptr
	call void %129(%..rawptr %130, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$440, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%131 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%132 = bitcast void (i32, i32)** @gl.BindFramebuffer to %..rawptr
	call void %131(%..rawptr %132, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$441, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%133 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%134 = bitcast void (i32, i32*)** @gl.DeleteFramebuffers to %..rawptr
	call void %133(%..rawptr %134, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$442, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%135 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%136 = bitcast void (i32, i32*)** @gl.GenFramebuffers to %..rawptr
	call void %135(%..rawptr %136, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$443, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%137 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%138 = bitcast i32 (i32)** @gl.CheckFramebufferStatus to %..rawptr
	call void %137(%..rawptr %138, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$444, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%139 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%140 = bitcast void (i32, i32, i32, i32, i32)** @gl.FramebufferTexture1D to %..rawptr
	call void %139(%..rawptr %140, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$445, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%141 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%142 = bitcast void (i32, i32, i32, i32, i32)** @gl.FramebufferTexture2D to %..rawptr
	call void %141(%..rawptr %142, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$446, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%143 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%144 = bitcast void (i32, i32, i32, i32, i32, i32)** @gl.FramebufferTexture3D to %..rawptr
	call void %143(%..rawptr %144, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$447, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%145 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%146 = bitcast void (i32, i32, i32, i32)** @gl.FramebufferRenderbuffer to %..rawptr
	call void %145(%..rawptr %146, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$448, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%147 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%148 = bitcast void (i32, i32, i32, i32*)** @gl.GetFramebufferAttachmentParameteriv to %..rawptr
	call void %147(%..rawptr %148, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str$449, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%149 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%150 = bitcast void (i32)** @gl.GenerateMipmap to %..rawptr
	call void %149(%..rawptr %150, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$44a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%151 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%152 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32)** @gl.BlitFramebuffer to %..rawptr
	call void %151(%..rawptr %152, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$44b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%153 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%154 = bitcast void (i32, i32, i32, i32, i32)** @gl.RenderbufferStorageMultisample to %..rawptr
	call void %153(%..rawptr %154, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @str$44c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%155 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%156 = bitcast void (i32, i32, i32, i32, i32)** @gl.FramebufferTextureLayer to %..rawptr
	call void %155(%..rawptr %156, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$44d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%157 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%158 = bitcast %..rawptr (i32, i64, i64, i32)** @gl.MapBufferRange to %..rawptr
	call void %157(%..rawptr %158, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$44e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%159 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%160 = bitcast void (i32, i64, i64)** @gl.FlushMappedBufferRange to %..rawptr
	call void %159(%..rawptr %160, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$44f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%161 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%162 = bitcast void (i32)** @gl.BindVertexArray to %..rawptr
	call void %161(%..rawptr %162, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$450, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%163 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%164 = bitcast void (i32, i32*)** @gl.DeleteVertexArrays to %..rawptr
	call void %163(%..rawptr %164, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$451, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%165 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%166 = bitcast void (i32, i32*)** @gl.GenVertexArrays to %..rawptr
	call void %165(%..rawptr %166, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$452, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%167 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%168 = bitcast i8 (i32)** @gl.IsVertexArray to %..rawptr
	call void %167(%..rawptr %168, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$453, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_3_1(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32, i32, i32, i32)** @gl.DrawArraysInstanced to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$454, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, i32, i32, %..rawptr, i32)** @gl.DrawElementsInstanced to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$455, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32, i32)** @gl.TexBuffer to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$456, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i32)** @gl.PrimitiveRestartIndex to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$457, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (i32, i32, i64, i64, i64)** @gl.CopyBufferSubData to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$458, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast void (i32, i32, i8*, i32*)** @gl.GetUniformIndices to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$459, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast void (i32, i32, i32*, i32, i32*)** @gl.GetActiveUniformsiv to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$45a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void (i32, i32, i32, i32*, i8*)** @gl.GetActiveUniformName to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$45b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast i32 (i32, i8*)** @gl.GetUniformBlockIndex to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$45c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%20 = bitcast void (i32, i32, i32, i32*)** @gl.GetActiveUniformBlockiv to %..rawptr
	call void %19(%..rawptr %20, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$45d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%22 = bitcast void (i32, i32, i32, i32*, i8*)** @gl.GetActiveUniformBlockName to %..rawptr
	call void %21(%..rawptr %22, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$45e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%24 = bitcast void (i32, i32, i32)** @gl.UniformBlockBinding to %..rawptr
	call void %23(%..rawptr %24, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$45f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_3_2(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32, i32, i32, %..rawptr, i32)** @gl.DrawElementsBaseVertex to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$460, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, i32, i32, i32, i32, %..rawptr, i32)** @gl.DrawRangeElementsBaseVertex to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$461, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32, i32, %..rawptr, i32, i32)** @gl.DrawElementsInstancedBaseVertex to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @str$462, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i32, i32*, i32, %..rawptr*, i32, i32*)** @gl.MultiDrawElementsBaseVertex to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$463, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (i32)** @gl.ProvokingVertex to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$464, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast %..rawptr (i32, i32)** @gl.FenceSync to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$465, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast i8 (%..rawptr)** @gl.IsSync to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$466, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void (%..rawptr)** @gl.DeleteSync to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$467, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast i32 (%..rawptr, i32, i64)** @gl.ClientWaitSync to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$468, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%20 = bitcast void (%..rawptr, i32, i64)** @gl.WaitSync to %..rawptr
	call void %19(%..rawptr %20, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$469, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%22 = bitcast void (i32, i64*)** @gl.GetInteger64v to %..rawptr
	call void %21(%..rawptr %22, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$46a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%24 = bitcast void (%..rawptr, i32, i32, i32*, i32*)** @gl.GetSynciv to %..rawptr
	call void %23(%..rawptr %24, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$46b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%25 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%26 = bitcast void (i32, i32, i64*)** @gl.GetInteger64i_v to %..rawptr
	call void %25(%..rawptr %26, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$46c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%27 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%28 = bitcast void (i32, i32, i64*)** @gl.GetBufferParameteri64v to %..rawptr
	call void %27(%..rawptr %28, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$46d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%29 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%30 = bitcast void (i32, i32, i32, i32)** @gl.FramebufferTexture to %..rawptr
	call void %29(%..rawptr %30, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$46e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%31 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%32 = bitcast void (i32, i32, i32, i32, i32, i8)** @gl.TexImage2DMultisample to %..rawptr
	call void %31(%..rawptr %32, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$46f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%33 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%34 = bitcast void (i32, i32, i32, i32, i32, i32, i8)** @gl.TexImage3DMultisample to %..rawptr
	call void %33(%..rawptr %34, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$470, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%35 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%36 = bitcast void (i32, i32, float*)** @gl.GetMultisamplefv to %..rawptr
	call void %35(%..rawptr %36, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$471, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%37 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%38 = bitcast void (i32, i32)** @gl.SampleMaski to %..rawptr
	call void %37(%..rawptr %38, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$472, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_3_3(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32, i32, i32, i8*)** @gl.BindFragDataLocationIndexed to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$473, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast i32 (i32, i8*)** @gl.GetFragDataIndex to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$474, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32*)** @gl.GenSamplers to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$475, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i32, i32*)** @gl.DeleteSamplers to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$476, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast i8 (i32)** @gl.IsSampler to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$477, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast void (i32, i32)** @gl.BindSampler to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$478, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast void (i32, i32, i32)** @gl.SamplerParameteri to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$479, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void (i32, i32, i32*)** @gl.SamplerParameteriv to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$47a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast void (i32, i32, float)** @gl.SamplerParameterf to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$47b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%20 = bitcast void (i32, i32, float*)** @gl.SamplerParameterfv to %..rawptr
	call void %19(%..rawptr %20, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$47c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%22 = bitcast void (i32, i32, i32*)** @gl.SamplerParameterIiv to %..rawptr
	call void %21(%..rawptr %22, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$47d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%24 = bitcast void (i32, i32, i32*)** @gl.SamplerParameterIuiv to %..rawptr
	call void %23(%..rawptr %24, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$47e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%25 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%26 = bitcast void (i32, i32, i32*)** @gl.GetSamplerParameteriv to %..rawptr
	call void %25(%..rawptr %26, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$47f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%27 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%28 = bitcast void (i32, i32, i32*)** @gl.GetSamplerParameterIiv to %..rawptr
	call void %27(%..rawptr %28, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$480, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%29 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%30 = bitcast void (i32, i32, float*)** @gl.GetSamplerParameterfv to %..rawptr
	call void %29(%..rawptr %30, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$481, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%31 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%32 = bitcast void (i32, i32, i32*)** @gl.GetSamplerParameterIuiv to %..rawptr
	call void %31(%..rawptr %32, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$482, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%33 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%34 = bitcast void (i32, i32)** @gl.QueryCounter to %..rawptr
	call void %33(%..rawptr %34, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$483, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%35 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%36 = bitcast void (i32, i32, i64*)** @gl.GetQueryObjecti64v to %..rawptr
	call void %35(%..rawptr %36, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$484, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%37 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%38 = bitcast void (i32, i32, i64*)** @gl.GetQueryObjectui64v to %..rawptr
	call void %37(%..rawptr %38, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$485, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%39 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%40 = bitcast void (i32, i32)** @gl.VertexAttribDivisor to %..rawptr
	call void %39(%..rawptr %40, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$486, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%41 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%42 = bitcast void (i32, i32, i8, i32)** @gl.VertexAttribP1ui to %..rawptr
	call void %41(%..rawptr %42, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$487, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%43 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%44 = bitcast void (i32, i32, i8, i32*)** @gl.VertexAttribP1uiv to %..rawptr
	call void %43(%..rawptr %44, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$488, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%45 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%46 = bitcast void (i32, i32, i8, i32)** @gl.VertexAttribP2ui to %..rawptr
	call void %45(%..rawptr %46, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$489, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%47 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%48 = bitcast void (i32, i32, i8, i32*)** @gl.VertexAttribP2uiv to %..rawptr
	call void %47(%..rawptr %48, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$48a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%49 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%50 = bitcast void (i32, i32, i8, i32)** @gl.VertexAttribP3ui to %..rawptr
	call void %49(%..rawptr %50, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$48b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%51 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%52 = bitcast void (i32, i32, i8, i32*)** @gl.VertexAttribP3uiv to %..rawptr
	call void %51(%..rawptr %52, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$48c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%53 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%54 = bitcast void (i32, i32, i8, i32)** @gl.VertexAttribP4ui to %..rawptr
	call void %53(%..rawptr %54, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$48d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%55 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%56 = bitcast void (i32, i32, i8, i32*)** @gl.VertexAttribP4uiv to %..rawptr
	call void %55(%..rawptr %56, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$48e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%57 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%58 = bitcast void (i32, i32)** @gl.VertexP2ui to %..rawptr
	call void %57(%..rawptr %58, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$48f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%59 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%60 = bitcast void (i32, i32*)** @gl.VertexP2uiv to %..rawptr
	call void %59(%..rawptr %60, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$490, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%61 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%62 = bitcast void (i32, i32)** @gl.VertexP3ui to %..rawptr
	call void %61(%..rawptr %62, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$491, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%63 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%64 = bitcast void (i32, i32*)** @gl.VertexP3uiv to %..rawptr
	call void %63(%..rawptr %64, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$492, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%65 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%66 = bitcast void (i32, i32)** @gl.VertexP4ui to %..rawptr
	call void %65(%..rawptr %66, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$493, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%67 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%68 = bitcast void (i32, i32*)** @gl.VertexP4uiv to %..rawptr
	call void %67(%..rawptr %68, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$494, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%69 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%70 = bitcast void (i32, i32)** @gl.TexCoordP1ui to %..rawptr
	call void %69(%..rawptr %70, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$495, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%71 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%72 = bitcast void (i32, i32*)** @gl.TexCoordP1uiv to %..rawptr
	call void %71(%..rawptr %72, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$496, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%73 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%74 = bitcast void (i32, i32)** @gl.TexCoordP2ui to %..rawptr
	call void %73(%..rawptr %74, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$497, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%75 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%76 = bitcast void (i32, i32*)** @gl.TexCoordP2uiv to %..rawptr
	call void %75(%..rawptr %76, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$498, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%77 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%78 = bitcast void (i32, i32)** @gl.TexCoordP3ui to %..rawptr
	call void %77(%..rawptr %78, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$499, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%79 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%80 = bitcast void (i32, i32*)** @gl.TexCoordP3uiv to %..rawptr
	call void %79(%..rawptr %80, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$49a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%81 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%82 = bitcast void (i32, i32)** @gl.TexCoordP4ui to %..rawptr
	call void %81(%..rawptr %82, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$49b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%83 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%84 = bitcast void (i32, i32*)** @gl.TexCoordP4uiv to %..rawptr
	call void %83(%..rawptr %84, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$49c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%85 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%86 = bitcast void (i32, i32, i32)** @gl.MultiTexCoordP1ui to %..rawptr
	call void %85(%..rawptr %86, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$49d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%87 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%88 = bitcast void (i32, i32, i32*)** @gl.MultiTexCoordP1uiv to %..rawptr
	call void %87(%..rawptr %88, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$49e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%89 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%90 = bitcast void (i32, i32, i32)** @gl.MultiTexCoordP2ui to %..rawptr
	call void %89(%..rawptr %90, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$49f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%91 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%92 = bitcast void (i32, i32, i32*)** @gl.MultiTexCoordP2uiv to %..rawptr
	call void %91(%..rawptr %92, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$4a0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%93 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%94 = bitcast void (i32, i32, i32)** @gl.MultiTexCoordP3ui to %..rawptr
	call void %93(%..rawptr %94, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4a1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%95 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%96 = bitcast void (i32, i32, i32*)** @gl.MultiTexCoordP3uiv to %..rawptr
	call void %95(%..rawptr %96, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$4a2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%97 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%98 = bitcast void (i32, i32, i32)** @gl.MultiTexCoordP4ui to %..rawptr
	call void %97(%..rawptr %98, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4a3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%99 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%100 = bitcast void (i32, i32, i32*)** @gl.MultiTexCoordP4uiv to %..rawptr
	call void %99(%..rawptr %100, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$4a4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%101 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%102 = bitcast void (i32, i32)** @gl.NormalP3ui to %..rawptr
	call void %101(%..rawptr %102, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$4a5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%103 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%104 = bitcast void (i32, i32*)** @gl.NormalP3uiv to %..rawptr
	call void %103(%..rawptr %104, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$4a6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%105 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%106 = bitcast void (i32, i32)** @gl.ColorP3ui to %..rawptr
	call void %105(%..rawptr %106, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$4a7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%107 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%108 = bitcast void (i32, i32*)** @gl.ColorP3uiv to %..rawptr
	call void %107(%..rawptr %108, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$4a8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%109 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%110 = bitcast void (i32, i32)** @gl.ColorP4ui to %..rawptr
	call void %109(%..rawptr %110, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$4a9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%111 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%112 = bitcast void (i32, i32*)** @gl.ColorP4uiv to %..rawptr
	call void %111(%..rawptr %112, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$4aa, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%113 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%114 = bitcast void (i32, i32)** @gl.SecondaryColorP3ui to %..rawptr
	call void %113(%..rawptr %114, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$4ab, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%115 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%116 = bitcast void (i32, i32*)** @gl.SecondaryColorP3uiv to %..rawptr
	call void %115(%..rawptr %116, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$4ac, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_4_0(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (float)** @gl.MinSampleShading to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4ad, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, i32)** @gl.BlendEquationi to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$4ae, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32, i32)** @gl.BlendEquationSeparatei to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$4af, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i32, i32, i32)** @gl.BlendFunci to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$4b0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (i32, i32, i32, i32, i32)** @gl.BlendFuncSeparatei to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$4b1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast void (i32, %..rawptr)** @gl.DrawArraysIndirect to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$4b2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast void (i32, i32, %..rawptr)** @gl.DrawElementsIndirect to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$4b3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void (i32, double)** @gl.Uniform1d to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$4b4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast void (i32, double, double)** @gl.Uniform2d to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$4b5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%20 = bitcast void (i32, double, double, double)** @gl.Uniform3d to %..rawptr
	call void %19(%..rawptr %20, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$4b6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%22 = bitcast void (i32, double, double, double, double)** @gl.Uniform4d to %..rawptr
	call void %21(%..rawptr %22, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$4b7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%24 = bitcast void (i32, i32, double*)** @gl.Uniform1dv to %..rawptr
	call void %23(%..rawptr %24, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$4b8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%25 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%26 = bitcast void (i32, i32, double*)** @gl.Uniform2dv to %..rawptr
	call void %25(%..rawptr %26, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$4b9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%27 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%28 = bitcast void (i32, i32, double*)** @gl.Uniform3dv to %..rawptr
	call void %27(%..rawptr %28, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$4ba, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%29 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%30 = bitcast void (i32, i32, double*)** @gl.Uniform4dv to %..rawptr
	call void %29(%..rawptr %30, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$4bb, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%31 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%32 = bitcast void (i32, i32, i8, double*)** @gl.UniformMatrix2dv to %..rawptr
	call void %31(%..rawptr %32, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4bc, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%33 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%34 = bitcast void (i32, i32, i8, double*)** @gl.UniformMatrix3dv to %..rawptr
	call void %33(%..rawptr %34, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4bd, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%35 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%36 = bitcast void (i32, i32, i8, double*)** @gl.UniformMatrix4dv to %..rawptr
	call void %35(%..rawptr %36, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4be, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%37 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%38 = bitcast void (i32, i32, i8, double*)** @gl.UniformMatrix2x3dv to %..rawptr
	call void %37(%..rawptr %38, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$4bf, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%39 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%40 = bitcast void (i32, i32, i8, double*)** @gl.UniformMatrix2x4dv to %..rawptr
	call void %39(%..rawptr %40, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$4c0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%41 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%42 = bitcast void (i32, i32, i8, double*)** @gl.UniformMatrix3x2dv to %..rawptr
	call void %41(%..rawptr %42, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$4c1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%43 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%44 = bitcast void (i32, i32, i8, double*)** @gl.UniformMatrix3x4dv to %..rawptr
	call void %43(%..rawptr %44, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$4c2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%45 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%46 = bitcast void (i32, i32, i8, double*)** @gl.UniformMatrix4x2dv to %..rawptr
	call void %45(%..rawptr %46, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$4c3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%47 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%48 = bitcast void (i32, i32, i8, double*)** @gl.UniformMatrix4x3dv to %..rawptr
	call void %47(%..rawptr %48, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$4c4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%49 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%50 = bitcast void (i32, i32, double*)** @gl.GetUniformdv to %..rawptr
	call void %49(%..rawptr %50, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$4c5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%51 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%52 = bitcast i32 (i32, i32, i8*)** @gl.GetSubroutineUniformLocation to %..rawptr
	call void %51(%..rawptr %52, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @str$4c6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%53 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%54 = bitcast i32 (i32, i32, i8*)** @gl.GetSubroutineIndex to %..rawptr
	call void %53(%..rawptr %54, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$4c7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%55 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%56 = bitcast void (i32, i32, i32, i32, i32*)** @gl.GetActiveSubroutineUniformiv to %..rawptr
	call void %55(%..rawptr %56, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @str$4c8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%57 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%58 = bitcast void (i32, i32, i32, i32, i32*, i8*)** @gl.GetActiveSubroutineUniformName to %..rawptr
	call void %57(%..rawptr %58, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @str$4c9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%59 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%60 = bitcast void (i32, i32, i32, i32, i32*, i8*)** @gl.GetActiveSubroutineName to %..rawptr
	call void %59(%..rawptr %60, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$4ca, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%61 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%62 = bitcast void (i32, i32, i32*)** @gl.UniformSubroutinesuiv to %..rawptr
	call void %61(%..rawptr %62, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$4cb, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%63 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%64 = bitcast void (i32, i32, i32*)** @gl.GetUniformSubroutineuiv to %..rawptr
	call void %63(%..rawptr %64, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$4cc, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%65 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%66 = bitcast void (i32, i32, i32, i32*)** @gl.GetProgramStageiv to %..rawptr
	call void %65(%..rawptr %66, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4cd, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%67 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%68 = bitcast void (i32, i32)** @gl.PatchParameteri to %..rawptr
	call void %67(%..rawptr %68, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$4ce, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%69 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%70 = bitcast void (i32, float*)** @gl.PatchParameterfv to %..rawptr
	call void %69(%..rawptr %70, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4cf, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%71 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%72 = bitcast void (i32, i32)** @gl.BindTransformFeedback to %..rawptr
	call void %71(%..rawptr %72, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$4d0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%73 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%74 = bitcast void (i32, i32*)** @gl.DeleteTransformFeedbacks to %..rawptr
	call void %73(%..rawptr %74, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$4d1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%75 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%76 = bitcast void (i32, i32*)** @gl.GenTransformFeedbacks to %..rawptr
	call void %75(%..rawptr %76, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$4d2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%77 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%78 = bitcast i8 (i32)** @gl.IsTransformFeedback to %..rawptr
	call void %77(%..rawptr %78, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$4d3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%79 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%80 = bitcast void ()** @gl.PauseTransformFeedback to %..rawptr
	call void %79(%..rawptr %80, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$4d4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%81 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%82 = bitcast void ()** @gl.ResumeTransformFeedback to %..rawptr
	call void %81(%..rawptr %82, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$4d5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%83 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%84 = bitcast void (i32, i32)** @gl.DrawTransformFeedback to %..rawptr
	call void %83(%..rawptr %84, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$4d6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%85 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%86 = bitcast void (i32, i32, i32)** @gl.DrawTransformFeedbackStream to %..rawptr
	call void %85(%..rawptr %86, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$4d7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%87 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%88 = bitcast void (i32, i32, i32)** @gl.BeginQueryIndexed to %..rawptr
	call void %87(%..rawptr %88, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4d8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%89 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%90 = bitcast void (i32, i32)** @gl.EndQueryIndexed to %..rawptr
	call void %89(%..rawptr %90, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$4d9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%91 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%92 = bitcast void (i32, i32, i32, i32*)** @gl.GetQueryIndexediv to %..rawptr
	call void %91(%..rawptr %92, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4da, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_4_1(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void ()** @gl.ReleaseShaderCompiler to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$4db, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, i32*, i32, %..rawptr, i32)** @gl.ShaderBinary to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$4dc, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32, i32*, i32*)** @gl.GetShaderPrecisionFormat to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$4dd, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (float, float)** @gl.DepthRangef to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$4de, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (float)** @gl.ClearDepthf to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$4df, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast void (i32, i32, i32*, i32*, %..rawptr)** @gl.GetProgramBinary to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4e0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast void (i32, i32, %..rawptr, i32)** @gl.ProgramBinary to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$4e1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void (i32, i32, i32)** @gl.ProgramParameteri to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4e2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast void (i32, i32, i32)** @gl.UseProgramStages to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4e3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%20 = bitcast void (i32, i32)** @gl.ActiveShaderProgram to %..rawptr
	call void %19(%..rawptr %20, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$4e4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%22 = bitcast i32 (i32, i32, i8*)** @gl.CreateShaderProgramv to %..rawptr
	call void %21(%..rawptr %22, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$4e5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%24 = bitcast void (i32)** @gl.BindProgramPipeline to %..rawptr
	call void %23(%..rawptr %24, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$4e6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%25 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%26 = bitcast void (i32, i32*)** @gl.DeleteProgramPipelines to %..rawptr
	call void %25(%..rawptr %26, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$4e7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%27 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%28 = bitcast void (i32, i32*)** @gl.GenProgramPipelines to %..rawptr
	call void %27(%..rawptr %28, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$4e8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%29 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%30 = bitcast i8 (i32)** @gl.IsProgramPipeline to %..rawptr
	call void %29(%..rawptr %30, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4e9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%31 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%32 = bitcast void (i32, i32, i32*)** @gl.GetProgramPipelineiv to %..rawptr
	call void %31(%..rawptr %32, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$4ea, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%33 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%34 = bitcast void (i32, i32, i32)** @gl.ProgramUniform1i to %..rawptr
	call void %33(%..rawptr %34, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4eb, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%35 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%36 = bitcast void (i32, i32, i32, i32*)** @gl.ProgramUniform1iv to %..rawptr
	call void %35(%..rawptr %36, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4ec, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%37 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%38 = bitcast void (i32, i32, float)** @gl.ProgramUniform1f to %..rawptr
	call void %37(%..rawptr %38, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4ed, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%39 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%40 = bitcast void (i32, i32, i32, float*)** @gl.ProgramUniform1fv to %..rawptr
	call void %39(%..rawptr %40, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4ee, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%41 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%42 = bitcast void (i32, i32, double)** @gl.ProgramUniform1d to %..rawptr
	call void %41(%..rawptr %42, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4ef, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%43 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%44 = bitcast void (i32, i32, i32, double*)** @gl.ProgramUniform1dv to %..rawptr
	call void %43(%..rawptr %44, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4f0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%45 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%46 = bitcast void (i32, i32, i32)** @gl.ProgramUniform1ui to %..rawptr
	call void %45(%..rawptr %46, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4f1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%47 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%48 = bitcast void (i32, i32, i32, i32*)** @gl.ProgramUniform1uiv to %..rawptr
	call void %47(%..rawptr %48, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$4f2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%49 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%50 = bitcast void (i32, i32, i32, i32)** @gl.ProgramUniform2i to %..rawptr
	call void %49(%..rawptr %50, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4f3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%51 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%52 = bitcast void (i32, i32, i32, i32*)** @gl.ProgramUniform2iv to %..rawptr
	call void %51(%..rawptr %52, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4f4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%53 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%54 = bitcast void (i32, i32, float, float)** @gl.ProgramUniform2f to %..rawptr
	call void %53(%..rawptr %54, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4f5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%55 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%56 = bitcast void (i32, i32, i32, float*)** @gl.ProgramUniform2fv to %..rawptr
	call void %55(%..rawptr %56, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4f6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%57 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%58 = bitcast void (i32, i32, double, double)** @gl.ProgramUniform2d to %..rawptr
	call void %57(%..rawptr %58, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4f7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%59 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%60 = bitcast void (i32, i32, i32, double*)** @gl.ProgramUniform2dv to %..rawptr
	call void %59(%..rawptr %60, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4f8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%61 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%62 = bitcast void (i32, i32, i32, i32)** @gl.ProgramUniform2ui to %..rawptr
	call void %61(%..rawptr %62, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4f9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%63 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%64 = bitcast void (i32, i32, i32, i32*)** @gl.ProgramUniform2uiv to %..rawptr
	call void %63(%..rawptr %64, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$4fa, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%65 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%66 = bitcast void (i32, i32, i32, i32, i32)** @gl.ProgramUniform3i to %..rawptr
	call void %65(%..rawptr %66, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4fb, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%67 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%68 = bitcast void (i32, i32, i32, i32*)** @gl.ProgramUniform3iv to %..rawptr
	call void %67(%..rawptr %68, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4fc, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%69 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%70 = bitcast void (i32, i32, float, float, float)** @gl.ProgramUniform3f to %..rawptr
	call void %69(%..rawptr %70, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4fd, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%71 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%72 = bitcast void (i32, i32, i32, float*)** @gl.ProgramUniform3fv to %..rawptr
	call void %71(%..rawptr %72, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$4fe, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%73 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%74 = bitcast void (i32, i32, double, double, double)** @gl.ProgramUniform3d to %..rawptr
	call void %73(%..rawptr %74, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$4ff, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%75 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%76 = bitcast void (i32, i32, i32, double*)** @gl.ProgramUniform3dv to %..rawptr
	call void %75(%..rawptr %76, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$500, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%77 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%78 = bitcast void (i32, i32, i32, i32, i32)** @gl.ProgramUniform3ui to %..rawptr
	call void %77(%..rawptr %78, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$501, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%79 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%80 = bitcast void (i32, i32, i32, i32*)** @gl.ProgramUniform3uiv to %..rawptr
	call void %79(%..rawptr %80, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$502, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%81 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%82 = bitcast void (i32, i32, i32, i32, i32, i32)** @gl.ProgramUniform4i to %..rawptr
	call void %81(%..rawptr %82, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$503, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%83 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%84 = bitcast void (i32, i32, i32, i32*)** @gl.ProgramUniform4iv to %..rawptr
	call void %83(%..rawptr %84, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$504, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%85 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%86 = bitcast void (i32, i32, float, float, float, float)** @gl.ProgramUniform4f to %..rawptr
	call void %85(%..rawptr %86, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$505, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%87 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%88 = bitcast void (i32, i32, i32, float*)** @gl.ProgramUniform4fv to %..rawptr
	call void %87(%..rawptr %88, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$506, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%89 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%90 = bitcast void (i32, i32, double, double, double, double)** @gl.ProgramUniform4d to %..rawptr
	call void %89(%..rawptr %90, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$507, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%91 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%92 = bitcast void (i32, i32, i32, double*)** @gl.ProgramUniform4dv to %..rawptr
	call void %91(%..rawptr %92, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$508, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%93 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%94 = bitcast void (i32, i32, i32, i32, i32, i32)** @gl.ProgramUniform4ui to %..rawptr
	call void %93(%..rawptr %94, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$509, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%95 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%96 = bitcast void (i32, i32, i32, i32*)** @gl.ProgramUniform4uiv to %..rawptr
	call void %95(%..rawptr %96, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$50a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%97 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%98 = bitcast void (i32, i32, i32, i8, float*)** @gl.ProgramUniformMatrix2fv to %..rawptr
	call void %97(%..rawptr %98, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$50b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%99 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%100 = bitcast void (i32, i32, i32, i8, float*)** @gl.ProgramUniformMatrix3fv to %..rawptr
	call void %99(%..rawptr %100, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$50c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%101 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%102 = bitcast void (i32, i32, i32, i8, float*)** @gl.ProgramUniformMatrix4fv to %..rawptr
	call void %101(%..rawptr %102, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$50d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%103 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%104 = bitcast void (i32, i32, i32, i8, double*)** @gl.ProgramUniformMatrix2dv to %..rawptr
	call void %103(%..rawptr %104, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$50e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%105 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%106 = bitcast void (i32, i32, i32, i8, double*)** @gl.ProgramUniformMatrix3dv to %..rawptr
	call void %105(%..rawptr %106, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$50f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%107 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%108 = bitcast void (i32, i32, i32, i8, double*)** @gl.ProgramUniformMatrix4dv to %..rawptr
	call void %107(%..rawptr %108, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$510, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%109 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%110 = bitcast void (i32, i32, i32, i8, float*)** @gl.ProgramUniformMatrix2x3fv to %..rawptr
	call void %109(%..rawptr %110, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$511, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%111 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%112 = bitcast void (i32, i32, i32, i8, float*)** @gl.ProgramUniformMatrix3x2fv to %..rawptr
	call void %111(%..rawptr %112, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$512, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%113 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%114 = bitcast void (i32, i32, i32, i8, float*)** @gl.ProgramUniformMatrix2x4fv to %..rawptr
	call void %113(%..rawptr %114, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$513, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%115 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%116 = bitcast void (i32, i32, i32, i8, float*)** @gl.ProgramUniformMatrix4x2fv to %..rawptr
	call void %115(%..rawptr %116, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$514, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%117 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%118 = bitcast void (i32, i32, i32, i8, float*)** @gl.ProgramUniformMatrix3x4fv to %..rawptr
	call void %117(%..rawptr %118, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$515, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%119 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%120 = bitcast void (i32, i32, i32, i8, float*)** @gl.ProgramUniformMatrix4x3fv to %..rawptr
	call void %119(%..rawptr %120, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$516, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%121 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%122 = bitcast void (i32, i32, i32, i8, double*)** @gl.ProgramUniformMatrix2x3dv to %..rawptr
	call void %121(%..rawptr %122, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$517, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%123 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%124 = bitcast void (i32, i32, i32, i8, double*)** @gl.ProgramUniformMatrix3x2dv to %..rawptr
	call void %123(%..rawptr %124, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$518, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%125 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%126 = bitcast void (i32, i32, i32, i8, double*)** @gl.ProgramUniformMatrix2x4dv to %..rawptr
	call void %125(%..rawptr %126, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$519, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%127 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%128 = bitcast void (i32, i32, i32, i8, double*)** @gl.ProgramUniformMatrix4x2dv to %..rawptr
	call void %127(%..rawptr %128, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$51a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%129 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%130 = bitcast void (i32, i32, i32, i8, double*)** @gl.ProgramUniformMatrix3x4dv to %..rawptr
	call void %129(%..rawptr %130, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$51b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%131 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%132 = bitcast void (i32, i32, i32, i8, double*)** @gl.ProgramUniformMatrix4x3dv to %..rawptr
	call void %131(%..rawptr %132, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$51c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%133 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%134 = bitcast void (i32)** @gl.ValidateProgramPipeline to %..rawptr
	call void %133(%..rawptr %134, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$51d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%135 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%136 = bitcast void (i32, i32, i32*, i8*)** @gl.GetProgramPipelineInfoLog to %..rawptr
	call void %135(%..rawptr %136, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$51e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%137 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%138 = bitcast void (i32, double)** @gl.VertexAttribL1d to %..rawptr
	call void %137(%..rawptr %138, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$51f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%139 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%140 = bitcast void (i32, double, double)** @gl.VertexAttribL2d to %..rawptr
	call void %139(%..rawptr %140, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$520, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%141 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%142 = bitcast void (i32, double, double, double)** @gl.VertexAttribL3d to %..rawptr
	call void %141(%..rawptr %142, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$521, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%143 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%144 = bitcast void (i32, double, double, double, double)** @gl.VertexAttribL4d to %..rawptr
	call void %143(%..rawptr %144, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$522, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%145 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%146 = bitcast void (i32, double*)** @gl.VertexAttribL1dv to %..rawptr
	call void %145(%..rawptr %146, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$523, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%147 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%148 = bitcast void (i32, double*)** @gl.VertexAttribL2dv to %..rawptr
	call void %147(%..rawptr %148, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$524, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%149 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%150 = bitcast void (i32, double*)** @gl.VertexAttribL3dv to %..rawptr
	call void %149(%..rawptr %150, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$525, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%151 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%152 = bitcast void (i32, double*)** @gl.VertexAttribL4dv to %..rawptr
	call void %151(%..rawptr %152, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$526, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%153 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%154 = bitcast void (i32, i32, i32, i32, %..rawptr)** @gl.VertexAttribLPointer to %..rawptr
	call void %153(%..rawptr %154, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$527, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%155 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%156 = bitcast void (i32, i32, double*)** @gl.GetVertexAttribLdv to %..rawptr
	call void %155(%..rawptr %156, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$528, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%157 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%158 = bitcast void (i32, i32, float*)** @gl.ViewportArrayv to %..rawptr
	call void %157(%..rawptr %158, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$529, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%159 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%160 = bitcast void (i32, float, float, float, float)** @gl.ViewportIndexedf to %..rawptr
	call void %159(%..rawptr %160, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$52a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%161 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%162 = bitcast void (i32, float*)** @gl.ViewportIndexedfv to %..rawptr
	call void %161(%..rawptr %162, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$52b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%163 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%164 = bitcast void (i32, i32, i32*)** @gl.ScissorArrayv to %..rawptr
	call void %163(%..rawptr %164, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$52c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%165 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%166 = bitcast void (i32, i32, i32, i32, i32)** @gl.ScissorIndexed to %..rawptr
	call void %165(%..rawptr %166, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$52d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%167 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%168 = bitcast void (i32, i32*)** @gl.ScissorIndexedv to %..rawptr
	call void %167(%..rawptr %168, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$52e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%169 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%170 = bitcast void (i32, i32, double*)** @gl.DepthRangeArrayv to %..rawptr
	call void %169(%..rawptr %170, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$52f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%171 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%172 = bitcast void (i32, double, double)** @gl.DepthRangeIndexed to %..rawptr
	call void %171(%..rawptr %172, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$530, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%173 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%174 = bitcast void (i32, i32, float*)** @gl.GetFloati_v to %..rawptr
	call void %173(%..rawptr %174, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$531, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%175 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%176 = bitcast void (i32, i32, double*)** @gl.GetDoublei_v to %..rawptr
	call void %175(%..rawptr %176, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$532, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_4_2(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32, i32, i32, i32, i32)** @gl.DrawArraysInstancedBaseInstance to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @str$533, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, i32, i32, %..rawptr, i32, i32)** @gl.DrawElementsInstancedBaseInstance to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @str$534, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32, i32, %..rawptr, i32, i32, i32)** @gl.DrawElementsInstancedBaseVertexBaseInstance to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @str$535, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i32, i32, i32, i32, i32*)** @gl.GetInternalformativ to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$536, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (i32, i32, i32, i32*)** @gl.GetActiveAtomicCounterBufferiv to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @str$537, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast void (i32, i32, i32, i8, i32, i32, i32)** @gl.BindImageTexture to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$538, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast void (i32)** @gl.MemoryBarrier to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$539, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void (i32, i32, i32, i32)** @gl.TexStorage1D to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$53a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast void (i32, i32, i32, i32, i32)** @gl.TexStorage2D to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$53b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%20 = bitcast void (i32, i32, i32, i32, i32, i32)** @gl.TexStorage3D to %..rawptr
	call void %19(%..rawptr %20, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$53c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%22 = bitcast void (i32, i32, i32)** @gl.DrawTransformFeedbackInstanced to %..rawptr
	call void %21(%..rawptr %22, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @str$53d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%24 = bitcast void (i32, i32, i32, i32)** @gl.DrawTransformFeedbackStreamInstanced to %..rawptr
	call void %23(%..rawptr %24, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @str$53e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_4_3(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32, i32, i32, i32, %..rawptr)** @gl.ClearBufferData to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$53f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, i32, i64, i64, i32, i32, %..rawptr)** @gl.ClearBufferSubData to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$540, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32, i32)** @gl.DispatchCompute to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$541, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i64)** @gl.DispatchComputeIndirect to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$542, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32)** @gl.CopyImageSubData to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$543, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast void (i32, i32, i32)** @gl.FramebufferParameteri to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$544, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast void (i32, i32, i32*)** @gl.GetFramebufferParameteriv to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$545, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void (i32, i32, i32, i32, i64*)** @gl.GetInternalformati64v to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$546, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32)** @gl.InvalidateTexSubImage to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$547, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%20 = bitcast void (i32, i32)** @gl.InvalidateTexImage to %..rawptr
	call void %19(%..rawptr %20, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$548, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%22 = bitcast void (i32, i64, i64)** @gl.InvalidateBufferSubData to %..rawptr
	call void %21(%..rawptr %22, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$549, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%24 = bitcast void (i32)** @gl.InvalidateBufferData to %..rawptr
	call void %23(%..rawptr %24, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$54a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%25 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%26 = bitcast void (i32, i32, i32*)** @gl.InvalidateFramebuffer to %..rawptr
	call void %25(%..rawptr %26, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$54b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%27 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%28 = bitcast void (i32, i32, i32*, i32, i32, i32, i32)** @gl.InvalidateSubFramebuffer to %..rawptr
	call void %27(%..rawptr %28, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$54c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%29 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%30 = bitcast void (i32, %..rawptr, i32, i32)** @gl.MultiDrawArraysIndirect to %..rawptr
	call void %29(%..rawptr %30, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$54d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%31 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%32 = bitcast void (i32, i32, %..rawptr, i32, i32)** @gl.MultiDrawElementsIndirect to %..rawptr
	call void %31(%..rawptr %32, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$54e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%33 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%34 = bitcast void (i32, i32, i32, i32*)** @gl.GetProgramInterfaceiv to %..rawptr
	call void %33(%..rawptr %34, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$54f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%35 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%36 = bitcast i32 (i32, i32, i8*)** @gl.GetProgramResourceIndex to %..rawptr
	call void %35(%..rawptr %36, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$550, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%37 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%38 = bitcast void (i32, i32, i32, i32, i32*, i8*)** @gl.GetProgramResourceName to %..rawptr
	call void %37(%..rawptr %38, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$551, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%39 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%40 = bitcast void (i32, i32, i32, i32, i32*, i32, i32*, i32*)** @gl.GetProgramResourceiv to %..rawptr
	call void %39(%..rawptr %40, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$552, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%41 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%42 = bitcast i32 (i32, i32, i8*)** @gl.GetProgramResourceLocation to %..rawptr
	call void %41(%..rawptr %42, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @str$553, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%43 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%44 = bitcast i32 (i32, i32, i8*)** @gl.GetProgramResourceLocationIndex to %..rawptr
	call void %43(%..rawptr %44, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @str$554, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%45 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%46 = bitcast void (i32, i32, i32)** @gl.ShaderStorageBlockBinding to %..rawptr
	call void %45(%..rawptr %46, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$555, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%47 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%48 = bitcast void (i32, i32, i32, i64, i64)** @gl.TexBufferRange to %..rawptr
	call void %47(%..rawptr %48, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$556, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%49 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%50 = bitcast void (i32, i32, i32, i32, i32, i8)** @gl.TexStorage2DMultisample to %..rawptr
	call void %49(%..rawptr %50, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$557, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%51 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%52 = bitcast void (i32, i32, i32, i32, i32, i32, i8)** @gl.TexStorage3DMultisample to %..rawptr
	call void %51(%..rawptr %52, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$558, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%53 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%54 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32)** @gl.TextureView to %..rawptr
	call void %53(%..rawptr %54, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$559, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%55 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%56 = bitcast void (i32, i32, i64, i32)** @gl.BindVertexBuffer to %..rawptr
	call void %55(%..rawptr %56, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$55a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%57 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%58 = bitcast void (i32, i32, i32, i8, i32)** @gl.VertexAttribFormat to %..rawptr
	call void %57(%..rawptr %58, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$55b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%59 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%60 = bitcast void (i32, i32, i32, i32)** @gl.VertexAttribIFormat to %..rawptr
	call void %59(%..rawptr %60, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$55c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%61 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%62 = bitcast void (i32, i32, i32, i32)** @gl.VertexAttribLFormat to %..rawptr
	call void %61(%..rawptr %62, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$55d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%63 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%64 = bitcast void (i32, i32)** @gl.VertexAttribBinding to %..rawptr
	call void %63(%..rawptr %64, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$55e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%65 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%66 = bitcast void (i32, i32)** @gl.VertexBindingDivisor to %..rawptr
	call void %65(%..rawptr %66, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$55f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%67 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%68 = bitcast void (i32, i32, i32, i32, i32*, i8)** @gl.DebugMessageControl to %..rawptr
	call void %67(%..rawptr %68, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$560, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%69 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%70 = bitcast void (i32, i32, i32, i32, i32, i8*)** @gl.DebugMessageInsert to %..rawptr
	call void %69(%..rawptr %70, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$561, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%71 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%72 = bitcast void (void (i32, i32, i32, i32, i32, i8*, %..rawptr)*, %..rawptr)** @gl.DebugMessageCallback to %..rawptr
	call void %71(%..rawptr %72, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$562, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%73 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%74 = bitcast i32 (i32, i32, i32*, i32*, i32*, i32*, i32*, i8*)** @gl.GetDebugMessageLog to %..rawptr
	call void %73(%..rawptr %74, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$563, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%75 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%76 = bitcast void (i32, i32, i32, i8*)** @gl.PushDebugGroup to %..rawptr
	call void %75(%..rawptr %76, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$564, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%77 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%78 = bitcast void ()** @gl.PopDebugGroup to %..rawptr
	call void %77(%..rawptr %78, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$565, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%79 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%80 = bitcast void (i32, i32, i32, i8*)** @gl.ObjectLabel to %..rawptr
	call void %79(%..rawptr %80, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$566, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%81 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%82 = bitcast void (i32, i32, i32, i32*, i8*)** @gl.GetObjectLabel to %..rawptr
	call void %81(%..rawptr %82, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$567, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%83 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%84 = bitcast void (%..rawptr, i32, i8*)** @gl.ObjectPtrLabel to %..rawptr
	call void %83(%..rawptr %84, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$568, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%85 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%86 = bitcast void (%..rawptr, i32, i32*, i8*)** @gl.GetObjectPtrLabel to %..rawptr
	call void %85(%..rawptr %86, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$569, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_4_4(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32, i64, %..rawptr, i32)** @gl.BufferStorage to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$56a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, i32, i32, i32, %..rawptr)** @gl.ClearTexImage to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$56b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.ClearTexSubImage to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$56c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i32, i32, i32, i32*)** @gl.BindBuffersBase to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$56d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (i32, i32, i32, i32*, i64*, i64*)** @gl.BindBuffersRange to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$56e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast void (i32, i32, i32*)** @gl.BindTextures to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$56f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast void (i32, i32, i32*)** @gl.BindSamplers to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$570, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void (i32, i32, i32*)** @gl.BindImageTextures to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$571, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast void (i32, i32, i32*, i64*, i32*)** @gl.BindVertexBuffers to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$572, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_4_5(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32, i32)** @gl.ClipControl to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$573, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, i32*)** @gl.CreateTransformFeedbacks to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$574, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32, i32)** @gl.TransformFeedbackBufferBase to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$575, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (i32, i32, i32, i64, i64)** @gl.TransformFeedbackBufferRange to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @str$576, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%10 = bitcast void (i32, i32, i32*)** @gl.GetTransformFeedbackiv to %..rawptr
	call void %9(%..rawptr %10, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$577, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%12 = bitcast void (i32, i32, i32, i32*)** @gl.GetTransformFeedbacki_v to %..rawptr
	call void %11(%..rawptr %12, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$578, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%13 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%14 = bitcast void (i32, i32, i32, i64*)** @gl.GetTransformFeedbacki64_v to %..rawptr
	call void %13(%..rawptr %14, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$579, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%16 = bitcast void (i32, i32*)** @gl.CreateBuffers to %..rawptr
	call void %15(%..rawptr %16, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$57a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%18 = bitcast void (i32, i64, %..rawptr, i32)** @gl.NamedBufferStorage to %..rawptr
	call void %17(%..rawptr %18, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$57b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%20 = bitcast void (i32, i64, %..rawptr, i32)** @gl.NamedBufferData to %..rawptr
	call void %19(%..rawptr %20, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$57c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%21 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%22 = bitcast void (i32, i64, i64, %..rawptr)** @gl.NamedBufferSubData to %..rawptr
	call void %21(%..rawptr %22, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$57d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%24 = bitcast void (i32, i32, i64, i64, i64)** @gl.CopyNamedBufferSubData to %..rawptr
	call void %23(%..rawptr %24, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$57e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%25 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%26 = bitcast void (i32, i32, i32, i32, %..rawptr)** @gl.ClearNamedBufferData to %..rawptr
	call void %25(%..rawptr %26, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$57f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%27 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%28 = bitcast void (i32, i32, i64, i64, i32, i32, %..rawptr)** @gl.ClearNamedBufferSubData to %..rawptr
	call void %27(%..rawptr %28, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$580, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%29 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%30 = bitcast %..rawptr (i32, i32)** @gl.MapNamedBuffer to %..rawptr
	call void %29(%..rawptr %30, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$581, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%31 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%32 = bitcast %..rawptr (i32, i64, i64, i32)** @gl.MapNamedBufferRange to %..rawptr
	call void %31(%..rawptr %32, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$582, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%33 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%34 = bitcast i8 (i32)** @gl.UnmapNamedBuffer to %..rawptr
	call void %33(%..rawptr %34, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$583, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%35 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%36 = bitcast void (i32, i64, i64)** @gl.FlushMappedNamedBufferRange to %..rawptr
	call void %35(%..rawptr %36, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$584, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%37 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%38 = bitcast void (i32, i32, i32*)** @gl.GetNamedBufferParameteriv to %..rawptr
	call void %37(%..rawptr %38, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$585, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%39 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%40 = bitcast void (i32, i32, i64*)** @gl.GetNamedBufferParameteri64v to %..rawptr
	call void %39(%..rawptr %40, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$586, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%41 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%42 = bitcast void (i32, i32, %..rawptr*)** @gl.GetNamedBufferPointerv to %..rawptr
	call void %41(%..rawptr %42, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$587, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%43 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%44 = bitcast void (i32, i64, i64, %..rawptr)** @gl.GetNamedBufferSubData to %..rawptr
	call void %43(%..rawptr %44, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$588, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%45 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%46 = bitcast void (i32, i32*)** @gl.CreateFramebuffers to %..rawptr
	call void %45(%..rawptr %46, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$589, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%47 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%48 = bitcast void (i32, i32, i32, i32)** @gl.NamedFramebufferRenderbuffer to %..rawptr
	call void %47(%..rawptr %48, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @str$58a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%49 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%50 = bitcast void (i32, i32, i32)** @gl.NamedFramebufferParameteri to %..rawptr
	call void %49(%..rawptr %50, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @str$58b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%51 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%52 = bitcast void (i32, i32, i32, i32)** @gl.NamedFramebufferTexture to %..rawptr
	call void %51(%..rawptr %52, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$58c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%53 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%54 = bitcast void (i32, i32, i32, i32, i32)** @gl.NamedFramebufferTextureLayer to %..rawptr
	call void %53(%..rawptr %54, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @str$58d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%55 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%56 = bitcast void (i32, i32)** @gl.NamedFramebufferDrawBuffer to %..rawptr
	call void %55(%..rawptr %56, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @str$58e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%57 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%58 = bitcast void (i32, i32, i32*)** @gl.NamedFramebufferDrawBuffers to %..rawptr
	call void %57(%..rawptr %58, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$58f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%59 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%60 = bitcast void (i32, i32)** @gl.NamedFramebufferReadBuffer to %..rawptr
	call void %59(%..rawptr %60, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @str$590, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%61 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%62 = bitcast void (i32, i32, i32*)** @gl.InvalidateNamedFramebufferData to %..rawptr
	call void %61(%..rawptr %62, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @str$591, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%63 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%64 = bitcast void (i32, i32, i32*, i32, i32, i32, i32)** @gl.InvalidateNamedFramebufferSubData to %..rawptr
	call void %63(%..rawptr %64, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @str$592, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%65 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%66 = bitcast void (i32, i32, i32, i32*)** @gl.ClearNamedFramebufferiv to %..rawptr
	call void %65(%..rawptr %66, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$593, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%67 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%68 = bitcast void (i32, i32, i32, i32*)** @gl.ClearNamedFramebufferuiv to %..rawptr
	call void %67(%..rawptr %68, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$594, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%69 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%70 = bitcast void (i32, i32, i32, float*)** @gl.ClearNamedFramebufferfv to %..rawptr
	call void %69(%..rawptr %70, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$595, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%71 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%72 = bitcast void (i32, i32, i32, float, i32)** @gl.ClearNamedFramebufferfi to %..rawptr
	call void %71(%..rawptr %72, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$596, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%73 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%74 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32)** @gl.BlitNamedFramebuffer to %..rawptr
	call void %73(%..rawptr %74, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$597, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%75 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%76 = bitcast i32 (i32, i32)** @gl.CheckNamedFramebufferStatus to %..rawptr
	call void %75(%..rawptr %76, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$598, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%77 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%78 = bitcast void (i32, i32, i32*)** @gl.GetNamedFramebufferParameteriv to %..rawptr
	call void %77(%..rawptr %78, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @str$599, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%79 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%80 = bitcast void (i32, i32, i32, i32*)** @gl.GetNamedFramebufferAttachmentParameteriv to %..rawptr
	call void %79(%..rawptr %80, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @str$59a, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%81 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%82 = bitcast void (i32, i32*)** @gl.CreateRenderbuffers to %..rawptr
	call void %81(%..rawptr %82, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$59b, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%83 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%84 = bitcast void (i32, i32, i32, i32)** @gl.NamedRenderbufferStorage to %..rawptr
	call void %83(%..rawptr %84, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$59c, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%85 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%86 = bitcast void (i32, i32, i32, i32, i32)** @gl.NamedRenderbufferStorageMultisample to %..rawptr
	call void %85(%..rawptr %86, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str$59d, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%87 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%88 = bitcast void (i32, i32, i32*)** @gl.GetNamedRenderbufferParameteriv to %..rawptr
	call void %87(%..rawptr %88, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @str$59e, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%89 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%90 = bitcast void (i32, i32, i32*)** @gl.CreateTextures to %..rawptr
	call void %89(%..rawptr %90, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$59f, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%91 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%92 = bitcast void (i32, i32, i32)** @gl.TextureBuffer to %..rawptr
	call void %91(%..rawptr %92, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$5a0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%93 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%94 = bitcast void (i32, i32, i32, i64, i64)** @gl.TextureBufferRange to %..rawptr
	call void %93(%..rawptr %94, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$5a1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%95 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%96 = bitcast void (i32, i32, i32, i32)** @gl.TextureStorage1D to %..rawptr
	call void %95(%..rawptr %96, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$5a2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%97 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%98 = bitcast void (i32, i32, i32, i32, i32)** @gl.TextureStorage2D to %..rawptr
	call void %97(%..rawptr %98, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$5a3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%99 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%100 = bitcast void (i32, i32, i32, i32, i32, i32)** @gl.TextureStorage3D to %..rawptr
	call void %99(%..rawptr %100, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$5a4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%101 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%102 = bitcast void (i32, i32, i32, i32, i32, i8)** @gl.TextureStorage2DMultisample to %..rawptr
	call void %101(%..rawptr %102, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$5a5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%103 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%104 = bitcast void (i32, i32, i32, i32, i32, i32, i8)** @gl.TextureStorage3DMultisample to %..rawptr
	call void %103(%..rawptr %104, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$5a6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%105 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%106 = bitcast void (i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.TextureSubImage1D to %..rawptr
	call void %105(%..rawptr %106, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$5a7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%107 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%108 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.TextureSubImage2D to %..rawptr
	call void %107(%..rawptr %108, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$5a8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%109 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%110 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.TextureSubImage3D to %..rawptr
	call void %109(%..rawptr %110, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$5a9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%111 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%112 = bitcast void (i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.CompressedTextureSubImage1D to %..rawptr
	call void %111(%..rawptr %112, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$5aa, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%113 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%114 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.CompressedTextureSubImage2D to %..rawptr
	call void %113(%..rawptr %114, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$5ab, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%115 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%116 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.CompressedTextureSubImage3D to %..rawptr
	call void %115(%..rawptr %116, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$5ac, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%117 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%118 = bitcast void (i32, i32, i32, i32, i32, i32)** @gl.CopyTextureSubImage1D to %..rawptr
	call void %117(%..rawptr %118, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$5ad, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%119 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%120 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32)** @gl.CopyTextureSubImage2D to %..rawptr
	call void %119(%..rawptr %120, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$5ae, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%121 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%122 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, i32)** @gl.CopyTextureSubImage3D to %..rawptr
	call void %121(%..rawptr %122, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$5af, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%123 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%124 = bitcast void (i32, i32, float)** @gl.TextureParameterf to %..rawptr
	call void %123(%..rawptr %124, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$5b0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%125 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%126 = bitcast void (i32, i32, float*)** @gl.TextureParameterfv to %..rawptr
	call void %125(%..rawptr %126, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$5b1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%127 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%128 = bitcast void (i32, i32, i32)** @gl.TextureParameteri to %..rawptr
	call void %127(%..rawptr %128, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$5b2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%129 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%130 = bitcast void (i32, i32, i32*)** @gl.TextureParameterIiv to %..rawptr
	call void %129(%..rawptr %130, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$5b3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%131 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%132 = bitcast void (i32, i32, i32*)** @gl.TextureParameterIuiv to %..rawptr
	call void %131(%..rawptr %132, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$5b4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%133 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%134 = bitcast void (i32, i32, i32*)** @gl.TextureParameteriv to %..rawptr
	call void %133(%..rawptr %134, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$5b5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%135 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%136 = bitcast void (i32)** @gl.GenerateTextureMipmap to %..rawptr
	call void %135(%..rawptr %136, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$5b6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%137 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%138 = bitcast void (i32, i32)** @gl.BindTextureUnit to %..rawptr
	call void %137(%..rawptr %138, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$5b7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%139 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%140 = bitcast void (i32, i32, i32, i32, i32, %..rawptr)** @gl.GetTextureImage to %..rawptr
	call void %139(%..rawptr %140, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$5b8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%141 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%142 = bitcast void (i32, i32, i32, %..rawptr)** @gl.GetCompressedTextureImage to %..rawptr
	call void %141(%..rawptr %142, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$5b9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%143 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%144 = bitcast void (i32, i32, i32, float*)** @gl.GetTextureLevelParameterfv to %..rawptr
	call void %143(%..rawptr %144, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @str$5ba, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%145 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%146 = bitcast void (i32, i32, i32, i32*)** @gl.GetTextureLevelParameteriv to %..rawptr
	call void %145(%..rawptr %146, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @str$5bb, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%147 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%148 = bitcast void (i32, i32, float*)** @gl.GetTextureParameterfv to %..rawptr
	call void %147(%..rawptr %148, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$5bc, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%149 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%150 = bitcast void (i32, i32, i32*)** @gl.GetTextureParameterIiv to %..rawptr
	call void %149(%..rawptr %150, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$5bd, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%151 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%152 = bitcast void (i32, i32, i32*)** @gl.GetTextureParameterIuiv to %..rawptr
	call void %151(%..rawptr %152, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$5be, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%153 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%154 = bitcast void (i32, i32, i32*)** @gl.GetTextureParameteriv to %..rawptr
	call void %153(%..rawptr %154, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$5bf, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%155 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%156 = bitcast void (i32, i32*)** @gl.CreateVertexArrays to %..rawptr
	call void %155(%..rawptr %156, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$5c0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%157 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%158 = bitcast void (i32, i32)** @gl.DisableVertexArrayAttrib to %..rawptr
	call void %157(%..rawptr %158, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$5c1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%159 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%160 = bitcast void (i32, i32)** @gl.EnableVertexArrayAttrib to %..rawptr
	call void %159(%..rawptr %160, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$5c2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%161 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%162 = bitcast void (i32, i32)** @gl.VertexArrayElementBuffer to %..rawptr
	call void %161(%..rawptr %162, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$5c3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%163 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%164 = bitcast void (i32, i32, i32, i64, i32)** @gl.VertexArrayVertexBuffer to %..rawptr
	call void %163(%..rawptr %164, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$5c4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%165 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%166 = bitcast void (i32, i32, i32, i32*, i64*, i32*)** @gl.VertexArrayVertexBuffers to %..rawptr
	call void %165(%..rawptr %166, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$5c5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%167 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%168 = bitcast void (i32, i32, i32)** @gl.VertexArrayAttribBinding to %..rawptr
	call void %167(%..rawptr %168, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$5c6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%169 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%170 = bitcast void (i32, i32, i32, i32, i8, i32)** @gl.VertexArrayAttribFormat to %..rawptr
	call void %169(%..rawptr %170, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$5c7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%171 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%172 = bitcast void (i32, i32, i32, i32, i32)** @gl.VertexArrayAttribIFormat to %..rawptr
	call void %171(%..rawptr %172, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$5c8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%173 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%174 = bitcast void (i32, i32, i32, i32, i32)** @gl.VertexArrayAttribLFormat to %..rawptr
	call void %173(%..rawptr %174, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$5c9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%175 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%176 = bitcast void (i32, i32, i32)** @gl.VertexArrayBindingDivisor to %..rawptr
	call void %175(%..rawptr %176, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$5ca, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%177 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%178 = bitcast void (i32, i32, i32*)** @gl.GetVertexArrayiv to %..rawptr
	call void %177(%..rawptr %178, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$5cb, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%179 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%180 = bitcast void (i32, i32, i32, i32*)** @gl.GetVertexArrayIndexediv to %..rawptr
	call void %179(%..rawptr %180, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$5cc, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%181 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%182 = bitcast void (i32, i32, i32, i64*)** @gl.GetVertexArrayIndexed64iv to %..rawptr
	call void %181(%..rawptr %182, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$5cd, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%183 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%184 = bitcast void (i32, i32*)** @gl.CreateSamplers to %..rawptr
	call void %183(%..rawptr %184, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$5ce, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%185 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%186 = bitcast void (i32, i32*)** @gl.CreateProgramPipelines to %..rawptr
	call void %185(%..rawptr %186, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$5cf, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%187 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%188 = bitcast void (i32, i32, i32*)** @gl.CreateQueries to %..rawptr
	call void %187(%..rawptr %188, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$5d0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%189 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%190 = bitcast void (i32, i32, i32, i64)** @gl.GetQueryBufferObjecti64v to %..rawptr
	call void %189(%..rawptr %190, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$5d1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%191 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%192 = bitcast void (i32, i32, i32, i64)** @gl.GetQueryBufferObjectiv to %..rawptr
	call void %191(%..rawptr %192, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$5d2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%193 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%194 = bitcast void (i32, i32, i32, i64)** @gl.GetQueryBufferObjectui64v to %..rawptr
	call void %193(%..rawptr %194, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$5d3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%195 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%196 = bitcast void (i32, i32, i32, i64)** @gl.GetQueryBufferObjectuiv to %..rawptr
	call void %195(%..rawptr %196, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$5d4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%197 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%198 = bitcast void (i32)** @gl.MemoryBarrierByRegion to %..rawptr
	call void %197(%..rawptr %198, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$5d5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%199 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%200 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.GetTextureSubImage to %..rawptr
	call void %199(%..rawptr %200, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$5d6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%201 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%202 = bitcast void (i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.GetCompressedTextureSubImage to %..rawptr
	call void %201(%..rawptr %202, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @str$5d7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%203 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%204 = bitcast i32 ()** @gl.GetGraphicsResetStatus to %..rawptr
	call void %203(%..rawptr %204, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$5d8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%205 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%206 = bitcast void (i32, i32, i32, %..rawptr)** @gl.GetnCompressedTexImage to %..rawptr
	call void %205(%..rawptr %206, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$5d9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%207 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%208 = bitcast void (i32, i32, i32, i32, i32, %..rawptr)** @gl.GetnTexImage to %..rawptr
	call void %207(%..rawptr %208, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$5da, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%209 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%210 = bitcast void (i32, i32, i32, double*)** @gl.GetnUniformdv to %..rawptr
	call void %209(%..rawptr %210, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$5db, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%211 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%212 = bitcast void (i32, i32, i32, float*)** @gl.GetnUniformfv to %..rawptr
	call void %211(%..rawptr %212, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$5dc, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%213 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%214 = bitcast void (i32, i32, i32, i32*)** @gl.GetnUniformiv to %..rawptr
	call void %213(%..rawptr %214, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$5dd, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%215 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%216 = bitcast void (i32, i32, i32, i32*)** @gl.GetnUniformuiv to %..rawptr
	call void %215(%..rawptr %216, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$5de, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%217 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%218 = bitcast void (i32, i32, i32, i32, i32, i32, i32, %..rawptr)** @gl.ReadnPixels to %..rawptr
	call void %217(%..rawptr %218, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$5df, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%219 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%220 = bitcast void (i32, i32, i32, double*)** @gl.GetnMapdv to %..rawptr
	call void %219(%..rawptr %220, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$5e0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%221 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%222 = bitcast void (i32, i32, i32, float*)** @gl.GetnMapfv to %..rawptr
	call void %221(%..rawptr %222, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$5e1, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%223 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%224 = bitcast void (i32, i32, i32, i32*)** @gl.GetnMapiv to %..rawptr
	call void %223(%..rawptr %224, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$5e2, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%225 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%226 = bitcast void (i32, i32, float*)** @gl.GetnPixelMapfv to %..rawptr
	call void %225(%..rawptr %226, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$5e3, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%227 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%228 = bitcast void (i32, i32, i32*)** @gl.GetnPixelMapuiv to %..rawptr
	call void %227(%..rawptr %228, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$5e4, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%229 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%230 = bitcast void (i32, i32, i16*)** @gl.GetnPixelMapusv to %..rawptr
	call void %229(%..rawptr %230, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$5e5, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%231 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%232 = bitcast void (i32, i8*)** @gl.GetnPolygonStipple to %..rawptr
	call void %231(%..rawptr %232, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$5e6, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%233 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%234 = bitcast void (i32, i32, i32, i32, %..rawptr)** @gl.GetnColorTable to %..rawptr
	call void %233(%..rawptr %234, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$5e7, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%235 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%236 = bitcast void (i32, i32, i32, i32, %..rawptr)** @gl.GetnConvolutionFilter to %..rawptr
	call void %235(%..rawptr %236, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$5e8, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%237 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%238 = bitcast void (i32, i32, i32, i32, %..rawptr, i32, %..rawptr, %..rawptr)** @gl.GetnSeparableFilter to %..rawptr
	call void %237(%..rawptr %238, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$5e9, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%239 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%240 = bitcast void (i32, i8, i32, i32, i32, %..rawptr)** @gl.GetnHistogram to %..rawptr
	call void %239(%..rawptr %240, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$5ea, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%241 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%242 = bitcast void (i32, i8, i32, i32, i32, %..rawptr)** @gl.GetnMinmax to %..rawptr
	call void %241(%..rawptr %242, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$5eb, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%243 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%244 = bitcast void ()** @gl.TextureBarrier to %..rawptr
	call void %243(%..rawptr %244, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$5ec, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @gl.load_4_6(void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca void (%..rawptr, i8*, %runtime.Context*)*, align 16
	store void (%..rawptr, i8*, %runtime.Context*)* %set_proc_address, void (%..rawptr, i8*, %runtime.Context*)** %0
	%1 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%2 = bitcast void (i32, i8*, i32, i32*, i32*)** @gl.SpecializeShader to %..rawptr
	call void %1(%..rawptr %2, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$5ed, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%3 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%4 = bitcast void (i32, %..rawptr, i64, i32, i32)** @gl.MultiDrawArraysIndirectCount to %..rawptr
	call void %3(%..rawptr %4, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @str$5ee, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%5 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%6 = bitcast void (i32, i32, %..rawptr, i64, i32, i32)** @gl.MultiDrawElementsIndirectCount to %..rawptr
	call void %5(%..rawptr %6, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @str$5ef, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load void (%..rawptr, i8*, %runtime.Context*)*, void (%..rawptr, i8*, %runtime.Context*)** %0, align 8
	%8 = bitcast void (float, float, float)** @gl.PolygonOffsetClamp to %..rawptr
	call void %7(%..rawptr %8, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$5f0, i64 0, i32 0), %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @decimal.trim(%decimal.Decimal* %a, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	; ForStmt
	br label %for.loop-1

for.loop-1:
	; SelectorExpr
	%1 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%2 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %1, i64 0
	%3 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %2, i64 0, i32 1
	%4 = load i64, i64* %3, align 8
	%5 = icmp sgt i64 %4, 0
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %cmp.and-2, label %for.done-4

cmp.and-2:
	; IndexExpr
	; SelectorExpr
	%8 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%9 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %8, i64 0
	%10 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %9, i64 0, i32 0
	; SelectorExpr
	%11 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%12 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %11, i64 0
	%13 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %12, i64 0, i32 1
	%14 = load i64, i64* %13, align 8
	%15 = sub i64 %14, 1
	%16 = trunc i64 %15 to i32
	%17 = getelementptr inbounds [384 x i8], [384 x i8]* %10, i64 0, i32 %16
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$5f1, i64 0, i32 0), i64 61}, i64 50, i64 32, i64 %15, i64 384)
	%18 = load i8, i8* %17, align 1
	%19 = icmp eq i8 %18, 48
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %for.body-3, label %for.done-4

for.body-3:
	; AssignStmt
	; SelectorExpr
	%22 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%23 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %22, i64 0
	%24 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %23, i64 0, i32 1
	%25 = load i64, i64* %24, align 8
	%26 = sub i64 %25, 1
	store i64 %26, i64* %24
	br label %for.loop-1

for.done-4:
	; IfStmt
	; SelectorExpr
	%27 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%28 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %27, i64 0
	%29 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %28, i64 0, i32 1
	%30 = load i64, i64* %29, align 8
	%31 = icmp eq i64 %30, 0
	%32 = zext i1 %31 to i8
	%33 = trunc i8 %32 to i1
	br i1 %33, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%34 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%35 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %34, i64 0
	%36 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %35, i64 0, i32 2
	store i64 0, i64* %36
	br label %if.done-6

if.done-6:
	ret void
}

define void @decimal.assign(%decimal.Decimal* %a, i64 %i, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca [64 x i8], align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %i, i64* %1
	; buf
	%5 = bitcast [64 x i8]* %2 to %..rawptr
	%6 = call %..rawptr @mem.zero(%..rawptr %5, i64 64) noinline
	store [64 x i8] zeroinitializer, [64 x i8]* %2
	; n
	store i64 0, i64* %3
	; ForStmt
	br label %for.loop-1

for.loop-1:
	%7 = load i64, i64* %1, align 8
	%8 = icmp ugt i64 %7, 0
	%9 = zext i1 %8 to i8
	%10 = trunc i8 %9 to i1
	br i1 %10, label %for.body-2, label %for.done-3

for.body-2:
	; j
	%11 = load i64, i64* %1, align 8
	%12 = udiv i64 %11, 10
	store i64 %12, i64* %4
	; AssignStmt
	%13 = load i64, i64* %4, align 8
	%14 = mul i64 10, %13
	%15 = load i64, i64* %1, align 8
	%16 = sub i64 %15, %14
	store i64 %16, i64* %1
	; AssignStmt
	; IndexExpr
	%17 = load i64, i64* %3, align 8
	%18 = trunc i64 %17 to i32
	%19 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i32 %18
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$5f2, i64 0, i32 0), i64 61}, i64 65, i64 7, i64 %17, i64 64)
	%20 = load i64, i64* %1, align 8
	%21 = add i64 48, %20
	%22 = trunc i64 %21 to i8
	store i8 %22, i8* %19
	; AssignStmt
	%23 = load i64, i64* %3, align 8
	%24 = add i64 %23, 1
	store i64 %24, i64* %3
	; AssignStmt
	%25 = load i64, i64* %4, align 8
	store i64 %25, i64* %1
	br label %for.loop-1

for.done-3:
	; AssignStmt
	; SelectorExpr
	%26 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%27 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %26, i64 0
	%28 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %27, i64 0, i32 1
	store i64 0, i64* %28
	; ForStmt
	; AssignStmt
	%29 = load i64, i64* %3, align 8
	%30 = sub i64 %29, 1
	store i64 %30, i64* %3
	br label %for.loop-4

for.loop-4:
	%31 = load i64, i64* %3, align 8
	%32 = icmp sge i64 %31, 0
	%33 = zext i1 %32 to i8
	%34 = trunc i8 %33 to i1
	br i1 %34, label %for.body-5, label %for.done-6

for.body-5:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%35 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%36 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %35, i64 0
	%37 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %36, i64 0, i32 0
	; SelectorExpr
	%38 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%39 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %38, i64 0
	%40 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %39, i64 0, i32 1
	%41 = load i64, i64* %40, align 8
	%42 = trunc i64 %41 to i32
	%43 = getelementptr inbounds [384 x i8], [384 x i8]* %37, i64 0, i32 %42
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$5f3, i64 0, i32 0), i64 61}, i64 72, i64 14, i64 %41, i64 384)
	; IndexExpr
	%44 = load i64, i64* %3, align 8
	%45 = trunc i64 %44 to i32
	%46 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i32 %45
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$5f4, i64 0, i32 0), i64 61}, i64 72, i64 27, i64 %44, i64 64)
	%47 = load i8, i8* %46, align 1
	store i8 %47, i8* %43
	; AssignStmt
	; SelectorExpr
	%48 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%49 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %48, i64 0
	%50 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %49, i64 0, i32 1
	%51 = load i64, i64* %50, align 8
	%52 = add i64 %51, 1
	store i64 %52, i64* %50
	; AssignStmt
	%53 = load i64, i64* %3, align 8
	%54 = sub i64 %53, 1
	store i64 %54, i64* %3
	br label %for.loop-4

for.done-6:
	; AssignStmt
	; SelectorExpr
	%55 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%56 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %55, i64 0
	%57 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %56, i64 0, i32 2
	; SelectorExpr
	%58 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%59 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %58, i64 0
	%60 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %59, i64 0, i32 1
	%61 = load i64, i64* %60, align 8
	store i64 %61, i64* %57
	%62 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.trim(%decimal.Decimal* %62, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @decimal.shift_right(%decimal.Decimal* %a, i64 %k, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %k, i64* %1
	; r
	store i64 0, i64* %2
	; w
	store i64 0, i64* %3
	; n
	%10 = bitcast i64* %4 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	; ForStmt
	br label %for.loop-1

for.loop-1:
	%12 = load i64, i64* %4, align 8
	%13 = load i64, i64* %1, align 8
	%14 = lshr i64 %12, %13
	%15 = icmp eq i64 %14, 0
	%16 = zext i1 %15 to i8
	%17 = trunc i8 %16 to i1
	br i1 %17, label %for.body-2, label %for.done-10

for.body-2:
	; IfStmt
	%18 = load i64, i64* %2, align 8
	; SelectorExpr
	%19 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%20 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %19, i64 0
	%21 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %20, i64 0, i32 1
	%22 = load i64, i64* %21, align 8
	%23 = icmp sge i64 %18, %22
	%24 = zext i1 %23 to i8
	%25 = trunc i8 %24 to i1
	br i1 %25, label %if.then-3, label %if.done-9

if.then-3:
	; IfStmt
	%26 = load i64, i64* %4, align 8
	%27 = icmp eq i64 %26, 0
	%28 = zext i1 %27 to i8
	%29 = trunc i8 %28 to i1
	br i1 %29, label %if.then-4, label %if.done-5

if.then-4:
	; AssignStmt
	; SelectorExpr
	%30 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%31 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %30, i64 0
	%32 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %31, i64 0, i32 1
	store i64 0, i64* %32
	; ReturnStmt
	ret void

if.done-5:
	; ForStmt
	br label %for.loop-6

for.loop-6:
	%33 = load i64, i64* %4, align 8
	%34 = load i64, i64* %1, align 8
	%35 = lshr i64 %33, %34
	%36 = icmp eq i64 %35, 0
	%37 = zext i1 %36 to i8
	%38 = trunc i8 %37 to i1
	br i1 %38, label %for.body-7, label %for.done-8

for.body-7:
	; AssignStmt
	%39 = load i64, i64* %4, align 8
	%40 = mul i64 %39, 10
	store i64 %40, i64* %4
	; AssignStmt
	%41 = load i64, i64* %2, align 8
	%42 = add i64 %41, 1
	store i64 %42, i64* %2
	br label %for.loop-6

for.done-8:
	; break
	br label %for.done-10

if.done-9:
	; c
	; IndexExpr
	; SelectorExpr
	%43 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%44 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %43, i64 0
	%45 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %44, i64 0, i32 0
	%46 = load i64, i64* %2, align 8
	%47 = trunc i64 %46 to i32
	%48 = getelementptr inbounds [384 x i8], [384 x i8]* %45, i64 0, i32 %47
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$5f5, i64 0, i32 0), i64 61}, i64 99, i64 22, i64 %46, i64 384)
	%49 = load i8, i8* %48, align 1
	%50 = zext i8 %49 to i64
	store i64 %50, i64* %5
	; AssignStmt
	%51 = load i64, i64* %4, align 8
	%52 = mul i64 %51, 10
	%53 = load i64, i64* %5, align 8
	%54 = add i64 %52, %53
	%55 = sub i64 %54, 48
	store i64 %55, i64* %4
	; AssignStmt
	%56 = load i64, i64* %2, align 8
	%57 = add i64 %56, 1
	store i64 %57, i64* %2
	br label %for.loop-1

for.done-10:
	; AssignStmt
	; SelectorExpr
	%58 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%59 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %58, i64 0
	%60 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %59, i64 0, i32 2
	%61 = load i64, i64* %2, align 8
	%62 = sub i64 %61, 1
	%63 = load i64, i64* %60, align 8
	%64 = sub i64 %63, %62
	store i64 %64, i64* %60
	; mask
	%65 = load i64, i64* %1, align 8
	%66 = shl i64 1, %65
	%67 = bitcast i64 %66 to i64
	%68 = sub i64 %67, 1
	%69 = bitcast i64 %68 to i64
	store i64 %69, i64* %6
	; ForStmt
	br label %for.loop-11

for.loop-11:
	%70 = load i64, i64* %2, align 8
	; SelectorExpr
	%71 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%72 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %71, i64 0
	%73 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %72, i64 0, i32 1
	%74 = load i64, i64* %73, align 8
	%75 = icmp slt i64 %70, %74
	%76 = zext i1 %75 to i8
	%77 = trunc i8 %76 to i1
	br i1 %77, label %for.body-12, label %for.done-13

for.body-12:
	; c
	; IndexExpr
	; SelectorExpr
	%78 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%79 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %78, i64 0
	%80 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %79, i64 0, i32 0
	%81 = load i64, i64* %2, align 8
	%82 = trunc i64 %81 to i32
	%83 = getelementptr inbounds [384 x i8], [384 x i8]* %80, i64 0, i32 %82
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$5f6, i64 0, i32 0), i64 61}, i64 107, i64 22, i64 %81, i64 384)
	%84 = load i8, i8* %83, align 1
	%85 = zext i8 %84 to i64
	store i64 %85, i64* %7
	; dig
	%86 = load i64, i64* %4, align 8
	%87 = load i64, i64* %1, align 8
	%88 = lshr i64 %86, %87
	store i64 %88, i64* %8
	; AssignStmt
	%89 = load i64, i64* %6, align 8
	%90 = load i64, i64* %4, align 8
	%91 = and i64 %90, %89
	store i64 %91, i64* %4
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%92 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%93 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %92, i64 0
	%94 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %93, i64 0, i32 0
	%95 = load i64, i64* %3, align 8
	%96 = trunc i64 %95 to i32
	%97 = getelementptr inbounds [384 x i8], [384 x i8]* %94, i64 0, i32 %96
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$5f7, i64 0, i32 0), i64 61}, i64 110, i64 12, i64 %95, i64 384)
	%98 = load i64, i64* %8, align 8
	%99 = add i64 48, %98
	%100 = trunc i64 %99 to i8
	store i8 %100, i8* %97
	; AssignStmt
	%101 = load i64, i64* %3, align 8
	%102 = add i64 %101, 1
	store i64 %102, i64* %3
	; AssignStmt
	%103 = load i64, i64* %4, align 8
	%104 = mul i64 %103, 10
	%105 = load i64, i64* %7, align 8
	%106 = add i64 %104, %105
	%107 = sub i64 %106, 48
	store i64 %107, i64* %4
	; AssignStmt
	%108 = load i64, i64* %2, align 8
	%109 = add i64 %108, 1
	store i64 %109, i64* %2
	br label %for.loop-11

for.done-13:
	; ForStmt
	br label %for.loop-14

for.loop-14:
	%110 = load i64, i64* %4, align 8
	%111 = icmp ugt i64 %110, 0
	%112 = zext i1 %111 to i8
	%113 = trunc i8 %112 to i1
	br i1 %113, label %for.body-15, label %for.done-21

for.body-15:
	; dig
	%114 = load i64, i64* %4, align 8
	%115 = load i64, i64* %1, align 8
	%116 = lshr i64 %114, %115
	store i64 %116, i64* %9
	; AssignStmt
	%117 = load i64, i64* %6, align 8
	%118 = load i64, i64* %4, align 8
	%119 = and i64 %118, %117
	store i64 %119, i64* %4
	; IfStmt
	%120 = load i64, i64* %3, align 8
	%121 = icmp slt i64 %120, 384
	%122 = zext i1 %121 to i8
	%123 = trunc i8 %122 to i1
	br i1 %123, label %if.then-16, label %if.else-17

if.then-16:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%124 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%125 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %124, i64 0
	%126 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %125, i64 0, i32 0
	%127 = load i64, i64* %3, align 8
	%128 = trunc i64 %127 to i32
	%129 = getelementptr inbounds [384 x i8], [384 x i8]* %126, i64 0, i32 %128
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$5f8, i64 0, i32 0), i64 61}, i64 119, i64 13, i64 %127, i64 384)
	%130 = load i64, i64* %9, align 8
	%131 = add i64 48, %130
	%132 = trunc i64 %131 to i8
	store i8 %132, i8* %129
	; AssignStmt
	%133 = load i64, i64* %3, align 8
	%134 = add i64 %133, 1
	store i64 %134, i64* %3
	br label %if.done-20

if.else-17:
	; IfStmt
	%135 = load i64, i64* %9, align 8
	%136 = icmp ugt i64 %135, 0
	%137 = zext i1 %136 to i8
	%138 = trunc i8 %137 to i1
	br i1 %138, label %if.then-18, label %if.done-19

if.then-18:
	; AssignStmt
	; SelectorExpr
	%139 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%140 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %139, i64 0
	%141 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %140, i64 0, i32 4
	store i8 1, i8* %141
	br label %if.done-19

if.done-19:
	br label %if.done-20

if.done-20:
	; AssignStmt
	%142 = load i64, i64* %4, align 8
	%143 = mul i64 %142, 10
	store i64 %143, i64* %4
	br label %for.loop-14

for.done-21:
	; AssignStmt
	; SelectorExpr
	%144 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%145 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %144, i64 0
	%146 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %145, i64 0, i32 1
	%147 = load i64, i64* %3, align 8
	store i64 %147, i64* %146
	%148 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.trim(%decimal.Decimal* %148, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @decimal.shift_left(%decimal.Decimal* %a, i64 %k, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %k, i64* %1
	; delta
	%10 = load i64, i64* %1, align 8
	%11 = udiv i64 %10, 4
	%12 = bitcast i64 %11 to i64
	store i64 %12, i64* %2
	; r
	; SelectorExpr
	%13 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%14 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %13, i64 0
	%15 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %14, i64 0, i32 1
	%16 = load i64, i64* %15, align 8
	store i64 %16, i64* %3
	; w
	; SelectorExpr
	%17 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%18 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %17, i64 0
	%19 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %18, i64 0, i32 1
	%20 = load i64, i64* %19, align 8
	%21 = load i64, i64* %2, align 8
	%22 = add i64 %20, %21
	store i64 %22, i64* %4
	; n
	%23 = bitcast i64* %5 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	; ForStmt
	; AssignStmt
	%25 = load i64, i64* %3, align 8
	%26 = sub i64 %25, 1
	store i64 %26, i64* %3
	br label %for.loop-1

for.loop-1:
	%27 = load i64, i64* %3, align 8
	%28 = icmp sge i64 %27, 0
	%29 = zext i1 %28 to i8
	%30 = trunc i8 %29 to i1
	br i1 %30, label %for.body-2, label %for.done-8

for.body-2:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%31 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%32 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %31, i64 0
	%33 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %32, i64 0, i32 0
	%34 = load i64, i64* %3, align 8
	%35 = trunc i64 %34 to i32
	%36 = getelementptr inbounds [384 x i8], [384 x i8]* %33, i64 0, i32 %35
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$5f9, i64 0, i32 0), i64 61}, i64 140, i64 23, i64 %34, i64 384)
	%37 = load i8, i8* %36, align 1
	%38 = zext i8 %37 to i64
	%39 = sub i64 %38, 48
	%40 = load i64, i64* %1, align 8
	%41 = shl i64 %39, %40
	%42 = load i64, i64* %5, align 8
	%43 = add i64 %42, %41
	store i64 %43, i64* %5
	; quo
	%44 = load i64, i64* %5, align 8
	%45 = udiv i64 %44, 10
	store i64 %45, i64* %6
	; rem
	%46 = load i64, i64* %5, align 8
	%47 = load i64, i64* %6, align 8
	%48 = mul i64 10, %47
	%49 = sub i64 %46, %48
	store i64 %49, i64* %7
	; AssignStmt
	%50 = load i64, i64* %4, align 8
	%51 = sub i64 %50, 1
	store i64 %51, i64* %4
	; IfStmt
	%52 = load i64, i64* %4, align 8
	%53 = icmp slt i64 %52, 384
	%54 = zext i1 %53 to i8
	%55 = trunc i8 %54 to i1
	br i1 %55, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%56 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%57 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %56, i64 0
	%58 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %57, i64 0, i32 0
	%59 = load i64, i64* %4, align 8
	%60 = trunc i64 %59 to i32
	%61 = getelementptr inbounds [384 x i8], [384 x i8]* %58, i64 0, i32 %60
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$5fa, i64 0, i32 0), i64 61}, i64 145, i64 13, i64 %59, i64 384)
	%62 = load i64, i64* %7, align 8
	%63 = add i64 48, %62
	%64 = trunc i64 %63 to i8
	store i8 %64, i8* %61
	br label %if.done-7

if.else-4:
	; IfStmt
	%65 = load i64, i64* %7, align 8
	%66 = icmp ne i64 %65, 0
	%67 = zext i1 %66 to i8
	%68 = trunc i8 %67 to i1
	br i1 %68, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%69 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%70 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %69, i64 0
	%71 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %70, i64 0, i32 4
	store i8 1, i8* %71
	br label %if.done-6

if.done-6:
	br label %if.done-7

if.done-7:
	; AssignStmt
	%72 = load i64, i64* %6, align 8
	store i64 %72, i64* %5
	; AssignStmt
	%73 = load i64, i64* %3, align 8
	%74 = sub i64 %73, 1
	store i64 %74, i64* %3
	br label %for.loop-1

for.done-8:
	; ForStmt
	br label %for.loop-9

for.loop-9:
	%75 = load i64, i64* %5, align 8
	%76 = icmp ugt i64 %75, 0
	%77 = zext i1 %76 to i8
	%78 = trunc i8 %77 to i1
	br i1 %78, label %for.body-10, label %for.done-17

for.body-10:
	; quo
	%79 = load i64, i64* %5, align 8
	%80 = udiv i64 %79, 10
	store i64 %80, i64* %8
	; rem
	%81 = load i64, i64* %5, align 8
	%82 = load i64, i64* %8, align 8
	%83 = mul i64 10, %82
	%84 = sub i64 %81, %83
	store i64 %84, i64* %9
	; AssignStmt
	%85 = load i64, i64* %4, align 8
	%86 = sub i64 %85, 1
	store i64 %86, i64* %4
	; IfStmt
	%87 = load i64, i64* %4, align 8
	%88 = icmp sle i64 0, %87
	%89 = zext i1 %88 to i8
	%90 = trunc i8 %89 to i1
	br i1 %90, label %cmp.and-11, label %if.else-13

cmp.and-11:
	%91 = load i64, i64* %4, align 8
	%92 = icmp slt i64 %91, 384
	%93 = zext i1 %92 to i8
	%94 = trunc i8 %93 to i1
	br i1 %94, label %if.then-12, label %if.else-13

if.then-12:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%95 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%96 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %95, i64 0
	%97 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %96, i64 0, i32 0
	%98 = load i64, i64* %4, align 8
	%99 = trunc i64 %98 to i32
	%100 = getelementptr inbounds [384 x i8], [384 x i8]* %97, i64 0, i32 %99
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$5fb, i64 0, i32 0), i64 61}, i64 157, i64 13, i64 %98, i64 384)
	%101 = load i64, i64* %9, align 8
	%102 = add i64 48, %101
	%103 = trunc i64 %102 to i8
	store i8 %103, i8* %100
	br label %if.done-16

if.else-13:
	; IfStmt
	%104 = load i64, i64* %9, align 8
	%105 = icmp ne i64 %104, 0
	%106 = zext i1 %105 to i8
	%107 = trunc i8 %106 to i1
	br i1 %107, label %if.then-14, label %if.done-15

if.then-14:
	; AssignStmt
	; SelectorExpr
	%108 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%109 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %108, i64 0
	%110 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %109, i64 0, i32 4
	store i8 1, i8* %110
	br label %if.done-15

if.done-15:
	br label %if.done-16

if.done-16:
	; AssignStmt
	%111 = load i64, i64* %8, align 8
	store i64 %111, i64* %5
	br label %for.loop-9

for.done-17:
	; AssignStmt
	; SelectorExpr
	%112 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%113 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %112, i64 0
	%114 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %113, i64 0, i32 1
	%115 = load i64, i64* %2, align 8
	%116 = load i64, i64* %114, align 8
	%117 = add i64 %116, %115
	store i64 %117, i64* %114
	; AssignStmt
	; SelectorExpr
	%118 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%119 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %118, i64 0
	%120 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %119, i64 0, i32 1
	; min
	; SelectorExpr
	%121 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%122 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %121, i64 0
	%123 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %122, i64 0, i32 1
	%124 = load i64, i64* %123, align 8
	%125 = icmp slt i64 %124, 384
	%126 = select i1 %125, i64 %124, i64 384
	store i64 %126, i64* %120
	; AssignStmt
	; SelectorExpr
	%127 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%128 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %127, i64 0
	%129 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %128, i64 0, i32 2
	%130 = load i64, i64* %2, align 8
	%131 = load i64, i64* %129, align 8
	%132 = add i64 %131, %130
	store i64 %132, i64* %129
	%133 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.trim(%decimal.Decimal* %133, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @decimal.shift(%decimal.Decimal* %a, i64 %k, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %k, i64* %1
	; SwitchStmt
	; SelectorExpr
	%2 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%3 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %2, i64 0
	%4 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %3, i64 0, i32 1
	%5 = load i64, i64* %4, align 8
	%6 = icmp eq i64 %5, 0
	%7 = zext i1 %6 to i8
	%8 = icmp eq i8 1, %7
	br i1 %8, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%9 = load i64, i64* %1, align 8
	%10 = icmp sgt i64 %9, 0
	%11 = zext i1 %10 to i8
	%12 = icmp eq i8 1, %11
	br i1 %12, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	br label %switch.done-13

switch.case.next-3:
	%13 = load i64, i64* %1, align 8
	%14 = icmp slt i64 %13, 0
	%15 = zext i1 %14 to i8
	%16 = icmp eq i8 1, %15
	br i1 %16, label %switch.fall.body-9, label %switch.case.next-8

switch.fall.body-4:
	; ForStmt
	br label %for.loop-5

for.loop-5:
	%17 = load i64, i64* %1, align 8
	%18 = icmp sgt i64 %17, 60
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %for.body-6, label %for.done-7

for.body-6:
	%21 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.shift_left(%decimal.Decimal* %21, i64 60, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	%22 = load i64, i64* %1, align 8
	%23 = sub i64 %22, 60
	store i64 %23, i64* %1
	br label %for.loop-5

for.done-7:
	%24 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%25 = load i64, i64* %1, align 8
	%26 = bitcast i64 %25 to i64
	call void @decimal.shift_left(%decimal.Decimal* %24, i64 %26, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-13

switch.case.next-8:
	br label %switch.done-13

switch.fall.body-9:
	; ForStmt
	br label %for.loop-10

for.loop-10:
	%27 = load i64, i64* %1, align 8
	%28 = icmp slt i64 %27, -60
	%29 = zext i1 %28 to i8
	%30 = trunc i8 %29 to i1
	br i1 %30, label %for.body-11, label %for.done-12

for.body-11:
	%31 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.shift_right(%decimal.Decimal* %31, i64 60, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	%32 = load i64, i64* %1, align 8
	%33 = add i64 %32, 60
	store i64 %33, i64* %1
	br label %for.loop-10

for.done-12:
	%34 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%35 = load i64, i64* %1, align 8
	%36 = sub i64 0, %35
	%37 = bitcast i64 %36 to i64
	call void @decimal.shift_right(%decimal.Decimal* %34, i64 %37, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-13

switch.done-13:
	ret void
}

define i8 @decimal.can_round_up(%decimal.Decimal* %a, i64 %nd, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %nd, i64* %1
	; IfStmt
	%2 = load i64, i64* %1, align 8
	%3 = icmp slt i64 %2, 0
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%6 = load i64, i64* %1, align 8
	; SelectorExpr
	%7 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%8 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %7, i64 0
	%9 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %8, i64 0, i32 1
	%10 = load i64, i64* %9, align 8
	%11 = icmp sge i64 %6, %10
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret i8 0

if.done-3:
	; IfStmt
	; IndexExpr
	; SelectorExpr
	%14 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%15 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %14, i64 0
	%16 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %15, i64 0, i32 0
	%17 = load i64, i64* %1, align 8
	%18 = trunc i64 %17 to i32
	%19 = getelementptr inbounds [384 x i8], [384 x i8]* %16, i64 0, i32 %18
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$5fc, i64 0, i32 0), i64 61}, i64 196, i64 14, i64 %17, i64 384)
	%20 = load i8, i8* %19, align 1
	%21 = icmp eq i8 %20, 53
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %cmp.and-4, label %if.done-10

cmp.and-4:
	%24 = load i64, i64* %1, align 8
	%25 = add i64 %24, 1
	; SelectorExpr
	%26 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%27 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %26, i64 0
	%28 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %27, i64 0, i32 1
	%29 = load i64, i64* %28, align 8
	%30 = icmp eq i64 %25, %29
	%31 = zext i1 %30 to i8
	%32 = trunc i8 %31 to i1
	br i1 %32, label %if.then-5, label %if.done-10

if.then-5:
	; IfStmt
	; SelectorExpr
	%33 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%34 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %33, i64 0
	%35 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %34, i64 0, i32 4
	%36 = load i8, i8* %35, align 1
	%37 = trunc i8 %36 to i1
	br i1 %37, label %if.then-6, label %if.done-7

if.then-6:
	; ReturnStmt
	ret i8 1

if.done-7:
	; ReturnStmt
	%38 = load i64, i64* %1, align 8
	%39 = icmp sgt i64 %38, 0
	%40 = zext i1 %39 to i8
	%41 = load i64, i64* %1, align 8
	%42 = icmp sgt i64 %41, 0
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	br i1 %44, label %logical.cmp.rhs-8, label %logical.cmp.done-9

logical.cmp.rhs-8:
	; IndexExpr
	; SelectorExpr
	%45 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%46 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %45, i64 0
	%47 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %46, i64 0, i32 0
	%48 = load i64, i64* %1, align 8
	%49 = sub i64 %48, 1
	%50 = trunc i64 %49 to i32
	%51 = getelementptr inbounds [384 x i8], [384 x i8]* %47, i64 0, i32 %50
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$5fd, i64 0, i32 0), i64 61}, i64 198, i64 30, i64 %49, i64 384)
	%52 = load i8, i8* %51, align 1
	%53 = sub i8 %52, 48
	%54 = urem i8 %53, 2
	%55 = icmp ne i8 %54, 0
	%56 = zext i1 %55 to i8
	br label %logical.cmp.done-9

logical.cmp.done-9:
	%57 = phi i8 [ 0, %if.done-7 ], [ %56, %logical.cmp.rhs-8 ]
	ret i8 %57

if.done-10:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%58 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%59 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %58, i64 0
	%60 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %59, i64 0, i32 0
	%61 = load i64, i64* %1, align 8
	%62 = trunc i64 %61 to i32
	%63 = getelementptr inbounds [384 x i8], [384 x i8]* %60, i64 0, i32 %62
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$5fe, i64 0, i32 0), i64 61}, i64 201, i64 18, i64 %61, i64 384)
	%64 = load i8, i8* %63, align 1
	%65 = icmp uge i8 %64, 53
	%66 = zext i1 %65 to i8
	ret i8 %66
}

define void @decimal.round(%decimal.Decimal* %a, i64 %nd, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %nd, i64* %1
	; IfStmt
	%2 = load i64, i64* %1, align 8
	%3 = icmp slt i64 %2, 0
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%6 = load i64, i64* %1, align 8
	; SelectorExpr
	%7 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%8 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %7, i64 0
	%9 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %8, i64 0, i32 1
	%10 = load i64, i64* %9, align 8
	%11 = icmp sge i64 %6, %10
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	; IfStmt
	%14 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%15 = load i64, i64* %1, align 8
	%16 = call i8 @decimal.can_round_up(%decimal.Decimal* %14, i64 %15, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = trunc i8 %16 to i1
	br i1 %17, label %if.then-4, label %if.else-5

if.then-4:
	%18 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%19 = load i64, i64* %1, align 8
	call void @decimal.round_up(%decimal.Decimal* %18, i64 %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-6

if.else-5:
	%20 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%21 = load i64, i64* %1, align 8
	call void @decimal.round_down(%decimal.Decimal* %20, i64 %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-6

if.done-6:
	ret void
}

define void @decimal.round_up(%decimal.Decimal* %a, i64 %nd, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i8, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %nd, i64* %1
	; IfStmt
	%4 = load i64, i64* %1, align 8
	%5 = icmp slt i64 %4, 0
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%8 = load i64, i64* %1, align 8
	; SelectorExpr
	%9 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%10 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %9, i64 0
	%11 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %10, i64 0, i32 1
	%12 = load i64, i64* %11, align 8
	%13 = icmp sge i64 %8, %12
	%14 = zext i1 %13 to i8
	%15 = trunc i8 %14 to i1
	br i1 %15, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	; ForStmt
	; i
	%16 = load i64, i64* %1, align 8
	%17 = sub i64 %16, 1
	store i64 %17, i64* %2
	br label %for.loop-4

for.loop-4:
	%18 = load i64, i64* %2, align 8
	%19 = icmp sge i64 %18, 0
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %for.body-5, label %for.done-8

for.body-5:
	; IfStmt
	; c
	; IndexExpr
	; SelectorExpr
	%22 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%23 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %22, i64 0
	%24 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %23, i64 0, i32 0
	%25 = load i64, i64* %2, align 8
	%26 = trunc i64 %25 to i32
	%27 = getelementptr inbounds [384 x i8], [384 x i8]* %24, i64 0, i32 %26
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$5ff, i64 0, i32 0), i64 61}, i64 217, i64 20, i64 %25, i64 384)
	%28 = load i8, i8* %27, align 1
	store i8 %28, i8* %3
	%29 = load i8, i8* %3, align 1
	%30 = icmp ult i8 %29, 57
	%31 = zext i1 %30 to i8
	%32 = trunc i8 %31 to i1
	br i1 %32, label %if.then-6, label %if.done-7

if.then-6:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%33 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%34 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %33, i64 0
	%35 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %34, i64 0, i32 0
	%36 = load i64, i64* %2, align 8
	%37 = trunc i64 %36 to i32
	%38 = getelementptr inbounds [384 x i8], [384 x i8]* %35, i64 0, i32 %37
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$600, i64 0, i32 0), i64 61}, i64 218, i64 13, i64 %36, i64 384)
	%39 = load i8, i8* %38, align 1
	%40 = add i8 %39, 1
	store i8 %40, i8* %38
	; AssignStmt
	; SelectorExpr
	%41 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%42 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %41, i64 0
	%43 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %42, i64 0, i32 1
	%44 = load i64, i64* %2, align 8
	%45 = add i64 %44, 1
	store i64 %45, i64* %43
	; ReturnStmt
	ret void

if.done-7:
	; AssignStmt
	%46 = load i64, i64* %2, align 8
	%47 = sub i64 %46, 1
	store i64 %47, i64* %2
	br label %for.loop-4

for.done-8:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%48 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%49 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %48, i64 0
	%50 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %49, i64 0, i32 0
	%51 = getelementptr inbounds [384 x i8], [384 x i8]* %50, i64 0, i32 0
	store i8 49, i8* %51
	; AssignStmt
	; SelectorExpr
	%52 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%53 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %52, i64 0
	%54 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %53, i64 0, i32 1
	store i64 1, i64* %54
	; AssignStmt
	; SelectorExpr
	%55 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%56 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %55, i64 0
	%57 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %56, i64 0, i32 2
	%58 = load i64, i64* %57, align 8
	%59 = add i64 %58, 1
	store i64 %59, i64* %57
	ret void
}

define void @decimal.round_down(%decimal.Decimal* %a, i64 %nd, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %nd, i64* %1
	; IfStmt
	%2 = load i64, i64* %1, align 8
	%3 = icmp slt i64 %2, 0
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%6 = load i64, i64* %1, align 8
	; SelectorExpr
	%7 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%8 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %7, i64 0
	%9 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %8, i64 0, i32 1
	%10 = load i64, i64* %9, align 8
	%11 = icmp sge i64 %6, %10
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	; AssignStmt
	; SelectorExpr
	%14 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%15 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %14, i64 0
	%16 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %15, i64 0, i32 1
	%17 = load i64, i64* %1, align 8
	store i64 %17, i64* %16
	%18 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.trim(%decimal.Decimal* %18, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define i8 @types.is_rune(%runtime.Type_Info* %info, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca {%runtime.Type_Info_Rune, i8}, align 16
	store %runtime.Type_Info* %info, %runtime.Type_Info** %0
	; IfStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%5 = icmp eq %runtime.Type_Info* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ok
	; SelectorExpr
	; SelectorExpr
	%8 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%9 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %8)
	%10 = bitcast %runtime.Type_Info** %2 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %2
	store %runtime.Type_Info* %9, %runtime.Type_Info** %2
	%12 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%13 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %12, i64 0
	%14 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %13, i64 0, i32 3
	%15 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, align 8
	; cast - union_cast
	%16 = bitcast {%runtime.Type_Info_Rune, i8}* %3 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 1) noinline
	store {%runtime.Type_Info_Rune, i8} zeroinitializer, {%runtime.Type_Info_Rune, i8}* %3
	%18 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, i64 0, i32 2 ; UnionTagPtr
	%19 = load i8, i8* %18, align 1
	%20 = icmp eq i8 %19, 3
	br i1 %20, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%21 = getelementptr inbounds {%runtime.Type_Info_Rune, i8}, {%runtime.Type_Info_Rune, i8}* %3, i64 0, i32 0
	%22 = getelementptr inbounds {%runtime.Type_Info_Rune, i8}, {%runtime.Type_Info_Rune, i8}* %3, i64 0, i32 1
	%23 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %14 to %runtime.Type_Info_Rune*
	%24 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %23, align 1
	store %runtime.Type_Info_Rune %24, %runtime.Type_Info_Rune* %21
	store i8 1, i8* %22
	br label %union_cast.end-4

union_cast.end-4:
	%25 = load {%runtime.Type_Info_Rune, i8}, {%runtime.Type_Info_Rune, i8}* %3, align 1
	%26 = extractvalue {%runtime.Type_Info_Rune, i8} %25, 0
	%27 = extractvalue {%runtime.Type_Info_Rune, i8} %25, 1
	store i8 %27, i8* %1
	; ReturnStmt
	%28 = load i8, i8* %1, align 1
	ret i8 %28
}

define i8 @types.is_any(%runtime.Type_Info* %info, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca {%runtime.Type_Info_Any, i8}, align 16
	store %runtime.Type_Info* %info, %runtime.Type_Info** %0
	; IfStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%5 = icmp eq %runtime.Type_Info* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ok
	; SelectorExpr
	; SelectorExpr
	%8 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%9 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %8)
	%10 = bitcast %runtime.Type_Info** %2 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %2
	store %runtime.Type_Info* %9, %runtime.Type_Info** %2
	%12 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%13 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %12, i64 0
	%14 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %13, i64 0, i32 3
	%15 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, align 8
	; cast - union_cast
	%16 = bitcast {%runtime.Type_Info_Any, i8}* %3 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 1) noinline
	store {%runtime.Type_Info_Any, i8} zeroinitializer, {%runtime.Type_Info_Any, i8}* %3
	%18 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, i64 0, i32 2 ; UnionTagPtr
	%19 = load i8, i8* %18, align 1
	%20 = icmp eq i8 %19, 8
	br i1 %20, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%21 = getelementptr inbounds {%runtime.Type_Info_Any, i8}, {%runtime.Type_Info_Any, i8}* %3, i64 0, i32 0
	%22 = getelementptr inbounds {%runtime.Type_Info_Any, i8}, {%runtime.Type_Info_Any, i8}* %3, i64 0, i32 1
	%23 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %14 to %runtime.Type_Info_Any*
	%24 = load %runtime.Type_Info_Any, %runtime.Type_Info_Any* %23, align 1
	store %runtime.Type_Info_Any %24, %runtime.Type_Info_Any* %21
	store i8 1, i8* %22
	br label %union_cast.end-4

union_cast.end-4:
	%25 = load {%runtime.Type_Info_Any, i8}, {%runtime.Type_Info_Any, i8}* %3, align 1
	%26 = extractvalue {%runtime.Type_Info_Any, i8} %25, 0
	%27 = extractvalue {%runtime.Type_Info_Any, i8} %25, 1
	store i8 %27, i8* %1
	; ReturnStmt
	%28 = load i8, i8* %1, align 1
	ret i8 %28
}

define i8 @types.is_string(%runtime.Type_Info* %info, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca {%runtime.Type_Info_String, i8}, align 16
	store %runtime.Type_Info* %info, %runtime.Type_Info** %0
	; IfStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%5 = icmp eq %runtime.Type_Info* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ok
	; SelectorExpr
	; SelectorExpr
	%8 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%9 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %8)
	%10 = bitcast %runtime.Type_Info** %2 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %2
	store %runtime.Type_Info* %9, %runtime.Type_Info** %2
	%12 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%13 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %12, i64 0
	%14 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %13, i64 0, i32 3
	%15 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, align 8
	; cast - union_cast
	%16 = bitcast {%runtime.Type_Info_String, i8}* %3 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 2) noinline
	store {%runtime.Type_Info_String, i8} zeroinitializer, {%runtime.Type_Info_String, i8}* %3
	%18 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, i64 0, i32 2 ; UnionTagPtr
	%19 = load i8, i8* %18, align 1
	%20 = icmp eq i8 %19, 6
	br i1 %20, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%21 = getelementptr inbounds {%runtime.Type_Info_String, i8}, {%runtime.Type_Info_String, i8}* %3, i64 0, i32 0
	%22 = getelementptr inbounds {%runtime.Type_Info_String, i8}, {%runtime.Type_Info_String, i8}* %3, i64 0, i32 1
	%23 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %14 to %runtime.Type_Info_String*
	%24 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %23, align 1
	store %runtime.Type_Info_String %24, %runtime.Type_Info_String* %21
	store i8 1, i8* %22
	br label %union_cast.end-4

union_cast.end-4:
	%25 = load {%runtime.Type_Info_String, i8}, {%runtime.Type_Info_String, i8}* %3, align 1
	%26 = extractvalue {%runtime.Type_Info_String, i8} %25, 0
	%27 = extractvalue {%runtime.Type_Info_String, i8} %25, 1
	store i8 %27, i8* %1
	; ReturnStmt
	%28 = load i8, i8* %1, align 1
	ret i8 %28
}

define i8 @types.is_enum(%runtime.Type_Info* %info, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca {%runtime.Type_Info_Enum, i8}, align 16
	store %runtime.Type_Info* %info, %runtime.Type_Info** %0
	; IfStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%5 = icmp eq %runtime.Type_Info* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ok
	; SelectorExpr
	; SelectorExpr
	%8 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%9 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %8)
	%10 = bitcast %runtime.Type_Info** %2 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %2
	store %runtime.Type_Info* %9, %runtime.Type_Info** %2
	%12 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%13 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %12, i64 0
	%14 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %13, i64 0, i32 3
	%15 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, align 8
	; cast - union_cast
	%16 = bitcast {%runtime.Type_Info_Enum, i8}* %3 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 48) noinline
	store {%runtime.Type_Info_Enum, i8} zeroinitializer, {%runtime.Type_Info_Enum, i8}* %3
	%18 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, i64 0, i32 2 ; UnionTagPtr
	%19 = load i8, i8* %18, align 1
	%20 = icmp eq i8 %19, 18
	br i1 %20, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%21 = getelementptr inbounds {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %3, i64 0, i32 0
	%22 = getelementptr inbounds {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %3, i64 0, i32 1
	%23 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %14 to %runtime.Type_Info_Enum*
	%24 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %23, align 8
	store %runtime.Type_Info_Enum %24, %runtime.Type_Info_Enum* %21
	store i8 1, i8* %22
	br label %union_cast.end-4

union_cast.end-4:
	%25 = load {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %3, align 8
	%26 = extractvalue {%runtime.Type_Info_Enum, i8} %25, 0
	%27 = extractvalue {%runtime.Type_Info_Enum, i8} %25, 1
	store i8 %27, i8* %1
	; ReturnStmt
	%28 = load i8, i8* %1, align 1
	ret i8 %28
}

define void @workbench._update_catalog(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %workbench.Catalog_Item*, align 16
	%3 = alloca i64, align 16
	%4 = alloca {i8*, i64}, align 16
	%5 = alloca i8, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca %mem.Allocator, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	%9 = alloca %..string, align 16
	%10 = alloca i64, align 16
	%11 = alloca %workbench.Subscriber, align 16
	%12 = alloca %..string, align 16
	%13 = alloca %..any, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [2 x %..any], align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca %runtime.Source_Code_Location, align 16
	; RangeStmt
	; i
	%19 = bitcast i64* %0 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 8) noinline
	store i64 zeroinitializer, i64* %0
	%21 = getelementptr inbounds {%workbench.Catalog_Item**, i64, i64, %mem.Allocator}, {%workbench.Catalog_Item**, i64, i64, %mem.Allocator}* @workbench.all_items, i64 0, i32 1
	%22 = bitcast i64* %1 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 8) noinline
	store i64 zeroinitializer, i64* %1
	store i64 -1, i64* %1
	br label %for.index.loop-1

for.index.loop-1:
	%24 = load i64, i64* %1, align 8
	%25 = add i64 %24, 1
	store i64 %25, i64* %1
	%26 = load i64, i64* %21, align 8
	%27 = icmp slt i64 %25, %26
	br i1 %27, label %for.index.body-2, label %for.index.done-8

for.index.body-2:
	%28 = load i64, i64* %1, align 8
	store i64 %28, i64* %0
	; item
	; IndexExpr
	%29 = load {%workbench.Catalog_Item**, i64, i64, %mem.Allocator}, {%workbench.Catalog_Item**, i64, i64, %mem.Allocator}* @workbench.all_items, align 8
	%30 = extractvalue {%workbench.Catalog_Item**, i64, i64, %mem.Allocator} %29, 0
	%31 = extractvalue {%workbench.Catalog_Item**, i64, i64, %mem.Allocator} %29, 1
	%32 = load i64, i64* %0, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$601, i64 0, i32 0), i64 65}, i64 50, i64 21, i64 %32, i64 %31)
	%33 = getelementptr inbounds %workbench.Catalog_Item*, %workbench.Catalog_Item** %30, i64 %32
	%34 = load %workbench.Catalog_Item*, %workbench.Catalog_Item** %33, align 8
	store %workbench.Catalog_Item* %34, %workbench.Catalog_Item** %2
	; new_write_time
	; SelectorExpr
	; SelectorExpr
	%35 = load %workbench.Catalog_Item*, %workbench.Catalog_Item** %2, align 8
	%36 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %35, i64 0
	%37 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %36, i64 0, i32 0
	%38 = load %..string, %..string* %37, align 8
	%39 = call i64 @os.last_write_time_by_name(%..string %38, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %39, i64* %3
	; IfStmt
	%40 = load i64, i64* %3, align 8
	; SelectorExpr
	%41 = load %workbench.Catalog_Item*, %workbench.Catalog_Item** %2, align 8
	%42 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %41, i64 0
	%43 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %42, i64 0, i32 2
	%44 = load i64, i64* %43, align 8
	%45 = icmp ugt i64 %40, %44
	%46 = zext i1 %45 to i8
	%47 = trunc i8 %46 to i1
	br i1 %47, label %if.then-3, label %if.done-7

if.then-3:
	; data
	; ok
	; SelectorExpr
	; SelectorExpr
	%48 = load %workbench.Catalog_Item*, %workbench.Catalog_Item** %2, align 8
	%49 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %48, i64 0
	%50 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %49, i64 0, i32 0
	%51 = load %..string, %..string* %50, align 8
	%52 = call {{i8*, i64}, i8} @os.read_entire_file(%..string %51, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%53 = extractvalue {{i8*, i64}, i8} %52, 0
	%54 = extractvalue {{i8*, i64}, i8} %52, 1
	store {i8*, i64} %53, {i8*, i64}* %4
	store i8 %54, i8* %5
	%55 = load i8, i8* %5, align 1
	%56 = trunc i8 %55 to i1
	%57 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$602, i64 0, i32 0), i64 65}, i64 55, i64 4, %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$603, i64 0, i32 0), i64 15}}, %runtime.Source_Code_Location* %6
	%59 = call i8 @runtime.assert(i1 %56, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; SelectorExpr
	%60 = load %workbench.Catalog_Item*, %workbench.Catalog_Item** %2, align 8
	%61 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %60, i64 0
	%62 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %61, i64 0, i32 1
	%63 = load %..string, %..string* %62, align 8
	; SelectorExpr
	%64 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%65 = load %mem.Allocator, %mem.Allocator* %64, align 8
	%66 = bitcast %mem.Allocator* %7 to %..rawptr
	%67 = call %..rawptr @mem.zero(%..rawptr %66, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %7
	store %mem.Allocator %65, %mem.Allocator* %7
	%68 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%69 = call %..rawptr @mem.zero(%..rawptr %68, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$604, i64 0, i32 0), i64 65}, i64 57, i64 4, %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$605, i64 0, i32 0), i64 15}}, %runtime.Source_Code_Location* %8
	call void @mem.delete_string(%..string %63, %mem.Allocator* %7, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	; SelectorExpr
	%70 = load %workbench.Catalog_Item*, %workbench.Catalog_Item** %2, align 8
	%71 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %70, i64 0
	%72 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %71, i64 0, i32 1
	%73 = load {i8*, i64}, {i8*, i64}* %4, align 8
	%74 = extractvalue {i8*, i64} %73, 0
	%75 = extractvalue {i8*, i64} %73, 1
	%76 = bitcast %..string* %9 to %..rawptr
	%77 = call %..rawptr @mem.zero(%..rawptr %76, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	%78 = getelementptr inbounds %..string, %..string* %9, i64 0, i32 0
	store i8* %74, i8** %78
	%79 = getelementptr inbounds %..string, %..string* %9, i64 0, i32 1
	store i64 %75, i64* %79
	%80 = load %..string, %..string* %9, align 8
	store %..string %80, %..string* %72
	; AssignStmt
	; SelectorExpr
	%81 = load %workbench.Catalog_Item*, %workbench.Catalog_Item** %2, align 8
	%82 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %81, i64 0
	%83 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %82, i64 0, i32 2
	%84 = load i64, i64* %3, align 8
	store i64 %84, i64* %83
	; sub_idx
	; SelectorExpr
	%85 = load %workbench.Catalog_Item*, %workbench.Catalog_Item** %2, align 8
	%86 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %85, i64 0
	%87 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %86, i64 0, i32 3
	%88 = load {%workbench.Subscriber*, i64, i64, %mem.Allocator}, {%workbench.Subscriber*, i64, i64, %mem.Allocator}* %87, align 8
	%89 = extractvalue {%workbench.Subscriber*, i64, i64, %mem.Allocator} %88, 1
	%90 = sub i64 %89, 1
	store i64 %90, i64* %10
	; ForStmt
	br label %for.loop-4

for.loop-4:
	%91 = load i64, i64* %10, align 8
	%92 = icmp sge i64 %91, 0
	%93 = zext i1 %92 to i8
	%94 = trunc i8 %93 to i1
	br i1 %94, label %for.body-5, label %for.done-6

for.body-5:
	; DeferStmt
	; sub
	; IndexExpr
	; SelectorExpr
	%95 = load %workbench.Catalog_Item*, %workbench.Catalog_Item** %2, align 8
	%96 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %95, i64 0
	%97 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %96, i64 0, i32 3
	%98 = load {%workbench.Subscriber*, i64, i64, %mem.Allocator}, {%workbench.Subscriber*, i64, i64, %mem.Allocator}* %97, align 8
	%99 = extractvalue {%workbench.Subscriber*, i64, i64, %mem.Allocator} %98, 0
	%100 = extractvalue {%workbench.Subscriber*, i64, i64, %mem.Allocator} %98, 1
	%101 = load i64, i64* %10, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$606, i64 0, i32 0), i64 65}, i64 65, i64 29, i64 %101, i64 %100)
	%102 = getelementptr inbounds %workbench.Subscriber, %workbench.Subscriber* %99, i64 %101
	%103 = load %workbench.Subscriber, %workbench.Subscriber* %102, align 8
	store %workbench.Subscriber %103, %workbench.Subscriber* %11
	; SelectorExpr
	%104 = getelementptr inbounds %workbench.Subscriber, %workbench.Subscriber* %11, i64 0, i32 1
	%105 = load void (%..rawptr, %..string, %runtime.Context*)*, void (%..rawptr, %..string, %runtime.Context*)** %104, align 8
	; SelectorExpr
	%106 = getelementptr inbounds %workbench.Subscriber, %workbench.Subscriber* %11, i64 0, i32 0
	%107 = load %..rawptr, %..rawptr* %106, align 8
	; SelectorExpr
	%108 = load %workbench.Catalog_Item*, %workbench.Catalog_Item** %2, align 8
	%109 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %108, i64 0
	%110 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %109, i64 0, i32 1
	%111 = load %..string, %..string* %110, align 8
	call void %105(%..rawptr %107, %..string %111, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; defer
	; AssignStmt
	%112 = load i64, i64* %10, align 8
	%113 = sub i64 %112, 1
	store i64 %113, i64* %10
	br label %for.loop-4

for.done-6:
	; SelectorExpr
	%114 = load %workbench.Catalog_Item*, %workbench.Catalog_Item** %2, align 8
	%115 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %114, i64 0
	%116 = getelementptr inbounds %workbench.Catalog_Item, %workbench.Catalog_Item* %115, i64 0, i32 0
	%117 = load %..string, %..string* %116, align 8
	%118 = bitcast %..string* %12 to %..rawptr
	%119 = call %..rawptr @mem.zero(%..rawptr %118, i64 16) noinline
	store %..string zeroinitializer, %..string* %12
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$607, i64 0, i32 0), i64 17}, %..string* %12
	%120 = load %..string, %..string* %12, align 8
	%121 = bitcast %..any* %13 to %..rawptr
	%122 = call %..rawptr @mem.zero(%..rawptr %121, i64 16) noinline
	store %..any zeroinitializer, %..any* %13
	%123 = bitcast %..string* %12 to %..rawptr
	%124 = getelementptr inbounds %..any, %..any* %13, i64 0, i32 0
	store %..rawptr %123, %..rawptr* %124
	%125 = getelementptr inbounds %..any, %..any* %13, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %125
	%126 = load %..any, %..any* %13, align 8
	%127 = bitcast %..any* %14 to %..rawptr
	%128 = call %..rawptr @mem.zero(%..rawptr %127, i64 16) noinline
	store %..any zeroinitializer, %..any* %14
	%129 = bitcast %..string* %116 to %..rawptr
	%130 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 0
	store %..rawptr %129, %..rawptr* %130
	%131 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %131
	%132 = load %..any, %..any* %14, align 8
	; variadic call argument generation
	%133 = bitcast {%..any*, i64}* %15 to %..rawptr
	%134 = call %..rawptr @mem.zero(%..rawptr %133, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	%135 = bitcast [2 x %..any]* %16 to %..rawptr
	%136 = call %..rawptr @mem.zero(%..rawptr %135, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %16
	%137 = getelementptr inbounds [2 x %..any], [2 x %..any]* %16, i64 0, i32 0
	store %..any %126, %..any* %137
	%138 = getelementptr inbounds [2 x %..any], [2 x %..any]* %16, i64 0, i32 1
	store %..any %132, %..any* %138
	%139 = getelementptr inbounds [2 x %..any], [2 x %..any]* %16, i64 0, i32 0
	%140 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 0
	store %..any* %139, %..any** %140
	%141 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 1
	store i64 2, i64* %141
	%142 = load {%..any*, i64}, {%..any*, i64}* %15, align 8
	%143 = bitcast {%..any*, i64}* %17 to %..rawptr
	%144 = call %..rawptr @mem.zero(%..rawptr %143, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	store {%..any*, i64} %142, {%..any*, i64}* %17
	%145 = bitcast %runtime.Source_Code_Location* %18 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %18
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$608, i64 0, i32 0), i64 65}, i64 69, i64 4, %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$609, i64 0, i32 0), i64 15}}, %runtime.Source_Code_Location* %18
	call void @workbench.logln({%..any*, i64}* %17, %runtime.Source_Code_Location* %18, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-7

if.done-7:
	br label %for.index.loop-1

for.index.done-8:
	ret void
}

define {%workbench.Key_Press*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-6385(i64 %len, i64 %cap, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %..rawptr, align 16
	%4 = alloca %mem.Allocator, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca %mem.Raw_Dynamic_Array, align 16
	%7 = alloca %mem.Raw_Dynamic_Array, align 16
	store i64 %len, i64* %0
	store i64 %cap, i64* %1
	%8 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%10 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%11 = load i64, i64* %0, align 8
	%12 = load i64, i64* %1, align 8
	%13 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %10, %runtime.Source_Code_Location* %2
	call void @runtime.make_dynamic_array_error_loc(%runtime.Source_Code_Location* %2, i64 %11, i64 %12)
	; data
	%14 = load i64, i64* %1, align 8
	%15 = mul i64 8, %14
	%16 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%17 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%18 = bitcast %mem.Allocator* %4 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %4
	store %mem.Allocator %16, %mem.Allocator* %4
	%19 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location %17, %runtime.Source_Code_Location* %5
	%20 = call %..rawptr @mem.alloc(i64 %15, i64 4, %mem.Allocator* %4, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %20, %..rawptr* %3
	; s
	; CompoundLit
	%21 = bitcast %mem.Raw_Dynamic_Array* %7 to %..rawptr
	store %mem.Raw_Dynamic_Array zeroinitializer, %mem.Raw_Dynamic_Array* %7
	store %mem.Raw_Dynamic_Array {%..rawptr zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %mem.Allocator zeroinitializer}, %mem.Raw_Dynamic_Array* %7
	%22 = load %..rawptr, %..rawptr* %3, align 8
	%23 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 0
	store %..rawptr %22, %..rawptr* %23
	%24 = load i64, i64* %0, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 1
	store i64 %24, i64* %25
	%26 = load i64, i64* %1, align 8
	%27 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 2
	store i64 %26, i64* %27
	%28 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%29 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 3
	store %mem.Allocator %28, %mem.Allocator* %29
	%30 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, align 8
	store %mem.Raw_Dynamic_Array %30, %mem.Raw_Dynamic_Array* %6
	; ReturnStmt
	%31 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %6, align 8
	%32 = bitcast %mem.Raw_Dynamic_Array* %6 to {%workbench.Key_Press*, i64, i64, %mem.Allocator}*
	%33 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %32, align 8
	ret {%workbench.Key_Press*, i64, i64, %mem.Allocator} %33
}

define i8* @mem.ptr_offset-13926(i8* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca i8*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store i8* %ptr, i8** %0
	store i64 %n, i64* %1
	; new
	%3 = load i8*, i8** %0, align 8
	%4 = ptrtoint i8* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 1, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to i8*
	ret i8* %11
}

define i8* @mem.raw_string_data-14018(%..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %mem.Raw_String*, align 16
	store %..string %s, %..string* %0
	; ReturnStmt
	; SelectorExpr
	%2 = bitcast %..string* %0 to %mem.Raw_String*
	%3 = bitcast %mem.Raw_String** %1 to %..rawptr
	store %mem.Raw_String* zeroinitializer, %mem.Raw_String** %1
	store %mem.Raw_String* %2, %mem.Raw_String** %1
	%4 = load %mem.Raw_String*, %mem.Raw_String** %1, align 8
	%5 = getelementptr inbounds %mem.Raw_String, %mem.Raw_String* %4, i64 0
	%6 = getelementptr inbounds %mem.Raw_String, %mem.Raw_String* %5, i64 0, i32 0
	%7 = load i8*, i8** %6, align 8
	ret i8* %7
}

define i8 @runtime.__slice_resize-14067({i64*, i64}* %array_, i64 %new_count, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i64*, i64}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Slice*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %..rawptr, align 16
	%7 = alloca %mem.Allocator, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {i64*, i64}* %array_, {i64*, i64}** %0
	store i64 %new_count, i64* %1
	%9 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%10 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; array
	%11 = load {i64*, i64}*, {i64*, i64}** %0, align 8
	%12 = bitcast {i64*, i64}* %11 to %mem.Raw_Slice*
	store %mem.Raw_Slice* %12, %mem.Raw_Slice** %2
	; IfStmt
	%13 = load i64, i64* %1, align 8
	; SelectorExpr
	%14 = load %mem.Raw_Slice*, %mem.Raw_Slice** %2, align 8
	%15 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %14, i64 0
	%16 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %15, i64 0, i32 1
	%17 = load i64, i64* %16, align 8
	%18 = icmp slt i64 %13, %17
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 1

if.done-2:
	; SelectorExpr
	%21 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 0
	%22 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %21, align 8
	%23 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %22, zeroinitializer
	%24 = zext i1 %23 to i8
	%25 = trunc i8 %24 to i1
	%26 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$60a, i64 0, i32 0), i64 58}, i64 820, i64 2, %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$60b, i64 0, i32 0), i64 14}}, %runtime.Source_Code_Location* %3
	%28 = call i8 @runtime.assert(i1 %25, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%29 = load %mem.Raw_Slice*, %mem.Raw_Slice** %2, align 8
	%30 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %29, i64 0
	%31 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %30, i64 0, i32 1
	%32 = load i64, i64* %31, align 8
	%33 = mul i64 %32, 16
	store i64 %33, i64* %4
	; new_size
	%34 = load i64, i64* %1, align 8
	%35 = mul i64 %34, 16
	store i64 %35, i64* %5
	; new_data
	; SelectorExpr
	; SelectorExpr
	%36 = load %mem.Raw_Slice*, %mem.Raw_Slice** %2, align 8
	%37 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %36, i64 0
	%38 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %37, i64 0, i32 0
	%39 = load %..rawptr, %..rawptr* %38, align 8
	%40 = load i64, i64* %4, align 8
	%41 = load i64, i64* %5, align 8
	%42 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%43 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%44 = bitcast %mem.Allocator* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %7
	store %mem.Allocator %42, %mem.Allocator* %7
	%46 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%47 = call %..rawptr @mem.zero(%..rawptr %46, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %43, %runtime.Source_Code_Location* %8
	%48 = call %..rawptr @mem.resize(%..rawptr %39, i64 %40, i64 %41, i64 8, %mem.Allocator* %7, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %48, %..rawptr* %6
	; IfStmt
	%49 = load %..rawptr, %..rawptr* %6, align 8
	%50 = icmp eq %..rawptr %49, zeroinitializer
	%51 = zext i1 %50 to i8
	%52 = trunc i8 %51 to i1
	br i1 %52, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 0

if.done-4:
	; AssignStmt
	; SelectorExpr
	%53 = load %mem.Raw_Slice*, %mem.Raw_Slice** %2, align 8
	%54 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %53, i64 0
	%55 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %54, i64 0, i32 0
	%56 = load %..rawptr, %..rawptr* %6, align 8
	store %..rawptr %56, %..rawptr* %55
	; AssignStmt
	; SelectorExpr
	%57 = load %mem.Raw_Slice*, %mem.Raw_Slice** %2, align 8
	%58 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %57, i64 0
	%59 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %58, i64 0, i32 1
	%60 = load i64, i64* %1, align 8
	store i64 %60, i64* %59
	; ReturnStmt
	ret i8 1
}

define void @mem.delete_slice-14104({i64*, i64}* %array, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i64*, i64}, align 16
	%1 = alloca %mem.Allocator, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = load {i64*, i64}, {i64*, i64}* %array, align 8
	%4 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%5 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%6 = load {i64*, i64}, {i64*, i64}* %array, align 8
	%7 = bitcast {i64*, i64}* %0 to %..rawptr
	store {i64*, i64} zeroinitializer, {i64*, i64}* %0
	store {i64*, i64} %6, {i64*, i64}* %0
	%8 = call i64* @mem.raw_slice_data-20010({i64*, i64}* %0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%10 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%11 = bitcast i64* %8 to %..rawptr
	%12 = bitcast %mem.Allocator* %1 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %1
	store %mem.Allocator %9, %mem.Allocator* %1
	%13 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %10, %runtime.Source_Code_Location* %2
	call void @mem.free(%..rawptr %11, %mem.Allocator* %1, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define %main.Transform* @main.add_component-14177(i64 %entity, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %main.Transform, align 16
	%2 = alloca %main.Transform, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %main.Transform*, align 16
	%5 = alloca %..string, align 16
	%6 = alloca %..any, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %runtime.Type_Info*, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %runtime.Source_Code_Location, align 16
	store i64 %entity, i64* %0
	; _t
	%15 = bitcast %main.Transform* %1 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 24) noinline
	store %main.Transform zeroinitializer, %main.Transform* %1
	; AssignStmt
	; SelectorExpr
	%17 = getelementptr inbounds %main.Transform, %main.Transform* %1, i64 0, i32 0
	%18 = load i64, i64* %0, align 8
	store i64 %18, i64* %17
	%19 = load %main.Transform, %main.Transform* %1, align 8
	%20 = bitcast %main.Transform* %2 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 24) noinline
	store %main.Transform zeroinitializer, %main.Transform* %2
	store %main.Transform %19, %main.Transform* %2
	%22 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$60c, i64 0, i32 0), i64 74}, i64 15, i64 3, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$60d, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %3
	%24 = call i64 @runtime.append_elem-20032({%main.Transform*, i64, i64, %mem.Allocator}* @main.all_transforms, %main.Transform* %2, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; t
	; IndexExpr
	%25 = load {%main.Transform*, i64, i64, %mem.Allocator}, {%main.Transform*, i64, i64, %mem.Allocator}* @main.all_transforms, align 8
	%26 = extractvalue {%main.Transform*, i64, i64, %mem.Allocator} %25, 0
	%27 = extractvalue {%main.Transform*, i64, i64, %mem.Allocator} %25, 1
	%28 = load {%main.Transform*, i64, i64, %mem.Allocator}, {%main.Transform*, i64, i64, %mem.Allocator}* @main.all_transforms, align 8
	%29 = extractvalue {%main.Transform*, i64, i64, %mem.Allocator} %28, 1
	%30 = sub i64 %29, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$60e, i64 0, i32 0), i64 74}, i64 16, i64 24, i64 %30, i64 %27)
	%31 = getelementptr inbounds %main.Transform, %main.Transform* %26, i64 %30
	store %main.Transform* %31, %main.Transform** %4
	; ReturnStmt
	%32 = load %main.Transform*, %main.Transform** %4, align 8
	ret %main.Transform* %32
}

define %main.Mesh_Renderer* @main.add_component-14181(i64 %entity, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %main.Mesh_Renderer, align 16
	%2 = alloca %main.Mesh_Renderer, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %main.Mesh_Renderer*, align 16
	%5 = alloca %..string, align 16
	%6 = alloca %..any, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %runtime.Type_Info*, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %runtime.Source_Code_Location, align 16
	store i64 %entity, i64* %0
	; _t
	%15 = bitcast %main.Mesh_Renderer* %1 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 48) noinline
	store %main.Mesh_Renderer zeroinitializer, %main.Mesh_Renderer* %1
	; AssignStmt
	; SelectorExpr
	%17 = getelementptr inbounds %main.Mesh_Renderer, %main.Mesh_Renderer* %1, i64 0, i32 0
	%18 = load i64, i64* %0, align 8
	store i64 %18, i64* %17
	%19 = load %main.Mesh_Renderer, %main.Mesh_Renderer* %1, align 8
	%20 = bitcast %main.Mesh_Renderer* %2 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 48) noinline
	store %main.Mesh_Renderer zeroinitializer, %main.Mesh_Renderer* %2
	store %main.Mesh_Renderer %19, %main.Mesh_Renderer* %2
	%22 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$60f, i64 0, i32 0), i64 74}, i64 34, i64 3, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$610, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %3
	%24 = call i64 @runtime.append_elem-20066({%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* @main.all_mesh_renderers, %main.Mesh_Renderer* %2, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; t
	; IndexExpr
	%25 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* @main.all_mesh_renderers, align 8
	%26 = extractvalue {%main.Mesh_Renderer*, i64, i64, %mem.Allocator} %25, 0
	%27 = extractvalue {%main.Mesh_Renderer*, i64, i64, %mem.Allocator} %25, 1
	%28 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* @main.all_mesh_renderers, align 8
	%29 = extractvalue {%main.Mesh_Renderer*, i64, i64, %mem.Allocator} %28, 1
	%30 = sub i64 %29, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$611, i64 0, i32 0), i64 74}, i64 35, i64 28, i64 %30, i64 %27)
	%31 = getelementptr inbounds %main.Mesh_Renderer, %main.Mesh_Renderer* %26, i64 %30
	store %main.Mesh_Renderer* %31, %main.Mesh_Renderer** %4
	; ReturnStmt
	%32 = load %main.Mesh_Renderer*, %main.Mesh_Renderer** %4, align 8
	ret %main.Mesh_Renderer* %32
}

define %main.Sprite_Renderer* @main.add_component-14185(i64 %entity, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %main.Sprite_Renderer, align 16
	%2 = alloca %main.Sprite_Renderer, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %main.Sprite_Renderer*, align 16
	%5 = alloca %..string, align 16
	%6 = alloca %..any, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %runtime.Type_Info*, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %runtime.Source_Code_Location, align 16
	store i64 %entity, i64* %0
	; _t
	%15 = bitcast %main.Sprite_Renderer* %1 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 24) noinline
	store %main.Sprite_Renderer zeroinitializer, %main.Sprite_Renderer* %1
	; AssignStmt
	; SelectorExpr
	%17 = getelementptr inbounds %main.Sprite_Renderer, %main.Sprite_Renderer* %1, i64 0, i32 0
	%18 = load i64, i64* %0, align 8
	store i64 %18, i64* %17
	%19 = load %main.Sprite_Renderer, %main.Sprite_Renderer* %1, align 8
	%20 = bitcast %main.Sprite_Renderer* %2 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 24) noinline
	store %main.Sprite_Renderer zeroinitializer, %main.Sprite_Renderer* %2
	store %main.Sprite_Renderer %19, %main.Sprite_Renderer* %2
	%22 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$612, i64 0, i32 0), i64 74}, i64 21, i64 3, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$613, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %3
	%24 = call i64 @runtime.append_elem-20100({%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* @main.all_sprite_renderers, %main.Sprite_Renderer* %2, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; t
	; IndexExpr
	%25 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* @main.all_sprite_renderers, align 8
	%26 = extractvalue {%main.Sprite_Renderer*, i64, i64, %mem.Allocator} %25, 0
	%27 = extractvalue {%main.Sprite_Renderer*, i64, i64, %mem.Allocator} %25, 1
	%28 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* @main.all_sprite_renderers, align 8
	%29 = extractvalue {%main.Sprite_Renderer*, i64, i64, %mem.Allocator} %28, 1
	%30 = sub i64 %29, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$614, i64 0, i32 0), i64 74}, i64 22, i64 30, i64 %30, i64 %27)
	%31 = getelementptr inbounds %main.Sprite_Renderer, %main.Sprite_Renderer* %26, i64 %30
	store %main.Sprite_Renderer* %31, %main.Sprite_Renderer** %4
	; ReturnStmt
	%32 = load %main.Sprite_Renderer*, %main.Sprite_Renderer** %4, align 8
	ret %main.Sprite_Renderer* %32
}

define %main.Spinner_Component* @main.add_component-14189(i64 %entity, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %main.Spinner_Component, align 16
	%2 = alloca %main.Spinner_Component, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %main.Spinner_Component*, align 16
	%5 = alloca %..string, align 16
	%6 = alloca %..any, align 16
	%7 = alloca %..any, align 16
	%8 = alloca %runtime.Type_Info*, align 16
	%9 = alloca %..string, align 16
	%10 = alloca %..any, align 16
	%11 = alloca {%..any*, i64}, align 16
	%12 = alloca [3 x %..any], align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca %runtime.Source_Code_Location, align 16
	store i64 %entity, i64* %0
	; _t
	%15 = bitcast %main.Spinner_Component* %1 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 16) noinline
	store %main.Spinner_Component zeroinitializer, %main.Spinner_Component* %1
	; AssignStmt
	; SelectorExpr
	%17 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %1, i64 0, i32 0
	%18 = load i64, i64* %0, align 8
	store i64 %18, i64* %17
	%19 = load %main.Spinner_Component, %main.Spinner_Component* %1, align 8
	%20 = bitcast %main.Spinner_Component* %2 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 16) noinline
	store %main.Spinner_Component zeroinitializer, %main.Spinner_Component* %2
	store %main.Spinner_Component %19, %main.Spinner_Component* %2
	%22 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$615, i64 0, i32 0), i64 74}, i64 27, i64 3, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$616, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %3
	%24 = call i64 @runtime.append_elem-20134({%main.Spinner_Component*, i64, i64, %mem.Allocator}* @main.all_spinners, %main.Spinner_Component* %2, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; t
	; IndexExpr
	%25 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}, {%main.Spinner_Component*, i64, i64, %mem.Allocator}* @main.all_spinners, align 8
	%26 = extractvalue {%main.Spinner_Component*, i64, i64, %mem.Allocator} %25, 0
	%27 = extractvalue {%main.Spinner_Component*, i64, i64, %mem.Allocator} %25, 1
	%28 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}, {%main.Spinner_Component*, i64, i64, %mem.Allocator}* @main.all_spinners, align 8
	%29 = extractvalue {%main.Spinner_Component*, i64, i64, %mem.Allocator} %28, 1
	%30 = sub i64 %29, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$617, i64 0, i32 0), i64 74}, i64 28, i64 22, i64 %30, i64 %27)
	%31 = getelementptr inbounds %main.Spinner_Component, %main.Spinner_Component* %26, i64 %30
	store %main.Spinner_Component* %31, %main.Spinner_Component** %4
	%32 = load %main.Spinner_Component*, %main.Spinner_Component** %4, align 8
	call void @main.init_spinner(%main.Spinner_Component* %32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%33 = load %main.Spinner_Component*, %main.Spinner_Component** %4, align 8
	ret %main.Spinner_Component* %33
}

define %main.Mesh_Renderer* @main.get_component-14194(i64 %entity, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %main.Mesh_Renderer*, align 16
	%4 = alloca %..string, align 16
	%5 = alloca %..any, align 16
	%6 = alloca %..any, align 16
	%7 = alloca %runtime.Type_Info*, align 16
	%8 = alloca %..string, align 16
	%9 = alloca %..any, align 16
	%10 = alloca {%..any*, i64}, align 16
	%11 = alloca [3 x %..any], align 16
	%12 = alloca {%..any*, i64}, align 16
	%13 = alloca %runtime.Source_Code_Location, align 16
	store i64 %entity, i64* %0
	; RangeStmt
	; i
	%14 = bitcast i64* %1 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 8) noinline
	store i64 zeroinitializer, i64* %1
	%16 = getelementptr inbounds {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* @main.all_mesh_renderers, i64 0, i32 1
	%17 = bitcast i64* %2 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	store i64 -1, i64* %2
	br label %for.index.loop-1

for.index.loop-1:
	%19 = load i64, i64* %2, align 8
	%20 = add i64 %19, 1
	store i64 %20, i64* %2
	%21 = load i64, i64* %16, align 8
	%22 = icmp slt i64 %20, %21
	br i1 %22, label %for.index.body-2, label %for.index.done-5

for.index.body-2:
	%23 = load i64, i64* %2, align 8
	store i64 %23, i64* %1
	; c
	; IndexExpr
	%24 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* @main.all_mesh_renderers, align 8
	%25 = extractvalue {%main.Mesh_Renderer*, i64, i64, %mem.Allocator} %24, 0
	%26 = extractvalue {%main.Mesh_Renderer*, i64, i64, %mem.Allocator} %24, 1
	%27 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$618, i64 0, i32 0), i64 74}, i64 59, i64 29, i64 %27, i64 %26)
	%28 = getelementptr inbounds %main.Mesh_Renderer, %main.Mesh_Renderer* %25, i64 %27
	store %main.Mesh_Renderer* %28, %main.Mesh_Renderer** %3
	; IfStmt
	; SelectorExpr
	%29 = load %main.Mesh_Renderer*, %main.Mesh_Renderer** %3, align 8
	%30 = getelementptr inbounds %main.Mesh_Renderer, %main.Mesh_Renderer* %29, i64 0
	%31 = getelementptr inbounds %main.Mesh_Renderer, %main.Mesh_Renderer* %30, i64 0, i32 0
	%32 = load i64, i64* %31, align 8
	%33 = load i64, i64* %0, align 8
	%34 = icmp eq i64 %32, %33
	%35 = zext i1 %34 to i8
	%36 = trunc i8 %35 to i1
	br i1 %36, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	%37 = load %main.Mesh_Renderer*, %main.Mesh_Renderer** %3, align 8
	ret %main.Mesh_Renderer* %37

if.done-4:
	br label %for.index.loop-1

for.index.done-5:
	%38 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 138
	%39 = bitcast %..string* %4 to %..rawptr
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 16) noinline
	store %..string zeroinitializer, %..string* %4
	store %..string {i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$619, i64 0, i32 0), i64 27}, %..string* %4
	%41 = load %..string, %..string* %4, align 8
	%42 = bitcast %..any* %5 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 16) noinline
	store %..any zeroinitializer, %..any* %5
	%44 = bitcast %..string* %4 to %..rawptr
	%45 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	store %..rawptr %44, %..rawptr* %45
	%46 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %46
	%47 = load %..any, %..any* %5, align 8
	%48 = bitcast %..any* %6 to %..rawptr
	%49 = call %..rawptr @mem.zero(%..rawptr %48, i64 16) noinline
	store %..any zeroinitializer, %..any* %6
	%50 = bitcast %runtime.Type_Info** %7 to %..rawptr
	%51 = call %..rawptr @mem.zero(%..rawptr %50, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %7
	store %runtime.Type_Info* %38, %runtime.Type_Info** %7
	%52 = bitcast %runtime.Type_Info** %7 to %..rawptr
	%53 = getelementptr inbounds %..any, %..any* %6, i64 0, i32 0
	store %..rawptr %52, %..rawptr* %53
	%54 = getelementptr inbounds %..any, %..any* %6, i64 0, i32 1
	store %..typeid 648518346341351435, %..typeid* %54
	%55 = load %..any, %..any* %6, align 8
	%56 = bitcast %..string* %8 to %..rawptr
	%57 = call %..rawptr @mem.zero(%..rawptr %56, i64 16) noinline
	store %..string zeroinitializer, %..string* %8
	store %..string {i8* getelementptr inbounds ([88 x i8], [88 x i8]* @str$61a, i64 0, i32 0), i64 87}, %..string* %8
	%58 = load %..string, %..string* %8, align 8
	%59 = bitcast %..any* %9 to %..rawptr
	%60 = call %..rawptr @mem.zero(%..rawptr %59, i64 16) noinline
	store %..any zeroinitializer, %..any* %9
	%61 = bitcast %..string* %8 to %..rawptr
	%62 = getelementptr inbounds %..any, %..any* %9, i64 0, i32 0
	store %..rawptr %61, %..rawptr* %62
	%63 = getelementptr inbounds %..any, %..any* %9, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %63
	%64 = load %..any, %..any* %9, align 8
	; variadic call argument generation
	%65 = bitcast {%..any*, i64}* %10 to %..rawptr
	%66 = call %..rawptr @mem.zero(%..rawptr %65, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %10
	%67 = bitcast [3 x %..any]* %11 to %..rawptr
	%68 = call %..rawptr @mem.zero(%..rawptr %67, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %11
	%69 = getelementptr inbounds [3 x %..any], [3 x %..any]* %11, i64 0, i32 0
	store %..any %47, %..any* %69
	%70 = getelementptr inbounds [3 x %..any], [3 x %..any]* %11, i64 0, i32 1
	store %..any %55, %..any* %70
	%71 = getelementptr inbounds [3 x %..any], [3 x %..any]* %11, i64 0, i32 2
	store %..any %64, %..any* %71
	%72 = getelementptr inbounds [3 x %..any], [3 x %..any]* %11, i64 0, i32 0
	%73 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %10, i64 0, i32 0
	store %..any* %72, %..any** %73
	%74 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %10, i64 0, i32 1
	store i64 3, i64* %74
	%75 = load {%..any*, i64}, {%..any*, i64}* %10, align 8
	%76 = bitcast {%..any*, i64}* %12 to %..rawptr
	%77 = call %..rawptr @mem.zero(%..rawptr %76, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %12
	store {%..any*, i64} %75, {%..any*, i64}* %12
	%78 = call %..string @fmt.tprint({%..any*, i64}* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%79 = bitcast %runtime.Source_Code_Location* %13 to %..rawptr
	%80 = call %..rawptr @mem.zero(%..rawptr %79, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %13
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$61b, i64 0, i32 0), i64 74}, i64 62, i64 2, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$61c, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %13
	call void @runtime.panic(%..string %78, %runtime.Source_Code_Location* %13) noreturn
	; ReturnStmt
	ret %main.Mesh_Renderer* zeroinitializer
}

define %main.Transform* @main.get_component-14223(i64 %entity, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %main.Transform*, align 16
	%4 = alloca %..string, align 16
	%5 = alloca %..any, align 16
	%6 = alloca %..any, align 16
	%7 = alloca %runtime.Type_Info*, align 16
	%8 = alloca %..string, align 16
	%9 = alloca %..any, align 16
	%10 = alloca {%..any*, i64}, align 16
	%11 = alloca [3 x %..any], align 16
	%12 = alloca {%..any*, i64}, align 16
	%13 = alloca %runtime.Source_Code_Location, align 16
	store i64 %entity, i64* %0
	; RangeStmt
	; i
	%14 = bitcast i64* %1 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 8) noinline
	store i64 zeroinitializer, i64* %1
	%16 = getelementptr inbounds {%main.Transform*, i64, i64, %mem.Allocator}, {%main.Transform*, i64, i64, %mem.Allocator}* @main.all_transforms, i64 0, i32 1
	%17 = bitcast i64* %2 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	store i64 -1, i64* %2
	br label %for.index.loop-1

for.index.loop-1:
	%19 = load i64, i64* %2, align 8
	%20 = add i64 %19, 1
	store i64 %20, i64* %2
	%21 = load i64, i64* %16, align 8
	%22 = icmp slt i64 %20, %21
	br i1 %22, label %for.index.body-2, label %for.index.done-5

for.index.body-2:
	%23 = load i64, i64* %2, align 8
	store i64 %23, i64* %1
	; c
	; IndexExpr
	%24 = load {%main.Transform*, i64, i64, %mem.Allocator}, {%main.Transform*, i64, i64, %mem.Allocator}* @main.all_transforms, align 8
	%25 = extractvalue {%main.Transform*, i64, i64, %mem.Allocator} %24, 0
	%26 = extractvalue {%main.Transform*, i64, i64, %mem.Allocator} %24, 1
	%27 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$61d, i64 0, i32 0), i64 74}, i64 44, i64 25, i64 %27, i64 %26)
	%28 = getelementptr inbounds %main.Transform, %main.Transform* %25, i64 %27
	store %main.Transform* %28, %main.Transform** %3
	; IfStmt
	; SelectorExpr
	%29 = load %main.Transform*, %main.Transform** %3, align 8
	%30 = getelementptr inbounds %main.Transform, %main.Transform* %29, i64 0
	%31 = getelementptr inbounds %main.Transform, %main.Transform* %30, i64 0, i32 0
	%32 = load i64, i64* %31, align 8
	%33 = load i64, i64* %0, align 8
	%34 = icmp eq i64 %32, %33
	%35 = zext i1 %34 to i8
	%36 = trunc i8 %35 to i1
	br i1 %36, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	%37 = load %main.Transform*, %main.Transform** %3, align 8
	ret %main.Transform* %37

if.done-4:
	br label %for.index.loop-1

for.index.done-5:
	%38 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 136
	%39 = bitcast %..string* %4 to %..rawptr
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 16) noinline
	store %..string zeroinitializer, %..string* %4
	store %..string {i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$61e, i64 0, i32 0), i64 27}, %..string* %4
	%41 = load %..string, %..string* %4, align 8
	%42 = bitcast %..any* %5 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 16) noinline
	store %..any zeroinitializer, %..any* %5
	%44 = bitcast %..string* %4 to %..rawptr
	%45 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	store %..rawptr %44, %..rawptr* %45
	%46 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %46
	%47 = load %..any, %..any* %5, align 8
	%48 = bitcast %..any* %6 to %..rawptr
	%49 = call %..rawptr @mem.zero(%..rawptr %48, i64 16) noinline
	store %..any zeroinitializer, %..any* %6
	%50 = bitcast %runtime.Type_Info** %7 to %..rawptr
	%51 = call %..rawptr @mem.zero(%..rawptr %50, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %7
	store %runtime.Type_Info* %38, %runtime.Type_Info** %7
	%52 = bitcast %runtime.Type_Info** %7 to %..rawptr
	%53 = getelementptr inbounds %..any, %..any* %6, i64 0, i32 0
	store %..rawptr %52, %..rawptr* %53
	%54 = getelementptr inbounds %..any, %..any* %6, i64 0, i32 1
	store %..typeid 648518346341351435, %..typeid* %54
	%55 = load %..any, %..any* %6, align 8
	%56 = bitcast %..string* %8 to %..rawptr
	%57 = call %..rawptr @mem.zero(%..rawptr %56, i64 16) noinline
	store %..string zeroinitializer, %..string* %8
	store %..string {i8* getelementptr inbounds ([88 x i8], [88 x i8]* @str$61f, i64 0, i32 0), i64 87}, %..string* %8
	%58 = load %..string, %..string* %8, align 8
	%59 = bitcast %..any* %9 to %..rawptr
	%60 = call %..rawptr @mem.zero(%..rawptr %59, i64 16) noinline
	store %..any zeroinitializer, %..any* %9
	%61 = bitcast %..string* %8 to %..rawptr
	%62 = getelementptr inbounds %..any, %..any* %9, i64 0, i32 0
	store %..rawptr %61, %..rawptr* %62
	%63 = getelementptr inbounds %..any, %..any* %9, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %63
	%64 = load %..any, %..any* %9, align 8
	; variadic call argument generation
	%65 = bitcast {%..any*, i64}* %10 to %..rawptr
	%66 = call %..rawptr @mem.zero(%..rawptr %65, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %10
	%67 = bitcast [3 x %..any]* %11 to %..rawptr
	%68 = call %..rawptr @mem.zero(%..rawptr %67, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %11
	%69 = getelementptr inbounds [3 x %..any], [3 x %..any]* %11, i64 0, i32 0
	store %..any %47, %..any* %69
	%70 = getelementptr inbounds [3 x %..any], [3 x %..any]* %11, i64 0, i32 1
	store %..any %55, %..any* %70
	%71 = getelementptr inbounds [3 x %..any], [3 x %..any]* %11, i64 0, i32 2
	store %..any %64, %..any* %71
	%72 = getelementptr inbounds [3 x %..any], [3 x %..any]* %11, i64 0, i32 0
	%73 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %10, i64 0, i32 0
	store %..any* %72, %..any** %73
	%74 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %10, i64 0, i32 1
	store i64 3, i64* %74
	%75 = load {%..any*, i64}, {%..any*, i64}* %10, align 8
	%76 = bitcast {%..any*, i64}* %12 to %..rawptr
	%77 = call %..rawptr @mem.zero(%..rawptr %76, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %12
	store {%..any*, i64} %75, {%..any*, i64}* %12
	%78 = call %..string @fmt.tprint({%..any*, i64}* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%79 = bitcast %runtime.Source_Code_Location* %13 to %..rawptr
	%80 = call %..rawptr @mem.zero(%..rawptr %79, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %13
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$620, i64 0, i32 0), i64 74}, i64 62, i64 2, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$621, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %13
	call void @runtime.panic(%..string %78, %runtime.Source_Code_Location* %13) noreturn
	; ReturnStmt
	ret %main.Transform* zeroinitializer
}

define %main.Sprite_Renderer* @main.get_component-14231(i64 %entity, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %main.Sprite_Renderer*, align 16
	%4 = alloca %..string, align 16
	%5 = alloca %..any, align 16
	%6 = alloca %..any, align 16
	%7 = alloca %runtime.Type_Info*, align 16
	%8 = alloca %..string, align 16
	%9 = alloca %..any, align 16
	%10 = alloca {%..any*, i64}, align 16
	%11 = alloca [3 x %..any], align 16
	%12 = alloca {%..any*, i64}, align 16
	%13 = alloca %runtime.Source_Code_Location, align 16
	store i64 %entity, i64* %0
	; RangeStmt
	; i
	%14 = bitcast i64* %1 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 8) noinline
	store i64 zeroinitializer, i64* %1
	%16 = getelementptr inbounds {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* @main.all_sprite_renderers, i64 0, i32 1
	%17 = bitcast i64* %2 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	store i64 -1, i64* %2
	br label %for.index.loop-1

for.index.loop-1:
	%19 = load i64, i64* %2, align 8
	%20 = add i64 %19, 1
	store i64 %20, i64* %2
	%21 = load i64, i64* %16, align 8
	%22 = icmp slt i64 %20, %21
	br i1 %22, label %for.index.body-2, label %for.index.done-5

for.index.body-2:
	%23 = load i64, i64* %2, align 8
	store i64 %23, i64* %1
	; c
	; IndexExpr
	%24 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* @main.all_sprite_renderers, align 8
	%25 = extractvalue {%main.Sprite_Renderer*, i64, i64, %mem.Allocator} %24, 0
	%26 = extractvalue {%main.Sprite_Renderer*, i64, i64, %mem.Allocator} %24, 1
	%27 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$622, i64 0, i32 0), i64 74}, i64 49, i64 31, i64 %27, i64 %26)
	%28 = getelementptr inbounds %main.Sprite_Renderer, %main.Sprite_Renderer* %25, i64 %27
	store %main.Sprite_Renderer* %28, %main.Sprite_Renderer** %3
	; IfStmt
	; SelectorExpr
	%29 = load %main.Sprite_Renderer*, %main.Sprite_Renderer** %3, align 8
	%30 = getelementptr inbounds %main.Sprite_Renderer, %main.Sprite_Renderer* %29, i64 0
	%31 = getelementptr inbounds %main.Sprite_Renderer, %main.Sprite_Renderer* %30, i64 0, i32 0
	%32 = load i64, i64* %31, align 8
	%33 = load i64, i64* %0, align 8
	%34 = icmp eq i64 %32, %33
	%35 = zext i1 %34 to i8
	%36 = trunc i8 %35 to i1
	br i1 %36, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	%37 = load %main.Sprite_Renderer*, %main.Sprite_Renderer** %3, align 8
	ret %main.Sprite_Renderer* %37

if.done-4:
	br label %for.index.loop-1

for.index.done-5:
	%38 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 148
	%39 = bitcast %..string* %4 to %..rawptr
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 16) noinline
	store %..string zeroinitializer, %..string* %4
	store %..string {i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$623, i64 0, i32 0), i64 27}, %..string* %4
	%41 = load %..string, %..string* %4, align 8
	%42 = bitcast %..any* %5 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 16) noinline
	store %..any zeroinitializer, %..any* %5
	%44 = bitcast %..string* %4 to %..rawptr
	%45 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	store %..rawptr %44, %..rawptr* %45
	%46 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %46
	%47 = load %..any, %..any* %5, align 8
	%48 = bitcast %..any* %6 to %..rawptr
	%49 = call %..rawptr @mem.zero(%..rawptr %48, i64 16) noinline
	store %..any zeroinitializer, %..any* %6
	%50 = bitcast %runtime.Type_Info** %7 to %..rawptr
	%51 = call %..rawptr @mem.zero(%..rawptr %50, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %7
	store %runtime.Type_Info* %38, %runtime.Type_Info** %7
	%52 = bitcast %runtime.Type_Info** %7 to %..rawptr
	%53 = getelementptr inbounds %..any, %..any* %6, i64 0, i32 0
	store %..rawptr %52, %..rawptr* %53
	%54 = getelementptr inbounds %..any, %..any* %6, i64 0, i32 1
	store %..typeid 648518346341351435, %..typeid* %54
	%55 = load %..any, %..any* %6, align 8
	%56 = bitcast %..string* %8 to %..rawptr
	%57 = call %..rawptr @mem.zero(%..rawptr %56, i64 16) noinline
	store %..string zeroinitializer, %..string* %8
	store %..string {i8* getelementptr inbounds ([88 x i8], [88 x i8]* @str$624, i64 0, i32 0), i64 87}, %..string* %8
	%58 = load %..string, %..string* %8, align 8
	%59 = bitcast %..any* %9 to %..rawptr
	%60 = call %..rawptr @mem.zero(%..rawptr %59, i64 16) noinline
	store %..any zeroinitializer, %..any* %9
	%61 = bitcast %..string* %8 to %..rawptr
	%62 = getelementptr inbounds %..any, %..any* %9, i64 0, i32 0
	store %..rawptr %61, %..rawptr* %62
	%63 = getelementptr inbounds %..any, %..any* %9, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %63
	%64 = load %..any, %..any* %9, align 8
	; variadic call argument generation
	%65 = bitcast {%..any*, i64}* %10 to %..rawptr
	%66 = call %..rawptr @mem.zero(%..rawptr %65, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %10
	%67 = bitcast [3 x %..any]* %11 to %..rawptr
	%68 = call %..rawptr @mem.zero(%..rawptr %67, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %11
	%69 = getelementptr inbounds [3 x %..any], [3 x %..any]* %11, i64 0, i32 0
	store %..any %47, %..any* %69
	%70 = getelementptr inbounds [3 x %..any], [3 x %..any]* %11, i64 0, i32 1
	store %..any %55, %..any* %70
	%71 = getelementptr inbounds [3 x %..any], [3 x %..any]* %11, i64 0, i32 2
	store %..any %64, %..any* %71
	%72 = getelementptr inbounds [3 x %..any], [3 x %..any]* %11, i64 0, i32 0
	%73 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %10, i64 0, i32 0
	store %..any* %72, %..any** %73
	%74 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %10, i64 0, i32 1
	store i64 3, i64* %74
	%75 = load {%..any*, i64}, {%..any*, i64}* %10, align 8
	%76 = bitcast {%..any*, i64}* %12 to %..rawptr
	%77 = call %..rawptr @mem.zero(%..rawptr %76, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %12
	store {%..any*, i64} %75, {%..any*, i64}* %12
	%78 = call %..string @fmt.tprint({%..any*, i64}* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%79 = bitcast %runtime.Source_Code_Location* %13 to %..rawptr
	%80 = call %..rawptr @mem.zero(%..rawptr %79, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %13
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([75 x i8], [75 x i8]* @str$625, i64 0, i32 0), i64 74}, i64 62, i64 2, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$626, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %13
	call void @runtime.panic(%..string %78, %runtime.Source_Code_Location* %13) noreturn
	; ReturnStmt
	ret %main.Sprite_Renderer* zeroinitializer
}

define {i8*, i64} @mem.make_slice-14353(i64 %len, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = alloca %..rawptr, align 16
	%3 = alloca %mem.Allocator, align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	%5 = alloca %mem.Raw_Slice, align 16
	%6 = alloca %mem.Raw_Slice, align 16
	store i64 %len, i64* %0
	%7 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%10 = load i64, i64* %0, align 8
	%11 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %9, %runtime.Source_Code_Location* %1
	call void @runtime.make_slice_error_loc(%runtime.Source_Code_Location* %1, i64 %10)
	; data
	%12 = load i64, i64* %0, align 8
	%13 = mul i64 1, %12
	%14 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%15 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%16 = bitcast %mem.Allocator* %3 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %3
	store %mem.Allocator %14, %mem.Allocator* %3
	%17 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location %15, %runtime.Source_Code_Location* %4
	%18 = call %..rawptr @mem.alloc(i64 %13, i64 1, %mem.Allocator* %3, %runtime.Source_Code_Location* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %18, %..rawptr* %2
	; s
	; CompoundLit
	%19 = bitcast %mem.Raw_Slice* %6 to %..rawptr
	store %mem.Raw_Slice zeroinitializer, %mem.Raw_Slice* %6
	store %mem.Raw_Slice {%..rawptr zeroinitializer, i64 zeroinitializer}, %mem.Raw_Slice* %6
	%20 = load %..rawptr, %..rawptr* %2, align 8
	%21 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %6, i64 0, i32 0
	store %..rawptr %20, %..rawptr* %21
	%22 = load i64, i64* %0, align 8
	%23 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %6, i64 0, i32 1
	store i64 %22, i64* %23
	%24 = load %mem.Raw_Slice, %mem.Raw_Slice* %6, align 8
	store %mem.Raw_Slice %24, %mem.Raw_Slice* %5
	; ReturnStmt
	%25 = load %mem.Raw_Slice, %mem.Raw_Slice* %5, align 8
	%26 = bitcast %mem.Raw_Slice* %5 to {i8*, i64}*
	%27 = load {i8*, i64}, {i8*, i64}* %26, align 8
	ret {i8*, i64} %27
}

define {%..rawptr*, i64, i64, %mem.Allocator} @mem.make_dynamic_array-14458(%mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Allocator, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%3 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; ReturnStmt
	%4 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%5 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%6 = bitcast %mem.Allocator* %0 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %0
	store %mem.Allocator %4, %mem.Allocator* %0
	%7 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %5, %runtime.Source_Code_Location* %1
	%8 = call {%..rawptr*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-20175(i64 0, i64 16, %mem.Allocator* %0, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {%..rawptr*, i64, i64, %mem.Allocator} %8
}

define i64 @runtime.append_elem-14503({%..rawptr*, i64, i64, %mem.Allocator}* %array, %..rawptr %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%..rawptr*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	%5 = alloca %mem.Raw_Dynamic_Array*, align 16
	%6 = alloca %..rawptr*, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	store {%..rawptr*, i64, i64, %mem.Allocator}* %array, {%..rawptr*, i64, i64, %mem.Allocator}** %0
	store %..rawptr %arg, %..rawptr* %1
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {%..rawptr*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %2
	; IfStmt
	%13 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %2, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %2, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %3
	; AssignStmt
	%32 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %3, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %4
	%37 = call i8 @runtime.reserve_dynamic_array-20197({%..rawptr*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %2, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %2
	; IfStmt
	%48 = load i64, i64* %2, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {%..rawptr*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %5
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %5, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to %..rawptr*
	store %..rawptr* %58, %..rawptr** %6
	%59 = load %..rawptr*, %..rawptr** %6, align 8
	%60 = icmp ne %..rawptr* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$627, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$628, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %7
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %7)
	; SelectorExpr
	; SelectorExpr
	%66 = load %..rawptr*, %..rawptr** %6, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %5, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call %..rawptr* @mem.ptr_offset-20211(%..rawptr* %66, i64 %70)
	%72 = bitcast %..rawptr* %71 to %..rawptr
	%73 = bitcast %..rawptr* %1 to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 8)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %5, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %2, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define void @runtime.clear_dynamic_array-14532({%..rawptr*, i64, i64, %mem.Allocator}* %array) alwaysinline #1 {
decls-0:
	%0 = alloca {%..rawptr*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %mem.Raw_Dynamic_Array*, align 16
	store {%..rawptr*, i64, i64, %mem.Allocator}* %array, {%..rawptr*, i64, i64, %mem.Allocator}** %0
	; IfStmt
	%2 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%3 = icmp ne {%..rawptr*, i64, i64, %mem.Allocator}* %2, zeroinitializer
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; SelectorExpr
	%6 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%7 = bitcast {%..rawptr*, i64, i64, %mem.Allocator}* %6 to %mem.Raw_Dynamic_Array*
	%8 = bitcast %mem.Raw_Dynamic_Array** %1 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 8) noinline
	store %mem.Raw_Dynamic_Array* zeroinitializer, %mem.Raw_Dynamic_Array** %1
	store %mem.Raw_Dynamic_Array* %7, %mem.Raw_Dynamic_Array** %1
	%10 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %1, align 8
	%11 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %10, i64 0
	%12 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %11, i64 0, i32 1
	store i64 0, i64* %12
	br label %if.done-2

if.done-2:
	ret void
}

define void @mem.delete_slice-14873({i8*, i64}* %array, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64}, align 16
	%1 = alloca %mem.Allocator, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = load {i8*, i64}, {i8*, i64}* %array, align 8
	%4 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%5 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%6 = load {i8*, i64}, {i8*, i64}* %array, align 8
	%7 = bitcast {i8*, i64}* %0 to %..rawptr
	store {i8*, i64} zeroinitializer, {i8*, i64}* %0
	store {i8*, i64} %6, {i8*, i64}* %0
	%8 = call i8* @mem.raw_slice_data-20316({i8*, i64}* %0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%10 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%11 = bitcast i8* %8 to %..rawptr
	%12 = bitcast %mem.Allocator* %1 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %1
	store %mem.Allocator %9, %mem.Allocator* %1
	%13 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %10, %runtime.Source_Code_Location* %2
	call void @mem.free(%..rawptr %11, %mem.Allocator* %1, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define i64 @runtime.append_string-15135({i8*, i64, i64, %mem.Allocator}* %array, {%..string*, i64}* %args, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i8*, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca {i8*, i64}, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	store {i8*, i64, i64, %mem.Allocator}* %array, {i8*, i64, i64, %mem.Allocator}** %0
	%8 = load {%..string*, i64}, {%..string*, i64}* %args, align 8
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; RangeStmt
	; arg
	%10 = bitcast %..string* %1 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 16) noinline
	store %..string zeroinitializer, %..string* %1
	%12 = load {%..string*, i64}, {%..string*, i64}* %args, align 8
	%13 = bitcast i64* %2 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	%15 = extractvalue {%..string*, i64} %12, 1
	store i64 %15, i64* %2
	%16 = bitcast i64* %3 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	store i64 -1, i64* %3
	br label %for.index.loop-1

for.index.loop-1:
	%18 = load i64, i64* %3, align 8
	%19 = add i64 %18, 1
	store i64 %19, i64* %3
	%20 = load i64, i64* %2, align 8
	%21 = icmp slt i64 %19, %20
	br i1 %21, label %for.index.body-2, label %for.index.done-3

for.index.body-2:
	%22 = load i64, i64* %3, align 8
	%23 = extractvalue {%..string*, i64} %12, 0
	%24 = getelementptr inbounds %..string, %..string* %23, i64 %22
	%25 = load %..string, %..string* %24, align 8
	store %..string %25, %..string* %1
	%26 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%27 = load %..string, %..string* %1, align 8
	%28 = extractvalue %..string %27, 0
	%29 = bitcast i8** %4 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 8) noinline
	store i8* zeroinitializer, i8** %4
	store i8* %28, i8** %4
	%31 = extractvalue %..string %27, 1
	%32 = sub i64 %31, 0
	%33 = load i8*, i8** %4, align 8
	%34 = getelementptr inbounds i8, i8* %33, i64 0
	%35 = bitcast {i8*, i64}* %5 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	%37 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 0
	store i8* %34, i8** %37
	%38 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 1
	store i64 %32, i64* %38
	%39 = load {i8*, i64}, {i8*, i64}* %5, align 8
	%40 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%41 = bitcast {i8*, i64}* %6 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	store {i8*, i64} %39, {i8*, i64}* %6
	%43 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%44 = call %..rawptr @mem.zero(%..rawptr %43, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location %40, %runtime.Source_Code_Location* %7
	%45 = call i64 @runtime.append_elems-15148({i8*, i64, i64, %mem.Allocator}* %26, {i8*, i64}* %6, %runtime.Source_Code_Location* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-1

for.index.done-3:
	; ReturnStmt
	%46 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%47 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %46, align 8
	%48 = extractvalue {i8*, i64, i64, %mem.Allocator} %47, 1
	ret i64 %48
}

define i64 @runtime.append_elems-15148({i8*, i64, i64, %mem.Allocator}* %array, {i8*, i64}* %args, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca i8*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	store {i8*, i64, i64, %mem.Allocator}* %array, {i8*, i64, i64, %mem.Allocator}** %0
	%7 = load {i8*, i64}, {i8*, i64}* %args, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {i8*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	%13 = load {i8*, i64}, {i8*, i64}* %args, align 8
	%14 = extractvalue {i8*, i64} %13, 1
	store i64 %14, i64* %1
	; IfStmt
	%15 = load i64, i64* %1, align 8
	%16 = icmp sle i64 %15, 0
	%17 = zext i1 %16 to i8
	%18 = trunc i8 %17 to i1
	br i1 %18, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	%19 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%20 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %19, align 8
	%21 = extractvalue {i8*, i64, i64, %mem.Allocator} %20, 1
	ret i64 %21

if.done-4:
	; IfStmt
	%22 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%23 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %22, align 8
	%24 = extractvalue {i8*, i64, i64, %mem.Allocator} %23, 2
	%25 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%26 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %25, align 8
	%27 = extractvalue {i8*, i64, i64, %mem.Allocator} %26, 1
	%28 = load i64, i64* %1, align 8
	%29 = add i64 %27, %28
	%30 = icmp sle i64 %24, %29
	%31 = zext i1 %30 to i8
	%32 = trunc i8 %31 to i1
	br i1 %32, label %if.then-5, label %if.done-6

if.then-5:
	; cap
	%33 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%34 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %33, align 8
	%35 = extractvalue {i8*, i64, i64, %mem.Allocator} %34, 2
	%36 = mul i64 2, %35
	; max
	%37 = load i64, i64* %1, align 8
	%38 = icmp sgt i64 8, %37
	%39 = select i1 %38, i64 8, i64 %37
	%40 = add i64 %36, %39
	store i64 %40, i64* %2
	; AssignStmt
	%41 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load i64, i64* %2, align 8
	%43 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%44 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %43, %runtime.Source_Code_Location* %3
	%46 = call i8 @runtime.reserve_dynamic_array-20360({i8*, i64, i64, %mem.Allocator}* %41, i64 %42, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-6

if.done-6:
	; AssignStmt
	; min
	%47 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%48 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %47, align 8
	%49 = extractvalue {i8*, i64, i64, %mem.Allocator} %48, 2
	%50 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%51 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %50, align 8
	%52 = extractvalue {i8*, i64, i64, %mem.Allocator} %51, 1
	%53 = sub i64 %49, %52
	%54 = load i64, i64* %1, align 8
	%55 = icmp slt i64 %53, %54
	%56 = select i1 %55, i64 %53, i64 %54
	store i64 %56, i64* %1
	; IfStmt
	%57 = load i64, i64* %1, align 8
	%58 = icmp sgt i64 %57, 0
	%59 = zext i1 %58 to i8
	%60 = trunc i8 %59 to i1
	br i1 %60, label %if.then-7, label %if.done-8

if.then-7:
	; a
	%61 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%62 = bitcast {i8*, i64, i64, %mem.Allocator}* %61 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %62, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%63 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%64 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %63, i64 0
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0, i32 0
	%66 = load %..rawptr, %..rawptr* %65, align 8
	%67 = bitcast %..rawptr %66 to i8*
	store i8* %67, i8** %5
	%68 = load i8*, i8** %5, align 8
	%69 = icmp ne i8* %68, zeroinitializer
	%70 = zext i1 %69 to i8
	%71 = trunc i8 %70 to i1
	%72 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$629, i64 0, i32 0), i64 58}, i64 493, i64 3, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$62a, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %6
	%74 = call i8 @runtime.assert(i1 %71, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; SelectorExpr
	; SelectorExpr
	%75 = load i8*, i8** %5, align 8
	; SelectorExpr
	%76 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0, i32 1
	%79 = load i64, i64* %78, align 8
	%80 = call i8* @mem.ptr_offset-13926(i8* %75, i64 %79)
	; IndexExpr
	%81 = load {i8*, i64}, {i8*, i64}* %args, align 8
	%82 = extractvalue {i8*, i64} %81, 0
	%83 = extractvalue {i8*, i64} %81, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$62b, i64 0, i32 0), i64 58}, i64 494, i64 47, i64 0, i64 %83)
	%84 = getelementptr inbounds i8, i8* %82, i64 0
	%85 = load i64, i64* %1, align 8
	%86 = mul i64 1, %85
	%87 = bitcast i8* %80 to %..rawptr
	%88 = bitcast i8* %84 to %..rawptr
	%89 = call %..rawptr @mem.copy(%..rawptr %87, %..rawptr %88, i64 %86)
	; AssignStmt
	; SelectorExpr
	%90 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%91 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %90, i64 0
	%92 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %91, i64 0, i32 1
	%93 = load i64, i64* %1, align 8
	%94 = load i64, i64* %92, align 8
	%95 = add i64 %94, %93
	store i64 %95, i64* %92
	br label %if.done-8

if.done-8:
	; ReturnStmt
	%96 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%97 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %96, align 8
	%98 = extractvalue {i8*, i64, i64, %mem.Allocator} %97, 1
	ret i64 %98
}

define i64 @runtime.append_elem-15167({i8*, i64, i64, %mem.Allocator}* %array, i8 %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	%5 = alloca %mem.Raw_Dynamic_Array*, align 16
	%6 = alloca i8*, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	store {i8*, i64, i64, %mem.Allocator}* %array, {i8*, i64, i64, %mem.Allocator}** %0
	store i8 %arg, i8* %1
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {i8*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %2
	; IfStmt
	%13 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {i8*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {i8*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %2, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {i8*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %2, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %3
	; AssignStmt
	%32 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %3, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %4
	%37 = call i8 @runtime.reserve_dynamic_array-20360({i8*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {i8*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {i8*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %2, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %2
	; IfStmt
	%48 = load i64, i64* %2, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {i8*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %5
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %5, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to i8*
	store i8* %58, i8** %6
	%59 = load i8*, i8** %6, align 8
	%60 = icmp ne i8* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$62c, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$62d, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %7
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %7)
	; SelectorExpr
	; SelectorExpr
	%66 = load i8*, i8** %6, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %5, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call i8* @mem.ptr_offset-13926(i8* %66, i64 %70)
	%72 = bitcast i8* %71 to %..rawptr
	%73 = bitcast i8* %1 to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 1)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %5, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %2, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {i8*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define {i8*, i64, i64, %mem.Allocator} @mem.make_dynamic_array-15214(%mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Allocator, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%3 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; ReturnStmt
	%4 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%5 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%6 = bitcast %mem.Allocator* %0 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %0
	store %mem.Allocator %4, %mem.Allocator* %0
	%7 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %5, %runtime.Source_Code_Location* %1
	%8 = call {i8*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-20408(i64 0, i64 16, %mem.Allocator* %0, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i8*, i64, i64, %mem.Allocator} %8
}

define [4 x [4 x float]] @math.identity-15829(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca [4 x [4 x float]], align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	; m
	%4 = bitcast [4 x [4 x float]]* %0 to %..rawptr
	%5 = call %..rawptr @mem.zero(%..rawptr %4, i64 64) noinline
	store [4 x [4 x float]] zeroinitializer, [4 x [4 x float]]* %0
	; RangeStmt
	; i
	%6 = bitcast i64* %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 8) noinline
	store i64 zeroinitializer, i64* %1
	%8 = bitcast i64* %2 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	store i64 0, i64* %2
	%10 = bitcast i64* %3 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	store i64 0, i64* %3
	br label %for.interval.loop-1

for.interval.loop-1:
	%12 = load i64, i64* %2, align 8
	%13 = icmp sle i64 %12, 3
	br i1 %13, label %for.interval.body-2, label %for.interval.done-3

for.interval.body-2:
	%14 = load i64, i64* %2, align 8
	%15 = load i64, i64* %3, align 8
	%16 = load i64, i64* %2, align 8
	%17 = add i64 %16, 1
	store i64 %17, i64* %2
	%18 = load i64, i64* %3, align 8
	%19 = add i64 %18, 1
	store i64 %19, i64* %3
	store i64 %14, i64* %1
	; AssignStmt
	; IndexExpr
	; IndexExpr
	%20 = load i64, i64* %1, align 8
	%21 = trunc i64 %20 to i32
	%22 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* %0, i64 0, i32 %21
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$62e, i64 0, i32 0), i64 55}, i64 197, i64 23, i64 %20, i64 4)
	%23 = load i64, i64* %1, align 8
	%24 = trunc i64 %23 to i32
	%25 = getelementptr inbounds [4 x float], [4 x float]* %22, i64 0, i32 %24
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$62f, i64 0, i32 0), i64 55}, i64 197, i64 26, i64 %23, i64 4)
	store float 0x3ff0000000000000, float* %25
	br label %for.interval.loop-1

for.interval.done-3:
	; ReturnStmt
	%26 = load [4 x [4 x float]], [4 x [4 x float]]* %0, align 4
	ret [4 x [4 x float]] %26
}

define void @runtime.clear_dynamic_array-16027({%workbench.Key_Press*, i64, i64, %mem.Allocator}* %array) alwaysinline #1 {
decls-0:
	%0 = alloca {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %mem.Raw_Dynamic_Array*, align 16
	store {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %array, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0
	; IfStmt
	%2 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%3 = icmp ne {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %2, zeroinitializer
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; SelectorExpr
	%6 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%7 = bitcast {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %6 to %mem.Raw_Dynamic_Array*
	%8 = bitcast %mem.Raw_Dynamic_Array** %1 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 8) noinline
	store %mem.Raw_Dynamic_Array* zeroinitializer, %mem.Raw_Dynamic_Array** %1
	store %mem.Raw_Dynamic_Array* %7, %mem.Raw_Dynamic_Array** %1
	%10 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %1, align 8
	%11 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %10, i64 0
	%12 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %11, i64 0, i32 1
	store i64 0, i64* %12
	br label %if.done-2

if.done-2:
	ret void
}

define i64 @runtime.append_elem-16219({%workbench.Key_Press*, i64, i64, %mem.Allocator}* %array, %workbench.Key_Press* %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca %workbench.Key_Press*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %array, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0
	%7 = load %workbench.Key_Press, %workbench.Key_Press* %arg, align 4
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %1
	; IfStmt
	%13 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {%workbench.Key_Press*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {%workbench.Key_Press*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %1, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {%workbench.Key_Press*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %1, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %2
	; AssignStmt
	%32 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %2, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %3
	%37 = call i8 @runtime.reserve_dynamic_array-20590({%workbench.Key_Press*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {%workbench.Key_Press*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {%workbench.Key_Press*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %1, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %1
	; IfStmt
	%48 = load i64, i64* %1, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to %workbench.Key_Press*
	store %workbench.Key_Press* %58, %workbench.Key_Press** %5
	%59 = load %workbench.Key_Press*, %workbench.Key_Press** %5, align 8
	%60 = icmp ne %workbench.Key_Press* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$630, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$631, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; SelectorExpr
	; SelectorExpr
	%66 = load %workbench.Key_Press*, %workbench.Key_Press** %5, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call %workbench.Key_Press* @mem.ptr_offset-20604(%workbench.Key_Press* %66, i64 %70)
	%72 = bitcast %workbench.Key_Press* %71 to %..rawptr
	%73 = bitcast %workbench.Key_Press* %arg to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 8)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %1, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {%workbench.Key_Press*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define void @workbench.remove_at-16407({%workbench.Key_Press*, i64, i64, %mem.Allocator}* %array, i64 %to_remove, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	store {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %array, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0
	store i64 %to_remove, i64* %1
	; AssignStmt
	; IndexExpr
	%2 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%3 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %2, align 8
	%4 = extractvalue {%workbench.Key_Press*, i64, i64, %mem.Allocator} %3, 0
	%5 = extractvalue {%workbench.Key_Press*, i64, i64, %mem.Allocator} %3, 1
	%6 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$632, i64 0, i32 0), i64 63}, i64 57, i64 8, i64 %6, i64 %5)
	%7 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %4, i64 %6
	; IndexExpr
	%8 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%9 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %8, align 8
	%10 = extractvalue {%workbench.Key_Press*, i64, i64, %mem.Allocator} %9, 0
	%11 = extractvalue {%workbench.Key_Press*, i64, i64, %mem.Allocator} %9, 1
	%12 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%13 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %12, align 8
	%14 = extractvalue {%workbench.Key_Press*, i64, i64, %mem.Allocator} %13, 1
	%15 = sub i64 %14, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$633, i64 0, i32 0), i64 63}, i64 57, i64 27, i64 %15, i64 %11)
	%16 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %10, i64 %15
	%17 = load %workbench.Key_Press, %workbench.Key_Press* %16, align 4
	store %workbench.Key_Press %17, %workbench.Key_Press* %7
	%18 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%19 = call %workbench.Key_Press @runtime.pop-20636({%workbench.Key_Press*, i64, i64, %mem.Allocator}* %18)
	ret void
}

define float @math.lerp-16575(float %a, float %b, float %t, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca float, align 16
	%1 = alloca float, align 16
	%2 = alloca float, align 16
	%3 = alloca float, align 16
	store float %a, float* %0
	store float %b, float* %1
	store float %t, float* %2
	%4 = bitcast float* %3 to %..rawptr
	%5 = call %..rawptr @mem.zero(%..rawptr %4, i64 4) noinline
	store float zeroinitializer, float* %3
	; ReturnStmt
	%6 = load float, float* %0, align 4
	%7 = load float, float* %2, align 4
	%8 = fsub float 0x3ff0000000000000, %7
	%9 = fmul float %6, %8
	%10 = load float, float* %1, align 4
	%11 = load float, float* %2, align 4
	%12 = fmul float %10, %11
	%13 = fadd float %9, %12
	ret float %13
}

define [3 x float] @workbench.to_vec3-17032([2 x float]* %a, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca [3 x float], align 16
	%1 = alloca i64, align 16
	%2 = load [2 x float], [2 x float]* %a, align 4
	; result
	%3 = bitcast [3 x float]* %0 to %..rawptr
	%4 = call %..rawptr @mem.zero(%..rawptr %3, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %0
	; idx
	store i64 0, i64* %1
	; ForStmt
	br label %for.loop-1

for.loop-1:
	%5 = load i64, i64* %1, align 8
	%6 = icmp slt i64 %5, 2
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	br i1 %8, label %cmp.and-2, label %for.done-4

cmp.and-2:
	%9 = load i64, i64* %1, align 8
	%10 = icmp slt i64 %9, 3
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %for.body-3, label %for.done-4

for.body-3:
	; AssignStmt
	; IndexExpr
	%13 = load i64, i64* %1, align 8
	%14 = trunc i64 %13 to i32
	%15 = getelementptr inbounds [3 x float], [3 x float]* %0, i64 0, i32 %14
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$634, i64 0, i32 0), i64 62}, i64 155, i64 10, i64 %13, i64 3) alwaysinline
	; IndexExpr
	%16 = load i64, i64* %1, align 8
	%17 = trunc i64 %16 to i32
	%18 = getelementptr inbounds [2 x float], [2 x float]* %a, i64 0, i32 %17
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$635, i64 0, i32 0), i64 62}, i64 155, i64 19, i64 %16, i64 2) alwaysinline
	%19 = load float, float* %18, align 4
	store float %19, float* %15
	; AssignStmt
	%20 = load i64, i64* %1, align 8
	%21 = add i64 %20, 1
	store i64 %21, i64* %1
	br label %for.loop-1

for.done-4:
	; ReturnStmt
	%22 = load [3 x float], [3 x float]* %0, align 4
	ret [3 x float] %22
}

define i64 @runtime.append_elem-17064({%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %array, %workbench.Buffered_Vertex* %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca %workbench.Buffered_Vertex*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %array, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0
	%7 = load %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %arg, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %1
	; IfStmt
	%13 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %1, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %1, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %2
	; AssignStmt
	%32 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %2, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %3
	%37 = call i8 @runtime.reserve_dynamic_array-20768({%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %1, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %1
	; IfStmt
	%48 = load i64, i64* %1, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to %workbench.Buffered_Vertex*
	store %workbench.Buffered_Vertex* %58, %workbench.Buffered_Vertex** %5
	%59 = load %workbench.Buffered_Vertex*, %workbench.Buffered_Vertex** %5, align 8
	%60 = icmp ne %workbench.Buffered_Vertex* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$636, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$637, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; SelectorExpr
	; SelectorExpr
	%66 = load %workbench.Buffered_Vertex*, %workbench.Buffered_Vertex** %5, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call %workbench.Buffered_Vertex* @mem.ptr_offset-20782(%workbench.Buffered_Vertex* %66, i64 %70)
	%72 = bitcast %workbench.Buffered_Vertex* %71 to %..rawptr
	%73 = bitcast %workbench.Buffered_Vertex* %arg to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 112)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %1, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define void @runtime.clear_dynamic_array-17165({%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %array) alwaysinline #1 {
decls-0:
	%0 = alloca {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %mem.Raw_Dynamic_Array*, align 16
	store {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %array, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0
	; IfStmt
	%2 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0, align 8
	%3 = icmp ne {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %2, zeroinitializer
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; SelectorExpr
	%6 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0, align 8
	%7 = bitcast {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %6 to %mem.Raw_Dynamic_Array*
	%8 = bitcast %mem.Raw_Dynamic_Array** %1 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 8) noinline
	store %mem.Raw_Dynamic_Array* zeroinitializer, %mem.Raw_Dynamic_Array** %1
	store %mem.Raw_Dynamic_Array* %7, %mem.Raw_Dynamic_Array** %1
	%10 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %1, align 8
	%11 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %10, i64 0
	%12 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %11, i64 0, i32 1
	store i64 0, i64* %12
	br label %if.done-2

if.done-2:
	ret void
}

define void @sort.quick_sort_proc-17218({%workbench.Buffered_Vertex*, i64}* %array, i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)* %f, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)*, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = alloca {%workbench.Buffered_Vertex*, i64}, align 16
	%3 = alloca i64, align 16
	%4 = alloca %workbench.Buffered_Vertex, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca %workbench.Buffered_Vertex, align 16
	%8 = alloca %workbench.Buffered_Vertex, align 16
	%9 = alloca %workbench.Buffered_Vertex, align 16
	%10 = alloca %workbench.Buffered_Vertex, align 16
	%11 = alloca {%workbench.Buffered_Vertex*, i64}, align 16
	%12 = alloca {%workbench.Buffered_Vertex*, i64}, align 16
	%13 = alloca {%workbench.Buffered_Vertex*, i64}, align 16
	%14 = alloca {%workbench.Buffered_Vertex*, i64}, align 16
	%15 = load {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %array, align 8
	store i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)* %f, i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)** %0
	%16 = load i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)*, i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)** %0, align 8
	%17 = icmp ne i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)* %16, zeroinitializer
	%18 = zext i1 %17 to i8
	%19 = trunc i8 %18 to i1
	%20 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$638, i64 0, i32 0), i64 55}, i64 53, i64 2, %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$639, i64 0, i32 0), i64 15}}, %runtime.Source_Code_Location* %1
	%22 = call i8 @runtime.assert(i1 %19, %..string zeroinitializer, %runtime.Source_Code_Location* %1)
	; a
	%23 = load {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %array, align 8
	store {%workbench.Buffered_Vertex*, i64} %23, {%workbench.Buffered_Vertex*, i64}* %2
	; n
	%24 = load {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %2, align 8
	%25 = extractvalue {%workbench.Buffered_Vertex*, i64} %24, 1
	store i64 %25, i64* %3
	; IfStmt
	%26 = load i64, i64* %3, align 8
	%27 = icmp slt i64 %26, 2
	%28 = zext i1 %27 to i8
	%29 = trunc i8 %28 to i1
	br i1 %29, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; p
	; IndexExpr
	%30 = load {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %2, align 8
	%31 = extractvalue {%workbench.Buffered_Vertex*, i64} %30, 0
	%32 = load i64, i64* %3, align 8
	%33 = sdiv i64 %32, 2
	%34 = extractvalue {%workbench.Buffered_Vertex*, i64} %30, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$63a, i64 0, i32 0), i64 55}, i64 58, i64 9, i64 %33, i64 %34)
	%35 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %31, i64 %33
	%36 = load %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %35, align 8
	store %workbench.Buffered_Vertex %36, %workbench.Buffered_Vertex* %4
	; i
	; j
	%37 = load i64, i64* %3, align 8
	%38 = sub i64 %37, 1
	store i64 0, i64* %5
	store i64 %38, i64* %6
	; ForStmt
	br label %for.body-3

for.body-3:
	; ForStmt
	br label %for.loop-4

for.loop-4:
	%39 = load i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)*, i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)** %0, align 8
	; IndexExpr
	%40 = load {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %2, align 8
	%41 = extractvalue {%workbench.Buffered_Vertex*, i64} %40, 0
	%42 = load i64, i64* %5, align 8
	%43 = extractvalue {%workbench.Buffered_Vertex*, i64} %40, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$63b, i64 0, i32 0), i64 55}, i64 62, i64 11, i64 %42, i64 %43)
	%44 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %41, i64 %42
	%45 = load %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %44, align 8
	%46 = load %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %4, align 8
	%47 = bitcast %workbench.Buffered_Vertex* %7 to %..rawptr
	%48 = call %..rawptr @mem.zero(%..rawptr %47, i64 112) noinline
	store %workbench.Buffered_Vertex zeroinitializer, %workbench.Buffered_Vertex* %7
	store %workbench.Buffered_Vertex %45, %workbench.Buffered_Vertex* %7
	%49 = bitcast %workbench.Buffered_Vertex* %8 to %..rawptr
	%50 = call %..rawptr @mem.zero(%..rawptr %49, i64 112) noinline
	store %workbench.Buffered_Vertex zeroinitializer, %workbench.Buffered_Vertex* %8
	store %workbench.Buffered_Vertex %46, %workbench.Buffered_Vertex* %8
	%51 = call i64 %39(%workbench.Buffered_Vertex* %7, %workbench.Buffered_Vertex* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%52 = icmp slt i64 %51, 0
	%53 = zext i1 %52 to i8
	%54 = trunc i8 %53 to i1
	br i1 %54, label %for.body-5, label %for.done-6

for.body-5:
	; AssignStmt
	%55 = load i64, i64* %5, align 8
	%56 = add i64 %55, 1
	store i64 %56, i64* %5
	br label %for.loop-4

for.done-6:
	; ForStmt
	br label %for.loop-7

for.loop-7:
	%57 = load i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)*, i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)** %0, align 8
	%58 = load %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %4, align 8
	; IndexExpr
	%59 = load {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %2, align 8
	%60 = extractvalue {%workbench.Buffered_Vertex*, i64} %59, 0
	%61 = load i64, i64* %6, align 8
	%62 = extractvalue {%workbench.Buffered_Vertex*, i64} %59, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$63c, i64 0, i32 0), i64 55}, i64 63, i64 14, i64 %61, i64 %62)
	%63 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %60, i64 %61
	%64 = load %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %63, align 8
	%65 = bitcast %workbench.Buffered_Vertex* %9 to %..rawptr
	%66 = call %..rawptr @mem.zero(%..rawptr %65, i64 112) noinline
	store %workbench.Buffered_Vertex zeroinitializer, %workbench.Buffered_Vertex* %9
	store %workbench.Buffered_Vertex %58, %workbench.Buffered_Vertex* %9
	%67 = bitcast %workbench.Buffered_Vertex* %10 to %..rawptr
	%68 = call %..rawptr @mem.zero(%..rawptr %67, i64 112) noinline
	store %workbench.Buffered_Vertex zeroinitializer, %workbench.Buffered_Vertex* %10
	store %workbench.Buffered_Vertex %64, %workbench.Buffered_Vertex* %10
	%69 = call i64 %57(%workbench.Buffered_Vertex* %9, %workbench.Buffered_Vertex* %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%70 = icmp slt i64 %69, 0
	%71 = zext i1 %70 to i8
	%72 = trunc i8 %71 to i1
	br i1 %72, label %for.body-8, label %for.done-9

for.body-8:
	; AssignStmt
	%73 = load i64, i64* %6, align 8
	%74 = sub i64 %73, 1
	store i64 %74, i64* %6
	br label %for.loop-7

for.done-9:
	; IfStmt
	%75 = load i64, i64* %5, align 8
	%76 = load i64, i64* %6, align 8
	%77 = icmp sge i64 %75, %76
	%78 = zext i1 %77 to i8
	%79 = trunc i8 %78 to i1
	br i1 %79, label %if.then-10, label %if.done-11

if.then-10:
	; break
	; SliceExpr
	%80 = load i64, i64* %5, align 8
	%81 = load {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %2, align 8
	%82 = extractvalue {%workbench.Buffered_Vertex*, i64} %81, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$63d, i64 0, i32 0), i64 55}, i64 72, i64 19, i64 0, i64 %80, i64 %82)
	%83 = extractvalue {%workbench.Buffered_Vertex*, i64} %81, 0
	%84 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %83, i64 0
	%85 = sub i64 %80, 0
	%86 = bitcast {%workbench.Buffered_Vertex*, i64}* %11 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store {%workbench.Buffered_Vertex*, i64} zeroinitializer, {%workbench.Buffered_Vertex*, i64}* %11
	%88 = getelementptr inbounds {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %11, i64 0, i32 0
	store %workbench.Buffered_Vertex* %84, %workbench.Buffered_Vertex** %88
	%89 = getelementptr inbounds {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %11, i64 0, i32 1
	store i64 %85, i64* %89
	%90 = load {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %11, align 8
	%91 = load i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)*, i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)** %0, align 8
	%92 = bitcast {%workbench.Buffered_Vertex*, i64}* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store {%workbench.Buffered_Vertex*, i64} zeroinitializer, {%workbench.Buffered_Vertex*, i64}* %12
	store {%workbench.Buffered_Vertex*, i64} %90, {%workbench.Buffered_Vertex*, i64}* %12
	call void @sort.quick_sort_proc-17218({%workbench.Buffered_Vertex*, i64}* %12, i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)* %91, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SliceExpr
	%94 = load i64, i64* %5, align 8
	%95 = load i64, i64* %3, align 8
	%96 = load {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %2, align 8
	%97 = extractvalue {%workbench.Buffered_Vertex*, i64} %96, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$63e, i64 0, i32 0), i64 55}, i64 73, i64 19, i64 %94, i64 %95, i64 %97)
	%98 = extractvalue {%workbench.Buffered_Vertex*, i64} %96, 0
	%99 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %98, i64 %94
	%100 = sub i64 %95, %94
	%101 = bitcast {%workbench.Buffered_Vertex*, i64}* %13 to %..rawptr
	%102 = call %..rawptr @mem.zero(%..rawptr %101, i64 16) noinline
	store {%workbench.Buffered_Vertex*, i64} zeroinitializer, {%workbench.Buffered_Vertex*, i64}* %13
	%103 = getelementptr inbounds {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %13, i64 0, i32 0
	store %workbench.Buffered_Vertex* %99, %workbench.Buffered_Vertex** %103
	%104 = getelementptr inbounds {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %13, i64 0, i32 1
	store i64 %100, i64* %104
	%105 = load {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %13, align 8
	%106 = load i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)*, i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)** %0, align 8
	%107 = bitcast {%workbench.Buffered_Vertex*, i64}* %14 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 16) noinline
	store {%workbench.Buffered_Vertex*, i64} zeroinitializer, {%workbench.Buffered_Vertex*, i64}* %14
	store {%workbench.Buffered_Vertex*, i64} %105, {%workbench.Buffered_Vertex*, i64}* %14
	call void @sort.quick_sort_proc-17218({%workbench.Buffered_Vertex*, i64}* %14, i64 (%workbench.Buffered_Vertex*, %workbench.Buffered_Vertex*, %runtime.Context*)* %106, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void

if.done-11:
	; AssignStmt
	; IndexExpr
	%109 = load {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %2, align 8
	%110 = extractvalue {%workbench.Buffered_Vertex*, i64} %109, 0
	%111 = load i64, i64* %5, align 8
	%112 = extractvalue {%workbench.Buffered_Vertex*, i64} %109, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$63f, i64 0, i32 0), i64 55}, i64 67, i64 5, i64 %111, i64 %112)
	%113 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %110, i64 %111
	; IndexExpr
	%114 = load {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %2, align 8
	%115 = extractvalue {%workbench.Buffered_Vertex*, i64} %114, 0
	%116 = load i64, i64* %6, align 8
	%117 = extractvalue {%workbench.Buffered_Vertex*, i64} %114, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$640, i64 0, i32 0), i64 55}, i64 67, i64 11, i64 %116, i64 %117)
	%118 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %115, i64 %116
	; IndexExpr
	%119 = load {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %2, align 8
	%120 = extractvalue {%workbench.Buffered_Vertex*, i64} %119, 0
	%121 = load i64, i64* %6, align 8
	%122 = extractvalue {%workbench.Buffered_Vertex*, i64} %119, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$641, i64 0, i32 0), i64 55}, i64 67, i64 18, i64 %121, i64 %122)
	%123 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %120, i64 %121
	%124 = load %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %123, align 8
	; IndexExpr
	%125 = load {%workbench.Buffered_Vertex*, i64}, {%workbench.Buffered_Vertex*, i64}* %2, align 8
	%126 = extractvalue {%workbench.Buffered_Vertex*, i64} %125, 0
	%127 = load i64, i64* %5, align 8
	%128 = extractvalue {%workbench.Buffered_Vertex*, i64} %125, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$642, i64 0, i32 0), i64 55}, i64 67, i64 24, i64 %127, i64 %128)
	%129 = getelementptr inbounds %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %126, i64 %127
	%130 = load %workbench.Buffered_Vertex, %workbench.Buffered_Vertex* %129, align 8
	store %workbench.Buffered_Vertex %124, %workbench.Buffered_Vertex* %113
	store %workbench.Buffered_Vertex %130, %workbench.Buffered_Vertex* %118
	; AssignStmt
	%131 = load i64, i64* %5, align 8
	%132 = add i64 %131, 1
	store i64 %132, i64* %5
	; AssignStmt
	%133 = load i64, i64* %6, align 8
	%134 = sub i64 %133, 1
	store i64 %134, i64* %6
	br label %for.body-3
}

define void @workbench.draw_vertex_list-17232({%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %list, i32 %mode, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %workbench.Vertex2D*, align 16
	%7 = alloca [3 x float], align 16
	%8 = alloca %workbench.Colorf, align 16
	%9 = alloca i32, align 16
	%10 = alloca %runtime.Source_Code_Location, align 16
	%11 = alloca %runtime.Source_Code_Location, align 16
	%12 = alloca %runtime.Source_Code_Location, align 16
	%13 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %list, align 8
	store i32 %mode, i32* %0
	%14 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%15 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %list, align 8
	%16 = extractvalue {%workbench.Vertex2D*, i64, i64, %mem.Allocator} %15, 1
	%17 = icmp eq i64 %16, 0
	%18 = zext i1 %17 to i8
	%19 = trunc i8 %18 to i1
	br i1 %19, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; IfStmt
	%20 = load i32, i32* @workbench.debugging_rendering_max_draw_calls, align 4
	%21 = icmp ne i32 %20, -1
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %cmp.and-3, label %if.done-5

cmp.and-3:
	%24 = load i32, i32* @workbench.num_draw_calls, align 4
	%25 = load i32, i32* @workbench.debugging_rendering_max_draw_calls, align 4
	%26 = icmp sge i32 %24, %25
	%27 = zext i1 %26 to i8
	%28 = trunc i8 %27 to i1
	br i1 %28, label %if.then-4, label %if.done-5

if.then-4:
	; AssignStmt
	%29 = load i32, i32* @workbench.num_draw_calls, align 4
	%30 = add i32 %29, 1
	store i32 %30, i32* @workbench.num_draw_calls
	; ReturnStmt
	ret void

if.done-5:
	%31 = load i32, i32* @workbench.vao, align 4
	%32 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$643, i64 0, i32 0), i64 62}, i64 566, i64 2, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$644, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %1
	call void @workbench.bind_vao(i32 %31, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%34 = load i32, i32* @workbench.vbo, align 4
	%35 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$645, i64 0, i32 0), i64 62}, i64 567, i64 2, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$646, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %2
	call void @workbench.bind_buffer_vbo(i32 %34, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%37 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%38 = call %..rawptr @mem.zero(%..rawptr %37, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$647, i64 0, i32 0), i64 62}, i64 569, i64 2, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$648, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %3
	call void @workbench.set_vertex_format-20833(%runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	%39 = load i8, i8* @workbench.debugging_rendering, align 1
	%40 = trunc i8 %39 to i1
	br i1 %40, label %if.then-6, label %if.done-10

if.then-6:
	; RangeStmt
	; i
	%41 = bitcast i64* %4 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	%43 = getelementptr inbounds {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %list, i64 0, i32 1
	%44 = bitcast i64* %5 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	store i64 -1, i64* %5
	br label %for.index.loop-7

for.index.loop-7:
	%46 = load i64, i64* %5, align 8
	%47 = add i64 %46, 1
	store i64 %47, i64* %5
	%48 = load i64, i64* %43, align 8
	%49 = icmp slt i64 %47, %48
	br i1 %49, label %for.index.body-8, label %for.index.done-9

for.index.body-8:
	%50 = load i64, i64* %5, align 8
	store i64 %50, i64* %4
	; vert
	; IndexExpr
	%51 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %list, align 8
	%52 = extractvalue {%workbench.Vertex2D*, i64, i64, %mem.Allocator} %51, 0
	%53 = extractvalue {%workbench.Vertex2D*, i64, i64, %mem.Allocator} %51, 1
	%54 = load i64, i64* %4, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$649, i64 0, i32 0), i64 62}, i64 574, i64 19, i64 %54, i64 %53)
	%55 = getelementptr inbounds %workbench.Vertex2D, %workbench.Vertex2D* %52, i64 %54
	store %workbench.Vertex2D* %55, %workbench.Vertex2D** %6
	%56 = load void (%runtime.Context*)*, void (%runtime.Context*)** @workbench.current_rendermode, align 8
	; SelectorExpr
	%57 = load %workbench.Vertex2D*, %workbench.Vertex2D** %6, align 8
	%58 = getelementptr inbounds %workbench.Vertex2D, %workbench.Vertex2D* %57, i64 0
	%59 = getelementptr inbounds %workbench.Vertex2D, %workbench.Vertex2D* %58, i64 0, i32 0
	%60 = load [3 x float], [3 x float]* %59, align 4
	%61 = load %workbench.Colorf, %workbench.Colorf* @workbench.COLOR_GREEN, align 4
	%62 = bitcast void (%runtime.Context*)* %56 to void (%runtime.Context*)*
	%63 = bitcast [3 x float]* %7 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %7
	store [3 x float] %60, [3 x float]* %7
	%65 = bitcast %workbench.Colorf* %8 to %..rawptr
	%66 = call %..rawptr @mem.zero(%..rawptr %65, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %8
	store %workbench.Colorf %61, %workbench.Colorf* %8
	call void @workbench.push_debug_vertex(void (%runtime.Context*)* %62, [3 x float]* %7, %workbench.Colorf* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-7

for.index.done-9:
	br label %if.done-10

if.done-10:
	; SelectorExpr
	%67 = load void (i32, i64, %..rawptr, i32)*, void (i32, i64, %..rawptr, i32)** @gl.BufferData, align 8
	%68 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %list, align 8
	%69 = extractvalue {%workbench.Vertex2D*, i64, i64, %mem.Allocator} %68, 1
	%70 = mul i64 36, %69
	; IndexExpr
	%71 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %list, align 8
	%72 = extractvalue {%workbench.Vertex2D*, i64, i64, %mem.Allocator} %71, 0
	%73 = extractvalue {%workbench.Vertex2D*, i64, i64, %mem.Allocator} %71, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$64a, i64 0, i32 0), i64 62}, i64 581, i64 81, i64 0, i64 %73)
	%74 = getelementptr inbounds %workbench.Vertex2D, %workbench.Vertex2D* %72, i64 0
	%75 = bitcast %workbench.Vertex2D* %74 to %..rawptr
	call ccc void %67(i32 34962, i64 %70, %..rawptr %75, i32 35044)
	; program
	%76 = bitcast %runtime.Source_Code_Location* %10 to %..rawptr
	%77 = call %..rawptr @mem.zero(%..rawptr %76, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %10
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$64b, i64 0, i32 0), i64 62}, i64 583, i64 13, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$64c, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %10
	%78 = call i32 @workbench.get_current_shader(%runtime.Source_Code_Location* %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %78, i32* %9
	%79 = load i32, i32* %9, align 4
	%80 = bitcast %runtime.Source_Code_Location* %11 to %..rawptr
	%81 = call %..rawptr @mem.zero(%..rawptr %80, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %11
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$64d, i64 0, i32 0), i64 62}, i64 584, i64 2, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$64e, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %11
	call void @workbench.uniform1i(i32 %79, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$64f, i64 0, i32 0), i64 13}, i32 0, %runtime.Source_Code_Location* %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%82 = load i32, i32* %9, align 4
	; IndexExpr
	; IndexExpr
	%83 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* @workbench.mvp_matrix, i64 0, i32 0
	%84 = getelementptr inbounds [4 x float], [4 x float]* %83, i64 0, i32 0
	%85 = bitcast %runtime.Source_Code_Location* %12 to %..rawptr
	%86 = call %..rawptr @mem.zero(%..rawptr %85, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %12
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$650, i64 0, i32 0), i64 62}, i64 585, i64 2, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$651, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %12
	call void @workbench.uniform_matrix4fv(i32 %82, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$652, i64 0, i32 0), i64 10}, i32 1, i1 false, float* %84, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	%87 = load i32, i32* @workbench.num_draw_calls, align 4
	%88 = add i32 %87, 1
	store i32 %88, i32* @workbench.num_draw_calls
	; SelectorExpr
	%89 = load void (i32, i32, i32)*, void (i32, i32, i32)** @gl.DrawArrays, align 8
	%90 = load i32, i32* %0, align 4
	%91 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %list, align 8
	%92 = extractvalue {%workbench.Vertex2D*, i64, i64, %mem.Allocator} %91, 1
	%93 = trunc i64 %92 to i32
	call ccc void %89(i32 %90, i32 0, i32 %93)
	ret void
}

define void @runtime.clear_dynamic_array-17239({%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %array) alwaysinline #1 {
decls-0:
	%0 = alloca {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %mem.Raw_Dynamic_Array*, align 16
	store {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %array, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0
	; IfStmt
	%2 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0, align 8
	%3 = icmp ne {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %2, zeroinitializer
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; SelectorExpr
	%6 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0, align 8
	%7 = bitcast {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %6 to %mem.Raw_Dynamic_Array*
	%8 = bitcast %mem.Raw_Dynamic_Array** %1 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 8) noinline
	store %mem.Raw_Dynamic_Array* zeroinitializer, %mem.Raw_Dynamic_Array** %1
	store %mem.Raw_Dynamic_Array* %7, %mem.Raw_Dynamic_Array** %1
	%10 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %1, align 8
	%11 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %10, i64 0
	%12 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %11, i64 0, i32 1
	store i64 0, i64* %12
	br label %if.done-2

if.done-2:
	ret void
}

define i64 @runtime.append_elem-17267({%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %array, %workbench.Vertex2D* %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca %workbench.Vertex2D*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %array, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0
	%7 = load %workbench.Vertex2D, %workbench.Vertex2D* %arg, align 4
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %1
	; IfStmt
	%13 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {%workbench.Vertex2D*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {%workbench.Vertex2D*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %1, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {%workbench.Vertex2D*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %1, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %2
	; AssignStmt
	%32 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %2, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %3
	%37 = call i8 @runtime.reserve_dynamic_array-20852({%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {%workbench.Vertex2D*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {%workbench.Vertex2D*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %1, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %1
	; IfStmt
	%48 = load i64, i64* %1, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to %workbench.Vertex2D*
	store %workbench.Vertex2D* %58, %workbench.Vertex2D** %5
	%59 = load %workbench.Vertex2D*, %workbench.Vertex2D** %5, align 8
	%60 = icmp ne %workbench.Vertex2D* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$653, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$654, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; SelectorExpr
	; SelectorExpr
	%66 = load %workbench.Vertex2D*, %workbench.Vertex2D** %5, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call %workbench.Vertex2D* @mem.ptr_offset-20866(%workbench.Vertex2D* %66, i64 %70)
	%72 = bitcast %workbench.Vertex2D* %71 to %..rawptr
	%73 = bitcast %workbench.Vertex2D* %arg to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 36)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %1, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {%workbench.Vertex2D*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define {i64*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len-17443(i64 %len, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %mem.Allocator, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	store i64 %len, i64* %0
	%3 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%4 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; ReturnStmt
	%5 = load i64, i64* %0, align 8
	%6 = load i64, i64* %0, align 8
	%7 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%9 = bitcast %mem.Allocator* %1 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %1
	store %mem.Allocator %7, %mem.Allocator* %1
	%10 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %8, %runtime.Source_Code_Location* %2
	%11 = call {i64*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-20901(i64 %5, i64 %6, %mem.Allocator* %1, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i64*, i64, i64, %mem.Allocator} %11
}

define {%assimp.aiMesh**, i64} @mem.slice_ptr-17469(%assimp.aiMesh** %ptr, i64 %len) #0 {
decls-0:
	%0 = alloca %assimp.aiMesh**, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %mem.Raw_Slice, align 16
	%4 = alloca %mem.Raw_Slice, align 16
	store %assimp.aiMesh** %ptr, %assimp.aiMesh*** %0
	store i64 %len, i64* %1
	%5 = load i64, i64* %1, align 8
	%6 = icmp sge i64 %5, 0
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	%9 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$655, i64 0, i32 0), i64 53}, i64 93, i64 2, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$656, i64 0, i32 0), i64 9}}, %runtime.Source_Code_Location* %2
	%10 = call i8 @runtime.assert(i1 %8, %..string zeroinitializer, %runtime.Source_Code_Location* %2)
	; slice
	; CompoundLit
	%11 = bitcast %mem.Raw_Slice* %4 to %..rawptr
	store %mem.Raw_Slice zeroinitializer, %mem.Raw_Slice* %4
	store %mem.Raw_Slice {%..rawptr zeroinitializer, i64 zeroinitializer}, %mem.Raw_Slice* %4
	%12 = load %assimp.aiMesh**, %assimp.aiMesh*** %0, align 8
	%13 = bitcast %assimp.aiMesh** %12 to %..rawptr
	%14 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %4, i64 0, i32 0
	store %..rawptr %13, %..rawptr* %14
	%15 = load i64, i64* %1, align 8
	%16 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %4, i64 0, i32 1
	store i64 %15, i64* %16
	%17 = load %mem.Raw_Slice, %mem.Raw_Slice* %4, align 8
	store %mem.Raw_Slice %17, %mem.Raw_Slice* %3
	; ReturnStmt
	%18 = load %mem.Raw_Slice, %mem.Raw_Slice* %3, align 8
	%19 = bitcast %mem.Raw_Slice* %3 to {%assimp.aiMesh**, i64}*
	%20 = load {%assimp.aiMesh**, i64}, {%assimp.aiMesh**, i64}* %19, align 8
	ret {%assimp.aiMesh**, i64} %20
}

define {%assimp.aiVector3D*, i64} @mem.slice_ptr-17476(%assimp.aiVector3D* %ptr, i64 %len) #0 {
decls-0:
	%0 = alloca %assimp.aiVector3D*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %mem.Raw_Slice, align 16
	%4 = alloca %mem.Raw_Slice, align 16
	store %assimp.aiVector3D* %ptr, %assimp.aiVector3D** %0
	store i64 %len, i64* %1
	%5 = load i64, i64* %1, align 8
	%6 = icmp sge i64 %5, 0
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	%9 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$657, i64 0, i32 0), i64 53}, i64 93, i64 2, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$658, i64 0, i32 0), i64 9}}, %runtime.Source_Code_Location* %2
	%10 = call i8 @runtime.assert(i1 %8, %..string zeroinitializer, %runtime.Source_Code_Location* %2)
	; slice
	; CompoundLit
	%11 = bitcast %mem.Raw_Slice* %4 to %..rawptr
	store %mem.Raw_Slice zeroinitializer, %mem.Raw_Slice* %4
	store %mem.Raw_Slice {%..rawptr zeroinitializer, i64 zeroinitializer}, %mem.Raw_Slice* %4
	%12 = load %assimp.aiVector3D*, %assimp.aiVector3D** %0, align 8
	%13 = bitcast %assimp.aiVector3D* %12 to %..rawptr
	%14 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %4, i64 0, i32 0
	store %..rawptr %13, %..rawptr* %14
	%15 = load i64, i64* %1, align 8
	%16 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %4, i64 0, i32 1
	store i64 %15, i64* %16
	%17 = load %mem.Raw_Slice, %mem.Raw_Slice* %4, align 8
	store %mem.Raw_Slice %17, %mem.Raw_Slice* %3
	; ReturnStmt
	%18 = load %mem.Raw_Slice, %mem.Raw_Slice* %3, align 8
	%19 = bitcast %mem.Raw_Slice* %3 to {%assimp.aiVector3D*, i64}*
	%20 = load {%assimp.aiVector3D*, i64}, {%assimp.aiVector3D*, i64}* %19, align 8
	ret {%assimp.aiVector3D*, i64} %20
}

define {%workbench.Vertex3D*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-17527(i64 %len, i64 %cap, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %..rawptr, align 16
	%4 = alloca %mem.Allocator, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca %mem.Raw_Dynamic_Array, align 16
	%7 = alloca %mem.Raw_Dynamic_Array, align 16
	store i64 %len, i64* %0
	store i64 %cap, i64* %1
	%8 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%10 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%11 = load i64, i64* %0, align 8
	%12 = load i64, i64* %1, align 8
	%13 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %10, %runtime.Source_Code_Location* %2
	call void @runtime.make_dynamic_array_error_loc(%runtime.Source_Code_Location* %2, i64 %11, i64 %12)
	; data
	%14 = load i64, i64* %1, align 8
	%15 = mul i64 48, %14
	%16 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%17 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%18 = bitcast %mem.Allocator* %4 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %4
	store %mem.Allocator %16, %mem.Allocator* %4
	%19 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location %17, %runtime.Source_Code_Location* %5
	%20 = call %..rawptr @mem.alloc(i64 %15, i64 4, %mem.Allocator* %4, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %20, %..rawptr* %3
	; s
	; CompoundLit
	%21 = bitcast %mem.Raw_Dynamic_Array* %7 to %..rawptr
	store %mem.Raw_Dynamic_Array zeroinitializer, %mem.Raw_Dynamic_Array* %7
	store %mem.Raw_Dynamic_Array {%..rawptr zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %mem.Allocator zeroinitializer}, %mem.Raw_Dynamic_Array* %7
	%22 = load %..rawptr, %..rawptr* %3, align 8
	%23 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 0
	store %..rawptr %22, %..rawptr* %23
	%24 = load i64, i64* %0, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 1
	store i64 %24, i64* %25
	%26 = load i64, i64* %1, align 8
	%27 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 2
	store i64 %26, i64* %27
	%28 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%29 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 3
	store %mem.Allocator %28, %mem.Allocator* %29
	%30 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, align 8
	store %mem.Raw_Dynamic_Array %30, %mem.Raw_Dynamic_Array* %6
	; ReturnStmt
	%31 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %6, align 8
	%32 = bitcast %mem.Raw_Dynamic_Array* %6 to {%workbench.Vertex3D*, i64, i64, %mem.Allocator}*
	%33 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %32, align 8
	ret {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %33
}

define i64 @runtime.append_elem-17568({%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %array, %workbench.Vertex3D* %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.Vertex3D*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca %workbench.Vertex3D*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %array, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}** %0
	%7 = load %workbench.Vertex3D, %workbench.Vertex3D* %arg, align 4
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %1
	; IfStmt
	%13 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %1, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %1, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %2
	; AssignStmt
	%32 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %2, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %3
	%37 = call i8 @runtime.reserve_dynamic_array-20941({%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %1, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %1
	; IfStmt
	%48 = load i64, i64* %1, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to %workbench.Vertex3D*
	store %workbench.Vertex3D* %58, %workbench.Vertex3D** %5
	%59 = load %workbench.Vertex3D*, %workbench.Vertex3D** %5, align 8
	%60 = icmp ne %workbench.Vertex3D* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$659, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$65a, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; SelectorExpr
	; SelectorExpr
	%66 = load %workbench.Vertex3D*, %workbench.Vertex3D** %5, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call %workbench.Vertex3D* @mem.ptr_offset-20955(%workbench.Vertex3D* %66, i64 %70)
	%72 = bitcast %workbench.Vertex3D* %71 to %..rawptr
	%73 = bitcast %workbench.Vertex3D* %arg to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 48)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %1, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define i64 @runtime.append_elem-17600({i64*, i64, i64, %mem.Allocator}* %array, i64 %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i64*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	%5 = alloca %mem.Raw_Dynamic_Array*, align 16
	%6 = alloca i64*, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	store {i64*, i64, i64, %mem.Allocator}* %array, {i64*, i64, i64, %mem.Allocator}** %0
	store i64 %arg, i64* %1
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {i64*, i64, i64, %mem.Allocator}*, {i64*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {i64*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %2
	; IfStmt
	%13 = load {i64*, i64, i64, %mem.Allocator}*, {i64*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {i64*, i64, i64, %mem.Allocator}, {i64*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {i64*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {i64*, i64, i64, %mem.Allocator}*, {i64*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {i64*, i64, i64, %mem.Allocator}, {i64*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {i64*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %2, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {i64*, i64, i64, %mem.Allocator}*, {i64*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {i64*, i64, i64, %mem.Allocator}, {i64*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {i64*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %2, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %3
	; AssignStmt
	%32 = load {i64*, i64, i64, %mem.Allocator}*, {i64*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %3, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %4
	%37 = call i8 @runtime.reserve_dynamic_array-20997({i64*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {i64*, i64, i64, %mem.Allocator}*, {i64*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {i64*, i64, i64, %mem.Allocator}, {i64*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {i64*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {i64*, i64, i64, %mem.Allocator}*, {i64*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {i64*, i64, i64, %mem.Allocator}, {i64*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {i64*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %2, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %2
	; IfStmt
	%48 = load i64, i64* %2, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {i64*, i64, i64, %mem.Allocator}*, {i64*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {i64*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %5
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %5, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to i64*
	store i64* %58, i64** %6
	%59 = load i64*, i64** %6, align 8
	%60 = icmp ne i64* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$65b, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$65c, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %7
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %7)
	; SelectorExpr
	; SelectorExpr
	%66 = load i64*, i64** %6, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %5, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call i64* @mem.ptr_offset-21011(i64* %66, i64 %70)
	%72 = bitcast i64* %71 to %..rawptr
	%73 = bitcast i64* %1 to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 8)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %5, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %2, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {i64*, i64, i64, %mem.Allocator}*, {i64*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {i64*, i64, i64, %mem.Allocator}, {i64*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {i64*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define void @workbench.draw_vertex_list-17636({%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %list, i32 %mode, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %workbench.Vertex3D*, align 16
	%7 = alloca [3 x float], align 16
	%8 = alloca %workbench.Colorf, align 16
	%9 = alloca i32, align 16
	%10 = alloca %runtime.Source_Code_Location, align 16
	%11 = alloca %runtime.Source_Code_Location, align 16
	%12 = alloca %runtime.Source_Code_Location, align 16
	%13 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %list, align 8
	store i32 %mode, i32* %0
	%14 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%15 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %list, align 8
	%16 = extractvalue {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %15, 1
	%17 = icmp eq i64 %16, 0
	%18 = zext i1 %17 to i8
	%19 = trunc i8 %18 to i1
	br i1 %19, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; IfStmt
	%20 = load i32, i32* @workbench.debugging_rendering_max_draw_calls, align 4
	%21 = icmp ne i32 %20, -1
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %cmp.and-3, label %if.done-5

cmp.and-3:
	%24 = load i32, i32* @workbench.num_draw_calls, align 4
	%25 = load i32, i32* @workbench.debugging_rendering_max_draw_calls, align 4
	%26 = icmp sge i32 %24, %25
	%27 = zext i1 %26 to i8
	%28 = trunc i8 %27 to i1
	br i1 %28, label %if.then-4, label %if.done-5

if.then-4:
	; AssignStmt
	%29 = load i32, i32* @workbench.num_draw_calls, align 4
	%30 = add i32 %29, 1
	store i32 %30, i32* @workbench.num_draw_calls
	; ReturnStmt
	ret void

if.done-5:
	%31 = load i32, i32* @workbench.vao, align 4
	%32 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$65d, i64 0, i32 0), i64 62}, i64 566, i64 2, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$65e, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %1
	call void @workbench.bind_vao(i32 %31, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%34 = load i32, i32* @workbench.vbo, align 4
	%35 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$65f, i64 0, i32 0), i64 62}, i64 567, i64 2, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$660, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %2
	call void @workbench.bind_buffer_vbo(i32 %34, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%37 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%38 = call %..rawptr @mem.zero(%..rawptr %37, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$661, i64 0, i32 0), i64 62}, i64 569, i64 2, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$662, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %3
	call void @workbench.set_vertex_format-21041(%runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	%39 = load i8, i8* @workbench.debugging_rendering, align 1
	%40 = trunc i8 %39 to i1
	br i1 %40, label %if.then-6, label %if.done-10

if.then-6:
	; RangeStmt
	; i
	%41 = bitcast i64* %4 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	%43 = getelementptr inbounds {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %list, i64 0, i32 1
	%44 = bitcast i64* %5 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	store i64 -1, i64* %5
	br label %for.index.loop-7

for.index.loop-7:
	%46 = load i64, i64* %5, align 8
	%47 = add i64 %46, 1
	store i64 %47, i64* %5
	%48 = load i64, i64* %43, align 8
	%49 = icmp slt i64 %47, %48
	br i1 %49, label %for.index.body-8, label %for.index.done-9

for.index.body-8:
	%50 = load i64, i64* %5, align 8
	store i64 %50, i64* %4
	; vert
	; IndexExpr
	%51 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %list, align 8
	%52 = extractvalue {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %51, 0
	%53 = extractvalue {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %51, 1
	%54 = load i64, i64* %4, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$663, i64 0, i32 0), i64 62}, i64 574, i64 19, i64 %54, i64 %53)
	%55 = getelementptr inbounds %workbench.Vertex3D, %workbench.Vertex3D* %52, i64 %54
	store %workbench.Vertex3D* %55, %workbench.Vertex3D** %6
	%56 = load void (%runtime.Context*)*, void (%runtime.Context*)** @workbench.current_rendermode, align 8
	; SelectorExpr
	%57 = load %workbench.Vertex3D*, %workbench.Vertex3D** %6, align 8
	%58 = getelementptr inbounds %workbench.Vertex3D, %workbench.Vertex3D* %57, i64 0
	%59 = getelementptr inbounds %workbench.Vertex3D, %workbench.Vertex3D* %58, i64 0, i32 0
	%60 = load [3 x float], [3 x float]* %59, align 4
	%61 = load %workbench.Colorf, %workbench.Colorf* @workbench.COLOR_GREEN, align 4
	%62 = bitcast void (%runtime.Context*)* %56 to void (%runtime.Context*)*
	%63 = bitcast [3 x float]* %7 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %7
	store [3 x float] %60, [3 x float]* %7
	%65 = bitcast %workbench.Colorf* %8 to %..rawptr
	%66 = call %..rawptr @mem.zero(%..rawptr %65, i64 16) noinline
	store %workbench.Colorf zeroinitializer, %workbench.Colorf* %8
	store %workbench.Colorf %61, %workbench.Colorf* %8
	call void @workbench.push_debug_vertex(void (%runtime.Context*)* %62, [3 x float]* %7, %workbench.Colorf* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-7

for.index.done-9:
	br label %if.done-10

if.done-10:
	; SelectorExpr
	%67 = load void (i32, i64, %..rawptr, i32)*, void (i32, i64, %..rawptr, i32)** @gl.BufferData, align 8
	%68 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %list, align 8
	%69 = extractvalue {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %68, 1
	%70 = mul i64 48, %69
	; IndexExpr
	%71 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %list, align 8
	%72 = extractvalue {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %71, 0
	%73 = extractvalue {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %71, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$664, i64 0, i32 0), i64 62}, i64 581, i64 81, i64 0, i64 %73)
	%74 = getelementptr inbounds %workbench.Vertex3D, %workbench.Vertex3D* %72, i64 0
	%75 = bitcast %workbench.Vertex3D* %74 to %..rawptr
	call ccc void %67(i32 34962, i64 %70, %..rawptr %75, i32 35044)
	; program
	%76 = bitcast %runtime.Source_Code_Location* %10 to %..rawptr
	%77 = call %..rawptr @mem.zero(%..rawptr %76, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %10
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$665, i64 0, i32 0), i64 62}, i64 583, i64 13, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$666, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %10
	%78 = call i32 @workbench.get_current_shader(%runtime.Source_Code_Location* %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i32 %78, i32* %9
	%79 = load i32, i32* %9, align 4
	%80 = bitcast %runtime.Source_Code_Location* %11 to %..rawptr
	%81 = call %..rawptr @mem.zero(%..rawptr %80, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %11
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$667, i64 0, i32 0), i64 62}, i64 584, i64 2, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$668, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %11
	call void @workbench.uniform1i(i32 %79, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$669, i64 0, i32 0), i64 13}, i32 0, %runtime.Source_Code_Location* %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%82 = load i32, i32* %9, align 4
	; IndexExpr
	; IndexExpr
	%83 = getelementptr inbounds [4 x [4 x float]], [4 x [4 x float]]* @workbench.mvp_matrix, i64 0, i32 0
	%84 = getelementptr inbounds [4 x float], [4 x float]* %83, i64 0, i32 0
	%85 = bitcast %runtime.Source_Code_Location* %12 to %..rawptr
	%86 = call %..rawptr @mem.zero(%..rawptr %85, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %12
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$66a, i64 0, i32 0), i64 62}, i64 585, i64 2, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$66b, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %12
	call void @workbench.uniform_matrix4fv(i32 %82, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$66c, i64 0, i32 0), i64 10}, i32 1, i1 false, float* %84, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	%87 = load i32, i32* @workbench.num_draw_calls, align 4
	%88 = add i32 %87, 1
	store i32 %88, i32* @workbench.num_draw_calls
	; SelectorExpr
	%89 = load void (i32, i32, i32)*, void (i32, i32, i32)** @gl.DrawArrays, align 8
	%90 = load i32, i32* %0, align 4
	%91 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %list, align 8
	%92 = extractvalue {%workbench.Vertex3D*, i64, i64, %mem.Allocator} %91, 1
	%93 = trunc i64 %92 to i32
	call ccc void %89(i32 %90, i32 0, i32 %93)
	ret void
}

define {i8*, i64} @mem.slice_ptr-17810(i8* %ptr, i64 %len) #0 {
decls-0:
	%0 = alloca i8*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %mem.Raw_Slice, align 16
	%4 = alloca %mem.Raw_Slice, align 16
	store i8* %ptr, i8** %0
	store i64 %len, i64* %1
	%5 = load i64, i64* %1, align 8
	%6 = icmp sge i64 %5, 0
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	%9 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$66d, i64 0, i32 0), i64 53}, i64 93, i64 2, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$66e, i64 0, i32 0), i64 9}}, %runtime.Source_Code_Location* %2
	%10 = call i8 @runtime.assert(i1 %8, %..string zeroinitializer, %runtime.Source_Code_Location* %2)
	; slice
	; CompoundLit
	%11 = bitcast %mem.Raw_Slice* %4 to %..rawptr
	store %mem.Raw_Slice zeroinitializer, %mem.Raw_Slice* %4
	store %mem.Raw_Slice {%..rawptr zeroinitializer, i64 zeroinitializer}, %mem.Raw_Slice* %4
	%12 = load i8*, i8** %0, align 8
	%13 = bitcast i8* %12 to %..rawptr
	%14 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %4, i64 0, i32 0
	store %..rawptr %13, %..rawptr* %14
	%15 = load i64, i64* %1, align 8
	%16 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %4, i64 0, i32 1
	store i64 %15, i64* %16
	%17 = load %mem.Raw_Slice, %mem.Raw_Slice* %4, align 8
	store %mem.Raw_Slice %17, %mem.Raw_Slice* %3
	; ReturnStmt
	%18 = load %mem.Raw_Slice, %mem.Raw_Slice* %3, align 8
	%19 = bitcast %mem.Raw_Slice* %3 to {i8*, i64}*
	%20 = load {i8*, i64}, {i8*, i64}* %19, align 8
	ret {i8*, i64} %20
}

define void @workbench.rolling_average_push_sample-17819(%"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %ra, double %sample, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"*, align 16
	%1 = alloca double, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	store %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %ra, %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"** %0
	store double %sample, double* %1
	%3 = load %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"*, %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"** %0, align 8
	%4 = icmp ne %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %3, zeroinitializer
	%5 = zext i1 %4 to i8
	%6 = trunc i8 %5 to i1
	%7 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([74 x i8], [74 x i8]* @str$66f, i64 0, i32 0), i64 73}, i64 10, i64 2, %..string {i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$670, i64 0, i32 0), i64 27}}, %runtime.Source_Code_Location* %2
	%9 = call i8 @runtime.assert(i1 %6, %..string zeroinitializer, %runtime.Source_Code_Location* %2)
	; AssignStmt
	; IndexExpr
	%10 = load %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"*, %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"** %0, align 8
	%11 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %10, i64 0
	%12 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %11, i64 0, i32 0
	%13 = load %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"*, %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"** %0, align 8
	%14 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %13, i64 0
	%15 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %14, i64 0, i32 1
	%16 = load i64, i64* %15, align 8
	%17 = trunc i64 %16 to i32
	%18 = getelementptr inbounds [100 x double], [100 x double]* %12, i64 0, i32 %17
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([74 x i8], [74 x i8]* @str$671, i64 0, i32 0), i64 73}, i64 11, i64 9, i64 %16, i64 100)
	%19 = load double, double* %1, align 8
	store double %19, double* %18
	; AssignStmt
	%20 = load %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"*, %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"** %0, align 8
	%21 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %20, i64 0
	%22 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %21, i64 0, i32 1
	%23 = load %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"*, %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"** %0, align 8
	%24 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %23, i64 0
	%25 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %24, i64 0, i32 1
	%26 = load i64, i64* %25, align 8
	%27 = add i64 %26, 1
	%28 = srem i64 %27, 100
	store i64 %28, i64* %22
	; IfStmt
	%29 = load %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"*, %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"** %0, align 8
	%30 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %29, i64 0
	%31 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %30, i64 0, i32 1
	%32 = load i64, i64* %31, align 8
	%33 = icmp eq i64 %32, 0
	%34 = zext i1 %33 to i8
	%35 = trunc i8 %34 to i1
	br i1 %35, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	%36 = load %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"*, %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"** %0, align 8
	%37 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %36, i64 0
	%38 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %37, i64 0, i32 2
	store i8 1, i8* %38
	br label %if.done-2

if.done-2:
	ret void
}

define i64 @runtime.append_elem-17835({%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %array, %workbench._Scene_Internal* %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca %workbench._Scene_Internal*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %array, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0
	%7 = load %workbench._Scene_Internal, %workbench._Scene_Internal* %arg, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %1
	; IfStmt
	%13 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {%workbench._Scene_Internal*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {%workbench._Scene_Internal*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %1, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {%workbench._Scene_Internal*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %1, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %2
	; AssignStmt
	%32 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %2, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %3
	%37 = call i8 @runtime.reserve_dynamic_array-21086({%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {%workbench._Scene_Internal*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {%workbench._Scene_Internal*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %1, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %1
	; IfStmt
	%48 = load i64, i64* %1, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to %workbench._Scene_Internal*
	store %workbench._Scene_Internal* %58, %workbench._Scene_Internal** %5
	%59 = load %workbench._Scene_Internal*, %workbench._Scene_Internal** %5, align 8
	%60 = icmp ne %workbench._Scene_Internal* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$672, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$673, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; SelectorExpr
	; SelectorExpr
	%66 = load %workbench._Scene_Internal*, %workbench._Scene_Internal** %5, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call %workbench._Scene_Internal* @mem.ptr_offset-21100(%workbench._Scene_Internal* %66, i64 %70)
	%72 = bitcast %workbench._Scene_Internal* %71 to %..rawptr
	%73 = bitcast %workbench._Scene_Internal* %arg to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 56)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %1, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {%workbench._Scene_Internal*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define void @runtime.clear_dynamic_array-17894({%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %array) alwaysinline #1 {
decls-0:
	%0 = alloca {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %mem.Raw_Dynamic_Array*, align 16
	store {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %array, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0
	; IfStmt
	%2 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0, align 8
	%3 = icmp ne {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %2, zeroinitializer
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; SelectorExpr
	%6 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0, align 8
	%7 = bitcast {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %6 to %mem.Raw_Dynamic_Array*
	%8 = bitcast %mem.Raw_Dynamic_Array** %1 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 8) noinline
	store %mem.Raw_Dynamic_Array* zeroinitializer, %mem.Raw_Dynamic_Array** %1
	store %mem.Raw_Dynamic_Array* %7, %mem.Raw_Dynamic_Array** %1
	%10 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %1, align 8
	%11 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %10, i64 0
	%12 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %11, i64 0, i32 1
	store i64 0, i64* %12
	br label %if.done-2

if.done-2:
	ret void
}

define void @runtime.delete_key-17924({{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}* %m, i64 %key, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Map_Header, align 16
	%3 = alloca %runtime.Map_Key, align 16
	store {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}* %m, {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}** %0
	store i64 %key, i64* %1
	; IfStmt
	%4 = load {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}*, {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}** %0, align 8
	%5 = icmp ne {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	%8 = load {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}*, {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}** %0, align 8
	%9 = call %runtime.Map_Header @runtime.__get_map_header-21196({{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}* %8)
	%10 = load i64, i64* %1, align 8
	%11 = call %runtime.Map_Key @runtime.__get_map_key-21200(i64 %10)
	%12 = bitcast %runtime.Map_Header* %2 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %2
	store %runtime.Map_Header %9, %runtime.Map_Header* %2
	%14 = bitcast %runtime.Map_Key* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %3
	store %runtime.Map_Key %11, %runtime.Map_Key* %3
	call void @runtime.__dynamic_map_delete_key(%runtime.Map_Header* %2, %runtime.Map_Key* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-2

if.done-2:
	ret void
}

define double @workbench.rolling_average_get_value-17951(%"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %ra, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"*, align 16
	%1 = alloca double, align 16
	%2 = alloca i64, align 16
	%3 = alloca double, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	store %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %ra, %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"** %0
	; value
	%7 = bitcast double* %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 8) noinline
	store double zeroinitializer, double* %1
	; count
	%9 = bitcast i64* %2 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; RangeStmt
	; sample
	%11 = bitcast double* %3 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 8) noinline
	store double zeroinitializer, double* %3
	; i
	%13 = bitcast i64* %4 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	%15 = load %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"*, %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"** %0, align 8
	%16 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %15, i64 0
	%17 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %16, i64 0, i32 0
	%18 = bitcast i64* %5 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	store i64 100, i64* %5
	%20 = bitcast i64* %6 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 8) noinline
	store i64 zeroinitializer, i64* %6
	store i64 -1, i64* %6
	br label %for.index.loop-1

for.index.loop-1:
	%22 = load i64, i64* %6, align 8
	%23 = add i64 %22, 1
	store i64 %23, i64* %6
	%24 = icmp slt i64 %23, 100
	br i1 %24, label %for.index.body-2, label %for.index.done-7

for.index.body-2:
	%25 = load i64, i64* %6, align 8
	%26 = trunc i64 %25 to i32
	%27 = getelementptr inbounds [100 x double], [100 x double]* %17, i64 0, i32 %26
	%28 = load double, double* %27, align 8
	store double %28, double* %3
	store i64 %25, i64* %4
	; IfStmt
	; SelectorExpr
	%29 = load %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"*, %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"** %0, align 8
	%30 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %29, i64 0
	%31 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %30, i64 0, i32 2
	%32 = load i8, i8* %31, align 1
	%33 = trunc i8 %32 to i1
	br i1 %33, label %if.done-6, label %if.then-3

if.then-3:
	; IfStmt
	%34 = load i64, i64* %4, align 8
	%35 = load %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"*, %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"** %0, align 8
	%36 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %35, i64 0
	%37 = getelementptr inbounds %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29", %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29"* %36, i64 0, i32 1
	%38 = load i64, i64* %37, align 8
	%39 = icmp sge i64 %34, %38
	%40 = zext i1 %39 to i8
	%41 = trunc i8 %40 to i1
	br i1 %41, label %if.then-4, label %if.done-5

if.then-4:
	; break
	br label %for.index.done-7

if.done-5:
	br label %if.done-6

if.done-6:
	; AssignStmt
	%42 = load double, double* %3, align 8
	%43 = load double, double* %1, align 8
	%44 = fadd double %43, %42
	store double %44, double* %1
	; AssignStmt
	%45 = load i64, i64* %2, align 8
	%46 = add i64 %45, 1
	store i64 %46, i64* %2
	br label %for.index.loop-1

for.index.done-7:
	; IfStmt
	%47 = load i64, i64* %2, align 8
	%48 = icmp sge i64 %47, 1
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-8, label %if.done-9

if.then-8:
	; AssignStmt
	%51 = load i64, i64* %2, align 8
	%52 = sitofp i64 %51 to double
	%53 = load double, double* %1, align 8
	%54 = fdiv double %53, %52
	store double %54, double* %1
	br label %if.done-9

if.done-9:
	; ReturnStmt
	%55 = load double, double* %1, align 8
	ret double %55
}

define void @workbench.imgui_struct-17955(%workbench.WB_Debug_Data* %value, %..string %name, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %workbench.WB_Debug_Data*, align 16
	%1 = alloca %..string, align 16
	store %workbench.WB_Debug_Data* %value, %workbench.WB_Debug_Data** %0
	store %..string %name, %..string* %1
	; SelectorExpr
	%2 = load %imgui.Font*, %imgui.Font** @workbench.imgui_font_mono, align 8
	call ccc void @igPushFont(%imgui.Font* %2) alwaysinline
	; DeferStmt
	%3 = load %..string, %..string* %1, align 8
	%4 = load %workbench.WB_Debug_Data*, %workbench.WB_Debug_Data** %0, align 8
	%5 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 117
	%6 = bitcast %workbench.WB_Debug_Data* %4 to %..rawptr
	call void @workbench._imgui_struct_internal(%..string %3, %..rawptr %6, %runtime.Type_Info* %5, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	; defer
	; SelectorExpr
	call ccc void @igPopFont() alwaysinline
	ret void
}

define void @workbench.remove_at-18157({%workbench.Tweener**, i64, i64, %mem.Allocator}* %array, i64 %to_remove, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.Tweener**, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	store {%workbench.Tweener**, i64, i64, %mem.Allocator}* %array, {%workbench.Tweener**, i64, i64, %mem.Allocator}** %0
	store i64 %to_remove, i64* %1
	; AssignStmt
	; IndexExpr
	%2 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}*, {%workbench.Tweener**, i64, i64, %mem.Allocator}** %0, align 8
	%3 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}, {%workbench.Tweener**, i64, i64, %mem.Allocator}* %2, align 8
	%4 = extractvalue {%workbench.Tweener**, i64, i64, %mem.Allocator} %3, 0
	%5 = extractvalue {%workbench.Tweener**, i64, i64, %mem.Allocator} %3, 1
	%6 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$674, i64 0, i32 0), i64 63}, i64 57, i64 8, i64 %6, i64 %5)
	%7 = getelementptr inbounds %workbench.Tweener*, %workbench.Tweener** %4, i64 %6
	; IndexExpr
	%8 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}*, {%workbench.Tweener**, i64, i64, %mem.Allocator}** %0, align 8
	%9 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}, {%workbench.Tweener**, i64, i64, %mem.Allocator}* %8, align 8
	%10 = extractvalue {%workbench.Tweener**, i64, i64, %mem.Allocator} %9, 0
	%11 = extractvalue {%workbench.Tweener**, i64, i64, %mem.Allocator} %9, 1
	%12 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}*, {%workbench.Tweener**, i64, i64, %mem.Allocator}** %0, align 8
	%13 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}, {%workbench.Tweener**, i64, i64, %mem.Allocator}* %12, align 8
	%14 = extractvalue {%workbench.Tweener**, i64, i64, %mem.Allocator} %13, 1
	%15 = sub i64 %14, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$675, i64 0, i32 0), i64 63}, i64 57, i64 27, i64 %15, i64 %11)
	%16 = getelementptr inbounds %workbench.Tweener*, %workbench.Tweener** %10, i64 %15
	%17 = load %workbench.Tweener*, %workbench.Tweener** %16, align 8
	store %workbench.Tweener* %17, %workbench.Tweener** %7
	%18 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}*, {%workbench.Tweener**, i64, i64, %mem.Allocator}** %0, align 8
	%19 = call %workbench.Tweener* @runtime.pop-21343({%workbench.Tweener**, i64, i64, %mem.Allocator}* %18)
	ret void
}

define float @workbench._update_one_tweener-18165(%workbench.Tweener* %tweener, float %dt, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %workbench.Tweener*, align 16
	%1 = alloca float, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca {float, i8}, align 16
	%4 = alloca float, align 16
	%5 = alloca {float, i8}, align 16
	%6 = alloca {[0 x <4 x i8>], [16 x i8], i8}, align 16
	%7 = alloca float, align 16
	%8 = alloca float, align 16
	%9 = alloca {float, i8}, align 16
	%10 = alloca float, align 16
	%11 = alloca {float, i8}, align 16
	%12 = alloca float, align 16
	store %workbench.Tweener* %tweener, %workbench.Tweener** %0
	store float %dt, float* %1
	; AssignStmt
	; SelectorExpr
	%13 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%14 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %13, i64 0
	%15 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %14, i64 0, i32 4
	%16 = load float, float* %1, align 4
	%17 = load float, float* %15, align 4
	%18 = fadd float %17, %16
	store float %18, float* %15
	; SelectorExpr
	%19 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%20 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %19, i64 0
	%21 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %20, i64 0, i32 4
	%22 = load float, float* %21, align 4
	%23 = fcmp one float %22, 0x0000000000000000
	%24 = zext i1 %23 to i8
	%25 = trunc i8 %24 to i1
	%26 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$676, i64 0, i32 0), i64 63}, i64 135, i64 2, %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$677, i64 0, i32 0), i64 19}}, %runtime.Source_Code_Location* %2
	%28 = call i8 @runtime.assert(i1 %25, %..string zeroinitializer, %runtime.Source_Code_Location* %2)
	; ForStmt
	br label %for.loop-1

for.loop-1:
	; SelectorExpr
	%29 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%30 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %29, i64 0
	%31 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %30, i64 0, i32 4
	%32 = load float, float* %31, align 4
	; SelectorExpr
	%33 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%34 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %33, i64 0
	%35 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %34, i64 0, i32 5
	%36 = load float, float* %35, align 4
	%37 = fcmp oge float %32, %36
	%38 = zext i1 %37 to i8
	%39 = trunc i8 %38 to i1
	br i1 %39, label %for.body-2, label %for.done-9

for.body-2:
	; IfStmt
	; SelectorExpr
	%40 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%41 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %40, i64 0
	%42 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %41, i64 0, i32 8
	%43 = load i8, i8* %42, align 1
	%44 = trunc i8 %43 to i1
	br i1 %44, label %if.done-6, label %if.then-3

if.then-3:
	; ReturnStmt
	; SelectorExpr
	%45 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%46 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %45, i64 0
	%47 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %46, i64 0, i32 3
	%48 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %47, align 4
	; cast - union_cast
	%49 = bitcast {float, i8}* %3 to %..rawptr
	%50 = call %..rawptr @mem.zero(%..rawptr %49, i64 8) noinline
	store {float, i8} zeroinitializer, {float, i8}* %3
	%51 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %47, i64 0, i32 2 ; UnionTagPtr
	%52 = load i8, i8* %51, align 1
	%53 = icmp eq i8 %52, 2
	br i1 %53, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%54 = getelementptr inbounds {float, i8}, {float, i8}* %3, i64 0, i32 0
	%55 = getelementptr inbounds {float, i8}, {float, i8}* %3, i64 0, i32 1
	%56 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %47 to float*
	%57 = load float, float* %56, align 4
	store float %57, float* %54
	store i8 1, i8* %55
	br label %union_cast.end-5

union_cast.end-5:
	%58 = getelementptr inbounds {float, i8}, {float, i8}* %3, i64 0, i32 1
	%59 = load i8, i8* %58, align 1
	%60 = trunc i8 %59 to i1
	call void @runtime.type_assertion_check(i1 %60, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$678, i64 0, i32 0), i64 63}, i64 138, i64 38, %..typeid 1152921504606847090, %..typeid 216172782113783891)
	%61 = getelementptr inbounds {float, i8}, {float, i8}* %3, i64 0, i32 0
	%62 = load float, float* %61, align 4
	ret float %62

if.done-6:
	; AssignStmt
	; SelectorExpr
	%63 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%64 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %63, i64 0
	%65 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %64, i64 0, i32 4
	; SelectorExpr
	%66 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%67 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %66, i64 0
	%68 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %67, i64 0, i32 5
	%69 = load float, float* %68, align 4
	%70 = load float, float* %65, align 4
	%71 = fsub float %70, %69
	store float %71, float* %65
	; start
	; SelectorExpr
	%72 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%73 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %72, i64 0
	%74 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %73, i64 0, i32 2
	%75 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %74, align 4
	; cast - union_cast
	%76 = bitcast {float, i8}* %5 to %..rawptr
	%77 = call %..rawptr @mem.zero(%..rawptr %76, i64 8) noinline
	store {float, i8} zeroinitializer, {float, i8}* %5
	%78 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %74, i64 0, i32 2 ; UnionTagPtr
	%79 = load i8, i8* %78, align 1
	%80 = icmp eq i8 %79, 2
	br i1 %80, label %union_cast.ok-7, label %union_cast.end-8

union_cast.ok-7:
	%81 = getelementptr inbounds {float, i8}, {float, i8}* %5, i64 0, i32 0
	%82 = getelementptr inbounds {float, i8}, {float, i8}* %5, i64 0, i32 1
	%83 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %74 to float*
	%84 = load float, float* %83, align 4
	store float %84, float* %81
	store i8 1, i8* %82
	br label %union_cast.end-8

union_cast.end-8:
	%85 = getelementptr inbounds {float, i8}, {float, i8}* %5, i64 0, i32 1
	%86 = load i8, i8* %85, align 1
	%87 = trunc i8 %86 to i1
	call void @runtime.type_assertion_check(i1 %87, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$679, i64 0, i32 0), i64 63}, i64 142, i64 20, %..typeid 1152921504606847090, %..typeid 216172782113783891)
	%88 = getelementptr inbounds {float, i8}, {float, i8}* %5, i64 0, i32 0
	%89 = load float, float* %88, align 4
	store float %89, float* %4
	; AssignStmt
	; SelectorExpr
	%90 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%91 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %90, i64 0
	%92 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %91, i64 0, i32 2
	; SelectorExpr
	%93 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%94 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %93, i64 0
	%95 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %94, i64 0, i32 3
	%96 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %95, align 4
	store {[0 x <4 x i8>], [16 x i8], i8} %96, {[0 x <4 x i8>], [16 x i8], i8}* %92
	; AssignStmt
	; SelectorExpr
	%97 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%98 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %97, i64 0
	%99 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %98, i64 0, i32 3
	%100 = load float, float* %4, align 4
	; union - child to parent
	%101 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %6 to %..rawptr
	%102 = call %..rawptr @mem.zero(%..rawptr %101, i64 20) noinline
	store {[0 x <4 x i8>], [16 x i8], i8} zeroinitializer, {[0 x <4 x i8>], [16 x i8], i8}* %6
	%103 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %6 to float*
	store float %100, float* %103
	%104 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %6, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %104
	%105 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %6, align 4
	store {[0 x <4 x i8>], [16 x i8], i8} %105, {[0 x <4 x i8>], [16 x i8], i8}* %99
	br label %for.loop-1

for.done-9:
	; t
	; SelectorExpr
	%106 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%107 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %106, i64 0
	%108 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %107, i64 0, i32 4
	%109 = load float, float* %108, align 4
	; SelectorExpr
	%110 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%111 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %110, i64 0
	%112 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %111, i64 0, i32 5
	%113 = load float, float* %112, align 4
	%114 = fdiv float %109, %113
	store float %114, float* %7
	; AssignStmt
	; SelectorExpr
	%115 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%116 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %115, i64 0
	%117 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %116, i64 0, i32 6
	%118 = load float (float, %runtime.Context*)*, float (float, %runtime.Context*)** %117, align 8
	%119 = load float, float* %7, align 4
	%120 = call float %118(float %119, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store float %120, float* %7
	; a
	; SelectorExpr
	%121 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%122 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %121, i64 0
	%123 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %122, i64 0, i32 2
	%124 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %123, align 4
	; cast - union_cast
	%125 = bitcast {float, i8}* %9 to %..rawptr
	%126 = call %..rawptr @mem.zero(%..rawptr %125, i64 8) noinline
	store {float, i8} zeroinitializer, {float, i8}* %9
	%127 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %123, i64 0, i32 2 ; UnionTagPtr
	%128 = load i8, i8* %127, align 1
	%129 = icmp eq i8 %128, 2
	br i1 %129, label %union_cast.ok-10, label %union_cast.end-11

union_cast.ok-10:
	%130 = getelementptr inbounds {float, i8}, {float, i8}* %9, i64 0, i32 0
	%131 = getelementptr inbounds {float, i8}, {float, i8}* %9, i64 0, i32 1
	%132 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %123 to float*
	%133 = load float, float* %132, align 4
	store float %133, float* %130
	store i8 1, i8* %131
	br label %union_cast.end-11

union_cast.end-11:
	%134 = getelementptr inbounds {float, i8}, {float, i8}* %9, i64 0, i32 1
	%135 = load i8, i8* %134, align 1
	%136 = trunc i8 %135 to i1
	call void @runtime.type_assertion_check(i1 %136, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$67a, i64 0, i32 0), i64 63}, i64 150, i64 15, %..typeid 1152921504606847090, %..typeid 216172782113783891)
	%137 = getelementptr inbounds {float, i8}, {float, i8}* %9, i64 0, i32 0
	%138 = load float, float* %137, align 4
	store float %138, float* %8
	; b
	; SelectorExpr
	%139 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%140 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %139, i64 0
	%141 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %140, i64 0, i32 3
	%142 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %141, align 4
	; cast - union_cast
	%143 = bitcast {float, i8}* %11 to %..rawptr
	%144 = call %..rawptr @mem.zero(%..rawptr %143, i64 8) noinline
	store {float, i8} zeroinitializer, {float, i8}* %11
	%145 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %141, i64 0, i32 2 ; UnionTagPtr
	%146 = load i8, i8* %145, align 1
	%147 = icmp eq i8 %146, 2
	br i1 %147, label %union_cast.ok-12, label %union_cast.end-13

union_cast.ok-12:
	%148 = getelementptr inbounds {float, i8}, {float, i8}* %11, i64 0, i32 0
	%149 = getelementptr inbounds {float, i8}, {float, i8}* %11, i64 0, i32 1
	%150 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %141 to float*
	%151 = load float, float* %150, align 4
	store float %151, float* %148
	store i8 1, i8* %149
	br label %union_cast.end-13

union_cast.end-13:
	%152 = getelementptr inbounds {float, i8}, {float, i8}* %11, i64 0, i32 1
	%153 = load i8, i8* %152, align 1
	%154 = trunc i8 %153 to i1
	call void @runtime.type_assertion_check(i1 %154, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$67b, i64 0, i32 0), i64 63}, i64 151, i64 15, %..typeid 1152921504606847090, %..typeid 216172782113783891)
	%155 = getelementptr inbounds {float, i8}, {float, i8}* %11, i64 0, i32 0
	%156 = load float, float* %155, align 4
	store float %156, float* %10
	; result
	%157 = load float, float* %8, align 4
	%158 = load float, float* %10, align 4
	%159 = load float, float* %7, align 4
	%160 = call float @math.lerp-16575(float %157, float %158, float %159, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store float %160, float* %12
	; ReturnStmt
	%161 = load float, float* %12, align 4
	ret float %161
}

define [2 x float] @workbench._update_one_tweener-18171(%workbench.Tweener* %tweener, float %dt, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %workbench.Tweener*, align 16
	%1 = alloca float, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca {[2 x float], i8}, align 16
	%4 = alloca [2 x float], align 16
	%5 = alloca {[2 x float], i8}, align 16
	%6 = alloca {[0 x <4 x i8>], [16 x i8], i8}, align 16
	%7 = alloca float, align 16
	%8 = alloca [2 x float], align 16
	%9 = alloca {[2 x float], i8}, align 16
	%10 = alloca [2 x float], align 16
	%11 = alloca {[2 x float], i8}, align 16
	%12 = alloca [2 x float], align 16
	%13 = alloca [2 x float], align 16
	%14 = alloca [2 x float], align 16
	store %workbench.Tweener* %tweener, %workbench.Tweener** %0
	store float %dt, float* %1
	; AssignStmt
	; SelectorExpr
	%15 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%16 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %15, i64 0
	%17 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %16, i64 0, i32 4
	%18 = load float, float* %1, align 4
	%19 = load float, float* %17, align 4
	%20 = fadd float %19, %18
	store float %20, float* %17
	; SelectorExpr
	%21 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%22 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %21, i64 0
	%23 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %22, i64 0, i32 4
	%24 = load float, float* %23, align 4
	%25 = fcmp one float %24, 0x0000000000000000
	%26 = zext i1 %25 to i8
	%27 = trunc i8 %26 to i1
	%28 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$67c, i64 0, i32 0), i64 63}, i64 135, i64 2, %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$67d, i64 0, i32 0), i64 19}}, %runtime.Source_Code_Location* %2
	%30 = call i8 @runtime.assert(i1 %27, %..string zeroinitializer, %runtime.Source_Code_Location* %2)
	; ForStmt
	br label %for.loop-1

for.loop-1:
	; SelectorExpr
	%31 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%32 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %31, i64 0
	%33 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %32, i64 0, i32 4
	%34 = load float, float* %33, align 4
	; SelectorExpr
	%35 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%36 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %35, i64 0
	%37 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %36, i64 0, i32 5
	%38 = load float, float* %37, align 4
	%39 = fcmp oge float %34, %38
	%40 = zext i1 %39 to i8
	%41 = trunc i8 %40 to i1
	br i1 %41, label %for.body-2, label %for.done-9

for.body-2:
	; IfStmt
	; SelectorExpr
	%42 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%43 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %42, i64 0
	%44 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %43, i64 0, i32 8
	%45 = load i8, i8* %44, align 1
	%46 = trunc i8 %45 to i1
	br i1 %46, label %if.done-6, label %if.then-3

if.then-3:
	; ReturnStmt
	; SelectorExpr
	%47 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%48 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %47, i64 0
	%49 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %48, i64 0, i32 3
	%50 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %49, align 4
	; cast - union_cast
	%51 = bitcast {[2 x float], i8}* %3 to %..rawptr
	%52 = call %..rawptr @mem.zero(%..rawptr %51, i64 12) noinline
	store {[2 x float], i8} zeroinitializer, {[2 x float], i8}* %3
	%53 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %49, i64 0, i32 2 ; UnionTagPtr
	%54 = load i8, i8* %53, align 1
	%55 = icmp eq i8 %54, 1
	br i1 %55, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%56 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %3, i64 0, i32 0
	%57 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %3, i64 0, i32 1
	%58 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %49 to [2 x float]*
	%59 = load [2 x float], [2 x float]* %58, align 4
	store [2 x float] %59, [2 x float]* %56
	store i8 1, i8* %57
	br label %union_cast.end-5

union_cast.end-5:
	%60 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %3, i64 0, i32 1
	%61 = load i8, i8* %60, align 1
	%62 = trunc i8 %61 to i1
	call void @runtime.type_assertion_check(i1 %62, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$67e, i64 0, i32 0), i64 63}, i64 138, i64 38, %..typeid 1152921504606847090, %..typeid 3098476543630901354)
	%63 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %3, i64 0, i32 0
	%64 = load [2 x float], [2 x float]* %63, align 4
	ret [2 x float] %64

if.done-6:
	; AssignStmt
	; SelectorExpr
	%65 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%66 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %65, i64 0
	%67 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %66, i64 0, i32 4
	; SelectorExpr
	%68 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%69 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %68, i64 0
	%70 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %69, i64 0, i32 5
	%71 = load float, float* %70, align 4
	%72 = load float, float* %67, align 4
	%73 = fsub float %72, %71
	store float %73, float* %67
	; start
	; SelectorExpr
	%74 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%75 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %74, i64 0
	%76 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %75, i64 0, i32 2
	%77 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %76, align 4
	; cast - union_cast
	%78 = bitcast {[2 x float], i8}* %5 to %..rawptr
	%79 = call %..rawptr @mem.zero(%..rawptr %78, i64 12) noinline
	store {[2 x float], i8} zeroinitializer, {[2 x float], i8}* %5
	%80 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %76, i64 0, i32 2 ; UnionTagPtr
	%81 = load i8, i8* %80, align 1
	%82 = icmp eq i8 %81, 1
	br i1 %82, label %union_cast.ok-7, label %union_cast.end-8

union_cast.ok-7:
	%83 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %5, i64 0, i32 0
	%84 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %5, i64 0, i32 1
	%85 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %76 to [2 x float]*
	%86 = load [2 x float], [2 x float]* %85, align 4
	store [2 x float] %86, [2 x float]* %83
	store i8 1, i8* %84
	br label %union_cast.end-8

union_cast.end-8:
	%87 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %5, i64 0, i32 1
	%88 = load i8, i8* %87, align 1
	%89 = trunc i8 %88 to i1
	call void @runtime.type_assertion_check(i1 %89, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$67f, i64 0, i32 0), i64 63}, i64 142, i64 20, %..typeid 1152921504606847090, %..typeid 3098476543630901354)
	%90 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %5, i64 0, i32 0
	%91 = load [2 x float], [2 x float]* %90, align 4
	store [2 x float] %91, [2 x float]* %4
	; AssignStmt
	; SelectorExpr
	%92 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%93 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %92, i64 0
	%94 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %93, i64 0, i32 2
	; SelectorExpr
	%95 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%96 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %95, i64 0
	%97 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %96, i64 0, i32 3
	%98 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %97, align 4
	store {[0 x <4 x i8>], [16 x i8], i8} %98, {[0 x <4 x i8>], [16 x i8], i8}* %94
	; AssignStmt
	; SelectorExpr
	%99 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%100 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %99, i64 0
	%101 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %100, i64 0, i32 3
	%102 = load [2 x float], [2 x float]* %4, align 4
	; union - child to parent
	%103 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %6 to %..rawptr
	%104 = call %..rawptr @mem.zero(%..rawptr %103, i64 20) noinline
	store {[0 x <4 x i8>], [16 x i8], i8} zeroinitializer, {[0 x <4 x i8>], [16 x i8], i8}* %6
	%105 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %6 to [2 x float]*
	store [2 x float] %102, [2 x float]* %105
	%106 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %6, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %106
	%107 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %6, align 4
	store {[0 x <4 x i8>], [16 x i8], i8} %107, {[0 x <4 x i8>], [16 x i8], i8}* %101
	br label %for.loop-1

for.done-9:
	; t
	; SelectorExpr
	%108 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%109 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %108, i64 0
	%110 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %109, i64 0, i32 4
	%111 = load float, float* %110, align 4
	; SelectorExpr
	%112 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%113 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %112, i64 0
	%114 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %113, i64 0, i32 5
	%115 = load float, float* %114, align 4
	%116 = fdiv float %111, %115
	store float %116, float* %7
	; AssignStmt
	; SelectorExpr
	%117 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%118 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %117, i64 0
	%119 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %118, i64 0, i32 6
	%120 = load float (float, %runtime.Context*)*, float (float, %runtime.Context*)** %119, align 8
	%121 = load float, float* %7, align 4
	%122 = call float %120(float %121, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store float %122, float* %7
	; a
	; SelectorExpr
	%123 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%124 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %123, i64 0
	%125 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %124, i64 0, i32 2
	%126 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %125, align 4
	; cast - union_cast
	%127 = bitcast {[2 x float], i8}* %9 to %..rawptr
	%128 = call %..rawptr @mem.zero(%..rawptr %127, i64 12) noinline
	store {[2 x float], i8} zeroinitializer, {[2 x float], i8}* %9
	%129 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %125, i64 0, i32 2 ; UnionTagPtr
	%130 = load i8, i8* %129, align 1
	%131 = icmp eq i8 %130, 1
	br i1 %131, label %union_cast.ok-10, label %union_cast.end-11

union_cast.ok-10:
	%132 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %9, i64 0, i32 0
	%133 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %9, i64 0, i32 1
	%134 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %125 to [2 x float]*
	%135 = load [2 x float], [2 x float]* %134, align 4
	store [2 x float] %135, [2 x float]* %132
	store i8 1, i8* %133
	br label %union_cast.end-11

union_cast.end-11:
	%136 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %9, i64 0, i32 1
	%137 = load i8, i8* %136, align 1
	%138 = trunc i8 %137 to i1
	call void @runtime.type_assertion_check(i1 %138, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$680, i64 0, i32 0), i64 63}, i64 150, i64 15, %..typeid 1152921504606847090, %..typeid 3098476543630901354)
	%139 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %9, i64 0, i32 0
	%140 = load [2 x float], [2 x float]* %139, align 4
	store [2 x float] %140, [2 x float]* %8
	; b
	; SelectorExpr
	%141 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%142 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %141, i64 0
	%143 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %142, i64 0, i32 3
	%144 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %143, align 4
	; cast - union_cast
	%145 = bitcast {[2 x float], i8}* %11 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 12) noinline
	store {[2 x float], i8} zeroinitializer, {[2 x float], i8}* %11
	%147 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %143, i64 0, i32 2 ; UnionTagPtr
	%148 = load i8, i8* %147, align 1
	%149 = icmp eq i8 %148, 1
	br i1 %149, label %union_cast.ok-12, label %union_cast.end-13

union_cast.ok-12:
	%150 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %11, i64 0, i32 0
	%151 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %11, i64 0, i32 1
	%152 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %143 to [2 x float]*
	%153 = load [2 x float], [2 x float]* %152, align 4
	store [2 x float] %153, [2 x float]* %150
	store i8 1, i8* %151
	br label %union_cast.end-13

union_cast.end-13:
	%154 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %11, i64 0, i32 1
	%155 = load i8, i8* %154, align 1
	%156 = trunc i8 %155 to i1
	call void @runtime.type_assertion_check(i1 %156, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$681, i64 0, i32 0), i64 63}, i64 151, i64 15, %..typeid 1152921504606847090, %..typeid 3098476543630901354)
	%157 = getelementptr inbounds {[2 x float], i8}, {[2 x float], i8}* %11, i64 0, i32 0
	%158 = load [2 x float], [2 x float]* %157, align 4
	store [2 x float] %158, [2 x float]* %10
	; result
	%159 = load [2 x float], [2 x float]* %8, align 4
	%160 = load [2 x float], [2 x float]* %10, align 4
	%161 = load float, float* %7, align 4
	%162 = bitcast [2 x float]* %13 to %..rawptr
	%163 = call %..rawptr @mem.zero(%..rawptr %162, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %13
	store [2 x float] %159, [2 x float]* %13
	%164 = bitcast [2 x float]* %14 to %..rawptr
	%165 = call %..rawptr @mem.zero(%..rawptr %164, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %14
	store [2 x float] %160, [2 x float]* %14
	%166 = call [2 x float] @math.lerp-18839([2 x float]* %13, [2 x float]* %14, float %161, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [2 x float] %166, [2 x float]* %12
	; ReturnStmt
	%167 = load [2 x float], [2 x float]* %12, align 4
	ret [2 x float] %167
}

define [3 x float] @workbench._update_one_tweener-18177(%workbench.Tweener* %tweener, float %dt, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %workbench.Tweener*, align 16
	%1 = alloca float, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca {[3 x float], i8}, align 16
	%4 = alloca [3 x float], align 16
	%5 = alloca {[3 x float], i8}, align 16
	%6 = alloca {[0 x <4 x i8>], [16 x i8], i8}, align 16
	%7 = alloca float, align 16
	%8 = alloca [3 x float], align 16
	%9 = alloca {[3 x float], i8}, align 16
	%10 = alloca [3 x float], align 16
	%11 = alloca {[3 x float], i8}, align 16
	%12 = alloca [3 x float], align 16
	%13 = alloca [3 x float], align 16
	%14 = alloca [3 x float], align 16
	store %workbench.Tweener* %tweener, %workbench.Tweener** %0
	store float %dt, float* %1
	; AssignStmt
	; SelectorExpr
	%15 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%16 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %15, i64 0
	%17 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %16, i64 0, i32 4
	%18 = load float, float* %1, align 4
	%19 = load float, float* %17, align 4
	%20 = fadd float %19, %18
	store float %20, float* %17
	; SelectorExpr
	%21 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%22 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %21, i64 0
	%23 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %22, i64 0, i32 4
	%24 = load float, float* %23, align 4
	%25 = fcmp one float %24, 0x0000000000000000
	%26 = zext i1 %25 to i8
	%27 = trunc i8 %26 to i1
	%28 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$682, i64 0, i32 0), i64 63}, i64 135, i64 2, %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$683, i64 0, i32 0), i64 19}}, %runtime.Source_Code_Location* %2
	%30 = call i8 @runtime.assert(i1 %27, %..string zeroinitializer, %runtime.Source_Code_Location* %2)
	; ForStmt
	br label %for.loop-1

for.loop-1:
	; SelectorExpr
	%31 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%32 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %31, i64 0
	%33 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %32, i64 0, i32 4
	%34 = load float, float* %33, align 4
	; SelectorExpr
	%35 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%36 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %35, i64 0
	%37 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %36, i64 0, i32 5
	%38 = load float, float* %37, align 4
	%39 = fcmp oge float %34, %38
	%40 = zext i1 %39 to i8
	%41 = trunc i8 %40 to i1
	br i1 %41, label %for.body-2, label %for.done-9

for.body-2:
	; IfStmt
	; SelectorExpr
	%42 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%43 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %42, i64 0
	%44 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %43, i64 0, i32 8
	%45 = load i8, i8* %44, align 1
	%46 = trunc i8 %45 to i1
	br i1 %46, label %if.done-6, label %if.then-3

if.then-3:
	; ReturnStmt
	; SelectorExpr
	%47 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%48 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %47, i64 0
	%49 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %48, i64 0, i32 3
	%50 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %49, align 4
	; cast - union_cast
	%51 = bitcast {[3 x float], i8}* %3 to %..rawptr
	%52 = call %..rawptr @mem.zero(%..rawptr %51, i64 16) noinline
	store {[3 x float], i8} zeroinitializer, {[3 x float], i8}* %3
	%53 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %49, i64 0, i32 2 ; UnionTagPtr
	%54 = load i8, i8* %53, align 1
	%55 = icmp eq i8 %54, 3
	br i1 %55, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%56 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %3, i64 0, i32 0
	%57 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %3, i64 0, i32 1
	%58 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %49 to [3 x float]*
	%59 = load [3 x float], [3 x float]* %58, align 4
	store [3 x float] %59, [3 x float]* %56
	store i8 1, i8* %57
	br label %union_cast.end-5

union_cast.end-5:
	%60 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %3, i64 0, i32 1
	%61 = load i8, i8* %60, align 1
	%62 = trunc i8 %61 to i1
	call void @runtime.type_assertion_check(i1 %62, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$684, i64 0, i32 0), i64 63}, i64 138, i64 38, %..typeid 1152921504606847090, %..typeid 3098476543630901357)
	%63 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %3, i64 0, i32 0
	%64 = load [3 x float], [3 x float]* %63, align 4
	ret [3 x float] %64

if.done-6:
	; AssignStmt
	; SelectorExpr
	%65 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%66 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %65, i64 0
	%67 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %66, i64 0, i32 4
	; SelectorExpr
	%68 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%69 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %68, i64 0
	%70 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %69, i64 0, i32 5
	%71 = load float, float* %70, align 4
	%72 = load float, float* %67, align 4
	%73 = fsub float %72, %71
	store float %73, float* %67
	; start
	; SelectorExpr
	%74 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%75 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %74, i64 0
	%76 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %75, i64 0, i32 2
	%77 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %76, align 4
	; cast - union_cast
	%78 = bitcast {[3 x float], i8}* %5 to %..rawptr
	%79 = call %..rawptr @mem.zero(%..rawptr %78, i64 16) noinline
	store {[3 x float], i8} zeroinitializer, {[3 x float], i8}* %5
	%80 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %76, i64 0, i32 2 ; UnionTagPtr
	%81 = load i8, i8* %80, align 1
	%82 = icmp eq i8 %81, 3
	br i1 %82, label %union_cast.ok-7, label %union_cast.end-8

union_cast.ok-7:
	%83 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %5, i64 0, i32 0
	%84 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %5, i64 0, i32 1
	%85 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %76 to [3 x float]*
	%86 = load [3 x float], [3 x float]* %85, align 4
	store [3 x float] %86, [3 x float]* %83
	store i8 1, i8* %84
	br label %union_cast.end-8

union_cast.end-8:
	%87 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %5, i64 0, i32 1
	%88 = load i8, i8* %87, align 1
	%89 = trunc i8 %88 to i1
	call void @runtime.type_assertion_check(i1 %89, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$685, i64 0, i32 0), i64 63}, i64 142, i64 20, %..typeid 1152921504606847090, %..typeid 3098476543630901357)
	%90 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %5, i64 0, i32 0
	%91 = load [3 x float], [3 x float]* %90, align 4
	store [3 x float] %91, [3 x float]* %4
	; AssignStmt
	; SelectorExpr
	%92 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%93 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %92, i64 0
	%94 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %93, i64 0, i32 2
	; SelectorExpr
	%95 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%96 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %95, i64 0
	%97 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %96, i64 0, i32 3
	%98 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %97, align 4
	store {[0 x <4 x i8>], [16 x i8], i8} %98, {[0 x <4 x i8>], [16 x i8], i8}* %94
	; AssignStmt
	; SelectorExpr
	%99 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%100 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %99, i64 0
	%101 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %100, i64 0, i32 3
	%102 = load [3 x float], [3 x float]* %4, align 4
	; union - child to parent
	%103 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %6 to %..rawptr
	%104 = call %..rawptr @mem.zero(%..rawptr %103, i64 20) noinline
	store {[0 x <4 x i8>], [16 x i8], i8} zeroinitializer, {[0 x <4 x i8>], [16 x i8], i8}* %6
	%105 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %6 to [3 x float]*
	store [3 x float] %102, [3 x float]* %105
	%106 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %6, i64 0, i32 2 ; UnionTagPtr
	store i8 3, i8* %106
	%107 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %6, align 4
	store {[0 x <4 x i8>], [16 x i8], i8} %107, {[0 x <4 x i8>], [16 x i8], i8}* %101
	br label %for.loop-1

for.done-9:
	; t
	; SelectorExpr
	%108 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%109 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %108, i64 0
	%110 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %109, i64 0, i32 4
	%111 = load float, float* %110, align 4
	; SelectorExpr
	%112 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%113 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %112, i64 0
	%114 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %113, i64 0, i32 5
	%115 = load float, float* %114, align 4
	%116 = fdiv float %111, %115
	store float %116, float* %7
	; AssignStmt
	; SelectorExpr
	%117 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%118 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %117, i64 0
	%119 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %118, i64 0, i32 6
	%120 = load float (float, %runtime.Context*)*, float (float, %runtime.Context*)** %119, align 8
	%121 = load float, float* %7, align 4
	%122 = call float %120(float %121, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store float %122, float* %7
	; a
	; SelectorExpr
	%123 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%124 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %123, i64 0
	%125 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %124, i64 0, i32 2
	%126 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %125, align 4
	; cast - union_cast
	%127 = bitcast {[3 x float], i8}* %9 to %..rawptr
	%128 = call %..rawptr @mem.zero(%..rawptr %127, i64 16) noinline
	store {[3 x float], i8} zeroinitializer, {[3 x float], i8}* %9
	%129 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %125, i64 0, i32 2 ; UnionTagPtr
	%130 = load i8, i8* %129, align 1
	%131 = icmp eq i8 %130, 3
	br i1 %131, label %union_cast.ok-10, label %union_cast.end-11

union_cast.ok-10:
	%132 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %9, i64 0, i32 0
	%133 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %9, i64 0, i32 1
	%134 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %125 to [3 x float]*
	%135 = load [3 x float], [3 x float]* %134, align 4
	store [3 x float] %135, [3 x float]* %132
	store i8 1, i8* %133
	br label %union_cast.end-11

union_cast.end-11:
	%136 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %9, i64 0, i32 1
	%137 = load i8, i8* %136, align 1
	%138 = trunc i8 %137 to i1
	call void @runtime.type_assertion_check(i1 %138, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$686, i64 0, i32 0), i64 63}, i64 150, i64 15, %..typeid 1152921504606847090, %..typeid 3098476543630901357)
	%139 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %9, i64 0, i32 0
	%140 = load [3 x float], [3 x float]* %139, align 4
	store [3 x float] %140, [3 x float]* %8
	; b
	; SelectorExpr
	%141 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%142 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %141, i64 0
	%143 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %142, i64 0, i32 3
	%144 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %143, align 4
	; cast - union_cast
	%145 = bitcast {[3 x float], i8}* %11 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 16) noinline
	store {[3 x float], i8} zeroinitializer, {[3 x float], i8}* %11
	%147 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %143, i64 0, i32 2 ; UnionTagPtr
	%148 = load i8, i8* %147, align 1
	%149 = icmp eq i8 %148, 3
	br i1 %149, label %union_cast.ok-12, label %union_cast.end-13

union_cast.ok-12:
	%150 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %11, i64 0, i32 0
	%151 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %11, i64 0, i32 1
	%152 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %143 to [3 x float]*
	%153 = load [3 x float], [3 x float]* %152, align 4
	store [3 x float] %153, [3 x float]* %150
	store i8 1, i8* %151
	br label %union_cast.end-13

union_cast.end-13:
	%154 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %11, i64 0, i32 1
	%155 = load i8, i8* %154, align 1
	%156 = trunc i8 %155 to i1
	call void @runtime.type_assertion_check(i1 %156, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$687, i64 0, i32 0), i64 63}, i64 151, i64 15, %..typeid 1152921504606847090, %..typeid 3098476543630901357)
	%157 = getelementptr inbounds {[3 x float], i8}, {[3 x float], i8}* %11, i64 0, i32 0
	%158 = load [3 x float], [3 x float]* %157, align 4
	store [3 x float] %158, [3 x float]* %10
	; result
	%159 = load [3 x float], [3 x float]* %8, align 4
	%160 = load [3 x float], [3 x float]* %10, align 4
	%161 = load float, float* %7, align 4
	%162 = bitcast [3 x float]* %13 to %..rawptr
	%163 = call %..rawptr @mem.zero(%..rawptr %162, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %13
	store [3 x float] %159, [3 x float]* %13
	%164 = bitcast [3 x float]* %14 to %..rawptr
	%165 = call %..rawptr @mem.zero(%..rawptr %164, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %14
	store [3 x float] %160, [3 x float]* %14
	%166 = call [3 x float] @math.lerp-21377([3 x float]* %13, [3 x float]* %14, float %161, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [3 x float] %166, [3 x float]* %12
	; ReturnStmt
	%167 = load [3 x float], [3 x float]* %12, align 4
	ret [3 x float] %167
}

define [4 x float] @workbench._update_one_tweener-18183(%workbench.Tweener* %tweener, float %dt, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %workbench.Tweener*, align 16
	%1 = alloca float, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca {[4 x float], i8}, align 16
	%4 = alloca [4 x float], align 16
	%5 = alloca {[4 x float], i8}, align 16
	%6 = alloca {[0 x <4 x i8>], [16 x i8], i8}, align 16
	%7 = alloca float, align 16
	%8 = alloca [4 x float], align 16
	%9 = alloca {[4 x float], i8}, align 16
	%10 = alloca [4 x float], align 16
	%11 = alloca {[4 x float], i8}, align 16
	%12 = alloca [4 x float], align 16
	%13 = alloca [4 x float], align 16
	%14 = alloca [4 x float], align 16
	store %workbench.Tweener* %tweener, %workbench.Tweener** %0
	store float %dt, float* %1
	; AssignStmt
	; SelectorExpr
	%15 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%16 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %15, i64 0
	%17 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %16, i64 0, i32 4
	%18 = load float, float* %1, align 4
	%19 = load float, float* %17, align 4
	%20 = fadd float %19, %18
	store float %20, float* %17
	; SelectorExpr
	%21 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%22 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %21, i64 0
	%23 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %22, i64 0, i32 4
	%24 = load float, float* %23, align 4
	%25 = fcmp one float %24, 0x0000000000000000
	%26 = zext i1 %25 to i8
	%27 = trunc i8 %26 to i1
	%28 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$688, i64 0, i32 0), i64 63}, i64 135, i64 2, %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$689, i64 0, i32 0), i64 19}}, %runtime.Source_Code_Location* %2
	%30 = call i8 @runtime.assert(i1 %27, %..string zeroinitializer, %runtime.Source_Code_Location* %2)
	; ForStmt
	br label %for.loop-1

for.loop-1:
	; SelectorExpr
	%31 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%32 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %31, i64 0
	%33 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %32, i64 0, i32 4
	%34 = load float, float* %33, align 4
	; SelectorExpr
	%35 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%36 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %35, i64 0
	%37 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %36, i64 0, i32 5
	%38 = load float, float* %37, align 4
	%39 = fcmp oge float %34, %38
	%40 = zext i1 %39 to i8
	%41 = trunc i8 %40 to i1
	br i1 %41, label %for.body-2, label %for.done-9

for.body-2:
	; IfStmt
	; SelectorExpr
	%42 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%43 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %42, i64 0
	%44 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %43, i64 0, i32 8
	%45 = load i8, i8* %44, align 1
	%46 = trunc i8 %45 to i1
	br i1 %46, label %if.done-6, label %if.then-3

if.then-3:
	; ReturnStmt
	; SelectorExpr
	%47 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%48 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %47, i64 0
	%49 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %48, i64 0, i32 3
	%50 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %49, align 4
	; cast - union_cast
	%51 = bitcast {[4 x float], i8}* %3 to %..rawptr
	%52 = call %..rawptr @mem.zero(%..rawptr %51, i64 20) noinline
	store {[4 x float], i8} zeroinitializer, {[4 x float], i8}* %3
	%53 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %49, i64 0, i32 2 ; UnionTagPtr
	%54 = load i8, i8* %53, align 1
	%55 = icmp eq i8 %54, 4
	br i1 %55, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%56 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %3, i64 0, i32 0
	%57 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %3, i64 0, i32 1
	%58 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %49 to [4 x float]*
	%59 = load [4 x float], [4 x float]* %58, align 4
	store [4 x float] %59, [4 x float]* %56
	store i8 1, i8* %57
	br label %union_cast.end-5

union_cast.end-5:
	%60 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %3, i64 0, i32 1
	%61 = load i8, i8* %60, align 1
	%62 = trunc i8 %61 to i1
	call void @runtime.type_assertion_check(i1 %62, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$68a, i64 0, i32 0), i64 63}, i64 138, i64 38, %..typeid 1152921504606847090, %..typeid 3098476543630901360)
	%63 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %3, i64 0, i32 0
	%64 = load [4 x float], [4 x float]* %63, align 4
	ret [4 x float] %64

if.done-6:
	; AssignStmt
	; SelectorExpr
	%65 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%66 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %65, i64 0
	%67 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %66, i64 0, i32 4
	; SelectorExpr
	%68 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%69 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %68, i64 0
	%70 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %69, i64 0, i32 5
	%71 = load float, float* %70, align 4
	%72 = load float, float* %67, align 4
	%73 = fsub float %72, %71
	store float %73, float* %67
	; start
	; SelectorExpr
	%74 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%75 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %74, i64 0
	%76 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %75, i64 0, i32 2
	%77 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %76, align 4
	; cast - union_cast
	%78 = bitcast {[4 x float], i8}* %5 to %..rawptr
	%79 = call %..rawptr @mem.zero(%..rawptr %78, i64 20) noinline
	store {[4 x float], i8} zeroinitializer, {[4 x float], i8}* %5
	%80 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %76, i64 0, i32 2 ; UnionTagPtr
	%81 = load i8, i8* %80, align 1
	%82 = icmp eq i8 %81, 4
	br i1 %82, label %union_cast.ok-7, label %union_cast.end-8

union_cast.ok-7:
	%83 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %5, i64 0, i32 0
	%84 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %5, i64 0, i32 1
	%85 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %76 to [4 x float]*
	%86 = load [4 x float], [4 x float]* %85, align 4
	store [4 x float] %86, [4 x float]* %83
	store i8 1, i8* %84
	br label %union_cast.end-8

union_cast.end-8:
	%87 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %5, i64 0, i32 1
	%88 = load i8, i8* %87, align 1
	%89 = trunc i8 %88 to i1
	call void @runtime.type_assertion_check(i1 %89, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$68b, i64 0, i32 0), i64 63}, i64 142, i64 20, %..typeid 1152921504606847090, %..typeid 3098476543630901360)
	%90 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %5, i64 0, i32 0
	%91 = load [4 x float], [4 x float]* %90, align 4
	store [4 x float] %91, [4 x float]* %4
	; AssignStmt
	; SelectorExpr
	%92 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%93 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %92, i64 0
	%94 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %93, i64 0, i32 2
	; SelectorExpr
	%95 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%96 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %95, i64 0
	%97 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %96, i64 0, i32 3
	%98 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %97, align 4
	store {[0 x <4 x i8>], [16 x i8], i8} %98, {[0 x <4 x i8>], [16 x i8], i8}* %94
	; AssignStmt
	; SelectorExpr
	%99 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%100 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %99, i64 0
	%101 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %100, i64 0, i32 3
	%102 = load [4 x float], [4 x float]* %4, align 4
	; union - child to parent
	%103 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %6 to %..rawptr
	%104 = call %..rawptr @mem.zero(%..rawptr %103, i64 20) noinline
	store {[0 x <4 x i8>], [16 x i8], i8} zeroinitializer, {[0 x <4 x i8>], [16 x i8], i8}* %6
	%105 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %6 to [4 x float]*
	store [4 x float] %102, [4 x float]* %105
	%106 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %6, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %106
	%107 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %6, align 4
	store {[0 x <4 x i8>], [16 x i8], i8} %107, {[0 x <4 x i8>], [16 x i8], i8}* %101
	br label %for.loop-1

for.done-9:
	; t
	; SelectorExpr
	%108 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%109 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %108, i64 0
	%110 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %109, i64 0, i32 4
	%111 = load float, float* %110, align 4
	; SelectorExpr
	%112 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%113 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %112, i64 0
	%114 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %113, i64 0, i32 5
	%115 = load float, float* %114, align 4
	%116 = fdiv float %111, %115
	store float %116, float* %7
	; AssignStmt
	; SelectorExpr
	%117 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%118 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %117, i64 0
	%119 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %118, i64 0, i32 6
	%120 = load float (float, %runtime.Context*)*, float (float, %runtime.Context*)** %119, align 8
	%121 = load float, float* %7, align 4
	%122 = call float %120(float %121, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store float %122, float* %7
	; a
	; SelectorExpr
	%123 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%124 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %123, i64 0
	%125 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %124, i64 0, i32 2
	%126 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %125, align 4
	; cast - union_cast
	%127 = bitcast {[4 x float], i8}* %9 to %..rawptr
	%128 = call %..rawptr @mem.zero(%..rawptr %127, i64 20) noinline
	store {[4 x float], i8} zeroinitializer, {[4 x float], i8}* %9
	%129 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %125, i64 0, i32 2 ; UnionTagPtr
	%130 = load i8, i8* %129, align 1
	%131 = icmp eq i8 %130, 4
	br i1 %131, label %union_cast.ok-10, label %union_cast.end-11

union_cast.ok-10:
	%132 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %9, i64 0, i32 0
	%133 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %9, i64 0, i32 1
	%134 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %125 to [4 x float]*
	%135 = load [4 x float], [4 x float]* %134, align 4
	store [4 x float] %135, [4 x float]* %132
	store i8 1, i8* %133
	br label %union_cast.end-11

union_cast.end-11:
	%136 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %9, i64 0, i32 1
	%137 = load i8, i8* %136, align 1
	%138 = trunc i8 %137 to i1
	call void @runtime.type_assertion_check(i1 %138, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$68c, i64 0, i32 0), i64 63}, i64 150, i64 15, %..typeid 1152921504606847090, %..typeid 3098476543630901360)
	%139 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %9, i64 0, i32 0
	%140 = load [4 x float], [4 x float]* %139, align 4
	store [4 x float] %140, [4 x float]* %8
	; b
	; SelectorExpr
	%141 = load %workbench.Tweener*, %workbench.Tweener** %0, align 8
	%142 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %141, i64 0
	%143 = getelementptr inbounds %workbench.Tweener, %workbench.Tweener* %142, i64 0, i32 3
	%144 = load {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %143, align 4
	; cast - union_cast
	%145 = bitcast {[4 x float], i8}* %11 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 20) noinline
	store {[4 x float], i8} zeroinitializer, {[4 x float], i8}* %11
	%147 = getelementptr inbounds {[0 x <4 x i8>], [16 x i8], i8}, {[0 x <4 x i8>], [16 x i8], i8}* %143, i64 0, i32 2 ; UnionTagPtr
	%148 = load i8, i8* %147, align 1
	%149 = icmp eq i8 %148, 4
	br i1 %149, label %union_cast.ok-12, label %union_cast.end-13

union_cast.ok-12:
	%150 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %11, i64 0, i32 0
	%151 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %11, i64 0, i32 1
	%152 = bitcast {[0 x <4 x i8>], [16 x i8], i8}* %143 to [4 x float]*
	%153 = load [4 x float], [4 x float]* %152, align 4
	store [4 x float] %153, [4 x float]* %150
	store i8 1, i8* %151
	br label %union_cast.end-13

union_cast.end-13:
	%154 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %11, i64 0, i32 1
	%155 = load i8, i8* %154, align 1
	%156 = trunc i8 %155 to i1
	call void @runtime.type_assertion_check(i1 %156, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$68d, i64 0, i32 0), i64 63}, i64 151, i64 15, %..typeid 1152921504606847090, %..typeid 3098476543630901360)
	%157 = getelementptr inbounds {[4 x float], i8}, {[4 x float], i8}* %11, i64 0, i32 0
	%158 = load [4 x float], [4 x float]* %157, align 4
	store [4 x float] %158, [4 x float]* %10
	; result
	%159 = load [4 x float], [4 x float]* %8, align 4
	%160 = load [4 x float], [4 x float]* %10, align 4
	%161 = load float, float* %7, align 4
	%162 = bitcast [4 x float]* %13 to %..rawptr
	%163 = call %..rawptr @mem.zero(%..rawptr %162, i64 16) noinline
	store [4 x float] zeroinitializer, [4 x float]* %13
	store [4 x float] %159, [4 x float]* %13
	%164 = bitcast [4 x float]* %14 to %..rawptr
	%165 = call %..rawptr @mem.zero(%..rawptr %164, i64 16) noinline
	store [4 x float] zeroinitializer, [4 x float]* %14
	store [4 x float] %160, [4 x float]* %14
	%166 = call [4 x float] @math.lerp-21389([4 x float]* %13, [4 x float]* %14, float %161, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store [4 x float] %166, [4 x float]* %12
	; ReturnStmt
	%167 = load [4 x float], [4 x float]* %12, align 4
	ret [4 x float] %167
}

define {%imgui.DrawList**, i64} @mem.slice_ptr-18228(%imgui.DrawList** %ptr, i64 %len) #0 {
decls-0:
	%0 = alloca %imgui.DrawList**, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %mem.Raw_Slice, align 16
	%4 = alloca %mem.Raw_Slice, align 16
	store %imgui.DrawList** %ptr, %imgui.DrawList*** %0
	store i64 %len, i64* %1
	%5 = load i64, i64* %1, align 8
	%6 = icmp sge i64 %5, 0
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	%9 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$68e, i64 0, i32 0), i64 53}, i64 93, i64 2, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$68f, i64 0, i32 0), i64 9}}, %runtime.Source_Code_Location* %2
	%10 = call i8 @runtime.assert(i1 %8, %..string zeroinitializer, %runtime.Source_Code_Location* %2)
	; slice
	; CompoundLit
	%11 = bitcast %mem.Raw_Slice* %4 to %..rawptr
	store %mem.Raw_Slice zeroinitializer, %mem.Raw_Slice* %4
	store %mem.Raw_Slice {%..rawptr zeroinitializer, i64 zeroinitializer}, %mem.Raw_Slice* %4
	%12 = load %imgui.DrawList**, %imgui.DrawList*** %0, align 8
	%13 = bitcast %imgui.DrawList** %12 to %..rawptr
	%14 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %4, i64 0, i32 0
	store %..rawptr %13, %..rawptr* %14
	%15 = load i64, i64* %1, align 8
	%16 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %4, i64 0, i32 1
	store i64 %15, i64* %16
	%17 = load %mem.Raw_Slice, %mem.Raw_Slice* %4, align 8
	store %mem.Raw_Slice %17, %mem.Raw_Slice* %3
	; ReturnStmt
	%18 = load %mem.Raw_Slice, %mem.Raw_Slice* %3, align 8
	%19 = bitcast %mem.Raw_Slice* %3 to {%imgui.DrawList**, i64}*
	%20 = load {%imgui.DrawList**, i64}, {%imgui.DrawList**, i64}* %19, align 8
	ret {%imgui.DrawList**, i64} %20
}

define i16* @mem.ptr_offset-18238(i16* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca i16*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store i16* %ptr, i16** %0
	store i64 %n, i64* %1
	; new
	%3 = load i16*, i16** %0, align 8
	%4 = ptrtoint i16* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 2, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to i16*
	ret i16* %11
}

define void @runtime.clear_map-18409({{i64*, i64}, {{%runtime.Map_Key, i64, i64}*, i64, i64, %mem.Allocator}}* %m) alwaysinline #1 {
decls-0:
	%0 = alloca {{i64*, i64}, {{%runtime.Map_Key, i64, i64}*, i64, i64, %mem.Allocator}}*, align 16
	%1 = alloca %mem.Raw_Map*, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	store {{i64*, i64}, {{%runtime.Map_Key, i64, i64}*, i64, i64, %mem.Allocator}}* %m, {{i64*, i64}, {{%runtime.Map_Key, i64, i64}*, i64, i64, %mem.Allocator}}** %0
	; IfStmt
	%6 = load {{i64*, i64}, {{%runtime.Map_Key, i64, i64}*, i64, i64, %mem.Allocator}}*, {{i64*, i64}, {{%runtime.Map_Key, i64, i64}*, i64, i64, %mem.Allocator}}** %0, align 8
	%7 = icmp eq {{i64*, i64}, {{%runtime.Map_Key, i64, i64}*, i64, i64, %mem.Allocator}}* %6, zeroinitializer
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	br i1 %9, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; raw_map
	%10 = load {{i64*, i64}, {{%runtime.Map_Key, i64, i64}*, i64, i64, %mem.Allocator}}*, {{i64*, i64}, {{%runtime.Map_Key, i64, i64}*, i64, i64, %mem.Allocator}}** %0, align 8
	%11 = bitcast {{i64*, i64}, {{%runtime.Map_Key, i64, i64}*, i64, i64, %mem.Allocator}}* %10 to %mem.Raw_Map*
	store %mem.Raw_Map* %11, %mem.Raw_Map** %1
	; entries
	; SelectorExpr
	%12 = load %mem.Raw_Map*, %mem.Raw_Map** %1, align 8
	%13 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %12, i64 0
	%14 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %13, i64 0, i32 1
	store %mem.Raw_Dynamic_Array* %14, %mem.Raw_Dynamic_Array** %2
	; AssignStmt
	; SelectorExpr
	%15 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%16 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %15, i64 0
	%17 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %16, i64 0, i32 1
	store i64 0, i64* %17
	; RangeStmt
	; i
	%18 = bitcast i64* %3 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	; SelectorExpr
	%20 = load %mem.Raw_Map*, %mem.Raw_Map** %1, align 8
	%21 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %20, i64 0
	%22 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %21, i64 0, i32 0
	%23 = load {i64*, i64}, {i64*, i64}* %22, align 8
	%24 = bitcast i64* %4 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	%26 = extractvalue {i64*, i64} %23, 1
	store i64 %26, i64* %4
	%27 = bitcast i64* %5 to %..rawptr
	%28 = call %..rawptr @mem.zero(%..rawptr %27, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	store i64 -1, i64* %5
	br label %for.index.loop-3

for.index.loop-3:
	%29 = load i64, i64* %5, align 8
	%30 = add i64 %29, 1
	store i64 %30, i64* %5
	%31 = load i64, i64* %4, align 8
	%32 = icmp slt i64 %30, %31
	br i1 %32, label %for.index.body-4, label %for.index.done-5

for.index.body-4:
	%33 = load i64, i64* %5, align 8
	store i64 %33, i64* %3
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%34 = load %mem.Raw_Map*, %mem.Raw_Map** %1, align 8
	%35 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %34, i64 0
	%36 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %35, i64 0, i32 0
	%37 = load {i64*, i64}, {i64*, i64}* %36, align 8
	%38 = extractvalue {i64*, i64} %37, 0
	%39 = load i64, i64* %3, align 8
	%40 = extractvalue {i64*, i64} %37, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$690, i64 0, i32 0), i64 58}, i64 441, i64 18, i64 %39, i64 %40) alwaysinline
	%41 = getelementptr inbounds i64, i64* %38, i64 %39
	store i64 -1, i64* %41
	br label %for.index.loop-3

for.index.done-5:
	ret void
}

define void @runtime.clear_dynamic_array-18427({%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %array) alwaysinline #1 {
decls-0:
	%0 = alloca {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %mem.Raw_Dynamic_Array*, align 16
	store {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %array, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0
	; IfStmt
	%2 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%3 = icmp ne {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %2, zeroinitializer
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; SelectorExpr
	%6 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%7 = bitcast {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %6 to %mem.Raw_Dynamic_Array*
	%8 = bitcast %mem.Raw_Dynamic_Array** %1 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 8) noinline
	store %mem.Raw_Dynamic_Array* zeroinitializer, %mem.Raw_Dynamic_Array** %1
	store %mem.Raw_Dynamic_Array* %7, %mem.Raw_Dynamic_Array** %1
	%10 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %1, align 8
	%11 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %10, i64 0
	%12 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %11, i64 0, i32 1
	store i64 0, i64* %12
	br label %if.done-2

if.done-2:
	ret void
}

define void @workbench.imgui_struct-18489(%workbench._late_update_ui.UI_Debug_Info-1465* %value, %..string %name, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %workbench._late_update_ui.UI_Debug_Info-1465*, align 16
	%1 = alloca %..string, align 16
	store %workbench._late_update_ui.UI_Debug_Info-1465* %value, %workbench._late_update_ui.UI_Debug_Info-1465** %0
	store %..string %name, %..string* %1
	; SelectorExpr
	%2 = load %imgui.Font*, %imgui.Font** @workbench.imgui_font_mono, align 8
	call ccc void @igPushFont(%imgui.Font* %2) alwaysinline
	; DeferStmt
	%3 = load %..string, %..string* %1, align 8
	%4 = load %workbench._late_update_ui.UI_Debug_Info-1465*, %workbench._late_update_ui.UI_Debug_Info-1465** %0, align 8
	%5 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 120
	%6 = bitcast %workbench._late_update_ui.UI_Debug_Info-1465* %4 to %..rawptr
	call void @workbench._imgui_struct_internal(%..string %3, %..rawptr %6, %runtime.Type_Info* %5, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	; defer
	; SelectorExpr
	call ccc void @igPopFont() alwaysinline
	ret void
}

define void @workbench.imgui_struct-18496(%workbench.IMGUI_Rect* %value, %..string %name, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %workbench.IMGUI_Rect*, align 16
	%1 = alloca %..string, align 16
	store %workbench.IMGUI_Rect* %value, %workbench.IMGUI_Rect** %0
	store %..string %name, %..string* %1
	; SelectorExpr
	%2 = load %imgui.Font*, %imgui.Font** @workbench.imgui_font_mono, align 8
	call ccc void @igPushFont(%imgui.Font* %2) alwaysinline
	; DeferStmt
	%3 = load %..string, %..string* %1, align 8
	%4 = load %workbench.IMGUI_Rect*, %workbench.IMGUI_Rect** %0, align 8
	%5 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 122
	%6 = bitcast %workbench.IMGUI_Rect* %4 to %..rawptr
	call void @workbench._imgui_struct_internal(%..string %3, %..rawptr %6, %runtime.Type_Info* %5, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	; defer
	; SelectorExpr
	call ccc void @igPopFont() alwaysinline
	ret void
}

define i64 @runtime.append_elem-18531({%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* %array, %workbench.Location_ID_Mapping* %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca %workbench.Location_ID_Mapping*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* %array, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}** %0
	%7 = load %workbench.Location_ID_Mapping, %workbench.Location_ID_Mapping* %arg, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}*, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %1
	; IfStmt
	%13 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}*, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}*, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %1, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}*, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %1, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %2
	; AssignStmt
	%32 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}*, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %2, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %3
	%37 = call i8 @runtime.reserve_dynamic_array-21493({%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}*, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}*, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %1, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %1
	; IfStmt
	%48 = load i64, i64* %1, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}*, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to %workbench.Location_ID_Mapping*
	store %workbench.Location_ID_Mapping* %58, %workbench.Location_ID_Mapping** %5
	%59 = load %workbench.Location_ID_Mapping*, %workbench.Location_ID_Mapping** %5, align 8
	%60 = icmp ne %workbench.Location_ID_Mapping* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$691, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$692, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; SelectorExpr
	; SelectorExpr
	%66 = load %workbench.Location_ID_Mapping*, %workbench.Location_ID_Mapping** %5, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call %workbench.Location_ID_Mapping* @mem.ptr_offset-21507(%workbench.Location_ID_Mapping* %66, i64 %70)
	%72 = bitcast %workbench.Location_ID_Mapping* %71 to %..rawptr
	%73 = bitcast %workbench.Location_ID_Mapping* %arg to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 64)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %1, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}*, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define %workbench.IMGUI_Rect* @workbench.last_dyn-18557({%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %list, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %list, align 8
	; ReturnStmt
	; IndexExpr
	%1 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %list, align 8
	%2 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %1, 0
	%3 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %1, 1
	%4 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %list, align 8
	%5 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %4, 1
	%6 = sub i64 %5, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$693, i64 0, i32 0), i64 63}, i64 72, i64 68, i64 %6, i64 %3) alwaysinline
	%7 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %2, i64 %6
	ret %workbench.IMGUI_Rect* %7
}

define i64 @runtime.append_elem-18594({%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %array, %workbench.IMGUI_Rect* %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca %workbench.IMGUI_Rect*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %array, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0
	%7 = load %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %arg, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %1
	; IfStmt
	%13 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %1, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %1, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %2
	; AssignStmt
	%32 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %2, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %3
	%37 = call i8 @runtime.reserve_dynamic_array-21549({%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %1, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %1
	; IfStmt
	%48 = load i64, i64* %1, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to %workbench.IMGUI_Rect*
	store %workbench.IMGUI_Rect* %58, %workbench.IMGUI_Rect** %5
	%59 = load %workbench.IMGUI_Rect*, %workbench.IMGUI_Rect** %5, align 8
	%60 = icmp ne %workbench.IMGUI_Rect* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$694, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$695, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; SelectorExpr
	; SelectorExpr
	%66 = load %workbench.IMGUI_Rect*, %workbench.IMGUI_Rect** %5, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call %workbench.IMGUI_Rect* @mem.ptr_offset-21563(%workbench.IMGUI_Rect* %66, i64 %70)
	%72 = bitcast %workbench.IMGUI_Rect* %71 to %..rawptr
	%73 = bitcast %workbench.IMGUI_Rect* %arg to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 176)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %1, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define %workbench.IMGUI_Rect @runtime.pop-18650({%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %array) #0 {
decls-0:
	%0 = alloca {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = alloca %workbench.IMGUI_Rect, align 16
	%3 = alloca %mem.Raw_Dynamic_Array*, align 16
	store {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %array, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0
	; IfStmt
	%4 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%5 = icmp eq {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %workbench.IMGUI_Rect zeroinitializer

if.done-2:
	%8 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%9 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %8, align 8
	%10 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %9, 1
	%11 = icmp sgt i64 %10, 0
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	%14 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$696, i64 0, i32 0), i64 58}, i64 367, i64 2, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$697, i64 0, i32 0), i64 3}}, %runtime.Source_Code_Location* %1
	%16 = call i8 @runtime.assert(i1 %13, %..string zeroinitializer, %runtime.Source_Code_Location* %1)
	; res
	; IndexExpr
	%17 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%18 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %17, align 8
	%19 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %18, 0
	%20 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %18, 1
	%21 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%22 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %21, align 8
	%23 = extractvalue {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} %22, 1
	%24 = sub i64 %23, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$698, i64 0, i32 0), i64 58}, i64 368, i64 15, i64 %24, i64 %20)
	%25 = getelementptr inbounds %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %19, i64 %24
	%26 = load %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %25, align 8
	store %workbench.IMGUI_Rect %26, %workbench.IMGUI_Rect* %2
	; AssignStmt
	; SelectorExpr
	%27 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%28 = bitcast {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %27 to %mem.Raw_Dynamic_Array*
	%29 = bitcast %mem.Raw_Dynamic_Array** %3 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 8) noinline
	store %mem.Raw_Dynamic_Array* zeroinitializer, %mem.Raw_Dynamic_Array** %3
	store %mem.Raw_Dynamic_Array* %28, %mem.Raw_Dynamic_Array** %3
	%31 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%32 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %31, i64 0
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0, i32 1
	%34 = load i64, i64* %33, align 8
	%35 = sub i64 %34, 1
	store i64 %35, i64* %33
	; ReturnStmt
	%36 = load %workbench.IMGUI_Rect, %workbench.IMGUI_Rect* %2, align 8
	ret %workbench.IMGUI_Rect %36
}

define [2 x float] @math.lerp-18839([2 x float]* %a, [2 x float]* %b, float %t, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca float, align 16
	%1 = alloca [2 x float], align 16
	%2 = alloca [2 x float], align 16
	%3 = alloca [2 x float], align 16
	%4 = alloca [2 x float], align 16
	%5 = alloca [2 x float], align 16
	%6 = alloca [2 x float], align 16
	%7 = load [2 x float], [2 x float]* %a, align 4
	%8 = load [2 x float], [2 x float]* %b, align 4
	store float %t, float* %0
	%9 = bitcast [2 x float]* %1 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %1
	; ReturnStmt
	%11 = load [2 x float], [2 x float]* %a, align 4
	%12 = load float, float* %0, align 4
	%13 = fsub float 0x3ff0000000000000, %12
	; array.arith.begin
	%14 = bitcast [2 x float]* %2 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %2
	%16 = getelementptr inbounds [2 x float], [2 x float]* %2, i64 0, i32 0
	store float %13, float* %16
	%17 = getelementptr inbounds [2 x float], [2 x float]* %2, i64 0, i32 1
	store float %13, float* %17
	%18 = load [2 x float], [2 x float]* %2, align 4
	%19 = bitcast [2 x float]* %3 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %3
	%21 = getelementptr inbounds [2 x float], [2 x float]* %a, i64 0, i32 0
	%22 = load float, float* %21, align 4
	%23 = getelementptr inbounds [2 x float], [2 x float]* %2, i64 0, i32 0
	%24 = load float, float* %23, align 4
	%25 = fmul float %22, %24
	%26 = getelementptr inbounds [2 x float], [2 x float]* %3, i64 0, i32 0
	store float %25, float* %26
	%27 = getelementptr inbounds [2 x float], [2 x float]* %a, i64 0, i32 1
	%28 = load float, float* %27, align 4
	%29 = getelementptr inbounds [2 x float], [2 x float]* %2, i64 0, i32 1
	%30 = load float, float* %29, align 4
	%31 = fmul float %28, %30
	%32 = getelementptr inbounds [2 x float], [2 x float]* %3, i64 0, i32 1
	store float %31, float* %32
	; array.arith.end
	%33 = load [2 x float], [2 x float]* %3, align 4
	%34 = load [2 x float], [2 x float]* %b, align 4
	%35 = load float, float* %0, align 4
	; array.arith.begin
	%36 = bitcast [2 x float]* %4 to %..rawptr
	%37 = call %..rawptr @mem.zero(%..rawptr %36, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %4
	%38 = getelementptr inbounds [2 x float], [2 x float]* %4, i64 0, i32 0
	store float %35, float* %38
	%39 = getelementptr inbounds [2 x float], [2 x float]* %4, i64 0, i32 1
	store float %35, float* %39
	%40 = load [2 x float], [2 x float]* %4, align 4
	%41 = bitcast [2 x float]* %5 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %5
	%43 = getelementptr inbounds [2 x float], [2 x float]* %b, i64 0, i32 0
	%44 = load float, float* %43, align 4
	%45 = getelementptr inbounds [2 x float], [2 x float]* %4, i64 0, i32 0
	%46 = load float, float* %45, align 4
	%47 = fmul float %44, %46
	%48 = getelementptr inbounds [2 x float], [2 x float]* %5, i64 0, i32 0
	store float %47, float* %48
	%49 = getelementptr inbounds [2 x float], [2 x float]* %b, i64 0, i32 1
	%50 = load float, float* %49, align 4
	%51 = getelementptr inbounds [2 x float], [2 x float]* %4, i64 0, i32 1
	%52 = load float, float* %51, align 4
	%53 = fmul float %50, %52
	%54 = getelementptr inbounds [2 x float], [2 x float]* %5, i64 0, i32 1
	store float %53, float* %54
	; array.arith.end
	%55 = load [2 x float], [2 x float]* %5, align 4
	; array.arith.begin
	%56 = bitcast [2 x float]* %6 to %..rawptr
	%57 = call %..rawptr @mem.zero(%..rawptr %56, i64 8) noinline
	store [2 x float] zeroinitializer, [2 x float]* %6
	%58 = getelementptr inbounds [2 x float], [2 x float]* %3, i64 0, i32 0
	%59 = load float, float* %58, align 4
	%60 = getelementptr inbounds [2 x float], [2 x float]* %5, i64 0, i32 0
	%61 = load float, float* %60, align 4
	%62 = fadd float %59, %61
	%63 = getelementptr inbounds [2 x float], [2 x float]* %6, i64 0, i32 0
	store float %62, float* %63
	%64 = getelementptr inbounds [2 x float], [2 x float]* %3, i64 0, i32 1
	%65 = load float, float* %64, align 4
	%66 = getelementptr inbounds [2 x float], [2 x float]* %5, i64 0, i32 1
	%67 = load float, float* %66, align 4
	%68 = fadd float %65, %67
	%69 = getelementptr inbounds [2 x float], [2 x float]* %6, i64 0, i32 1
	store float %68, float* %69
	; array.arith.end
	%70 = load [2 x float], [2 x float]* %6, align 4
	ret [2 x float] %70
}

define i64 @runtime.append_elem-18904({%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* %array, %workbench.UI_Debug_File_Line* %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca %workbench.UI_Debug_File_Line*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* %array, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}** %0
	%7 = load %workbench.UI_Debug_File_Line, %workbench.UI_Debug_File_Line* %arg, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}*, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %1
	; IfStmt
	%13 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}*, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}*, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %1, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}*, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %1, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %2
	; AssignStmt
	%32 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}*, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %2, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %3
	%37 = call i8 @runtime.reserve_dynamic_array-21617({%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}*, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}*, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %1, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %1
	; IfStmt
	%48 = load i64, i64* %1, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}*, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to %workbench.UI_Debug_File_Line*
	store %workbench.UI_Debug_File_Line* %58, %workbench.UI_Debug_File_Line** %5
	%59 = load %workbench.UI_Debug_File_Line*, %workbench.UI_Debug_File_Line** %5, align 8
	%60 = icmp ne %workbench.UI_Debug_File_Line* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$699, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$69a, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; SelectorExpr
	; SelectorExpr
	%66 = load %workbench.UI_Debug_File_Line*, %workbench.UI_Debug_File_Line** %5, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call %workbench.UI_Debug_File_Line* @mem.ptr_offset-21631(%workbench.UI_Debug_File_Line* %66, i64 %70)
	%72 = bitcast %workbench.UI_Debug_File_Line* %71 to %..rawptr
	%73 = bitcast %workbench.UI_Debug_File_Line* %arg to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 40)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %1, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}*, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define i64 @runtime.copy-18955({i8*, i64}* %dst, {i8*, i64}* %src) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = load {i8*, i64}, {i8*, i64}* %dst, align 8
	%2 = load {i8*, i64}, {i8*, i64}* %src, align 8
	; n
	; max
	; min
	%3 = load {i8*, i64}, {i8*, i64}* %dst, align 8
	%4 = extractvalue {i8*, i64} %3, 1
	%5 = load {i8*, i64}, {i8*, i64}* %src, align 8
	%6 = extractvalue {i8*, i64} %5, 1
	%7 = icmp slt i64 %4, %6
	%8 = select i1 %7, i64 %4, i64 %6
	%9 = icmp sgt i64 0, %8
	%10 = select i1 %9, i64 0, i64 %8
	store i64 %10, i64* %0
	; IfStmt
	%11 = load i64, i64* %0, align 8
	%12 = icmp sgt i64 %11, 0
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	; IndexExpr
	%15 = load {i8*, i64}, {i8*, i64}* %dst, align 8
	%16 = extractvalue {i8*, i64} %15, 0
	%17 = extractvalue {i8*, i64} %15, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$69b, i64 0, i32 0), i64 58}, i64 358, i64 28, i64 0, i64 %17)
	%18 = getelementptr inbounds i8, i8* %16, i64 0
	; IndexExpr
	%19 = load {i8*, i64}, {i8*, i64}* %src, align 8
	%20 = extractvalue {i8*, i64} %19, 0
	%21 = extractvalue {i8*, i64} %19, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$69c, i64 0, i32 0), i64 58}, i64 358, i64 37, i64 0, i64 %21)
	%22 = getelementptr inbounds i8, i8* %20, i64 0
	%23 = load i64, i64* %0, align 8
	%24 = mul i64 %23, 1
	%25 = bitcast i8* %18 to %..rawptr
	%26 = bitcast i8* %22 to %..rawptr
	%27 = call %..rawptr @mem.copy(%..rawptr %25, %..rawptr %26, i64 %24)
	br label %if.done-2

if.done-2:
	; ReturnStmt
	%28 = load i64, i64* %0, align 8
	ret i64 %28
}

define {float*, i64} @mem.slice_ptr-19071(float* %ptr, i64 %len) #0 {
decls-0:
	%0 = alloca float*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %mem.Raw_Slice, align 16
	%4 = alloca %mem.Raw_Slice, align 16
	store float* %ptr, float** %0
	store i64 %len, i64* %1
	%5 = load i64, i64* %1, align 8
	%6 = icmp sge i64 %5, 0
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	%9 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$69d, i64 0, i32 0), i64 53}, i64 93, i64 2, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$69e, i64 0, i32 0), i64 9}}, %runtime.Source_Code_Location* %2
	%10 = call i8 @runtime.assert(i1 %8, %..string zeroinitializer, %runtime.Source_Code_Location* %2)
	; slice
	; CompoundLit
	%11 = bitcast %mem.Raw_Slice* %4 to %..rawptr
	store %mem.Raw_Slice zeroinitializer, %mem.Raw_Slice* %4
	store %mem.Raw_Slice {%..rawptr zeroinitializer, i64 zeroinitializer}, %mem.Raw_Slice* %4
	%12 = load float*, float** %0, align 8
	%13 = bitcast float* %12 to %..rawptr
	%14 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %4, i64 0, i32 0
	store %..rawptr %13, %..rawptr* %14
	%15 = load i64, i64* %1, align 8
	%16 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %4, i64 0, i32 1
	store i64 %15, i64* %16
	%17 = load %mem.Raw_Slice, %mem.Raw_Slice* %4, align 8
	store %mem.Raw_Slice %17, %mem.Raw_Slice* %3
	; ReturnStmt
	%18 = load %mem.Raw_Slice, %mem.Raw_Slice* %3, align 8
	%19 = bitcast %mem.Raw_Slice* %3 to {float*, i64}*
	%20 = load {float*, i64}, {float*, i64}* %19, align 8
	ret {float*, i64} %20
}

define i64* @mem.raw_slice_data-20010({i64*, i64}* %a, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %mem.Raw_Slice*, align 16
	%1 = load {i64*, i64}, {i64*, i64}* %a, align 8
	; ReturnStmt
	; SelectorExpr
	%2 = bitcast {i64*, i64}* %a to %mem.Raw_Slice*
	%3 = bitcast %mem.Raw_Slice** %0 to %..rawptr
	store %mem.Raw_Slice* zeroinitializer, %mem.Raw_Slice** %0
	store %mem.Raw_Slice* %2, %mem.Raw_Slice** %0
	%4 = load %mem.Raw_Slice*, %mem.Raw_Slice** %0, align 8
	%5 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %4, i64 0
	%6 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %5, i64 0, i32 0
	%7 = load %..rawptr, %..rawptr* %6, align 8
	%8 = bitcast %..rawptr %7 to i64*
	ret i64* %8
}

define i64 @runtime.append_elem-20032({%main.Transform*, i64, i64, %mem.Allocator}* %array, %main.Transform* %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%main.Transform*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca %main.Transform*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	store {%main.Transform*, i64, i64, %mem.Allocator}* %array, {%main.Transform*, i64, i64, %mem.Allocator}** %0
	%7 = load %main.Transform, %main.Transform* %arg, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {%main.Transform*, i64, i64, %mem.Allocator}*, {%main.Transform*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {%main.Transform*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %1
	; IfStmt
	%13 = load {%main.Transform*, i64, i64, %mem.Allocator}*, {%main.Transform*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {%main.Transform*, i64, i64, %mem.Allocator}, {%main.Transform*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {%main.Transform*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {%main.Transform*, i64, i64, %mem.Allocator}*, {%main.Transform*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {%main.Transform*, i64, i64, %mem.Allocator}, {%main.Transform*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {%main.Transform*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %1, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {%main.Transform*, i64, i64, %mem.Allocator}*, {%main.Transform*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {%main.Transform*, i64, i64, %mem.Allocator}, {%main.Transform*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {%main.Transform*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %1, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %2
	; AssignStmt
	%32 = load {%main.Transform*, i64, i64, %mem.Allocator}*, {%main.Transform*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %2, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %3
	%37 = call i8 @runtime.reserve_dynamic_array-22130({%main.Transform*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {%main.Transform*, i64, i64, %mem.Allocator}*, {%main.Transform*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {%main.Transform*, i64, i64, %mem.Allocator}, {%main.Transform*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {%main.Transform*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {%main.Transform*, i64, i64, %mem.Allocator}*, {%main.Transform*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {%main.Transform*, i64, i64, %mem.Allocator}, {%main.Transform*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {%main.Transform*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %1, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %1
	; IfStmt
	%48 = load i64, i64* %1, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {%main.Transform*, i64, i64, %mem.Allocator}*, {%main.Transform*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {%main.Transform*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to %main.Transform*
	store %main.Transform* %58, %main.Transform** %5
	%59 = load %main.Transform*, %main.Transform** %5, align 8
	%60 = icmp ne %main.Transform* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$69f, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$6a0, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; SelectorExpr
	; SelectorExpr
	%66 = load %main.Transform*, %main.Transform** %5, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call %main.Transform* @mem.ptr_offset-22144(%main.Transform* %66, i64 %70)
	%72 = bitcast %main.Transform* %71 to %..rawptr
	%73 = bitcast %main.Transform* %arg to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 24)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %1, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {%main.Transform*, i64, i64, %mem.Allocator}*, {%main.Transform*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {%main.Transform*, i64, i64, %mem.Allocator}, {%main.Transform*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {%main.Transform*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define i64 @runtime.append_elem-20066({%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* %array, %main.Mesh_Renderer* %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca %main.Mesh_Renderer*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	store {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* %array, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}** %0
	%7 = load %main.Mesh_Renderer, %main.Mesh_Renderer* %arg, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}*, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %1
	; IfStmt
	%13 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}*, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {%main.Mesh_Renderer*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}*, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {%main.Mesh_Renderer*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %1, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}*, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {%main.Mesh_Renderer*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %1, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %2
	; AssignStmt
	%32 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}*, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %2, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %3
	%37 = call i8 @runtime.reserve_dynamic_array-22186({%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}*, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {%main.Mesh_Renderer*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}*, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {%main.Mesh_Renderer*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %1, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %1
	; IfStmt
	%48 = load i64, i64* %1, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}*, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to %main.Mesh_Renderer*
	store %main.Mesh_Renderer* %58, %main.Mesh_Renderer** %5
	%59 = load %main.Mesh_Renderer*, %main.Mesh_Renderer** %5, align 8
	%60 = icmp ne %main.Mesh_Renderer* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6a1, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$6a2, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; SelectorExpr
	; SelectorExpr
	%66 = load %main.Mesh_Renderer*, %main.Mesh_Renderer** %5, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call %main.Mesh_Renderer* @mem.ptr_offset-22200(%main.Mesh_Renderer* %66, i64 %70)
	%72 = bitcast %main.Mesh_Renderer* %71 to %..rawptr
	%73 = bitcast %main.Mesh_Renderer* %arg to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 48)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %1, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}*, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {%main.Mesh_Renderer*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define i64 @runtime.append_elem-20100({%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* %array, %main.Sprite_Renderer* %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca %main.Sprite_Renderer*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	store {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* %array, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}** %0
	%7 = load %main.Sprite_Renderer, %main.Sprite_Renderer* %arg, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}*, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %1
	; IfStmt
	%13 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}*, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {%main.Sprite_Renderer*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}*, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {%main.Sprite_Renderer*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %1, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}*, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {%main.Sprite_Renderer*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %1, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %2
	; AssignStmt
	%32 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}*, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %2, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %3
	%37 = call i8 @runtime.reserve_dynamic_array-22242({%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}*, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {%main.Sprite_Renderer*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}*, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {%main.Sprite_Renderer*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %1, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %1
	; IfStmt
	%48 = load i64, i64* %1, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}*, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to %main.Sprite_Renderer*
	store %main.Sprite_Renderer* %58, %main.Sprite_Renderer** %5
	%59 = load %main.Sprite_Renderer*, %main.Sprite_Renderer** %5, align 8
	%60 = icmp ne %main.Sprite_Renderer* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6a3, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$6a4, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; SelectorExpr
	; SelectorExpr
	%66 = load %main.Sprite_Renderer*, %main.Sprite_Renderer** %5, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call %main.Sprite_Renderer* @mem.ptr_offset-22256(%main.Sprite_Renderer* %66, i64 %70)
	%72 = bitcast %main.Sprite_Renderer* %71 to %..rawptr
	%73 = bitcast %main.Sprite_Renderer* %arg to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 24)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %1, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}*, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {%main.Sprite_Renderer*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define i64 @runtime.append_elem-20134({%main.Spinner_Component*, i64, i64, %mem.Allocator}* %array, %main.Spinner_Component* %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%main.Spinner_Component*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca %main.Spinner_Component*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	store {%main.Spinner_Component*, i64, i64, %mem.Allocator}* %array, {%main.Spinner_Component*, i64, i64, %mem.Allocator}** %0
	%7 = load %main.Spinner_Component, %main.Spinner_Component* %arg, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}*, {%main.Spinner_Component*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {%main.Spinner_Component*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %1
	; IfStmt
	%13 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}*, {%main.Spinner_Component*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}, {%main.Spinner_Component*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {%main.Spinner_Component*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}*, {%main.Spinner_Component*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}, {%main.Spinner_Component*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {%main.Spinner_Component*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %1, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}*, {%main.Spinner_Component*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}, {%main.Spinner_Component*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {%main.Spinner_Component*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %1, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %2
	; AssignStmt
	%32 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}*, {%main.Spinner_Component*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %2, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %3
	%37 = call i8 @runtime.reserve_dynamic_array-22298({%main.Spinner_Component*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}*, {%main.Spinner_Component*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}, {%main.Spinner_Component*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {%main.Spinner_Component*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}*, {%main.Spinner_Component*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}, {%main.Spinner_Component*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {%main.Spinner_Component*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %1, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %1
	; IfStmt
	%48 = load i64, i64* %1, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}*, {%main.Spinner_Component*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {%main.Spinner_Component*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to %main.Spinner_Component*
	store %main.Spinner_Component* %58, %main.Spinner_Component** %5
	%59 = load %main.Spinner_Component*, %main.Spinner_Component** %5, align 8
	%60 = icmp ne %main.Spinner_Component* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6a5, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$6a6, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; SelectorExpr
	; SelectorExpr
	%66 = load %main.Spinner_Component*, %main.Spinner_Component** %5, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call %main.Spinner_Component* @mem.ptr_offset-22312(%main.Spinner_Component* %66, i64 %70)
	%72 = bitcast %main.Spinner_Component* %71 to %..rawptr
	%73 = bitcast %main.Spinner_Component* %arg to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 16)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %1, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}*, {%main.Spinner_Component*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}, {%main.Spinner_Component*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {%main.Spinner_Component*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define {%..rawptr*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-20175(i64 %len, i64 %cap, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %..rawptr, align 16
	%4 = alloca %mem.Allocator, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca %mem.Raw_Dynamic_Array, align 16
	%7 = alloca %mem.Raw_Dynamic_Array, align 16
	store i64 %len, i64* %0
	store i64 %cap, i64* %1
	%8 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%10 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%11 = load i64, i64* %0, align 8
	%12 = load i64, i64* %1, align 8
	%13 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %10, %runtime.Source_Code_Location* %2
	call void @runtime.make_dynamic_array_error_loc(%runtime.Source_Code_Location* %2, i64 %11, i64 %12)
	; data
	%14 = load i64, i64* %1, align 8
	%15 = mul i64 8, %14
	%16 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%17 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%18 = bitcast %mem.Allocator* %4 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %4
	store %mem.Allocator %16, %mem.Allocator* %4
	%19 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location %17, %runtime.Source_Code_Location* %5
	%20 = call %..rawptr @mem.alloc(i64 %15, i64 8, %mem.Allocator* %4, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %20, %..rawptr* %3
	; s
	; CompoundLit
	%21 = bitcast %mem.Raw_Dynamic_Array* %7 to %..rawptr
	store %mem.Raw_Dynamic_Array zeroinitializer, %mem.Raw_Dynamic_Array* %7
	store %mem.Raw_Dynamic_Array {%..rawptr zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %mem.Allocator zeroinitializer}, %mem.Raw_Dynamic_Array* %7
	%22 = load %..rawptr, %..rawptr* %3, align 8
	%23 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 0
	store %..rawptr %22, %..rawptr* %23
	%24 = load i64, i64* %0, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 1
	store i64 %24, i64* %25
	%26 = load i64, i64* %1, align 8
	%27 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 2
	store i64 %26, i64* %27
	%28 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%29 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 3
	store %mem.Allocator %28, %mem.Allocator* %29
	%30 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, align 8
	store %mem.Raw_Dynamic_Array %30, %mem.Raw_Dynamic_Array* %6
	; ReturnStmt
	%31 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %6, align 8
	%32 = bitcast %mem.Raw_Dynamic_Array* %6 to {%..rawptr*, i64, i64, %mem.Allocator}*
	%33 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %32, align 8
	ret {%..rawptr*, i64, i64, %mem.Allocator} %33
}

define i8 @runtime.reserve_dynamic_array-20197({%..rawptr*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%..rawptr*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {%..rawptr*, i64, i64, %mem.Allocator}* %array, {%..rawptr*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {%..rawptr*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {%..rawptr*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6a7, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6a8, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 8
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 8
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 8, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define %..rawptr* @mem.ptr_offset-20211(%..rawptr* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca %..rawptr*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %..rawptr* %ptr, %..rawptr** %0
	store i64 %n, i64* %1
	; new
	%3 = load %..rawptr*, %..rawptr** %0, align 8
	%4 = ptrtoint %..rawptr* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 8, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to %..rawptr*
	ret %..rawptr* %11
}

define i8* @mem.raw_slice_data-20316({i8*, i64}* %a, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %mem.Raw_Slice*, align 16
	%1 = load {i8*, i64}, {i8*, i64}* %a, align 8
	; ReturnStmt
	; SelectorExpr
	%2 = bitcast {i8*, i64}* %a to %mem.Raw_Slice*
	%3 = bitcast %mem.Raw_Slice** %0 to %..rawptr
	store %mem.Raw_Slice* zeroinitializer, %mem.Raw_Slice** %0
	store %mem.Raw_Slice* %2, %mem.Raw_Slice** %0
	%4 = load %mem.Raw_Slice*, %mem.Raw_Slice** %0, align 8
	%5 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %4, i64 0
	%6 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %5, i64 0, i32 0
	%7 = load %..rawptr, %..rawptr* %6, align 8
	%8 = bitcast %..rawptr %7 to i8*
	ret i8* %8
}

define i8 @runtime.reserve_dynamic_array-20360({i8*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {i8*, i64, i64, %mem.Allocator}* %array, {i8*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {i8*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {i8*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6a9, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6aa, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 1
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 1
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 1, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define {i8*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-20408(i64 %len, i64 %cap, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %..rawptr, align 16
	%4 = alloca %mem.Allocator, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca %mem.Raw_Dynamic_Array, align 16
	%7 = alloca %mem.Raw_Dynamic_Array, align 16
	store i64 %len, i64* %0
	store i64 %cap, i64* %1
	%8 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%10 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%11 = load i64, i64* %0, align 8
	%12 = load i64, i64* %1, align 8
	%13 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %10, %runtime.Source_Code_Location* %2
	call void @runtime.make_dynamic_array_error_loc(%runtime.Source_Code_Location* %2, i64 %11, i64 %12)
	; data
	%14 = load i64, i64* %1, align 8
	%15 = mul i64 1, %14
	%16 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%17 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%18 = bitcast %mem.Allocator* %4 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %4
	store %mem.Allocator %16, %mem.Allocator* %4
	%19 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location %17, %runtime.Source_Code_Location* %5
	%20 = call %..rawptr @mem.alloc(i64 %15, i64 1, %mem.Allocator* %4, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %20, %..rawptr* %3
	; s
	; CompoundLit
	%21 = bitcast %mem.Raw_Dynamic_Array* %7 to %..rawptr
	store %mem.Raw_Dynamic_Array zeroinitializer, %mem.Raw_Dynamic_Array* %7
	store %mem.Raw_Dynamic_Array {%..rawptr zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %mem.Allocator zeroinitializer}, %mem.Raw_Dynamic_Array* %7
	%22 = load %..rawptr, %..rawptr* %3, align 8
	%23 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 0
	store %..rawptr %22, %..rawptr* %23
	%24 = load i64, i64* %0, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 1
	store i64 %24, i64* %25
	%26 = load i64, i64* %1, align 8
	%27 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 2
	store i64 %26, i64* %27
	%28 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%29 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 3
	store %mem.Allocator %28, %mem.Allocator* %29
	%30 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, align 8
	store %mem.Raw_Dynamic_Array %30, %mem.Raw_Dynamic_Array* %6
	; ReturnStmt
	%31 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %6, align 8
	%32 = bitcast %mem.Raw_Dynamic_Array* %6 to {i8*, i64, i64, %mem.Allocator}*
	%33 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %32, align 8
	ret {i8*, i64, i64, %mem.Allocator} %33
}

define i8 @runtime.reserve_dynamic_array-20590({%workbench.Key_Press*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %array, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6ab, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6ac, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 8
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 8
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 4, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define %workbench.Key_Press* @mem.ptr_offset-20604(%workbench.Key_Press* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca %workbench.Key_Press*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %workbench.Key_Press* %ptr, %workbench.Key_Press** %0
	store i64 %n, i64* %1
	; new
	%3 = load %workbench.Key_Press*, %workbench.Key_Press** %0, align 8
	%4 = ptrtoint %workbench.Key_Press* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 8, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to %workbench.Key_Press*
	ret %workbench.Key_Press* %11
}

define %workbench.Key_Press @runtime.pop-20636({%workbench.Key_Press*, i64, i64, %mem.Allocator}* %array) #0 {
decls-0:
	%0 = alloca {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = alloca %workbench.Key_Press, align 16
	%3 = alloca %mem.Raw_Dynamic_Array*, align 16
	store {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %array, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0
	; IfStmt
	%4 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%5 = icmp eq {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %workbench.Key_Press zeroinitializer

if.done-2:
	%8 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%9 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %8, align 8
	%10 = extractvalue {%workbench.Key_Press*, i64, i64, %mem.Allocator} %9, 1
	%11 = icmp sgt i64 %10, 0
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	%14 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6ad, i64 0, i32 0), i64 58}, i64 367, i64 2, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$6ae, i64 0, i32 0), i64 3}}, %runtime.Source_Code_Location* %1
	%16 = call i8 @runtime.assert(i1 %13, %..string zeroinitializer, %runtime.Source_Code_Location* %1)
	; res
	; IndexExpr
	%17 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%18 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %17, align 8
	%19 = extractvalue {%workbench.Key_Press*, i64, i64, %mem.Allocator} %18, 0
	%20 = extractvalue {%workbench.Key_Press*, i64, i64, %mem.Allocator} %18, 1
	%21 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%22 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %21, align 8
	%23 = extractvalue {%workbench.Key_Press*, i64, i64, %mem.Allocator} %22, 1
	%24 = sub i64 %23, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6af, i64 0, i32 0), i64 58}, i64 368, i64 15, i64 %24, i64 %20)
	%25 = getelementptr inbounds %workbench.Key_Press, %workbench.Key_Press* %19, i64 %24
	%26 = load %workbench.Key_Press, %workbench.Key_Press* %25, align 4
	store %workbench.Key_Press %26, %workbench.Key_Press* %2
	; AssignStmt
	; SelectorExpr
	%27 = load {%workbench.Key_Press*, i64, i64, %mem.Allocator}*, {%workbench.Key_Press*, i64, i64, %mem.Allocator}** %0, align 8
	%28 = bitcast {%workbench.Key_Press*, i64, i64, %mem.Allocator}* %27 to %mem.Raw_Dynamic_Array*
	%29 = bitcast %mem.Raw_Dynamic_Array** %3 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 8) noinline
	store %mem.Raw_Dynamic_Array* zeroinitializer, %mem.Raw_Dynamic_Array** %3
	store %mem.Raw_Dynamic_Array* %28, %mem.Raw_Dynamic_Array** %3
	%31 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%32 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %31, i64 0
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0, i32 1
	%34 = load i64, i64* %33, align 8
	%35 = sub i64 %34, 1
	store i64 %35, i64* %33
	; ReturnStmt
	%36 = load %workbench.Key_Press, %workbench.Key_Press* %2, align 4
	ret %workbench.Key_Press %36
}

define i8 @runtime.reserve_dynamic_array-20768({%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %array, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}*, {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6b0, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6b1, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 112
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 112
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 8, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define %workbench.Buffered_Vertex* @mem.ptr_offset-20782(%workbench.Buffered_Vertex* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca %workbench.Buffered_Vertex*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %workbench.Buffered_Vertex* %ptr, %workbench.Buffered_Vertex** %0
	store i64 %n, i64* %1
	; new
	%3 = load %workbench.Buffered_Vertex*, %workbench.Buffered_Vertex** %0, align 8
	%4 = ptrtoint %workbench.Buffered_Vertex* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 112, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to %workbench.Buffered_Vertex*
	ret %workbench.Buffered_Vertex* %11
}

define void @workbench.set_vertex_format-20833(%runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info_Struct, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	%2 = alloca {%runtime.Type_Info_Struct, i8}, align 16
	%3 = alloca %..string, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i32, align 16
	%8 = alloca i64, align 16
	%9 = alloca %..rawptr, align 16
	%10 = alloca i32, align 16
	%11 = alloca i32, align 16
	%12 = alloca %..any, align 16
	%13 = alloca %..any, align 16
	%14 = alloca {%..any*, i64}, align 16
	%15 = alloca [2 x %..any], align 16
	%16 = alloca {%..any*, i64}, align 16
	%17 = alloca %runtime.Source_Code_Location, align 16
	%18 = alloca %runtime.Source_Code_Location, align 16
	%19 = alloca %runtime.Source_Code_Location, align 16
	%20 = alloca %runtime.Source_Code_Location, align 16
	%21 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; ti
	; SelectorExpr
	%22 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 130
	%23 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %22)
	%24 = bitcast %runtime.Type_Info** %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %1
	store %runtime.Type_Info* %23, %runtime.Type_Info** %1
	%26 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%27 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %26, i64 0
	%28 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %27, i64 0, i32 3
	%29 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %28, align 8
	; cast - union_cast
	%30 = bitcast {%runtime.Type_Info_Struct, i8}* %2 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 80) noinline
	store {%runtime.Type_Info_Struct, i8} zeroinitializer, {%runtime.Type_Info_Struct, i8}* %2
	%32 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %28, i64 0, i32 2 ; UnionTagPtr
	%33 = load i8, i8* %32, align 1
	%34 = icmp eq i8 %33, 16
	br i1 %34, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%35 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %2, i64 0, i32 0
	%36 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %2, i64 0, i32 1
	%37 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %28 to %runtime.Type_Info_Struct*
	%38 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %37, align 8
	store %runtime.Type_Info_Struct %38, %runtime.Type_Info_Struct* %35
	store i8 1, i8* %36
	br label %union_cast.end-2

union_cast.end-2:
	%39 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %2, i64 0, i32 1
	%40 = load i8, i8* %39, align 1
	%41 = trunc i8 %40 to i1
	call void @runtime.type_assertion_check(i1 %41, %..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$6b2, i64 0, i32 0), i64 69}, i64 237, i64 43, %..typeid 1152921504606846991, %..typeid 3386706919782613039)
	%42 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %2, i64 0, i32 0
	%43 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %42, align 8
	store %runtime.Type_Info_Struct %43, %runtime.Type_Info_Struct* %0
	; RangeStmt
	; name
	%44 = bitcast %..string* %3 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 16) noinline
	store %..string zeroinitializer, %..string* %3
	; _i
	%46 = bitcast i64* %4 to %..rawptr
	%47 = call %..rawptr @mem.zero(%..rawptr %46, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	; SelectorExpr
	%48 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %0, i64 0, i32 1
	%49 = load {%..string*, i64}, {%..string*, i64}* %48, align 8
	%50 = bitcast i64* %5 to %..rawptr
	%51 = call %..rawptr @mem.zero(%..rawptr %50, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	%52 = extractvalue {%..string*, i64} %49, 1
	store i64 %52, i64* %5
	%53 = bitcast i64* %6 to %..rawptr
	%54 = call %..rawptr @mem.zero(%..rawptr %53, i64 8) noinline
	store i64 zeroinitializer, i64* %6
	store i64 -1, i64* %6
	br label %for.index.loop-3

for.index.loop-3:
	%55 = load i64, i64* %6, align 8
	%56 = add i64 %55, 1
	store i64 %56, i64* %6
	%57 = load i64, i64* %5, align 8
	%58 = icmp slt i64 %56, %57
	br i1 %58, label %for.index.body-4, label %for.index.done-31

for.index.body-4:
	%59 = load i64, i64* %6, align 8
	%60 = extractvalue {%..string*, i64} %49, 0
	%61 = getelementptr inbounds %..string, %..string* %60, i64 %59
	%62 = load %..string, %..string* %61, align 8
	store %..string %62, %..string* %3
	store i64 %59, i64* %4
	; i
	%63 = load i64, i64* %4, align 8
	%64 = trunc i64 %63 to i32
	store i32 %64, i32* %7
	; offset
	; IndexExpr
	; SelectorExpr
	%65 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %0, i64 0, i32 2
	%66 = load {i64*, i64}, {i64*, i64}* %65, align 8
	%67 = extractvalue {i64*, i64} %66, 0
	%68 = load i32, i32* %7, align 4
	%69 = zext i32 %68 to i64
	%70 = extractvalue {i64*, i64} %66, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$6b3, i64 0, i32 0), i64 69}, i64 241, i64 24, i64 %69, i64 %70)
	%71 = getelementptr inbounds i64, i64* %67, i64 %69
	%72 = load i64, i64* %71, align 8
	store i64 %72, i64* %8
	; offset_in_struct
	%73 = load i64, i64* %8, align 8
	%74 = inttoptr i64 %73 to %..rawptr
	store %..rawptr %74, %..rawptr* %9
	; num_elements
	%75 = bitcast i32* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 4) noinline
	store i32 zeroinitializer, i32* %10
	; type_of_elements
	%77 = bitcast i32* %11 to %..rawptr
	%78 = call %..rawptr @mem.zero(%..rawptr %77, i64 4) noinline
	store i32 zeroinitializer, i32* %11
	; SwitchStmt
	; SelectorExpr
	; IndexExpr
	; SelectorExpr
	%79 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %0, i64 0, i32 0
	%80 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %79, align 8
	%81 = extractvalue {%runtime.Type_Info**, i64} %80, 0
	%82 = load i32, i32* %7, align 4
	%83 = zext i32 %82 to i64
	%84 = extractvalue {%runtime.Type_Info**, i64} %80, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$6b4, i64 0, i32 0), i64 69}, i64 246, i64 19, i64 %83, i64 %84)
	%85 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %81, i64 %83
	%86 = load %runtime.Type_Info*, %runtime.Type_Info** %85, align 8
	%87 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %86, i64 0
	%88 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %87, i64 0, i32 2
	%89 = load %..typeid, %..typeid* %88, align 8
	%90 = icmp eq %..typeid %89, 3098476543630901354
	br i1 %90, label %switch.case.body-6, label %switch.case.next-5

switch.case.next-5:
	%91 = icmp eq %..typeid %89, 3098476543630901357
	br i1 %91, label %switch.fall.body-8, label %switch.case.next-7

switch.case.body-6:
	; AssignStmt
	store i32 2, i32* %10
	; AssignStmt
	store i32 5126, i32* %11
	br label %switch.done-30

switch.case.next-7:
	%92 = icmp eq %..typeid %89, 3098476543630901360
	br i1 %92, label %switch.fall.body-11, label %switch.case.next-9

switch.fall.body-8:
	; AssignStmt
	store i32 3, i32* %10
	; AssignStmt
	store i32 5126, i32* %11
	br label %switch.done-30

switch.case.next-9:
	%93 = icmp eq %..typeid %89, 3386706919782613124
	br i1 %93, label %switch.fall.body-11, label %switch.case.next-10

switch.case.next-10:
	%94 = icmp eq %..typeid %89, 3386706919782613126
	br i1 %94, label %switch.fall.body-13, label %switch.case.next-12

switch.fall.body-11:
	; AssignStmt
	store i32 4, i32* %10
	; AssignStmt
	store i32 5126, i32* %11
	br label %switch.done-30

switch.case.next-12:
	%95 = icmp eq %..typeid %89, 216172782113783892
	br i1 %95, label %switch.fall.body-15, label %switch.case.next-14

switch.fall.body-13:
	; AssignStmt
	store i32 4, i32* %10
	; AssignStmt
	store i32 5121, i32* %11
	br label %switch.done-30

switch.case.next-14:
	%96 = icmp eq %..typeid %89, 216172782113783891
	br i1 %96, label %switch.fall.body-17, label %switch.case.next-16

switch.fall.body-15:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5130, i32* %11
	br label %switch.done-30

switch.case.next-16:
	%97 = icmp eq %..typeid %89, 4683743612465315848
	br i1 %97, label %switch.fall.body-19, label %switch.case.next-18

switch.fall.body-17:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5126, i32* %11
	br label %switch.done-30

switch.case.next-18:
	%98 = icmp eq %..typeid %89, 72057594037928002
	br i1 %98, label %switch.fall.body-21, label %switch.case.next-20

switch.fall.body-19:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5124, i32* %11
	br label %switch.done-30

switch.case.next-20:
	%99 = icmp eq %..typeid %89, 4683743612465315903
	br i1 %99, label %switch.fall.body-23, label %switch.case.next-22

switch.fall.body-21:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5125, i32* %11
	br label %switch.done-30

switch.case.next-22:
	%100 = icmp eq %..typeid %89, 72057594037928001
	br i1 %100, label %switch.fall.body-25, label %switch.case.next-24

switch.fall.body-23:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5122, i32* %11
	br label %switch.done-30

switch.case.next-24:
	%101 = icmp eq %..typeid %89, 4683743612465315902
	br i1 %101, label %switch.fall.body-27, label %switch.case.next-26

switch.fall.body-25:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5123, i32* %11
	br label %switch.done-30

switch.case.next-26:
	%102 = icmp eq %..typeid %89, 72057594037927939
	br i1 %102, label %switch.fall.body-29, label %switch.case.next-28

switch.fall.body-27:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5120, i32* %11
	br label %switch.done-30

switch.case.next-28:
	; SelectorExpr
	%103 = load %..string, %..string* %3, align 8
	; SelectorExpr
	; IndexExpr
	; SelectorExpr
	%104 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %0, i64 0, i32 0
	%105 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %104, align 8
	%106 = extractvalue {%runtime.Type_Info**, i64} %105, 0
	%107 = load i32, i32* %7, align 4
	%108 = zext i32 %107 to i64
	%109 = extractvalue {%runtime.Type_Info**, i64} %105, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$6b5, i64 0, i32 0), i64 69}, i64 296, i64 86, i64 %108, i64 %109)
	%110 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %106, i64 %108
	%111 = load %runtime.Type_Info*, %runtime.Type_Info** %110, align 8
	%112 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %111, i64 0
	%113 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %112, i64 0, i32 2
	%114 = load %..typeid, %..typeid* %113, align 8
	%115 = bitcast %..any* %12 to %..rawptr
	%116 = call %..rawptr @mem.zero(%..rawptr %115, i64 16) noinline
	store %..any zeroinitializer, %..any* %12
	%117 = bitcast %..string* %3 to %..rawptr
	%118 = getelementptr inbounds %..any, %..any* %12, i64 0, i32 0
	store %..rawptr %117, %..rawptr* %118
	%119 = getelementptr inbounds %..any, %..any* %12, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %119
	%120 = load %..any, %..any* %12, align 8
	%121 = bitcast %..any* %13 to %..rawptr
	%122 = call %..rawptr @mem.zero(%..rawptr %121, i64 16) noinline
	store %..any zeroinitializer, %..any* %13
	%123 = bitcast %..typeid* %113 to %..rawptr
	%124 = getelementptr inbounds %..any, %..any* %13, i64 0, i32 0
	store %..rawptr %123, %..rawptr* %124
	%125 = getelementptr inbounds %..any, %..any* %13, i64 0, i32 1
	store %..typeid 14, %..typeid* %125
	%126 = load %..any, %..any* %13, align 8
	; variadic call argument generation
	%127 = bitcast {%..any*, i64}* %14 to %..rawptr
	%128 = call %..rawptr @mem.zero(%..rawptr %127, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %14
	%129 = bitcast [2 x %..any]* %15 to %..rawptr
	%130 = call %..rawptr @mem.zero(%..rawptr %129, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %15
	%131 = getelementptr inbounds [2 x %..any], [2 x %..any]* %15, i64 0, i32 0
	store %..any %120, %..any* %131
	%132 = getelementptr inbounds [2 x %..any], [2 x %..any]* %15, i64 0, i32 1
	store %..any %126, %..any* %132
	%133 = getelementptr inbounds [2 x %..any], [2 x %..any]* %15, i64 0, i32 0
	%134 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %14, i64 0, i32 0
	store %..any* %133, %..any** %134
	%135 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %14, i64 0, i32 1
	store i64 2, i64* %135
	%136 = load {%..any*, i64}, {%..any*, i64}* %14, align 8
	%137 = bitcast {%..any*, i64}* %16 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %16
	store {%..any*, i64} %136, {%..any*, i64}* %16
	%139 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([44 x i8], [44 x i8]* @str$6b6, i64 0, i32 0), i64 43}, {%..any*, i64}* %16, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%140 = bitcast %runtime.Source_Code_Location* %17 to %..rawptr
	%141 = call %..rawptr @mem.zero(%..rawptr %140, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %17
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$6b7, i64 0, i32 0), i64 69}, i64 296, i64 5, %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$6b8, i64 0, i32 0), i64 17}}, %runtime.Source_Code_Location* %17
	call void @runtime.panic(%..string %139, %runtime.Source_Code_Location* %17) noreturn
	br label %switch.done-30

switch.fall.body-29:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5121, i32* %11
	br label %switch.done-30

switch.done-30:
	%142 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%143 = bitcast %runtime.Source_Code_Location* %18 to %..rawptr
	%144 = call %..rawptr @mem.zero(%..rawptr %143, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %18
	store %runtime.Source_Code_Location %142, %runtime.Source_Code_Location* %18
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$6b9, i64 0, i32 0), i64 17}, %runtime.Source_Code_Location* %18, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%145 = load void (i32, i32, i32, i8, i32, %..rawptr)*, void (i32, i32, i32, i8, i32, %..rawptr)** @gl.VertexAttribPointer, align 8
	%146 = load i32, i32* %7, align 4
	%147 = load i32, i32* %10, align 4
	%148 = load i32, i32* %11, align 4
	%149 = load %..rawptr, %..rawptr* %9, align 8
	call ccc void %145(i32 %146, i32 %147, i32 %148, i8 0, i32 36, %..rawptr %149)
	%150 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%151 = bitcast %runtime.Source_Code_Location* %19 to %..rawptr
	%152 = call %..rawptr @mem.zero(%..rawptr %151, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %19
	store %runtime.Source_Code_Location %150, %runtime.Source_Code_Location* %19
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$6ba, i64 0, i32 0), i64 17}, %runtime.Source_Code_Location* %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%153 = load void (i32)*, void (i32)** @gl.EnableVertexAttribArray, align 8
	%154 = load i32, i32* %7, align 4
	call ccc void %153(i32 %154)
	%155 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%156 = bitcast %runtime.Source_Code_Location* %20 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %20
	store %runtime.Source_Code_Location %155, %runtime.Source_Code_Location* %20
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$6bb, i64 0, i32 0), i64 17}, %runtime.Source_Code_Location* %20, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-3

for.index.done-31:
	ret void
}

define i8 @runtime.reserve_dynamic_array-20852({%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %array, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {%workbench.Vertex2D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex2D*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {%workbench.Vertex2D*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6bc, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6bd, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 36
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 36
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 4, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define %workbench.Vertex2D* @mem.ptr_offset-20866(%workbench.Vertex2D* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca %workbench.Vertex2D*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %workbench.Vertex2D* %ptr, %workbench.Vertex2D** %0
	store i64 %n, i64* %1
	; new
	%3 = load %workbench.Vertex2D*, %workbench.Vertex2D** %0, align 8
	%4 = ptrtoint %workbench.Vertex2D* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 36, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to %workbench.Vertex2D*
	ret %workbench.Vertex2D* %11
}

define {i64*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-20901(i64 %len, i64 %cap, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %..rawptr, align 16
	%4 = alloca %mem.Allocator, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca %mem.Raw_Dynamic_Array, align 16
	%7 = alloca %mem.Raw_Dynamic_Array, align 16
	store i64 %len, i64* %0
	store i64 %cap, i64* %1
	%8 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%10 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%11 = load i64, i64* %0, align 8
	%12 = load i64, i64* %1, align 8
	%13 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %10, %runtime.Source_Code_Location* %2
	call void @runtime.make_dynamic_array_error_loc(%runtime.Source_Code_Location* %2, i64 %11, i64 %12)
	; data
	%14 = load i64, i64* %1, align 8
	%15 = mul i64 8, %14
	%16 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%17 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%18 = bitcast %mem.Allocator* %4 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %4
	store %mem.Allocator %16, %mem.Allocator* %4
	%19 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location %17, %runtime.Source_Code_Location* %5
	%20 = call %..rawptr @mem.alloc(i64 %15, i64 8, %mem.Allocator* %4, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %20, %..rawptr* %3
	; s
	; CompoundLit
	%21 = bitcast %mem.Raw_Dynamic_Array* %7 to %..rawptr
	store %mem.Raw_Dynamic_Array zeroinitializer, %mem.Raw_Dynamic_Array* %7
	store %mem.Raw_Dynamic_Array {%..rawptr zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %mem.Allocator zeroinitializer}, %mem.Raw_Dynamic_Array* %7
	%22 = load %..rawptr, %..rawptr* %3, align 8
	%23 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 0
	store %..rawptr %22, %..rawptr* %23
	%24 = load i64, i64* %0, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 1
	store i64 %24, i64* %25
	%26 = load i64, i64* %1, align 8
	%27 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 2
	store i64 %26, i64* %27
	%28 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%29 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 3
	store %mem.Allocator %28, %mem.Allocator* %29
	%30 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, align 8
	store %mem.Raw_Dynamic_Array %30, %mem.Raw_Dynamic_Array* %6
	; ReturnStmt
	%31 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %6, align 8
	%32 = bitcast %mem.Raw_Dynamic_Array* %6 to {i64*, i64, i64, %mem.Allocator}*
	%33 = load {i64*, i64, i64, %mem.Allocator}, {i64*, i64, i64, %mem.Allocator}* %32, align 8
	ret {i64*, i64, i64, %mem.Allocator} %33
}

define i8 @runtime.reserve_dynamic_array-20941({%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.Vertex3D*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %array, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {%workbench.Vertex3D*, i64, i64, %mem.Allocator}*, {%workbench.Vertex3D*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {%workbench.Vertex3D*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6be, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6bf, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 48
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 48
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 4, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define %workbench.Vertex3D* @mem.ptr_offset-20955(%workbench.Vertex3D* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca %workbench.Vertex3D*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %workbench.Vertex3D* %ptr, %workbench.Vertex3D** %0
	store i64 %n, i64* %1
	; new
	%3 = load %workbench.Vertex3D*, %workbench.Vertex3D** %0, align 8
	%4 = ptrtoint %workbench.Vertex3D* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 48, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to %workbench.Vertex3D*
	ret %workbench.Vertex3D* %11
}

define i8 @runtime.reserve_dynamic_array-20997({i64*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i64*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {i64*, i64, i64, %mem.Allocator}* %array, {i64*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {i64*, i64, i64, %mem.Allocator}*, {i64*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {i64*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {i64*, i64, i64, %mem.Allocator}*, {i64*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {i64*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6c0, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6c1, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 8
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 8
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 8, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define i64* @mem.ptr_offset-21011(i64* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca i64*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store i64* %ptr, i64** %0
	store i64 %n, i64* %1
	; new
	%3 = load i64*, i64** %0, align 8
	%4 = ptrtoint i64* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 8, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to i64*
	ret i64* %11
}

define void @workbench.set_vertex_format-21041(%runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info_Struct, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	%2 = alloca {%runtime.Type_Info_Struct, i8}, align 16
	%3 = alloca %..string, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i32, align 16
	%8 = alloca i64, align 16
	%9 = alloca %..rawptr, align 16
	%10 = alloca i32, align 16
	%11 = alloca i32, align 16
	%12 = alloca %..any, align 16
	%13 = alloca %..any, align 16
	%14 = alloca {%..any*, i64}, align 16
	%15 = alloca [2 x %..any], align 16
	%16 = alloca {%..any*, i64}, align 16
	%17 = alloca %runtime.Source_Code_Location, align 16
	%18 = alloca %runtime.Source_Code_Location, align 16
	%19 = alloca %runtime.Source_Code_Location, align 16
	%20 = alloca %runtime.Source_Code_Location, align 16
	%21 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; ti
	; SelectorExpr
	%22 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 154
	%23 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %22)
	%24 = bitcast %runtime.Type_Info** %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %1
	store %runtime.Type_Info* %23, %runtime.Type_Info** %1
	%26 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%27 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %26, i64 0
	%28 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %27, i64 0, i32 3
	%29 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %28, align 8
	; cast - union_cast
	%30 = bitcast {%runtime.Type_Info_Struct, i8}* %2 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 80) noinline
	store {%runtime.Type_Info_Struct, i8} zeroinitializer, {%runtime.Type_Info_Struct, i8}* %2
	%32 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %28, i64 0, i32 2 ; UnionTagPtr
	%33 = load i8, i8* %32, align 1
	%34 = icmp eq i8 %33, 16
	br i1 %34, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%35 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %2, i64 0, i32 0
	%36 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %2, i64 0, i32 1
	%37 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %28 to %runtime.Type_Info_Struct*
	%38 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %37, align 8
	store %runtime.Type_Info_Struct %38, %runtime.Type_Info_Struct* %35
	store i8 1, i8* %36
	br label %union_cast.end-2

union_cast.end-2:
	%39 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %2, i64 0, i32 1
	%40 = load i8, i8* %39, align 1
	%41 = trunc i8 %40 to i1
	call void @runtime.type_assertion_check(i1 %41, %..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$6c2, i64 0, i32 0), i64 69}, i64 237, i64 43, %..typeid 1152921504606846991, %..typeid 3386706919782613039)
	%42 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %2, i64 0, i32 0
	%43 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %42, align 8
	store %runtime.Type_Info_Struct %43, %runtime.Type_Info_Struct* %0
	; RangeStmt
	; name
	%44 = bitcast %..string* %3 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 16) noinline
	store %..string zeroinitializer, %..string* %3
	; _i
	%46 = bitcast i64* %4 to %..rawptr
	%47 = call %..rawptr @mem.zero(%..rawptr %46, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	; SelectorExpr
	%48 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %0, i64 0, i32 1
	%49 = load {%..string*, i64}, {%..string*, i64}* %48, align 8
	%50 = bitcast i64* %5 to %..rawptr
	%51 = call %..rawptr @mem.zero(%..rawptr %50, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	%52 = extractvalue {%..string*, i64} %49, 1
	store i64 %52, i64* %5
	%53 = bitcast i64* %6 to %..rawptr
	%54 = call %..rawptr @mem.zero(%..rawptr %53, i64 8) noinline
	store i64 zeroinitializer, i64* %6
	store i64 -1, i64* %6
	br label %for.index.loop-3

for.index.loop-3:
	%55 = load i64, i64* %6, align 8
	%56 = add i64 %55, 1
	store i64 %56, i64* %6
	%57 = load i64, i64* %5, align 8
	%58 = icmp slt i64 %56, %57
	br i1 %58, label %for.index.body-4, label %for.index.done-31

for.index.body-4:
	%59 = load i64, i64* %6, align 8
	%60 = extractvalue {%..string*, i64} %49, 0
	%61 = getelementptr inbounds %..string, %..string* %60, i64 %59
	%62 = load %..string, %..string* %61, align 8
	store %..string %62, %..string* %3
	store i64 %59, i64* %4
	; i
	%63 = load i64, i64* %4, align 8
	%64 = trunc i64 %63 to i32
	store i32 %64, i32* %7
	; offset
	; IndexExpr
	; SelectorExpr
	%65 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %0, i64 0, i32 2
	%66 = load {i64*, i64}, {i64*, i64}* %65, align 8
	%67 = extractvalue {i64*, i64} %66, 0
	%68 = load i32, i32* %7, align 4
	%69 = zext i32 %68 to i64
	%70 = extractvalue {i64*, i64} %66, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$6c3, i64 0, i32 0), i64 69}, i64 241, i64 24, i64 %69, i64 %70)
	%71 = getelementptr inbounds i64, i64* %67, i64 %69
	%72 = load i64, i64* %71, align 8
	store i64 %72, i64* %8
	; offset_in_struct
	%73 = load i64, i64* %8, align 8
	%74 = inttoptr i64 %73 to %..rawptr
	store %..rawptr %74, %..rawptr* %9
	; num_elements
	%75 = bitcast i32* %10 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 4) noinline
	store i32 zeroinitializer, i32* %10
	; type_of_elements
	%77 = bitcast i32* %11 to %..rawptr
	%78 = call %..rawptr @mem.zero(%..rawptr %77, i64 4) noinline
	store i32 zeroinitializer, i32* %11
	; SwitchStmt
	; SelectorExpr
	; IndexExpr
	; SelectorExpr
	%79 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %0, i64 0, i32 0
	%80 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %79, align 8
	%81 = extractvalue {%runtime.Type_Info**, i64} %80, 0
	%82 = load i32, i32* %7, align 4
	%83 = zext i32 %82 to i64
	%84 = extractvalue {%runtime.Type_Info**, i64} %80, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$6c4, i64 0, i32 0), i64 69}, i64 246, i64 19, i64 %83, i64 %84)
	%85 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %81, i64 %83
	%86 = load %runtime.Type_Info*, %runtime.Type_Info** %85, align 8
	%87 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %86, i64 0
	%88 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %87, i64 0, i32 2
	%89 = load %..typeid, %..typeid* %88, align 8
	%90 = icmp eq %..typeid %89, 3098476543630901354
	br i1 %90, label %switch.case.body-6, label %switch.case.next-5

switch.case.next-5:
	%91 = icmp eq %..typeid %89, 3098476543630901357
	br i1 %91, label %switch.fall.body-8, label %switch.case.next-7

switch.case.body-6:
	; AssignStmt
	store i32 2, i32* %10
	; AssignStmt
	store i32 5126, i32* %11
	br label %switch.done-30

switch.case.next-7:
	%92 = icmp eq %..typeid %89, 3098476543630901360
	br i1 %92, label %switch.fall.body-11, label %switch.case.next-9

switch.fall.body-8:
	; AssignStmt
	store i32 3, i32* %10
	; AssignStmt
	store i32 5126, i32* %11
	br label %switch.done-30

switch.case.next-9:
	%93 = icmp eq %..typeid %89, 3386706919782613124
	br i1 %93, label %switch.fall.body-11, label %switch.case.next-10

switch.case.next-10:
	%94 = icmp eq %..typeid %89, 3386706919782613126
	br i1 %94, label %switch.fall.body-13, label %switch.case.next-12

switch.fall.body-11:
	; AssignStmt
	store i32 4, i32* %10
	; AssignStmt
	store i32 5126, i32* %11
	br label %switch.done-30

switch.case.next-12:
	%95 = icmp eq %..typeid %89, 216172782113783892
	br i1 %95, label %switch.fall.body-15, label %switch.case.next-14

switch.fall.body-13:
	; AssignStmt
	store i32 4, i32* %10
	; AssignStmt
	store i32 5121, i32* %11
	br label %switch.done-30

switch.case.next-14:
	%96 = icmp eq %..typeid %89, 216172782113783891
	br i1 %96, label %switch.fall.body-17, label %switch.case.next-16

switch.fall.body-15:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5130, i32* %11
	br label %switch.done-30

switch.case.next-16:
	%97 = icmp eq %..typeid %89, 4683743612465315848
	br i1 %97, label %switch.fall.body-19, label %switch.case.next-18

switch.fall.body-17:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5126, i32* %11
	br label %switch.done-30

switch.case.next-18:
	%98 = icmp eq %..typeid %89, 72057594037928002
	br i1 %98, label %switch.fall.body-21, label %switch.case.next-20

switch.fall.body-19:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5124, i32* %11
	br label %switch.done-30

switch.case.next-20:
	%99 = icmp eq %..typeid %89, 4683743612465315903
	br i1 %99, label %switch.fall.body-23, label %switch.case.next-22

switch.fall.body-21:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5125, i32* %11
	br label %switch.done-30

switch.case.next-22:
	%100 = icmp eq %..typeid %89, 72057594037928001
	br i1 %100, label %switch.fall.body-25, label %switch.case.next-24

switch.fall.body-23:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5122, i32* %11
	br label %switch.done-30

switch.case.next-24:
	%101 = icmp eq %..typeid %89, 4683743612465315902
	br i1 %101, label %switch.fall.body-27, label %switch.case.next-26

switch.fall.body-25:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5123, i32* %11
	br label %switch.done-30

switch.case.next-26:
	%102 = icmp eq %..typeid %89, 72057594037927939
	br i1 %102, label %switch.fall.body-29, label %switch.case.next-28

switch.fall.body-27:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5120, i32* %11
	br label %switch.done-30

switch.case.next-28:
	; SelectorExpr
	%103 = load %..string, %..string* %3, align 8
	; SelectorExpr
	; IndexExpr
	; SelectorExpr
	%104 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %0, i64 0, i32 0
	%105 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %104, align 8
	%106 = extractvalue {%runtime.Type_Info**, i64} %105, 0
	%107 = load i32, i32* %7, align 4
	%108 = zext i32 %107 to i64
	%109 = extractvalue {%runtime.Type_Info**, i64} %105, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$6c5, i64 0, i32 0), i64 69}, i64 296, i64 86, i64 %108, i64 %109)
	%110 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %106, i64 %108
	%111 = load %runtime.Type_Info*, %runtime.Type_Info** %110, align 8
	%112 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %111, i64 0
	%113 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %112, i64 0, i32 2
	%114 = load %..typeid, %..typeid* %113, align 8
	%115 = bitcast %..any* %12 to %..rawptr
	%116 = call %..rawptr @mem.zero(%..rawptr %115, i64 16) noinline
	store %..any zeroinitializer, %..any* %12
	%117 = bitcast %..string* %3 to %..rawptr
	%118 = getelementptr inbounds %..any, %..any* %12, i64 0, i32 0
	store %..rawptr %117, %..rawptr* %118
	%119 = getelementptr inbounds %..any, %..any* %12, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %119
	%120 = load %..any, %..any* %12, align 8
	%121 = bitcast %..any* %13 to %..rawptr
	%122 = call %..rawptr @mem.zero(%..rawptr %121, i64 16) noinline
	store %..any zeroinitializer, %..any* %13
	%123 = bitcast %..typeid* %113 to %..rawptr
	%124 = getelementptr inbounds %..any, %..any* %13, i64 0, i32 0
	store %..rawptr %123, %..rawptr* %124
	%125 = getelementptr inbounds %..any, %..any* %13, i64 0, i32 1
	store %..typeid 14, %..typeid* %125
	%126 = load %..any, %..any* %13, align 8
	; variadic call argument generation
	%127 = bitcast {%..any*, i64}* %14 to %..rawptr
	%128 = call %..rawptr @mem.zero(%..rawptr %127, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %14
	%129 = bitcast [2 x %..any]* %15 to %..rawptr
	%130 = call %..rawptr @mem.zero(%..rawptr %129, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %15
	%131 = getelementptr inbounds [2 x %..any], [2 x %..any]* %15, i64 0, i32 0
	store %..any %120, %..any* %131
	%132 = getelementptr inbounds [2 x %..any], [2 x %..any]* %15, i64 0, i32 1
	store %..any %126, %..any* %132
	%133 = getelementptr inbounds [2 x %..any], [2 x %..any]* %15, i64 0, i32 0
	%134 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %14, i64 0, i32 0
	store %..any* %133, %..any** %134
	%135 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %14, i64 0, i32 1
	store i64 2, i64* %135
	%136 = load {%..any*, i64}, {%..any*, i64}* %14, align 8
	%137 = bitcast {%..any*, i64}* %16 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %16
	store {%..any*, i64} %136, {%..any*, i64}* %16
	%139 = call %..string @fmt.tprintf(%..string {i8* getelementptr inbounds ([44 x i8], [44 x i8]* @str$6c6, i64 0, i32 0), i64 43}, {%..any*, i64}* %16, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%140 = bitcast %runtime.Source_Code_Location* %17 to %..rawptr
	%141 = call %..rawptr @mem.zero(%..rawptr %140, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %17
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([70 x i8], [70 x i8]* @str$6c7, i64 0, i32 0), i64 69}, i64 296, i64 5, %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$6c8, i64 0, i32 0), i64 17}}, %runtime.Source_Code_Location* %17
	call void @runtime.panic(%..string %139, %runtime.Source_Code_Location* %17) noreturn
	br label %switch.done-30

switch.fall.body-29:
	; AssignStmt
	store i32 1, i32* %10
	; AssignStmt
	store i32 5121, i32* %11
	br label %switch.done-30

switch.done-30:
	%142 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%143 = bitcast %runtime.Source_Code_Location* %18 to %..rawptr
	%144 = call %..rawptr @mem.zero(%..rawptr %143, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %18
	store %runtime.Source_Code_Location %142, %runtime.Source_Code_Location* %18
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$6c9, i64 0, i32 0), i64 17}, %runtime.Source_Code_Location* %18, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%145 = load void (i32, i32, i32, i8, i32, %..rawptr)*, void (i32, i32, i32, i8, i32, %..rawptr)** @gl.VertexAttribPointer, align 8
	%146 = load i32, i32* %7, align 4
	%147 = load i32, i32* %10, align 4
	%148 = load i32, i32* %11, align 4
	%149 = load %..rawptr, %..rawptr* %9, align 8
	call ccc void %145(i32 %146, i32 %147, i32 %148, i8 0, i32 48, %..rawptr %149)
	%150 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%151 = bitcast %runtime.Source_Code_Location* %19 to %..rawptr
	%152 = call %..rawptr @mem.zero(%..rawptr %151, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %19
	store %runtime.Source_Code_Location %150, %runtime.Source_Code_Location* %19
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$6ca, i64 0, i32 0), i64 17}, %runtime.Source_Code_Location* %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%153 = load void (i32)*, void (i32)** @gl.EnableVertexAttribArray, align 8
	%154 = load i32, i32* %7, align 4
	call ccc void %153(i32 %154)
	%155 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%156 = bitcast %runtime.Source_Code_Location* %20 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %20
	store %runtime.Source_Code_Location %155, %runtime.Source_Code_Location* %20
	call void @workbench.log_gl_errors(%..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$6cb, i64 0, i32 0), i64 17}, %runtime.Source_Code_Location* %20, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-3

for.index.done-31:
	ret void
}

define i8 @runtime.reserve_dynamic_array-21086({%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %array, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}*, {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {%workbench._Scene_Internal*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6cc, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6cd, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 56
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 56
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 8, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define %workbench._Scene_Internal* @mem.ptr_offset-21100(%workbench._Scene_Internal* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca %workbench._Scene_Internal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %workbench._Scene_Internal* %ptr, %workbench._Scene_Internal** %0
	store i64 %n, i64* %1
	; new
	%3 = load %workbench._Scene_Internal*, %workbench._Scene_Internal** %0, align 8
	%4 = ptrtoint %workbench._Scene_Internal* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 56, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to %workbench._Scene_Internal*
	ret %workbench._Scene_Internal* %11
}

define %runtime.Map_Header @runtime.__get_map_header-21196({{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}* %m) #0 {
decls-0:
	%0 = alloca {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}*, align 16
	%1 = alloca %runtime.Map_Header, align 16
	%2 = alloca %runtime.Map_Header, align 16
	%3 = alloca i8, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca {%runtime.Type_Info_String, i8}, align 16
	store {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}* %m, {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}** %0
	; header
	; CompoundLit
	%6 = bitcast %runtime.Map_Header* %2 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 48) noinline
	store %runtime.Map_Header zeroinitializer, %runtime.Map_Header* %2
	store %runtime.Map_Header {%mem.Raw_Map* zeroinitializer, i8 zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i64 zeroinitializer}, %runtime.Map_Header* %2
	%8 = load {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}*, {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}** %0, align 8
	%9 = bitcast {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}}* %8 to %mem.Raw_Map*
	%10 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %2, i64 0, i32 0
	store %mem.Raw_Map* %9, %mem.Raw_Map** %10
	%11 = load %runtime.Map_Header, %runtime.Map_Header* %2, align 8
	store %runtime.Map_Header %11, %runtime.Map_Header* %1
	; is_string
	; SelectorExpr
	%12 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 119
	%13 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %12)
	%14 = bitcast %runtime.Type_Info** %4 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %4
	store %runtime.Type_Info* %13, %runtime.Type_Info** %4
	%16 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	%17 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %16, i64 0
	%18 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %17, i64 0, i32 3
	%19 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %18, align 8
	; cast - union_cast
	%20 = bitcast {%runtime.Type_Info_String, i8}* %5 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 2) noinline
	store {%runtime.Type_Info_String, i8} zeroinitializer, {%runtime.Type_Info_String, i8}* %5
	%22 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %18, i64 0, i32 2 ; UnionTagPtr
	%23 = load i8, i8* %22, align 1
	%24 = icmp eq i8 %23, 6
	br i1 %24, label %union_cast.ok-1, label %union_cast.end-2

union_cast.ok-1:
	%25 = getelementptr inbounds {%runtime.Type_Info_String, i8}, {%runtime.Type_Info_String, i8}* %5, i64 0, i32 0
	%26 = getelementptr inbounds {%runtime.Type_Info_String, i8}, {%runtime.Type_Info_String, i8}* %5, i64 0, i32 1
	%27 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %18 to %runtime.Type_Info_String*
	%28 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %27, align 1
	store %runtime.Type_Info_String %28, %runtime.Type_Info_String* %25
	store i8 1, i8* %26
	br label %union_cast.end-2

union_cast.end-2:
	%29 = load {%runtime.Type_Info_String, i8}, {%runtime.Type_Info_String, i8}* %5, align 1
	%30 = extractvalue {%runtime.Type_Info_String, i8} %29, 0
	%31 = extractvalue {%runtime.Type_Info_String, i8} %29, 1
	store i8 %31, i8* %3
	; AssignStmt
	; SelectorExpr
	%32 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %1, i64 0, i32 1
	%33 = load i8, i8* %3, align 1
	store i8 %33, i8* %32
	; AssignStmt
	; SelectorExpr
	%34 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %1, i64 0, i32 2
	store i64 88, i64* %34
	; AssignStmt
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %1, i64 0, i32 3
	store i64 8, i64* %35
	; AssignStmt
	; SelectorExpr
	%36 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %1, i64 0, i32 4
	store i64 32, i64* %36
	; AssignStmt
	; SelectorExpr
	%37 = getelementptr inbounds %runtime.Map_Header, %runtime.Map_Header* %1, i64 0, i32 5
	store i64 56, i64* %37
	; ReturnStmt
	%38 = load %runtime.Map_Header, %runtime.Map_Header* %1, align 8
	ret %runtime.Map_Header %38
}

define %runtime.Map_Key @runtime.__get_map_key-21200(i64 %key) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Map_Key, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca %runtime.Type_Info_Integer, align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	%5 = alloca %runtime.Type_Info_Rune, align 16
	%6 = alloca %runtime.Type_Info_Pointer, align 16
	%7 = alloca %runtime.Type_Info_Float, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	%9 = alloca %runtime.Type_Info_String, align 16
	%10 = alloca %..string, align 16
	%11 = alloca %runtime.Context, align 16
	%12 = bitcast %runtime.Context* %11 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %11
	%14 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %14, %runtime.Context* %11
	call void @runtime.__init_context(%runtime.Context* %11)
	%15 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	%16 = alloca %runtime.Source_Code_Location, align 16
	store i64 %key, i64* %0
	; map_key
	%17 = bitcast %runtime.Map_Key* %1 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 24) noinline
	store %runtime.Map_Key zeroinitializer, %runtime.Map_Key* %1
	; ti
	%19 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 119
	%20 = call %runtime.Type_Info* @runtime.type_info_base_without_enum(%runtime.Type_Info* %19)
	store %runtime.Type_Info* %20, %runtime.Type_Info** %2
	; TypeSwitchStmt
	; SelectorExpr
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%22 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %21, i64 0
	%23 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %22, i64 0, i32 3
	%24 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %23, align 8
	; get union's tag
	%25 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %23, i64 0, i32 2 ; UnionTagPtr
	%26 = load i8, i8* %25, align 1
	%27 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %23 to %..rawptr
	%28 = icmp eq i8 %26, 2
	br i1 %28, label %typeswitch.body-2, label %typeswitch.next-1

typeswitch.next-1:
	%29 = icmp eq i8 %26, 3
	br i1 %29, label %typeswitch.body-13, label %typeswitch.next-12

typeswitch.body-2:
	%30 = bitcast %..rawptr %27 to %runtime.Type_Info_Integer*
	%31 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %30, align 1
	store %runtime.Type_Info_Integer %31, %runtime.Type_Info_Integer* %3
	; SwitchStmt
	%32 = icmp eq i64 64, 8
	br i1 %32, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%33 = icmp eq i64 64, 16
	br i1 %33, label %switch.fall.body-6, label %switch.case.next-5

switch.case.body-4:
	; AssignStmt
	; SelectorExpr
	%34 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %1, i64 0, i32 0
	%35 = bitcast i64* %0 to i8*
	%36 = getelementptr inbounds i8, i8* %35, i64 0
	%37 = load i8, i8* %36, align 1
	%38 = zext i8 %37 to i64
	store i64 %38, i64* %34
	br label %switch.done-11

switch.case.next-5:
	%39 = icmp eq i64 64, 32
	br i1 %39, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	; AssignStmt
	; SelectorExpr
	%40 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %1, i64 0, i32 0
	%41 = bitcast i64* %0 to i16*
	%42 = getelementptr inbounds i16, i16* %41, i64 0
	%43 = load i16, i16* %42, align 2
	%44 = zext i16 %43 to i64
	store i64 %44, i64* %40
	br label %switch.done-11

switch.case.next-7:
	%45 = icmp eq i64 64, 64
	br i1 %45, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	; AssignStmt
	; SelectorExpr
	%46 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %1, i64 0, i32 0
	%47 = bitcast i64* %0 to i32*
	%48 = getelementptr inbounds i32, i32* %47, i64 0
	%49 = load i32, i32* %48, align 4
	%50 = zext i32 %49 to i64
	store i64 %50, i64* %46
	br label %switch.done-11

switch.case.next-9:
	%51 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	%52 = call %..rawptr @mem.zero(%..rawptr %51, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6ce, i64 0, i32 0), i64 58}, i64 779, i64 9, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$6cf, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %4
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$6d0, i64 0, i32 0), i64 22}, %runtime.Source_Code_Location* %4) noreturn
	br label %switch.done-11

switch.fall.body-10:
	; AssignStmt
	; SelectorExpr
	%53 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %1, i64 0, i32 0
	%54 = bitcast i64* %0 to i64*
	%55 = getelementptr inbounds i64, i64* %54, i64 0
	%56 = load i64, i64* %55, align 8
	store i64 %56, i64* %53
	br label %switch.done-11

switch.done-11:
	br label %typeswitch.done-25

typeswitch.next-12:
	%57 = icmp eq i8 %26, 10
	br i1 %57, label %typeswitch.body-15, label %typeswitch.next-14

typeswitch.body-13:
	%58 = bitcast %..rawptr %27 to %runtime.Type_Info_Rune*
	%59 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %58, align 1
	store %runtime.Type_Info_Rune %59, %runtime.Type_Info_Rune* %5
	; AssignStmt
	; SelectorExpr
	%60 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %1, i64 0, i32 0
	%61 = bitcast i64* %0 to i32*
	%62 = getelementptr inbounds i32, i32* %61, i64 0
	%63 = load i32, i32* %62, align 4
	%64 = sext i32 %63 to i64
	store i64 %64, i64* %60
	br label %typeswitch.done-25

typeswitch.next-14:
	%65 = icmp eq i8 %26, 4
	br i1 %65, label %typeswitch.body-17, label %typeswitch.next-16

typeswitch.body-15:
	%66 = bitcast %..rawptr %27 to %runtime.Type_Info_Pointer*
	%67 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %66, align 8
	store %runtime.Type_Info_Pointer %67, %runtime.Type_Info_Pointer* %6
	; AssignStmt
	; SelectorExpr
	%68 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %1, i64 0, i32 0
	%69 = bitcast i64* %0 to %..rawptr*
	%70 = getelementptr inbounds %..rawptr, %..rawptr* %69, i64 0
	%71 = load %..rawptr, %..rawptr* %70, align 8
	%72 = ptrtoint %..rawptr %71 to i64
	%73 = bitcast i64 %72 to i64
	store i64 %73, i64* %68
	br label %typeswitch.done-25

typeswitch.next-16:
	%74 = icmp eq i8 %26, 6
	br i1 %74, label %typeswitch.body-24, label %typeswitch.next-23

typeswitch.body-17:
	%75 = bitcast %..rawptr %27 to %runtime.Type_Info_Float*
	%76 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %75, align 1
	store %runtime.Type_Info_Float %76, %runtime.Type_Info_Float* %7
	; SwitchStmt
	%77 = icmp eq i64 64, 32
	br i1 %77, label %switch.case.body-19, label %switch.case.next-18

switch.case.next-18:
	%78 = icmp eq i64 64, 64
	br i1 %78, label %switch.fall.body-21, label %switch.case.next-20

switch.case.body-19:
	; AssignStmt
	; SelectorExpr
	%79 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %1, i64 0, i32 0
	%80 = bitcast i64* %0 to i32*
	%81 = getelementptr inbounds i32, i32* %80, i64 0
	%82 = load i32, i32* %81, align 4
	%83 = zext i32 %82 to i64
	store i64 %83, i64* %79
	br label %switch.done-22

switch.case.next-20:
	%84 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%85 = call %..rawptr @mem.zero(%..rawptr %84, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6d1, i64 0, i32 0), i64 58}, i64 789, i64 9, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$6d2, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %8
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$6d3, i64 0, i32 0), i64 20}, %runtime.Source_Code_Location* %8) noreturn
	br label %switch.done-22

switch.fall.body-21:
	; AssignStmt
	; SelectorExpr
	%86 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %1, i64 0, i32 0
	%87 = bitcast i64* %0 to i64*
	%88 = getelementptr inbounds i64, i64* %87, i64 0
	%89 = load i64, i64* %88, align 8
	store i64 %89, i64* %86
	br label %switch.done-22

switch.done-22:
	br label %typeswitch.done-25

typeswitch.next-23:
	store {[0 x <8 x i8>], [72 x i8], i8} %24, {[0 x <8 x i8>], [72 x i8], i8}* %15
	%90 = bitcast %runtime.Source_Code_Location* %16 to %..rawptr
	%91 = call %..rawptr @mem.zero(%..rawptr %90, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %16
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6d4, i64 0, i32 0), i64 58}, i64 796, i64 3, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$6d5, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %16
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$6d6, i64 0, i32 0), i64 22}, %runtime.Source_Code_Location* %16) noreturn
	br label %typeswitch.done-25

typeswitch.body-24:
	%92 = bitcast %..rawptr %27 to %runtime.Type_Info_String*
	%93 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %92, align 1
	store %runtime.Type_Info_String %93, %runtime.Type_Info_String* %9
	; str
	%94 = bitcast i64* %0 to %..string*
	%95 = getelementptr inbounds %..string, %..string* %94, i64 0
	%96 = load %..string, %..string* %95, align 8
	store %..string %96, %..string* %10
	; AssignStmt
	; SelectorExpr
	%97 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %1, i64 0, i32 0
	%98 = load %..string, %..string* %10, align 8
	%99 = call i64 @runtime.default_hash_string(%..string %98, %runtime.Context* noalias nonnull nocapture inreg %11)
	store i64 %99, i64* %97
	; AssignStmt
	; SelectorExpr
	%100 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %1, i64 0, i32 1
	%101 = load %..string, %..string* %10, align 8
	store %..string %101, %..string* %100
	br label %typeswitch.done-25

typeswitch.done-25:
	; ReturnStmt
	%102 = load %runtime.Map_Key, %runtime.Map_Key* %1, align 8
	ret %runtime.Map_Key %102
}

define %workbench.Tweener* @runtime.pop-21343({%workbench.Tweener**, i64, i64, %mem.Allocator}* %array) #0 {
decls-0:
	%0 = alloca {%workbench.Tweener**, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = alloca %workbench.Tweener*, align 16
	%3 = alloca %mem.Raw_Dynamic_Array*, align 16
	store {%workbench.Tweener**, i64, i64, %mem.Allocator}* %array, {%workbench.Tweener**, i64, i64, %mem.Allocator}** %0
	; IfStmt
	%4 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}*, {%workbench.Tweener**, i64, i64, %mem.Allocator}** %0, align 8
	%5 = icmp eq {%workbench.Tweener**, i64, i64, %mem.Allocator}* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %workbench.Tweener* zeroinitializer

if.done-2:
	%8 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}*, {%workbench.Tweener**, i64, i64, %mem.Allocator}** %0, align 8
	%9 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}, {%workbench.Tweener**, i64, i64, %mem.Allocator}* %8, align 8
	%10 = extractvalue {%workbench.Tweener**, i64, i64, %mem.Allocator} %9, 1
	%11 = icmp sgt i64 %10, 0
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	%14 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6d7, i64 0, i32 0), i64 58}, i64 367, i64 2, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$6d8, i64 0, i32 0), i64 3}}, %runtime.Source_Code_Location* %1
	%16 = call i8 @runtime.assert(i1 %13, %..string zeroinitializer, %runtime.Source_Code_Location* %1)
	; res
	; IndexExpr
	%17 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}*, {%workbench.Tweener**, i64, i64, %mem.Allocator}** %0, align 8
	%18 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}, {%workbench.Tweener**, i64, i64, %mem.Allocator}* %17, align 8
	%19 = extractvalue {%workbench.Tweener**, i64, i64, %mem.Allocator} %18, 0
	%20 = extractvalue {%workbench.Tweener**, i64, i64, %mem.Allocator} %18, 1
	%21 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}*, {%workbench.Tweener**, i64, i64, %mem.Allocator}** %0, align 8
	%22 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}, {%workbench.Tweener**, i64, i64, %mem.Allocator}* %21, align 8
	%23 = extractvalue {%workbench.Tweener**, i64, i64, %mem.Allocator} %22, 1
	%24 = sub i64 %23, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6d9, i64 0, i32 0), i64 58}, i64 368, i64 15, i64 %24, i64 %20)
	%25 = getelementptr inbounds %workbench.Tweener*, %workbench.Tweener** %19, i64 %24
	%26 = load %workbench.Tweener*, %workbench.Tweener** %25, align 8
	store %workbench.Tweener* %26, %workbench.Tweener** %2
	; AssignStmt
	; SelectorExpr
	%27 = load {%workbench.Tweener**, i64, i64, %mem.Allocator}*, {%workbench.Tweener**, i64, i64, %mem.Allocator}** %0, align 8
	%28 = bitcast {%workbench.Tweener**, i64, i64, %mem.Allocator}* %27 to %mem.Raw_Dynamic_Array*
	%29 = bitcast %mem.Raw_Dynamic_Array** %3 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 8) noinline
	store %mem.Raw_Dynamic_Array* zeroinitializer, %mem.Raw_Dynamic_Array** %3
	store %mem.Raw_Dynamic_Array* %28, %mem.Raw_Dynamic_Array** %3
	%31 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%32 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %31, i64 0
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0, i32 1
	%34 = load i64, i64* %33, align 8
	%35 = sub i64 %34, 1
	store i64 %35, i64* %33
	; ReturnStmt
	%36 = load %workbench.Tweener*, %workbench.Tweener** %2, align 8
	ret %workbench.Tweener* %36
}

define [3 x float] @math.lerp-21377([3 x float]* %a, [3 x float]* %b, float %t, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca float, align 16
	%1 = alloca [3 x float], align 16
	%2 = alloca [3 x float], align 16
	%3 = alloca [3 x float], align 16
	%4 = alloca [3 x float], align 16
	%5 = alloca [3 x float], align 16
	%6 = alloca [3 x float], align 16
	%7 = load [3 x float], [3 x float]* %a, align 4
	%8 = load [3 x float], [3 x float]* %b, align 4
	store float %t, float* %0
	%9 = bitcast [3 x float]* %1 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %1
	; ReturnStmt
	%11 = load [3 x float], [3 x float]* %a, align 4
	%12 = load float, float* %0, align 4
	%13 = fsub float 0x3ff0000000000000, %12
	; array.arith.begin
	%14 = bitcast [3 x float]* %2 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %2
	%16 = getelementptr inbounds [3 x float], [3 x float]* %2, i64 0, i32 0
	store float %13, float* %16
	%17 = getelementptr inbounds [3 x float], [3 x float]* %2, i64 0, i32 1
	store float %13, float* %17
	%18 = getelementptr inbounds [3 x float], [3 x float]* %2, i64 0, i32 2
	store float %13, float* %18
	%19 = load [3 x float], [3 x float]* %2, align 4
	%20 = bitcast [3 x float]* %3 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %3
	%22 = getelementptr inbounds [3 x float], [3 x float]* %a, i64 0, i32 0
	%23 = load float, float* %22, align 4
	%24 = getelementptr inbounds [3 x float], [3 x float]* %2, i64 0, i32 0
	%25 = load float, float* %24, align 4
	%26 = fmul float %23, %25
	%27 = getelementptr inbounds [3 x float], [3 x float]* %3, i64 0, i32 0
	store float %26, float* %27
	%28 = getelementptr inbounds [3 x float], [3 x float]* %a, i64 0, i32 1
	%29 = load float, float* %28, align 4
	%30 = getelementptr inbounds [3 x float], [3 x float]* %2, i64 0, i32 1
	%31 = load float, float* %30, align 4
	%32 = fmul float %29, %31
	%33 = getelementptr inbounds [3 x float], [3 x float]* %3, i64 0, i32 1
	store float %32, float* %33
	%34 = getelementptr inbounds [3 x float], [3 x float]* %a, i64 0, i32 2
	%35 = load float, float* %34, align 4
	%36 = getelementptr inbounds [3 x float], [3 x float]* %2, i64 0, i32 2
	%37 = load float, float* %36, align 4
	%38 = fmul float %35, %37
	%39 = getelementptr inbounds [3 x float], [3 x float]* %3, i64 0, i32 2
	store float %38, float* %39
	; array.arith.end
	%40 = load [3 x float], [3 x float]* %3, align 4
	%41 = load [3 x float], [3 x float]* %b, align 4
	%42 = load float, float* %0, align 4
	; array.arith.begin
	%43 = bitcast [3 x float]* %4 to %..rawptr
	%44 = call %..rawptr @mem.zero(%..rawptr %43, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %4
	%45 = getelementptr inbounds [3 x float], [3 x float]* %4, i64 0, i32 0
	store float %42, float* %45
	%46 = getelementptr inbounds [3 x float], [3 x float]* %4, i64 0, i32 1
	store float %42, float* %46
	%47 = getelementptr inbounds [3 x float], [3 x float]* %4, i64 0, i32 2
	store float %42, float* %47
	%48 = load [3 x float], [3 x float]* %4, align 4
	%49 = bitcast [3 x float]* %5 to %..rawptr
	%50 = call %..rawptr @mem.zero(%..rawptr %49, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %5
	%51 = getelementptr inbounds [3 x float], [3 x float]* %b, i64 0, i32 0
	%52 = load float, float* %51, align 4
	%53 = getelementptr inbounds [3 x float], [3 x float]* %4, i64 0, i32 0
	%54 = load float, float* %53, align 4
	%55 = fmul float %52, %54
	%56 = getelementptr inbounds [3 x float], [3 x float]* %5, i64 0, i32 0
	store float %55, float* %56
	%57 = getelementptr inbounds [3 x float], [3 x float]* %b, i64 0, i32 1
	%58 = load float, float* %57, align 4
	%59 = getelementptr inbounds [3 x float], [3 x float]* %4, i64 0, i32 1
	%60 = load float, float* %59, align 4
	%61 = fmul float %58, %60
	%62 = getelementptr inbounds [3 x float], [3 x float]* %5, i64 0, i32 1
	store float %61, float* %62
	%63 = getelementptr inbounds [3 x float], [3 x float]* %b, i64 0, i32 2
	%64 = load float, float* %63, align 4
	%65 = getelementptr inbounds [3 x float], [3 x float]* %4, i64 0, i32 2
	%66 = load float, float* %65, align 4
	%67 = fmul float %64, %66
	%68 = getelementptr inbounds [3 x float], [3 x float]* %5, i64 0, i32 2
	store float %67, float* %68
	; array.arith.end
	%69 = load [3 x float], [3 x float]* %5, align 4
	; array.arith.begin
	%70 = bitcast [3 x float]* %6 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 12) noinline
	store [3 x float] zeroinitializer, [3 x float]* %6
	%72 = getelementptr inbounds [3 x float], [3 x float]* %3, i64 0, i32 0
	%73 = load float, float* %72, align 4
	%74 = getelementptr inbounds [3 x float], [3 x float]* %5, i64 0, i32 0
	%75 = load float, float* %74, align 4
	%76 = fadd float %73, %75
	%77 = getelementptr inbounds [3 x float], [3 x float]* %6, i64 0, i32 0
	store float %76, float* %77
	%78 = getelementptr inbounds [3 x float], [3 x float]* %3, i64 0, i32 1
	%79 = load float, float* %78, align 4
	%80 = getelementptr inbounds [3 x float], [3 x float]* %5, i64 0, i32 1
	%81 = load float, float* %80, align 4
	%82 = fadd float %79, %81
	%83 = getelementptr inbounds [3 x float], [3 x float]* %6, i64 0, i32 1
	store float %82, float* %83
	%84 = getelementptr inbounds [3 x float], [3 x float]* %3, i64 0, i32 2
	%85 = load float, float* %84, align 4
	%86 = getelementptr inbounds [3 x float], [3 x float]* %5, i64 0, i32 2
	%87 = load float, float* %86, align 4
	%88 = fadd float %85, %87
	%89 = getelementptr inbounds [3 x float], [3 x float]* %6, i64 0, i32 2
	store float %88, float* %89
	; array.arith.end
	%90 = load [3 x float], [3 x float]* %6, align 4
	ret [3 x float] %90
}

define [4 x float] @math.lerp-21389([4 x float]* %a, [4 x float]* %b, float %t, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca float, align 16
	%1 = alloca [4 x float], align 16
	%2 = alloca [4 x float], align 16
	%3 = alloca [4 x float], align 16
	%4 = alloca [4 x float], align 16
	%5 = alloca [4 x float], align 16
	%6 = alloca [4 x float], align 16
	%7 = load [4 x float], [4 x float]* %a, align 4
	%8 = load [4 x float], [4 x float]* %b, align 4
	store float %t, float* %0
	%9 = bitcast [4 x float]* %1 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 16) noinline
	store [4 x float] zeroinitializer, [4 x float]* %1
	; ReturnStmt
	%11 = load [4 x float], [4 x float]* %a, align 4
	%12 = load float, float* %0, align 4
	%13 = fsub float 0x3ff0000000000000, %12
	; array.arith.begin
	%14 = bitcast [4 x float]* %2 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 16) noinline
	store [4 x float] zeroinitializer, [4 x float]* %2
	%16 = getelementptr inbounds [4 x float], [4 x float]* %2, i64 0, i32 0
	store float %13, float* %16
	%17 = getelementptr inbounds [4 x float], [4 x float]* %2, i64 0, i32 1
	store float %13, float* %17
	%18 = getelementptr inbounds [4 x float], [4 x float]* %2, i64 0, i32 2
	store float %13, float* %18
	%19 = getelementptr inbounds [4 x float], [4 x float]* %2, i64 0, i32 3
	store float %13, float* %19
	%20 = load [4 x float], [4 x float]* %2, align 4
	%21 = bitcast [4 x float]* %3 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 16) noinline
	store [4 x float] zeroinitializer, [4 x float]* %3
	%23 = getelementptr inbounds [4 x float], [4 x float]* %a, i64 0, i32 0
	%24 = load float, float* %23, align 4
	%25 = getelementptr inbounds [4 x float], [4 x float]* %2, i64 0, i32 0
	%26 = load float, float* %25, align 4
	%27 = fmul float %24, %26
	%28 = getelementptr inbounds [4 x float], [4 x float]* %3, i64 0, i32 0
	store float %27, float* %28
	%29 = getelementptr inbounds [4 x float], [4 x float]* %a, i64 0, i32 1
	%30 = load float, float* %29, align 4
	%31 = getelementptr inbounds [4 x float], [4 x float]* %2, i64 0, i32 1
	%32 = load float, float* %31, align 4
	%33 = fmul float %30, %32
	%34 = getelementptr inbounds [4 x float], [4 x float]* %3, i64 0, i32 1
	store float %33, float* %34
	%35 = getelementptr inbounds [4 x float], [4 x float]* %a, i64 0, i32 2
	%36 = load float, float* %35, align 4
	%37 = getelementptr inbounds [4 x float], [4 x float]* %2, i64 0, i32 2
	%38 = load float, float* %37, align 4
	%39 = fmul float %36, %38
	%40 = getelementptr inbounds [4 x float], [4 x float]* %3, i64 0, i32 2
	store float %39, float* %40
	%41 = getelementptr inbounds [4 x float], [4 x float]* %a, i64 0, i32 3
	%42 = load float, float* %41, align 4
	%43 = getelementptr inbounds [4 x float], [4 x float]* %2, i64 0, i32 3
	%44 = load float, float* %43, align 4
	%45 = fmul float %42, %44
	%46 = getelementptr inbounds [4 x float], [4 x float]* %3, i64 0, i32 3
	store float %45, float* %46
	; array.arith.end
	%47 = load [4 x float], [4 x float]* %3, align 4
	%48 = load [4 x float], [4 x float]* %b, align 4
	%49 = load float, float* %0, align 4
	; array.arith.begin
	%50 = bitcast [4 x float]* %4 to %..rawptr
	%51 = call %..rawptr @mem.zero(%..rawptr %50, i64 16) noinline
	store [4 x float] zeroinitializer, [4 x float]* %4
	%52 = getelementptr inbounds [4 x float], [4 x float]* %4, i64 0, i32 0
	store float %49, float* %52
	%53 = getelementptr inbounds [4 x float], [4 x float]* %4, i64 0, i32 1
	store float %49, float* %53
	%54 = getelementptr inbounds [4 x float], [4 x float]* %4, i64 0, i32 2
	store float %49, float* %54
	%55 = getelementptr inbounds [4 x float], [4 x float]* %4, i64 0, i32 3
	store float %49, float* %55
	%56 = load [4 x float], [4 x float]* %4, align 4
	%57 = bitcast [4 x float]* %5 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store [4 x float] zeroinitializer, [4 x float]* %5
	%59 = getelementptr inbounds [4 x float], [4 x float]* %b, i64 0, i32 0
	%60 = load float, float* %59, align 4
	%61 = getelementptr inbounds [4 x float], [4 x float]* %4, i64 0, i32 0
	%62 = load float, float* %61, align 4
	%63 = fmul float %60, %62
	%64 = getelementptr inbounds [4 x float], [4 x float]* %5, i64 0, i32 0
	store float %63, float* %64
	%65 = getelementptr inbounds [4 x float], [4 x float]* %b, i64 0, i32 1
	%66 = load float, float* %65, align 4
	%67 = getelementptr inbounds [4 x float], [4 x float]* %4, i64 0, i32 1
	%68 = load float, float* %67, align 4
	%69 = fmul float %66, %68
	%70 = getelementptr inbounds [4 x float], [4 x float]* %5, i64 0, i32 1
	store float %69, float* %70
	%71 = getelementptr inbounds [4 x float], [4 x float]* %b, i64 0, i32 2
	%72 = load float, float* %71, align 4
	%73 = getelementptr inbounds [4 x float], [4 x float]* %4, i64 0, i32 2
	%74 = load float, float* %73, align 4
	%75 = fmul float %72, %74
	%76 = getelementptr inbounds [4 x float], [4 x float]* %5, i64 0, i32 2
	store float %75, float* %76
	%77 = getelementptr inbounds [4 x float], [4 x float]* %b, i64 0, i32 3
	%78 = load float, float* %77, align 4
	%79 = getelementptr inbounds [4 x float], [4 x float]* %4, i64 0, i32 3
	%80 = load float, float* %79, align 4
	%81 = fmul float %78, %80
	%82 = getelementptr inbounds [4 x float], [4 x float]* %5, i64 0, i32 3
	store float %81, float* %82
	; array.arith.end
	%83 = load [4 x float], [4 x float]* %5, align 4
	; array.arith.begin
	%84 = bitcast [4 x float]* %6 to %..rawptr
	%85 = call %..rawptr @mem.zero(%..rawptr %84, i64 16) noinline
	store [4 x float] zeroinitializer, [4 x float]* %6
	%86 = getelementptr inbounds [4 x float], [4 x float]* %3, i64 0, i32 0
	%87 = load float, float* %86, align 4
	%88 = getelementptr inbounds [4 x float], [4 x float]* %5, i64 0, i32 0
	%89 = load float, float* %88, align 4
	%90 = fadd float %87, %89
	%91 = getelementptr inbounds [4 x float], [4 x float]* %6, i64 0, i32 0
	store float %90, float* %91
	%92 = getelementptr inbounds [4 x float], [4 x float]* %3, i64 0, i32 1
	%93 = load float, float* %92, align 4
	%94 = getelementptr inbounds [4 x float], [4 x float]* %5, i64 0, i32 1
	%95 = load float, float* %94, align 4
	%96 = fadd float %93, %95
	%97 = getelementptr inbounds [4 x float], [4 x float]* %6, i64 0, i32 1
	store float %96, float* %97
	%98 = getelementptr inbounds [4 x float], [4 x float]* %3, i64 0, i32 2
	%99 = load float, float* %98, align 4
	%100 = getelementptr inbounds [4 x float], [4 x float]* %5, i64 0, i32 2
	%101 = load float, float* %100, align 4
	%102 = fadd float %99, %101
	%103 = getelementptr inbounds [4 x float], [4 x float]* %6, i64 0, i32 2
	store float %102, float* %103
	%104 = getelementptr inbounds [4 x float], [4 x float]* %3, i64 0, i32 3
	%105 = load float, float* %104, align 4
	%106 = getelementptr inbounds [4 x float], [4 x float]* %5, i64 0, i32 3
	%107 = load float, float* %106, align 4
	%108 = fadd float %105, %107
	%109 = getelementptr inbounds [4 x float], [4 x float]* %6, i64 0, i32 3
	store float %108, float* %109
	; array.arith.end
	%110 = load [4 x float], [4 x float]* %6, align 4
	ret [4 x float] %110
}

define i8 @runtime.reserve_dynamic_array-21493({%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* %array, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}*, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}*, {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6da, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6db, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 64
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 64
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 8, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define %workbench.Location_ID_Mapping* @mem.ptr_offset-21507(%workbench.Location_ID_Mapping* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca %workbench.Location_ID_Mapping*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %workbench.Location_ID_Mapping* %ptr, %workbench.Location_ID_Mapping** %0
	store i64 %n, i64* %1
	; new
	%3 = load %workbench.Location_ID_Mapping*, %workbench.Location_ID_Mapping** %0, align 8
	%4 = ptrtoint %workbench.Location_ID_Mapping* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 64, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to %workbench.Location_ID_Mapping*
	ret %workbench.Location_ID_Mapping* %11
}

define i8 @runtime.reserve_dynamic_array-21549({%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %array, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}*, {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6dc, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6dd, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 176
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 176
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 8, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define %workbench.IMGUI_Rect* @mem.ptr_offset-21563(%workbench.IMGUI_Rect* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca %workbench.IMGUI_Rect*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %workbench.IMGUI_Rect* %ptr, %workbench.IMGUI_Rect** %0
	store i64 %n, i64* %1
	; new
	%3 = load %workbench.IMGUI_Rect*, %workbench.IMGUI_Rect** %0, align 8
	%4 = ptrtoint %workbench.IMGUI_Rect* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 176, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to %workbench.IMGUI_Rect*
	ret %workbench.IMGUI_Rect* %11
}

define i8 @runtime.reserve_dynamic_array-21617({%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* %array, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}*, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}*, {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6de, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6df, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 40
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 40
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 8, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define %workbench.UI_Debug_File_Line* @mem.ptr_offset-21631(%workbench.UI_Debug_File_Line* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca %workbench.UI_Debug_File_Line*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %workbench.UI_Debug_File_Line* %ptr, %workbench.UI_Debug_File_Line** %0
	store i64 %n, i64* %1
	; new
	%3 = load %workbench.UI_Debug_File_Line*, %workbench.UI_Debug_File_Line** %0, align 8
	%4 = ptrtoint %workbench.UI_Debug_File_Line* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 40, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to %workbench.UI_Debug_File_Line*
	ret %workbench.UI_Debug_File_Line* %11
}

define i8 @runtime.reserve_dynamic_array-22130({%main.Transform*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%main.Transform*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {%main.Transform*, i64, i64, %mem.Allocator}* %array, {%main.Transform*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {%main.Transform*, i64, i64, %mem.Allocator}*, {%main.Transform*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {%main.Transform*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {%main.Transform*, i64, i64, %mem.Allocator}*, {%main.Transform*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {%main.Transform*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6e0, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6e1, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 24
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 24
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 8, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define %main.Transform* @mem.ptr_offset-22144(%main.Transform* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca %main.Transform*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %main.Transform* %ptr, %main.Transform** %0
	store i64 %n, i64* %1
	; new
	%3 = load %main.Transform*, %main.Transform** %0, align 8
	%4 = ptrtoint %main.Transform* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 24, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to %main.Transform*
	ret %main.Transform* %11
}

define i8 @runtime.reserve_dynamic_array-22186({%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* %array, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}*, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}*, {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {%main.Mesh_Renderer*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6e2, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6e3, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 48
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 48
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 8, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define %main.Mesh_Renderer* @mem.ptr_offset-22200(%main.Mesh_Renderer* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca %main.Mesh_Renderer*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %main.Mesh_Renderer* %ptr, %main.Mesh_Renderer** %0
	store i64 %n, i64* %1
	; new
	%3 = load %main.Mesh_Renderer*, %main.Mesh_Renderer** %0, align 8
	%4 = ptrtoint %main.Mesh_Renderer* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 48, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to %main.Mesh_Renderer*
	ret %main.Mesh_Renderer* %11
}

define i8 @runtime.reserve_dynamic_array-22242({%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* %array, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}*, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}*, {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {%main.Sprite_Renderer*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6e4, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6e5, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 24
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 24
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 8, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define %main.Sprite_Renderer* @mem.ptr_offset-22256(%main.Sprite_Renderer* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca %main.Sprite_Renderer*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %main.Sprite_Renderer* %ptr, %main.Sprite_Renderer** %0
	store i64 %n, i64* %1
	; new
	%3 = load %main.Sprite_Renderer*, %main.Sprite_Renderer** %0, align 8
	%4 = ptrtoint %main.Sprite_Renderer* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 24, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to %main.Sprite_Renderer*
	ret %main.Sprite_Renderer* %11
}

define i8 @runtime.reserve_dynamic_array-22298({%main.Spinner_Component*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%main.Spinner_Component*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {%main.Spinner_Component*, i64, i64, %mem.Allocator}* %array, {%main.Spinner_Component*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}*, {%main.Spinner_Component*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {%main.Spinner_Component*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {%main.Spinner_Component*, i64, i64, %mem.Allocator}*, {%main.Spinner_Component*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {%main.Spinner_Component*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$6e6, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$6e7, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 16
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 16
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 8, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define %main.Spinner_Component* @mem.ptr_offset-22312(%main.Spinner_Component* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca %main.Spinner_Component*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %main.Spinner_Component* %ptr, %main.Spinner_Component** %0
	store i64 %n, i64* %1
	; new
	%3 = load %main.Spinner_Component*, %main.Spinner_Component** %0, align 8
	%4 = ptrtoint %main.Spinner_Component* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 16, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to %main.Spinner_Component*
	ret %main.Spinner_Component* %11
}

define ccc i32 @main(i32 %argc, i8** %argv) noinline #2 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i8**, align 16
	store i32 %argc, i32* %0
	store i8** %argv, i8*** %1
	%2 = load i32, i32* %0, align 4
	%3 = load i8**, i8*** %1, align 8
	%4 = sext i32 %2 to i64
	%5 = getelementptr inbounds {i8**, i64}, {i8**, i64}* @runtime.args__, i64 0, i32 0
	store i8** %3, i8*** %5
	%6 = getelementptr inbounds {i8**, i64}, {i8**, i64}* @runtime.args__, i64 0, i32 1
	store i64 %4, i64* %6
	call void @__$startup_runtime()
	call void @main.main() noinline
	ret i32 0
}

define void @__$startup_runtime() noinline #2 {
decls-0:
	%0 = alloca %runtime.Context, align 16
	%1 = bitcast %runtime.Context* %0 to %..rawptr
	%2 = call %..rawptr @mem.zero(%..rawptr %1, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %0
	%3 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %3, %runtime.Context* %0
	call void @runtime.__init_context(%runtime.Context* %0) noinline
	%4 = alloca %mem.Allocator, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca %mem.Allocator, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca %mem.Allocator, align 16
	%11 = alloca %runtime.Source_Code_Location, align 16
	%12 = alloca %mem.Allocator, align 16
	%13 = alloca %runtime.Source_Code_Location, align 16
	%14 = alloca %mem.Allocator, align 16
	%15 = alloca %runtime.Source_Code_Location, align 16
	call void @runtime.__init_context(%runtime.Context* @ggv$0) noinline
	%16 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 0
	%17 = getelementptr inbounds {%runtime.Type_Info*, i64}, {%runtime.Type_Info*, i64}* @runtime.type_table, i64 0, i32 0
	store %runtime.Type_Info* %16, %runtime.Type_Info** %17
	%18 = getelementptr inbounds {%runtime.Type_Info*, i64}, {%runtime.Type_Info*, i64}* @runtime.type_table, i64 0, i32 1
	store i64 156, i64* %18
	%19 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 115
	%20 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %19, i64 0, i32 3
	%21 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %19, i64 0, i32 0
	store i64 8, i64* %21
	%22 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %19, i64 0, i32 1
	store i64 8, i64* %22
	%23 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %19, i64 0, i32 2
	store %..typeid 3530822107858468979, %..typeid* %23
	; Type_Info_Named
	%24 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %20 to %runtime.Type_Info_Named*
	%25 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 116
	%26 = bitcast %runtime.Type_Info* %25 to %runtime.Type_Info*
	%27 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %24, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$6e8, i64 0, i32 0), i64 15}, %..string* %27
	%28 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %24, i64 0, i32 1
	store %runtime.Type_Info* %26, %runtime.Type_Info** %28
	%29 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %24, align 8
	%30 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %20 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %29, %runtime.Type_Info_Named* %30
	%31 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %20, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %31
	%32 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 116
	%33 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %32, i64 0, i32 3
	%34 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %32, i64 0, i32 0
	store i64 8, i64* %34
	%35 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %32, i64 0, i32 1
	store i64 8, i64* %35
	%36 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %32, i64 0, i32 2
	store %..typeid 1224979098644775028, %..typeid* %36
	; Type_Info_Enum
	%37 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %33 to %runtime.Type_Info_Enum*
	%38 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%39 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %37, i64 0, i32 0
	store %runtime.Type_Info* %38, %runtime.Type_Info** %39
	%40 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-74, i64 0, i32 0
	%41 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-74, i64 0, i32 0
	%42 = bitcast %runtime.Type_Info_Enum_Value* %41 to i64*
	store i64 0, i64* %42
	%43 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %43
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$6e9, i64 0, i32 0), i64 9}, %..string* %40
	%44 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-74, i64 0, i32 1
	%45 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-74, i64 0, i32 1
	%46 = bitcast %runtime.Type_Info_Enum_Value* %45 to i64*
	store i64 1, i64* %46
	%47 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %45, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %47
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$6ea, i64 0, i32 0), i64 17}, %..string* %44
	%48 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-74, i64 0, i32 2
	%49 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-74, i64 0, i32 2
	%50 = bitcast %runtime.Type_Info_Enum_Value* %49 to i64*
	store i64 2, i64* %50
	%51 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %49, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %51
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$6eb, i64 0, i32 0), i64 11}, %..string* %48
	%52 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-74, i64 0, i32 3
	%53 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-74, i64 0, i32 3
	%54 = bitcast %runtime.Type_Info_Enum_Value* %53 to i64*
	store i64 3, i64* %54
	%55 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %53, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %55
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$6ec, i64 0, i32 0), i64 6}, %..string* %52
	%56 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-74, i64 0, i32 4
	%57 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-74, i64 0, i32 4
	%58 = bitcast %runtime.Type_Info_Enum_Value* %57 to i64*
	store i64 4, i64* %58
	%59 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %57, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %59
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$6ed, i64 0, i32 0), i64 13}, %..string* %56
	%60 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-74, i64 0, i32 5
	%61 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-74, i64 0, i32 5
	%62 = bitcast %runtime.Type_Info_Enum_Value* %61 to i64*
	store i64 5, i64* %62
	%63 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %61, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %63
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$6ee, i64 0, i32 0), i64 11}, %..string* %60
	%64 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-74, i64 0, i32 6
	%65 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-74, i64 0, i32 6
	%66 = bitcast %runtime.Type_Info_Enum_Value* %65 to i64*
	store i64 6, i64* %66
	%67 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %65, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %67
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$6ef, i64 0, i32 0), i64 4}, %..string* %64
	%68 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %37, i64 0, i32 1
	%69 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-74, i64 0, i32 0
	%70 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %68, i64 0, i32 0
	store %..string* %69, %..string** %70
	%71 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %68, i64 0, i32 1
	store i64 7, i64* %71
	%72 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %37, i64 0, i32 2
	%73 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-74, i64 0, i32 0
	%74 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %72, i64 0, i32 0
	store %runtime.Type_Info_Enum_Value* %73, %runtime.Type_Info_Enum_Value** %74
	%75 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %72, i64 0, i32 1
	store i64 7, i64* %75
	%76 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %37, align 8
	%77 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %33 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %76, %runtime.Type_Info_Enum* %77
	%78 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %33, i64 0, i32 2 ; UnionTagPtr
	store i8 18, i8* %78
	%79 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%80 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %79, i64 0, i32 3
	%81 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %79, i64 0, i32 0
	store i64 8, i64* %81
	%82 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %79, i64 0, i32 1
	store i64 8, i64* %82
	%83 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %79, i64 0, i32 2
	store %..typeid 4683743612465315846, %..typeid* %83
	; Type_Info_Basic
	%84 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %80 to %runtime.Type_Info_Integer*
	%85 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %84, i64 0, i32 0
	store i8 1, i8* %85
	%86 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %84, align 1
	%87 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %80 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %86, %runtime.Type_Info_Integer* %87
	%88 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %80, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %88
	%89 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 101
	%90 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %89, i64 0, i32 3
	%91 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %89, i64 0, i32 0
	store i64 4, i64* %91
	%92 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %89, i64 0, i32 1
	store i64 4, i64* %92
	%93 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %89, i64 0, i32 2
	store %..typeid 3530822107858468965, %..typeid* %93
	; Type_Info_Named
	%94 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %90 to %runtime.Type_Info_Named*
	%95 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 102
	%96 = bitcast %runtime.Type_Info* %95 to %runtime.Type_Info*
	%97 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %94, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$6f0, i64 0, i32 0), i64 5}, %..string* %97
	%98 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %94, i64 0, i32 1
	store %runtime.Type_Info* %96, %runtime.Type_Info** %98
	%99 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %94, align 8
	%100 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %90 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %99, %runtime.Type_Info_Named* %100
	%101 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %90, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %101
	%102 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 102
	%103 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %102, i64 0, i32 3
	%104 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %102, i64 0, i32 0
	store i64 4, i64* %104
	%105 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %102, i64 0, i32 1
	store i64 4, i64* %105
	%106 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %102, i64 0, i32 2
	store %..typeid 1224979098644775014, %..typeid* %106
	; Type_Info_Enum
	%107 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %103 to %runtime.Type_Info_Enum*
	%108 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%109 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %107, i64 0, i32 0
	store %runtime.Type_Info* %108, %runtime.Type_Info** %109
	%110 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 0
	%111 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 0
	%112 = bitcast %runtime.Type_Info_Enum_Value* %111 to i32*
	store i32 0, i32* %112
	%113 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %111, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %113
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$6f1, i64 0, i32 0), i64 4}, %..string* %110
	%114 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 1
	%115 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 1
	%116 = bitcast %runtime.Type_Info_Enum_Value* %115 to i32*
	store i32 1, i32* %116
	%117 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %115, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %117
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$6f2, i64 0, i32 0), i64 12}, %..string* %114
	%118 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 2
	%119 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 2
	%120 = bitcast %runtime.Type_Info_Enum_Value* %119 to i32*
	store i32 2, i32* %120
	%121 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %119, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %121
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$6f3, i64 0, i32 0), i64 8}, %..string* %118
	%122 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 3
	%123 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 3
	%124 = bitcast %runtime.Type_Info_Enum_Value* %123 to i32*
	store i32 3, i32* %124
	%125 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %123, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %125
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$6f4, i64 0, i32 0), i64 7}, %..string* %122
	%126 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 4
	%127 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 4
	%128 = bitcast %runtime.Type_Info_Enum_Value* %127 to i32*
	store i32 4, i32* %128
	%129 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %127, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %129
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$6f5, i64 0, i32 0), i64 7}, %..string* %126
	%130 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 5
	%131 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 5
	%132 = bitcast %runtime.Type_Info_Enum_Value* %131 to i32*
	store i32 5, i32* %132
	%133 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %131, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %133
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$6f6, i64 0, i32 0), i64 6}, %..string* %130
	%134 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 6
	%135 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 6
	%136 = bitcast %runtime.Type_Info_Enum_Value* %135 to i32*
	store i32 6, i32* %136
	%137 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %135, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %137
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$6f7, i64 0, i32 0), i64 12}, %..string* %134
	%138 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 7
	%139 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 7
	%140 = bitcast %runtime.Type_Info_Enum_Value* %139 to i32*
	store i32 7, i32* %140
	%141 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %139, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %141
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$6f8, i64 0, i32 0), i64 7}, %..string* %138
	%142 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 8
	%143 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 8
	%144 = bitcast %runtime.Type_Info_Enum_Value* %143 to i32*
	store i32 8, i32* %144
	%145 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %143, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %145
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$6f9, i64 0, i32 0), i64 14}, %..string* %142
	%146 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 9
	%147 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 9
	%148 = bitcast %runtime.Type_Info_Enum_Value* %147 to i32*
	store i32 9, i32* %148
	%149 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %147, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %149
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$6fa, i64 0, i32 0), i64 13}, %..string* %146
	%150 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 10
	%151 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 10
	%152 = bitcast %runtime.Type_Info_Enum_Value* %151 to i32*
	store i32 10, i32* %152
	%153 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %151, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %153
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$6fb, i64 0, i32 0), i64 7}, %..string* %150
	%154 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 11
	%155 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 11
	%156 = bitcast %runtime.Type_Info_Enum_Value* %155 to i32*
	store i32 11, i32* %156
	%157 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %155, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %157
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$6fc, i64 0, i32 0), i64 13}, %..string* %154
	%158 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 12
	%159 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 12
	%160 = bitcast %runtime.Type_Info_Enum_Value* %159 to i32*
	store i32 12, i32* %160
	%161 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %159, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %161
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$6fd, i64 0, i32 0), i64 16}, %..string* %158
	%162 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 13
	%163 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 13
	%164 = bitcast %runtime.Type_Info_Enum_Value* %163 to i32*
	store i32 13, i32* %164
	%165 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %163, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %165
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$6fe, i64 0, i32 0), i64 9}, %..string* %162
	%166 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 14
	%167 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 14
	%168 = bitcast %runtime.Type_Info_Enum_Value* %167 to i32*
	store i32 14, i32* %168
	%169 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %167, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %169
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$6ff, i64 0, i32 0), i64 11}, %..string* %166
	%170 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 15
	%171 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 15
	%172 = bitcast %runtime.Type_Info_Enum_Value* %171 to i32*
	store i32 15, i32* %172
	%173 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %171, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %173
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$700, i64 0, i32 0), i64 13}, %..string* %170
	%174 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 16
	%175 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 16
	%176 = bitcast %runtime.Type_Info_Enum_Value* %175 to i32*
	store i32 16, i32* %176
	%177 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %175, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %177
	store %..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$701, i64 0, i32 0), i64 20}, %..string* %174
	%178 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 17
	%179 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 17
	%180 = bitcast %runtime.Type_Info_Enum_Value* %179 to i32*
	store i32 17, i32* %180
	%181 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %179, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %181
	store %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$702, i64 0, i32 0), i64 19}, %..string* %178
	%182 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 18
	%183 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 18
	%184 = bitcast %runtime.Type_Info_Enum_Value* %183 to i32*
	store i32 18, i32* %184
	%185 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %183, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %185
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$703, i64 0, i32 0), i64 9}, %..string* %182
	%186 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 19
	%187 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 19
	%188 = bitcast %runtime.Type_Info_Enum_Value* %187 to i32*
	store i32 19, i32* %188
	%189 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %187, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %189
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$704, i64 0, i32 0), i64 10}, %..string* %186
	%190 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 20
	%191 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 20
	%192 = bitcast %runtime.Type_Info_Enum_Value* %191 to i32*
	store i32 20, i32* %192
	%193 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %191, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %193
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$705, i64 0, i32 0), i64 16}, %..string* %190
	%194 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 21
	%195 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 21
	%196 = bitcast %runtime.Type_Info_Enum_Value* %195 to i32*
	store i32 21, i32* %196
	%197 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %195, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %197
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$706, i64 0, i32 0), i64 6}, %..string* %194
	%198 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 22
	%199 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 22
	%200 = bitcast %runtime.Type_Info_Enum_Value* %199 to i32*
	store i32 22, i32* %200
	%201 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %199, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %201
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$707, i64 0, i32 0), i64 13}, %..string* %198
	%202 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 23
	%203 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 23
	%204 = bitcast %runtime.Type_Info_Enum_Value* %203 to i32*
	store i32 23, i32* %204
	%205 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %203, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %205
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$708, i64 0, i32 0), i64 12}, %..string* %202
	%206 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 24
	%207 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 24
	%208 = bitcast %runtime.Type_Info_Enum_Value* %207 to i32*
	store i32 24, i32* %208
	%209 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %207, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %209
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$709, i64 0, i32 0), i64 6}, %..string* %206
	%210 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 25
	%211 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 25
	%212 = bitcast %runtime.Type_Info_Enum_Value* %211 to i32*
	store i32 25, i32* %212
	%213 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %211, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %213
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$70a, i64 0, i32 0), i64 13}, %..string* %210
	%214 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 26
	%215 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 26
	%216 = bitcast %runtime.Type_Info_Enum_Value* %215 to i32*
	store i32 26, i32* %216
	%217 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %215, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %217
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$70b, i64 0, i32 0), i64 12}, %..string* %214
	%218 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 27
	%219 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 27
	%220 = bitcast %runtime.Type_Info_Enum_Value* %219 to i32*
	store i32 27, i32* %220
	%221 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %219, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %221
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$70c, i64 0, i32 0), i64 9}, %..string* %218
	%222 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 28
	%223 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 28
	%224 = bitcast %runtime.Type_Info_Enum_Value* %223 to i32*
	store i32 28, i32* %224
	%225 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %223, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %225
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$70d, i64 0, i32 0), i64 16}, %..string* %222
	%226 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 29
	%227 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 29
	%228 = bitcast %runtime.Type_Info_Enum_Value* %227 to i32*
	store i32 29, i32* %228
	%229 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %227, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %229
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$70e, i64 0, i32 0), i64 15}, %..string* %226
	%230 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 30
	%231 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 30
	%232 = bitcast %runtime.Type_Info_Enum_Value* %231 to i32*
	store i32 30, i32* %232
	%233 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %231, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %233
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$70f, i64 0, i32 0), i64 10}, %..string* %230
	%234 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 31
	%235 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 31
	%236 = bitcast %runtime.Type_Info_Enum_Value* %235 to i32*
	store i32 31, i32* %236
	%237 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %235, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %237
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$710, i64 0, i32 0), i64 17}, %..string* %234
	%238 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 32
	%239 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 32
	%240 = bitcast %runtime.Type_Info_Enum_Value* %239 to i32*
	store i32 32, i32* %240
	%241 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %239, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %241
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$711, i64 0, i32 0), i64 16}, %..string* %238
	%242 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 33
	%243 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 33
	%244 = bitcast %runtime.Type_Info_Enum_Value* %243 to i32*
	store i32 33, i32* %244
	%245 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %243, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %245
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$712, i64 0, i32 0), i64 11}, %..string* %242
	%246 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 34
	%247 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 34
	%248 = bitcast %runtime.Type_Info_Enum_Value* %247 to i32*
	store i32 34, i32* %248
	%249 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %247, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %249
	store %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$713, i64 0, i32 0), i64 18}, %..string* %246
	%250 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 35
	%251 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 35
	%252 = bitcast %runtime.Type_Info_Enum_Value* %251 to i32*
	store i32 35, i32* %252
	%253 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %251, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %253
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$714, i64 0, i32 0), i64 17}, %..string* %250
	%254 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 36
	%255 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 36
	%256 = bitcast %runtime.Type_Info_Enum_Value* %255 to i32*
	store i32 36, i32* %256
	%257 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %255, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %257
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$715, i64 0, i32 0), i64 9}, %..string* %254
	%258 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 37
	%259 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 37
	%260 = bitcast %runtime.Type_Info_Enum_Value* %259 to i32*
	store i32 37, i32* %260
	%261 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %259, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %261
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$716, i64 0, i32 0), i64 16}, %..string* %258
	%262 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 38
	%263 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 38
	%264 = bitcast %runtime.Type_Info_Enum_Value* %263 to i32*
	store i32 38, i32* %264
	%265 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %263, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %265
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$717, i64 0, i32 0), i64 13}, %..string* %262
	%266 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 39
	%267 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 39
	%268 = bitcast %runtime.Type_Info_Enum_Value* %267 to i32*
	store i32 39, i32* %268
	%269 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %267, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %269
	store %..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$718, i64 0, i32 0), i64 20}, %..string* %266
	%270 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 40
	%271 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 40
	%272 = bitcast %runtime.Type_Info_Enum_Value* %271 to i32*
	store i32 40, i32* %272
	%273 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %271, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %273
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$719, i64 0, i32 0), i64 14}, %..string* %270
	%274 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 41
	%275 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 41
	%276 = bitcast %runtime.Type_Info_Enum_Value* %275 to i32*
	store i32 41, i32* %276
	%277 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %275, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %277
	store %..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$71a, i64 0, i32 0), i64 20}, %..string* %274
	%278 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 42
	%279 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 42
	%280 = bitcast %runtime.Type_Info_Enum_Value* %279 to i32*
	store i32 42, i32* %280
	%281 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %279, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %281
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$71b, i64 0, i32 0), i64 14}, %..string* %278
	%282 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 43
	%283 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 43
	%284 = bitcast %runtime.Type_Info_Enum_Value* %283 to i32*
	store i32 43, i32* %284
	%285 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %283, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %285
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$71c, i64 0, i32 0), i64 5}, %..string* %282
	%286 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 44
	%287 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 44
	%288 = bitcast %runtime.Type_Info_Enum_Value* %287 to i32*
	store i32 3, i32* %288
	%289 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %287, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %289
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$71d, i64 0, i32 0), i64 13}, %..string* %286
	%290 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 45
	%291 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 45
	%292 = bitcast %runtime.Type_Info_Enum_Value* %291 to i32*
	store i32 27, i32* %292
	%293 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %291, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %293
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$71e, i64 0, i32 0), i64 6}, %..string* %290
	%294 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 46
	%295 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 46
	%296 = bitcast %runtime.Type_Info_Enum_Value* %295 to i32*
	store i32 28, i32* %296
	%297 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %295, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %297
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$71f, i64 0, i32 0), i64 13}, %..string* %294
	%298 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 47
	%299 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 47
	%300 = bitcast %runtime.Type_Info_Enum_Value* %299 to i32*
	store i32 29, i32* %300
	%301 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %299, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %301
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$720, i64 0, i32 0), i64 12}, %..string* %298
	%302 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %107, i64 0, i32 1
	%303 = getelementptr inbounds [48 x %..string], [48 x %..string]* @$enum_names-66, i64 0, i32 0
	%304 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %302, i64 0, i32 0
	store %..string* %303, %..string** %304
	%305 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %302, i64 0, i32 1
	store i64 48, i64* %305
	%306 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %107, i64 0, i32 2
	%307 = getelementptr inbounds [48 x %runtime.Type_Info_Enum_Value], [48 x %runtime.Type_Info_Enum_Value]* @$enum_values-66, i64 0, i32 0
	%308 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %306, i64 0, i32 0
	store %runtime.Type_Info_Enum_Value* %307, %runtime.Type_Info_Enum_Value** %308
	%309 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %306, i64 0, i32 1
	store i64 48, i64* %309
	%310 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %107, align 8
	%311 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %103 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %310, %runtime.Type_Info_Enum* %311
	%312 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %103, i64 0, i32 2 ; UnionTagPtr
	store i8 18, i8* %312
	%313 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%314 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %313, i64 0, i32 3
	%315 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %313, i64 0, i32 0
	store i64 4, i64* %315
	%316 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %313, i64 0, i32 1
	store i64 4, i64* %316
	%317 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %313, i64 0, i32 2
	store %..typeid 4683743612465315848, %..typeid* %317
	; Type_Info_Basic
	%318 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %314 to %runtime.Type_Info_Integer*
	%319 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %318, i64 0, i32 0
	store i8 1, i8* %319
	%320 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %318, align 1
	%321 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %314 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %320, %runtime.Type_Info_Integer* %321
	%322 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %314, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %322
	%323 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 99
	%324 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %323, i64 0, i32 3
	%325 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %323, i64 0, i32 0
	store i64 4, i64* %325
	%326 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %323, i64 0, i32 1
	store i64 4, i64* %326
	%327 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %323, i64 0, i32 2
	store %..typeid 3530822107858468963, %..typeid* %327
	; Type_Info_Named
	%328 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %324 to %runtime.Type_Info_Named*
	%329 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 100
	%330 = bitcast %runtime.Type_Info* %329 to %runtime.Type_Info*
	%331 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %328, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$721, i64 0, i32 0), i64 3}, %..string* %331
	%332 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %328, i64 0, i32 1
	store %runtime.Type_Info* %330, %runtime.Type_Info** %332
	%333 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %328, align 8
	%334 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %324 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %333, %runtime.Type_Info_Named* %334
	%335 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %324, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %335
	%336 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 100
	%337 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %336, i64 0, i32 3
	%338 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %336, i64 0, i32 0
	store i64 4, i64* %338
	%339 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %336, i64 0, i32 1
	store i64 4, i64* %339
	%340 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %336, i64 0, i32 2
	store %..typeid 1224979098644775012, %..typeid* %340
	; Type_Info_Enum
	%341 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %337 to %runtime.Type_Info_Enum*
	%342 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%343 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %341, i64 0, i32 0
	store %runtime.Type_Info* %342, %runtime.Type_Info** %343
	%344 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 0
	%345 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 0
	%346 = bitcast %runtime.Type_Info_Enum_Value* %345 to i32*
	store i32 0, i32* %346
	%347 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %345, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %347
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$722, i64 0, i32 0), i64 3}, %..string* %344
	%348 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 1
	%349 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 1
	%350 = bitcast %runtime.Type_Info_Enum_Value* %349 to i32*
	store i32 1, i32* %350
	%351 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %349, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %351
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$723, i64 0, i32 0), i64 9}, %..string* %348
	%352 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 2
	%353 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 2
	%354 = bitcast %runtime.Type_Info_Enum_Value* %353 to i32*
	store i32 2, i32* %354
	%355 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %353, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %355
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$724, i64 0, i32 0), i64 10}, %..string* %352
	%356 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 3
	%357 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 3
	%358 = bitcast %runtime.Type_Info_Enum_Value* %357 to i32*
	store i32 3, i32* %358
	%359 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %357, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %359
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$725, i64 0, i32 0), i64 7}, %..string* %356
	%360 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 4
	%361 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 4
	%362 = bitcast %runtime.Type_Info_Enum_Value* %361 to i32*
	store i32 4, i32* %362
	%363 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %361, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %363
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$726, i64 0, i32 0), i64 9}, %..string* %360
	%364 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 5
	%365 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 5
	%366 = bitcast %runtime.Type_Info_Enum_Value* %365 to i32*
	store i32 5, i32* %366
	%367 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %365, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %367
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$727, i64 0, i32 0), i64 6}, %..string* %364
	%368 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 6
	%369 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 6
	%370 = bitcast %runtime.Type_Info_Enum_Value* %369 to i32*
	store i32 6, i32* %370
	%371 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %369, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %371
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$728, i64 0, i32 0), i64 8}, %..string* %368
	%372 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 7
	%373 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 7
	%374 = bitcast %runtime.Type_Info_Enum_Value* %373 to i32*
	store i32 7, i32* %374
	%375 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %373, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %375
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$729, i64 0, i32 0), i64 4}, %..string* %372
	%376 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 8
	%377 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 8
	%378 = bitcast %runtime.Type_Info_Enum_Value* %377 to i32*
	store i32 8, i32* %378
	%379 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %377, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %379
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$72a, i64 0, i32 0), i64 3}, %..string* %376
	%380 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 9
	%381 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 9
	%382 = bitcast %runtime.Type_Info_Enum_Value* %381 to i32*
	store i32 9, i32* %382
	%383 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %381, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %383
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$72b, i64 0, i32 0), i64 6}, %..string* %380
	%384 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 10
	%385 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 10
	%386 = bitcast %runtime.Type_Info_Enum_Value* %385 to i32*
	store i32 10, i32* %386
	%387 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %385, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %387
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$72c, i64 0, i32 0), i64 9}, %..string* %384
	%388 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 11
	%389 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 11
	%390 = bitcast %runtime.Type_Info_Enum_Value* %389 to i32*
	store i32 11, i32* %390
	%391 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %389, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %391
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$72d, i64 0, i32 0), i64 5}, %..string* %388
	%392 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 12
	%393 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 12
	%394 = bitcast %runtime.Type_Info_Enum_Value* %393 to i32*
	store i32 12, i32* %394
	%395 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %393, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %395
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$72e, i64 0, i32 0), i64 6}, %..string* %392
	%396 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 13
	%397 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 13
	%398 = bitcast %runtime.Type_Info_Enum_Value* %397 to i32*
	store i32 13, i32* %398
	%399 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %397, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %399
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$72f, i64 0, i32 0), i64 1}, %..string* %396
	%400 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 14
	%401 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 14
	%402 = bitcast %runtime.Type_Info_Enum_Value* %401 to i32*
	store i32 14, i32* %402
	%403 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %401, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %403
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$730, i64 0, i32 0), i64 1}, %..string* %400
	%404 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 15
	%405 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 15
	%406 = bitcast %runtime.Type_Info_Enum_Value* %405 to i32*
	store i32 15, i32* %406
	%407 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %405, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %407
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$731, i64 0, i32 0), i64 1}, %..string* %404
	%408 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 16
	%409 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 16
	%410 = bitcast %runtime.Type_Info_Enum_Value* %409 to i32*
	store i32 16, i32* %410
	%411 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %409, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %411
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$732, i64 0, i32 0), i64 1}, %..string* %408
	%412 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 17
	%413 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 17
	%414 = bitcast %runtime.Type_Info_Enum_Value* %413 to i32*
	store i32 17, i32* %414
	%415 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %413, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %415
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$733, i64 0, i32 0), i64 1}, %..string* %412
	%416 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 18
	%417 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 18
	%418 = bitcast %runtime.Type_Info_Enum_Value* %417 to i32*
	store i32 18, i32* %418
	%419 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %417, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %419
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$734, i64 0, i32 0), i64 1}, %..string* %416
	%420 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 19
	%421 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 19
	%422 = bitcast %runtime.Type_Info_Enum_Value* %421 to i32*
	store i32 19, i32* %422
	%423 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %421, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %423
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$735, i64 0, i32 0), i64 5}, %..string* %420
	%424 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %341, i64 0, i32 1
	%425 = getelementptr inbounds [20 x %..string], [20 x %..string]* @$enum_names-64, i64 0, i32 0
	%426 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %424, i64 0, i32 0
	store %..string* %425, %..string** %426
	%427 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %424, i64 0, i32 1
	store i64 20, i64* %427
	%428 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %341, i64 0, i32 2
	%429 = getelementptr inbounds [20 x %runtime.Type_Info_Enum_Value], [20 x %runtime.Type_Info_Enum_Value]* @$enum_values-64, i64 0, i32 0
	%430 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %428, i64 0, i32 0
	store %runtime.Type_Info_Enum_Value* %429, %runtime.Type_Info_Enum_Value** %430
	%431 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %428, i64 0, i32 1
	store i64 20, i64* %431
	%432 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %341, align 8
	%433 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %337 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %432, %runtime.Type_Info_Enum* %433
	%434 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %337, i64 0, i32 2 ; UnionTagPtr
	store i8 18, i8* %434
	%435 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 14
	%436 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %435, i64 0, i32 3
	%437 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %435, i64 0, i32 0
	store i64 8, i64* %437
	%438 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %435, i64 0, i32 1
	store i64 8, i64* %438
	%439 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %435, i64 0, i32 2
	store %..typeid 14, %..typeid* %439
	; Type_Info_Basic
	%440 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %436 to %runtime.Type_Info_Type_Id*
	%441 = load %runtime.Type_Info_Type_Id, %runtime.Type_Info_Type_Id* %440, align 1
	%442 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %436 to %runtime.Type_Info_Type_Id*
	store %runtime.Type_Info_Type_Id %441, %runtime.Type_Info_Type_Id* %442
	%443 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %436, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %443
	%444 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 15
	%445 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %444, i64 0, i32 3
	%446 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %444, i64 0, i32 0
	store i64 80, i64* %446
	%447 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %444, i64 0, i32 1
	store i64 8, i64* %447
	%448 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %444, i64 0, i32 2
	store %..typeid 1152921504606846991, %..typeid* %448
	; Type_Info_Union
	%449 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %445 to %runtime.Type_Info_Union*
	%450 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %449, i64 0, i32 0
	%451 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %449, i64 0, i32 1
	%452 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %449, i64 0, i32 2
	%453 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %449, i64 0, i32 3
	%454 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 0
	%455 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	%456 = bitcast %runtime.Type_Info* %455 to %runtime.Type_Info*
	%457 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 0
	%458 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	store %runtime.Type_Info* %458, %runtime.Type_Info** %457
	%459 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 18
	%460 = bitcast %runtime.Type_Info* %459 to %runtime.Type_Info*
	%461 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 1
	%462 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 18
	store %runtime.Type_Info* %462, %runtime.Type_Info** %461
	%463 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 21
	%464 = bitcast %runtime.Type_Info* %463 to %runtime.Type_Info*
	%465 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 2
	%466 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 21
	store %runtime.Type_Info* %466, %runtime.Type_Info** %465
	%467 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 23
	%468 = bitcast %runtime.Type_Info* %467 to %runtime.Type_Info*
	%469 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 3
	%470 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 23
	store %runtime.Type_Info* %470, %runtime.Type_Info** %469
	%471 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 24
	%472 = bitcast %runtime.Type_Info* %471 to %runtime.Type_Info*
	%473 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 4
	%474 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 24
	store %runtime.Type_Info* %474, %runtime.Type_Info** %473
	%475 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 25
	%476 = bitcast %runtime.Type_Info* %475 to %runtime.Type_Info*
	%477 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 5
	%478 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 25
	store %runtime.Type_Info* %478, %runtime.Type_Info** %477
	%479 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 27
	%480 = bitcast %runtime.Type_Info* %479 to %runtime.Type_Info*
	%481 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 6
	%482 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 27
	store %runtime.Type_Info* %482, %runtime.Type_Info** %481
	%483 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 28
	%484 = bitcast %runtime.Type_Info* %483 to %runtime.Type_Info*
	%485 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 7
	%486 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 28
	store %runtime.Type_Info* %486, %runtime.Type_Info** %485
	%487 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 29
	%488 = bitcast %runtime.Type_Info* %487 to %runtime.Type_Info*
	%489 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 8
	%490 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 29
	store %runtime.Type_Info* %490, %runtime.Type_Info** %489
	%491 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 30
	%492 = bitcast %runtime.Type_Info* %491 to %runtime.Type_Info*
	%493 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 9
	%494 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 30
	store %runtime.Type_Info* %494, %runtime.Type_Info** %493
	%495 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 32
	%496 = bitcast %runtime.Type_Info* %495 to %runtime.Type_Info*
	%497 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 10
	%498 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 32
	store %runtime.Type_Info* %498, %runtime.Type_Info** %497
	%499 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 36
	%500 = bitcast %runtime.Type_Info* %499 to %runtime.Type_Info*
	%501 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 11
	%502 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 36
	store %runtime.Type_Info* %502, %runtime.Type_Info** %501
	%503 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 38
	%504 = bitcast %runtime.Type_Info* %503 to %runtime.Type_Info*
	%505 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 12
	%506 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 38
	store %runtime.Type_Info* %506, %runtime.Type_Info** %505
	%507 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 40
	%508 = bitcast %runtime.Type_Info* %507 to %runtime.Type_Info*
	%509 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 13
	%510 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 40
	store %runtime.Type_Info* %510, %runtime.Type_Info** %509
	%511 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 41
	%512 = bitcast %runtime.Type_Info* %511 to %runtime.Type_Info*
	%513 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 14
	%514 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 41
	store %runtime.Type_Info* %514, %runtime.Type_Info** %513
	%515 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 47
	%516 = bitcast %runtime.Type_Info* %515 to %runtime.Type_Info*
	%517 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 15
	%518 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 47
	store %runtime.Type_Info* %518, %runtime.Type_Info** %517
	%519 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 54
	%520 = bitcast %runtime.Type_Info* %519 to %runtime.Type_Info*
	%521 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 16
	%522 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 54
	store %runtime.Type_Info* %522, %runtime.Type_Info** %521
	%523 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 56
	%524 = bitcast %runtime.Type_Info* %523 to %runtime.Type_Info*
	%525 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 17
	%526 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 56
	store %runtime.Type_Info* %526, %runtime.Type_Info** %525
	%527 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 69
	%528 = bitcast %runtime.Type_Info* %527 to %runtime.Type_Info*
	%529 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 18
	%530 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 69
	store %runtime.Type_Info* %530, %runtime.Type_Info** %529
	%531 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 71
	%532 = bitcast %runtime.Type_Info* %531 to %runtime.Type_Info*
	%533 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 19
	%534 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 71
	store %runtime.Type_Info* %534, %runtime.Type_Info** %533
	%535 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 75
	%536 = bitcast %runtime.Type_Info* %535 to %runtime.Type_Info*
	%537 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %454, i64 20
	%538 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 75
	store %runtime.Type_Info* %538, %runtime.Type_Info** %537
	%539 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %450, i64 0, i32 0
	store %runtime.Type_Info** %454, %runtime.Type_Info*** %539
	%540 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %450, i64 0, i32 1
	store i64 21, i64* %540
	store i64 72, i64* %451
	%541 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	store %runtime.Type_Info* %541, %runtime.Type_Info** %452
	store i8 0, i8* %453
	%542 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %449, align 8
	%543 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %445 to %runtime.Type_Info_Union*
	store %runtime.Type_Info_Union %542, %runtime.Type_Info_Union* %543
	%544 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %445, i64 0, i32 2 ; UnionTagPtr
	store i8 17, i8* %544
	%545 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%546 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %545, i64 0, i32 3
	%547 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %545, i64 0, i32 0
	store i64 8, i64* %547
	%548 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %545, i64 0, i32 1
	store i64 8, i64* %548
	%549 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %545, i64 0, i32 2
	store %..typeid 648518346341351435, %..typeid* %549
	; Type_Info_Pointer
	%550 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %546 to %runtime.Type_Info_Pointer*
	%551 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 12
	%552 = bitcast %runtime.Type_Info* %551 to %runtime.Type_Info*
	%553 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %550, i64 0, i32 0
	store %runtime.Type_Info* %552, %runtime.Type_Info** %553
	%554 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %550, align 8
	%555 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %546 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %554, %runtime.Type_Info_Pointer* %555
	%556 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %546, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %556
	%557 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 12
	%558 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %557, i64 0, i32 3
	%559 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %557, i64 0, i32 0
	store i64 104, i64* %559
	%560 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %557, i64 0, i32 1
	store i64 8, i64* %560
	%561 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %557, i64 0, i32 2
	store %..typeid 3386706919782613004, %..typeid* %561
	; Type_Info_Named
	%562 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %558 to %runtime.Type_Info_Named*
	%563 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 13
	%564 = bitcast %runtime.Type_Info* %563 to %runtime.Type_Info*
	%565 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %562, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$736, i64 0, i32 0), i64 9}, %..string* %565
	%566 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %562, i64 0, i32 1
	store %runtime.Type_Info* %564, %runtime.Type_Info** %566
	%567 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %562, align 8
	%568 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %558 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %567, %runtime.Type_Info_Named* %568
	%569 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %558, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %569
	%570 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 13
	%571 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %570, i64 0, i32 3
	%572 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %570, i64 0, i32 0
	store i64 104, i64* %572
	%573 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %570, i64 0, i32 1
	store i64 8, i64* %573
	%574 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %570, i64 0, i32 2
	store %..typeid 1080863910568919053, %..typeid* %574
	; Type_Info_Struct
	%575 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %571 to %runtime.Type_Info_Struct*
	%576 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %575, i64 0, i32 4
	store i8 0, i8* %576
	%577 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %575, i64 0, i32 5
	store i8 0, i8* %577
	%578 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %575, i64 0, i32 6
	store i8 0, i8* %578
	%579 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 21
	%580 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 0
	%581 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 0
	%582 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 0
	%583 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%584 = bitcast %runtime.Type_Info* %583 to %runtime.Type_Info*
	%585 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %579, i64 0
	%586 = getelementptr inbounds i64, i64* %581, i64 0
	%587 = getelementptr inbounds i8, i8* %582, i64 0
	%588 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %588, %runtime.Type_Info** %585
	%589 = getelementptr inbounds %..string, %..string* %580, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$737, i64 0, i32 0), i64 4}, %..string* %589
	store i64 0, i64* %586
	store i8 0, i8* %587
	%590 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%591 = bitcast %runtime.Type_Info* %590 to %runtime.Type_Info*
	%592 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %579, i64 1
	%593 = getelementptr inbounds i64, i64* %581, i64 1
	%594 = getelementptr inbounds i8, i8* %582, i64 1
	%595 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %595, %runtime.Type_Info** %592
	%596 = getelementptr inbounds %..string, %..string* %580, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$738, i64 0, i32 0), i64 5}, %..string* %596
	store i64 8, i64* %593
	store i8 0, i8* %594
	%597 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 14
	%598 = bitcast %runtime.Type_Info* %597 to %runtime.Type_Info*
	%599 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %579, i64 2
	%600 = getelementptr inbounds i64, i64* %581, i64 2
	%601 = getelementptr inbounds i8, i8* %582, i64 2
	%602 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 14
	store %runtime.Type_Info* %602, %runtime.Type_Info** %599
	%603 = getelementptr inbounds %..string, %..string* %580, i64 2
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$739, i64 0, i32 0), i64 2}, %..string* %603
	store i64 16, i64* %600
	store i8 0, i8* %601
	%604 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 15
	%605 = bitcast %runtime.Type_Info* %604 to %runtime.Type_Info*
	%606 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %579, i64 3
	%607 = getelementptr inbounds i64, i64* %581, i64 3
	%608 = getelementptr inbounds i8, i8* %582, i64 3
	%609 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 15
	store %runtime.Type_Info* %609, %runtime.Type_Info** %606
	%610 = getelementptr inbounds %..string, %..string* %580, i64 3
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$73a, i64 0, i32 0), i64 7}, %..string* %610
	store i64 24, i64* %607
	store i8 0, i8* %608
	%611 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %575, i64 0, i32 0
	%612 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %611, i64 0, i32 0
	store %runtime.Type_Info** %579, %runtime.Type_Info*** %612
	%613 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %611, i64 0, i32 1
	store i64 4, i64* %613
	%614 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %575, i64 0, i32 1
	%615 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %614, i64 0, i32 0
	store %..string* %580, %..string** %615
	%616 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %614, i64 0, i32 1
	store i64 4, i64* %616
	%617 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %575, i64 0, i32 2
	%618 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %617, i64 0, i32 0
	store i64* %581, i64** %618
	%619 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %617, i64 0, i32 1
	store i64 4, i64* %619
	%620 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %575, i64 0, i32 3
	%621 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %620, i64 0, i32 0
	store i8* %582, i8** %621
	%622 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %620, i64 0, i32 1
	store i64 4, i64* %622
	%623 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %575, align 8
	%624 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %571 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %623, %runtime.Type_Info_Struct* %624
	%625 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %571, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %625
	%626 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	%627 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %626, i64 0, i32 3
	%628 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %626, i64 0, i32 0
	store i64 24, i64* %628
	%629 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %626, i64 0, i32 1
	store i64 8, i64* %629
	%630 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %626, i64 0, i32 2
	store %..typeid 3386706919782613008, %..typeid* %630
	; Type_Info_Named
	%631 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %627 to %runtime.Type_Info_Named*
	%632 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 17
	%633 = bitcast %runtime.Type_Info* %632 to %runtime.Type_Info*
	%634 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %631, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$73b, i64 0, i32 0), i64 15}, %..string* %634
	%635 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %631, i64 0, i32 1
	store %runtime.Type_Info* %633, %runtime.Type_Info** %635
	%636 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %631, align 8
	%637 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %627 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %636, %runtime.Type_Info_Named* %637
	%638 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %627, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %638
	%639 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 17
	%640 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %639, i64 0, i32 3
	%641 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %639, i64 0, i32 0
	store i64 24, i64* %641
	%642 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %639, i64 0, i32 1
	store i64 8, i64* %642
	%643 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %639, i64 0, i32 2
	store %..typeid 1080863910568919057, %..typeid* %643
	; Type_Info_Struct
	%644 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %640 to %runtime.Type_Info_Struct*
	%645 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %644, i64 0, i32 4
	store i8 0, i8* %645
	%646 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %644, i64 0, i32 5
	store i8 0, i8* %646
	%647 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %644, i64 0, i32 6
	store i8 0, i8* %647
	%648 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 25
	%649 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 4
	%650 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 4
	%651 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 4
	%652 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%653 = bitcast %runtime.Type_Info* %652 to %runtime.Type_Info*
	%654 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %648, i64 0
	%655 = getelementptr inbounds i64, i64* %650, i64 0
	%656 = getelementptr inbounds i8, i8* %651, i64 0
	%657 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	store %runtime.Type_Info* %657, %runtime.Type_Info** %654
	%658 = getelementptr inbounds %..string, %..string* %649, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$73c, i64 0, i32 0), i64 4}, %..string* %658
	store i64 0, i64* %655
	store i8 0, i8* %656
	%659 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%660 = bitcast %runtime.Type_Info* %659 to %runtime.Type_Info*
	%661 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %648, i64 1
	%662 = getelementptr inbounds i64, i64* %650, i64 1
	%663 = getelementptr inbounds i8, i8* %651, i64 1
	%664 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	store %runtime.Type_Info* %664, %runtime.Type_Info** %661
	%665 = getelementptr inbounds %..string, %..string* %649, i64 1
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$73d, i64 0, i32 0), i64 4}, %..string* %665
	store i64 16, i64* %662
	store i8 0, i8* %663
	%666 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %644, i64 0, i32 0
	%667 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %666, i64 0, i32 0
	store %runtime.Type_Info** %648, %runtime.Type_Info*** %667
	%668 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %666, i64 0, i32 1
	store i64 2, i64* %668
	%669 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %644, i64 0, i32 1
	%670 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %669, i64 0, i32 0
	store %..string* %649, %..string** %670
	%671 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %669, i64 0, i32 1
	store i64 2, i64* %671
	%672 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %644, i64 0, i32 2
	%673 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %672, i64 0, i32 0
	store i64* %650, i64** %673
	%674 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %672, i64 0, i32 1
	store i64 2, i64* %674
	%675 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %644, i64 0, i32 3
	%676 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %675, i64 0, i32 0
	store i8* %651, i8** %676
	%677 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %675, i64 0, i32 1
	store i64 2, i64* %677
	%678 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %644, align 8
	%679 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %640 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %678, %runtime.Type_Info_Struct* %679
	%680 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %640, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %680
	%681 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%682 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %681, i64 0, i32 3
	%683 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %681, i64 0, i32 0
	store i64 16, i64* %683
	%684 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %681, i64 0, i32 1
	store i64 8, i64* %684
	%685 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %681, i64 0, i32 2
	store %..typeid 360287970189639684, %..typeid* %685
	; Type_Info_Basic
	%686 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %682 to %runtime.Type_Info_String*
	%687 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %686, align 1
	%688 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %682 to %runtime.Type_Info_String*
	store %runtime.Type_Info_String %687, %runtime.Type_Info_String* %688
	%689 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %682, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %689
	%690 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 5
	%691 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %690, i64 0, i32 3
	%692 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %690, i64 0, i32 0
	store i64 8, i64* %692
	%693 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %690, i64 0, i32 1
	store i64 8, i64* %693
	%694 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %690, i64 0, i32 2
	store %..typeid 648518346341351429, %..typeid* %694
	; Type_Info_Pointer
	%695 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %691 to %runtime.Type_Info_Pointer*
	%696 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	%697 = bitcast %runtime.Type_Info* %696 to %runtime.Type_Info*
	%698 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %695, i64 0, i32 0
	store %runtime.Type_Info* %697, %runtime.Type_Info** %698
	%699 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %695, align 8
	%700 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %691 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %699, %runtime.Type_Info_Pointer* %700
	%701 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %691, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %701
	%702 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	%703 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %702, i64 0, i32 3
	%704 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %702, i64 0, i32 0
	store i64 1, i64* %704
	%705 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %702, i64 0, i32 1
	store i64 1, i64* %705
	%706 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %702, i64 0, i32 2
	store %..typeid 72057594037927939, %..typeid* %706
	; Type_Info_Basic
	%707 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %703 to %runtime.Type_Info_Integer*
	%708 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %707, i64 0, i32 0
	store i8 0, i8* %708
	%709 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %707, align 1
	%710 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %703 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %709, %runtime.Type_Info_Integer* %710
	%711 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %703, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %711
	%712 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 18
	%713 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %712, i64 0, i32 3
	%714 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %712, i64 0, i32 0
	store i64 1, i64* %714
	%715 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %712, i64 0, i32 1
	store i64 1, i64* %715
	%716 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %712, i64 0, i32 2
	store %..typeid 3386706919782613010, %..typeid* %716
	; Type_Info_Named
	%717 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %713 to %runtime.Type_Info_Named*
	%718 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 19
	%719 = bitcast %runtime.Type_Info* %718 to %runtime.Type_Info*
	%720 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %717, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$73e, i64 0, i32 0), i64 17}, %..string* %720
	%721 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %717, i64 0, i32 1
	store %runtime.Type_Info* %719, %runtime.Type_Info** %721
	%722 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %717, align 8
	%723 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %713 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %722, %runtime.Type_Info_Named* %723
	%724 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %713, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %724
	%725 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 19
	%726 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %725, i64 0, i32 3
	%727 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %725, i64 0, i32 0
	store i64 1, i64* %727
	%728 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %725, i64 0, i32 1
	store i64 1, i64* %728
	%729 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %725, i64 0, i32 2
	store %..typeid 1080863910568919059, %..typeid* %729
	; Type_Info_Struct
	%730 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %726 to %runtime.Type_Info_Struct*
	%731 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %730, i64 0, i32 4
	store i8 0, i8* %731
	%732 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %730, i64 0, i32 5
	store i8 0, i8* %732
	%733 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %730, i64 0, i32 6
	store i8 0, i8* %733
	%734 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 27
	%735 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 6
	%736 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 6
	%737 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 6
	%738 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	%739 = bitcast %runtime.Type_Info* %738 to %runtime.Type_Info*
	%740 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %734, i64 0
	%741 = getelementptr inbounds i64, i64* %736, i64 0
	%742 = getelementptr inbounds i8, i8* %737, i64 0
	%743 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	store %runtime.Type_Info* %743, %runtime.Type_Info** %740
	%744 = getelementptr inbounds %..string, %..string* %735, i64 0
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$73f, i64 0, i32 0), i64 6}, %..string* %744
	store i64 0, i64* %741
	store i8 0, i8* %742
	%745 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %730, i64 0, i32 0
	%746 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %745, i64 0, i32 0
	store %runtime.Type_Info** %734, %runtime.Type_Info*** %746
	%747 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %745, i64 0, i32 1
	store i64 1, i64* %747
	%748 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %730, i64 0, i32 1
	%749 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %748, i64 0, i32 0
	store %..string* %735, %..string** %749
	%750 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %748, i64 0, i32 1
	store i64 1, i64* %750
	%751 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %730, i64 0, i32 2
	%752 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %751, i64 0, i32 0
	store i64* %736, i64** %752
	%753 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %751, i64 0, i32 1
	store i64 1, i64* %753
	%754 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %730, i64 0, i32 3
	%755 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %754, i64 0, i32 0
	store i8* %737, i8** %755
	%756 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %754, i64 0, i32 1
	store i64 1, i64* %756
	%757 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %730, align 8
	%758 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %726 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %757, %runtime.Type_Info_Struct* %758
	%759 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %726, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %759
	%760 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	%761 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %760, i64 0, i32 3
	%762 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %760, i64 0, i32 0
	store i64 1, i64* %762
	%763 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %760, i64 0, i32 1
	store i64 1, i64* %763
	%764 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %760, i64 0, i32 2
	store %..typeid 432345564227567636, %..typeid* %764
	; Type_Info_Basic
	%765 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %761 to %runtime.Type_Info_Boolean*
	%766 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %765, align 1
	%767 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %761 to %runtime.Type_Info_Boolean*
	store %runtime.Type_Info_Boolean %766, %runtime.Type_Info_Boolean* %767
	%768 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %761, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %768
	%769 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 21
	%770 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %769, i64 0, i32 3
	%771 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %769, i64 0, i32 0
	store i64 0, i64* %771
	%772 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %769, i64 0, i32 1
	store i64 1, i64* %772
	%773 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %769, i64 0, i32 2
	store %..typeid 3386706919782613013, %..typeid* %773
	; Type_Info_Named
	%774 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %770 to %runtime.Type_Info_Named*
	%775 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 22
	%776 = bitcast %runtime.Type_Info* %775 to %runtime.Type_Info*
	%777 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %774, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$740, i64 0, i32 0), i64 14}, %..string* %777
	%778 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %774, i64 0, i32 1
	store %runtime.Type_Info* %776, %runtime.Type_Info** %778
	%779 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %774, align 8
	%780 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %770 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %779, %runtime.Type_Info_Named* %780
	%781 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %770, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %781
	%782 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 22
	%783 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %782, i64 0, i32 3
	%784 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %782, i64 0, i32 0
	store i64 0, i64* %784
	%785 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %782, i64 0, i32 1
	store i64 1, i64* %785
	%786 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %782, i64 0, i32 2
	store %..typeid 1080863910568919062, %..typeid* %786
	; Type_Info_Struct
	%787 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %783 to %runtime.Type_Info_Struct*
	%788 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %787, i64 0, i32 4
	store i8 0, i8* %788
	%789 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %787, i64 0, i32 5
	store i8 0, i8* %789
	%790 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %787, i64 0, i32 6
	store i8 0, i8* %790
	%791 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %787, align 8
	%792 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %783 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %791, %runtime.Type_Info_Struct* %792
	%793 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %783, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %793
	%794 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 23
	%795 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %794, i64 0, i32 3
	%796 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %794, i64 0, i32 0
	store i64 0, i64* %796
	%797 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %794, i64 0, i32 1
	store i64 1, i64* %797
	%798 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %794, i64 0, i32 2
	store %..typeid 3386706919782613015, %..typeid* %798
	; Type_Info_Named
	%799 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %795 to %runtime.Type_Info_Named*
	%800 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 22
	%801 = bitcast %runtime.Type_Info* %800 to %runtime.Type_Info*
	%802 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %799, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$741, i64 0, i32 0), i64 15}, %..string* %802
	%803 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %799, i64 0, i32 1
	store %runtime.Type_Info* %801, %runtime.Type_Info** %803
	%804 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %799, align 8
	%805 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %795 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %804, %runtime.Type_Info_Named* %805
	%806 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %795, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %806
	%807 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 24
	%808 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %807, i64 0, i32 3
	%809 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %807, i64 0, i32 0
	store i64 0, i64* %809
	%810 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %807, i64 0, i32 1
	store i64 1, i64* %810
	%811 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %807, i64 0, i32 2
	store %..typeid 3386706919782613016, %..typeid* %811
	; Type_Info_Named
	%812 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %808 to %runtime.Type_Info_Named*
	%813 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 22
	%814 = bitcast %runtime.Type_Info* %813 to %runtime.Type_Info*
	%815 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %812, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$742, i64 0, i32 0), i64 17}, %..string* %815
	%816 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %812, i64 0, i32 1
	store %runtime.Type_Info* %814, %runtime.Type_Info** %816
	%817 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %812, align 8
	%818 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %808 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %817, %runtime.Type_Info_Named* %818
	%819 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %808, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %819
	%820 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 25
	%821 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %820, i64 0, i32 3
	%822 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %820, i64 0, i32 0
	store i64 1, i64* %822
	%823 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %820, i64 0, i32 1
	store i64 1, i64* %823
	%824 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %820, i64 0, i32 2
	store %..typeid 3386706919782613017, %..typeid* %824
	; Type_Info_Named
	%825 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %821 to %runtime.Type_Info_Named*
	%826 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 26
	%827 = bitcast %runtime.Type_Info* %826 to %runtime.Type_Info*
	%828 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %825, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$743, i64 0, i32 0), i64 16}, %..string* %828
	%829 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %825, i64 0, i32 1
	store %runtime.Type_Info* %827, %runtime.Type_Info** %829
	%830 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %825, align 8
	%831 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %821 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %830, %runtime.Type_Info_Named* %831
	%832 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %821, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %832
	%833 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 26
	%834 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %833, i64 0, i32 3
	%835 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %833, i64 0, i32 0
	store i64 1, i64* %835
	%836 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %833, i64 0, i32 1
	store i64 1, i64* %836
	%837 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %833, i64 0, i32 2
	store %..typeid 1080863910568919066, %..typeid* %837
	; Type_Info_Struct
	%838 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %834 to %runtime.Type_Info_Struct*
	%839 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %838, i64 0, i32 4
	store i8 0, i8* %839
	%840 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %838, i64 0, i32 5
	store i8 0, i8* %840
	%841 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %838, i64 0, i32 6
	store i8 0, i8* %841
	%842 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 28
	%843 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 7
	%844 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 7
	%845 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 7
	%846 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	%847 = bitcast %runtime.Type_Info* %846 to %runtime.Type_Info*
	%848 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %842, i64 0
	%849 = getelementptr inbounds i64, i64* %844, i64 0
	%850 = getelementptr inbounds i8, i8* %845, i64 0
	%851 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	store %runtime.Type_Info* %851, %runtime.Type_Info** %848
	%852 = getelementptr inbounds %..string, %..string* %843, i64 0
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$744, i64 0, i32 0), i64 10}, %..string* %852
	store i64 0, i64* %849
	store i8 0, i8* %850
	%853 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %838, i64 0, i32 0
	%854 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %853, i64 0, i32 0
	store %runtime.Type_Info** %842, %runtime.Type_Info*** %854
	%855 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %853, i64 0, i32 1
	store i64 1, i64* %855
	%856 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %838, i64 0, i32 1
	%857 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %856, i64 0, i32 0
	store %..string* %843, %..string** %857
	%858 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %856, i64 0, i32 1
	store i64 1, i64* %858
	%859 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %838, i64 0, i32 2
	%860 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %859, i64 0, i32 0
	store i64* %844, i64** %860
	%861 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %859, i64 0, i32 1
	store i64 1, i64* %861
	%862 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %838, i64 0, i32 3
	%863 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %862, i64 0, i32 0
	store i8* %845, i8** %863
	%864 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %862, i64 0, i32 1
	store i64 1, i64* %864
	%865 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %838, align 8
	%866 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %834 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %865, %runtime.Type_Info_Struct* %866
	%867 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %834, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %867
	%868 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 27
	%869 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %868, i64 0, i32 3
	%870 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %868, i64 0, i32 0
	store i64 0, i64* %870
	%871 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %868, i64 0, i32 1
	store i64 1, i64* %871
	%872 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %868, i64 0, i32 2
	store %..typeid 3386706919782613019, %..typeid* %872
	; Type_Info_Named
	%873 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %869 to %runtime.Type_Info_Named*
	%874 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 22
	%875 = bitcast %runtime.Type_Info* %874 to %runtime.Type_Info*
	%876 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %873, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$745, i64 0, i32 0), i64 17}, %..string* %876
	%877 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %873, i64 0, i32 1
	store %runtime.Type_Info* %875, %runtime.Type_Info** %877
	%878 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %873, align 8
	%879 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %869 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %878, %runtime.Type_Info_Named* %879
	%880 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %869, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %880
	%881 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 28
	%882 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %881, i64 0, i32 3
	%883 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %881, i64 0, i32 0
	store i64 0, i64* %883
	%884 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %881, i64 0, i32 1
	store i64 1, i64* %884
	%885 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %881, i64 0, i32 2
	store %..typeid 3386706919782613020, %..typeid* %885
	; Type_Info_Named
	%886 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %882 to %runtime.Type_Info_Named*
	%887 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 22
	%888 = bitcast %runtime.Type_Info* %887 to %runtime.Type_Info*
	%889 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %886, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$746, i64 0, i32 0), i64 13}, %..string* %889
	%890 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %886, i64 0, i32 1
	store %runtime.Type_Info* %888, %runtime.Type_Info** %890
	%891 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %886, align 8
	%892 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %882 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %891, %runtime.Type_Info_Named* %892
	%893 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %882, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %893
	%894 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 29
	%895 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %894, i64 0, i32 3
	%896 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %894, i64 0, i32 0
	store i64 0, i64* %896
	%897 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %894, i64 0, i32 1
	store i64 1, i64* %897
	%898 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %894, i64 0, i32 2
	store %..typeid 3386706919782613021, %..typeid* %898
	; Type_Info_Named
	%899 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %895 to %runtime.Type_Info_Named*
	%900 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 22
	%901 = bitcast %runtime.Type_Info* %900 to %runtime.Type_Info*
	%902 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %899, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$747, i64 0, i32 0), i64 17}, %..string* %902
	%903 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %899, i64 0, i32 1
	store %runtime.Type_Info* %901, %runtime.Type_Info** %903
	%904 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %899, align 8
	%905 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %895 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %904, %runtime.Type_Info_Named* %905
	%906 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %895, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %906
	%907 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 30
	%908 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %907, i64 0, i32 3
	%909 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %907, i64 0, i32 0
	store i64 8, i64* %909
	%910 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %907, i64 0, i32 1
	store i64 8, i64* %910
	%911 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %907, i64 0, i32 2
	store %..typeid 3386706919782613022, %..typeid* %911
	; Type_Info_Named
	%912 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %908 to %runtime.Type_Info_Named*
	%913 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 31
	%914 = bitcast %runtime.Type_Info* %913 to %runtime.Type_Info*
	%915 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %912, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$748, i64 0, i32 0), i64 17}, %..string* %915
	%916 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %912, i64 0, i32 1
	store %runtime.Type_Info* %914, %runtime.Type_Info** %916
	%917 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %912, align 8
	%918 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %908 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %917, %runtime.Type_Info_Named* %918
	%919 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %908, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %919
	%920 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 31
	%921 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %920, i64 0, i32 3
	%922 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %920, i64 0, i32 0
	store i64 8, i64* %922
	%923 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %920, i64 0, i32 1
	store i64 8, i64* %923
	%924 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %920, i64 0, i32 2
	store %..typeid 1080863910568919071, %..typeid* %924
	; Type_Info_Struct
	%925 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %921 to %runtime.Type_Info_Struct*
	%926 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %925, i64 0, i32 4
	store i8 0, i8* %926
	%927 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %925, i64 0, i32 5
	store i8 0, i8* %927
	%928 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %925, i64 0, i32 6
	store i8 0, i8* %928
	%929 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 29
	%930 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 8
	%931 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 8
	%932 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 8
	%933 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%934 = bitcast %runtime.Type_Info* %933 to %runtime.Type_Info*
	%935 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %929, i64 0
	%936 = getelementptr inbounds i64, i64* %931, i64 0
	%937 = getelementptr inbounds i8, i8* %932, i64 0
	%938 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	store %runtime.Type_Info* %938, %runtime.Type_Info** %935
	%939 = getelementptr inbounds %..string, %..string* %930, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$749, i64 0, i32 0), i64 4}, %..string* %939
	store i64 0, i64* %936
	store i8 0, i8* %937
	%940 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %925, i64 0, i32 0
	%941 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %940, i64 0, i32 0
	store %runtime.Type_Info** %929, %runtime.Type_Info*** %941
	%942 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %940, i64 0, i32 1
	store i64 1, i64* %942
	%943 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %925, i64 0, i32 1
	%944 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %943, i64 0, i32 0
	store %..string* %930, %..string** %944
	%945 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %943, i64 0, i32 1
	store i64 1, i64* %945
	%946 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %925, i64 0, i32 2
	%947 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %946, i64 0, i32 0
	store i64* %931, i64** %947
	%948 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %946, i64 0, i32 1
	store i64 1, i64* %948
	%949 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %925, i64 0, i32 3
	%950 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %949, i64 0, i32 0
	store i8* %932, i8** %950
	%951 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %949, i64 0, i32 1
	store i64 1, i64* %951
	%952 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %925, align 8
	%953 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %921 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %952, %runtime.Type_Info_Struct* %953
	%954 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %921, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %954
	%955 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 32
	%956 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %955, i64 0, i32 3
	%957 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %955, i64 0, i32 0
	store i64 32, i64* %957
	%958 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %955, i64 0, i32 1
	store i64 8, i64* %958
	%959 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %955, i64 0, i32 2
	store %..typeid 3386706919782613024, %..typeid* %959
	; Type_Info_Named
	%960 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %956 to %runtime.Type_Info_Named*
	%961 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 33
	%962 = bitcast %runtime.Type_Info* %961 to %runtime.Type_Info*
	%963 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %960, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$74a, i64 0, i32 0), i64 19}, %..string* %963
	%964 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %960, i64 0, i32 1
	store %runtime.Type_Info* %962, %runtime.Type_Info** %964
	%965 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %960, align 8
	%966 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %956 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %965, %runtime.Type_Info_Named* %966
	%967 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %956, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %967
	%968 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 33
	%969 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %968, i64 0, i32 3
	%970 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %968, i64 0, i32 0
	store i64 32, i64* %970
	%971 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %968, i64 0, i32 1
	store i64 8, i64* %971
	%972 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %968, i64 0, i32 2
	store %..typeid 1080863910568919073, %..typeid* %972
	; Type_Info_Struct
	%973 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %969 to %runtime.Type_Info_Struct*
	%974 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %973, i64 0, i32 4
	store i8 0, i8* %974
	%975 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %973, i64 0, i32 5
	store i8 0, i8* %975
	%976 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %973, i64 0, i32 6
	store i8 0, i8* %976
	%977 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 30
	%978 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 9
	%979 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 9
	%980 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 9
	%981 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%982 = bitcast %runtime.Type_Info* %981 to %runtime.Type_Info*
	%983 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %977, i64 0
	%984 = getelementptr inbounds i64, i64* %979, i64 0
	%985 = getelementptr inbounds i8, i8* %980, i64 0
	%986 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	store %runtime.Type_Info* %986, %runtime.Type_Info** %983
	%987 = getelementptr inbounds %..string, %..string* %978, i64 0
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$74b, i64 0, i32 0), i64 6}, %..string* %987
	store i64 0, i64* %984
	store i8 0, i8* %985
	%988 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%989 = bitcast %runtime.Type_Info* %988 to %runtime.Type_Info*
	%990 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %977, i64 1
	%991 = getelementptr inbounds i64, i64* %979, i64 1
	%992 = getelementptr inbounds i8, i8* %980, i64 1
	%993 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	store %runtime.Type_Info* %993, %runtime.Type_Info** %990
	%994 = getelementptr inbounds %..string, %..string* %978, i64 1
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$74c, i64 0, i32 0), i64 7}, %..string* %994
	store i64 8, i64* %991
	store i8 0, i8* %992
	%995 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	%996 = bitcast %runtime.Type_Info* %995 to %runtime.Type_Info*
	%997 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %977, i64 2
	%998 = getelementptr inbounds i64, i64* %979, i64 2
	%999 = getelementptr inbounds i8, i8* %980, i64 2
	%1000 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	store %runtime.Type_Info* %1000, %runtime.Type_Info** %997
	%1001 = getelementptr inbounds %..string, %..string* %978, i64 2
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$74d, i64 0, i32 0), i64 8}, %..string* %1001
	store i64 16, i64* %998
	store i8 0, i8* %999
	%1002 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 34
	%1003 = bitcast %runtime.Type_Info* %1002 to %runtime.Type_Info*
	%1004 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %977, i64 3
	%1005 = getelementptr inbounds i64, i64* %979, i64 3
	%1006 = getelementptr inbounds i8, i8* %980, i64 3
	%1007 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 34
	store %runtime.Type_Info* %1007, %runtime.Type_Info** %1004
	%1008 = getelementptr inbounds %..string, %..string* %978, i64 3
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$74e, i64 0, i32 0), i64 10}, %..string* %1008
	store i64 24, i64* %1005
	store i8 0, i8* %1006
	%1009 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %973, i64 0, i32 0
	%1010 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1009, i64 0, i32 0
	store %runtime.Type_Info** %977, %runtime.Type_Info*** %1010
	%1011 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1009, i64 0, i32 1
	store i64 4, i64* %1011
	%1012 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %973, i64 0, i32 1
	%1013 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1012, i64 0, i32 0
	store %..string* %978, %..string** %1013
	%1014 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1012, i64 0, i32 1
	store i64 4, i64* %1014
	%1015 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %973, i64 0, i32 2
	%1016 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1015, i64 0, i32 0
	store i64* %979, i64** %1016
	%1017 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1015, i64 0, i32 1
	store i64 4, i64* %1017
	%1018 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %973, i64 0, i32 3
	%1019 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1018, i64 0, i32 0
	store i8* %980, i8** %1019
	%1020 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1018, i64 0, i32 1
	store i64 4, i64* %1020
	%1021 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %973, align 8
	%1022 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %969 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1021, %runtime.Type_Info_Struct* %1022
	%1023 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %969, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1023
	%1024 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 34
	%1025 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1024, i64 0, i32 3
	%1026 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1024, i64 0, i32 0
	store i64 8, i64* %1026
	%1027 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1024, i64 0, i32 1
	store i64 8, i64* %1027
	%1028 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1024, i64 0, i32 2
	store %..typeid 3530822107858468898, %..typeid* %1028
	; Type_Info_Named
	%1029 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1025 to %runtime.Type_Info_Named*
	%1030 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 35
	%1031 = bitcast %runtime.Type_Info* %1030 to %runtime.Type_Info*
	%1032 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1029, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$74f, i64 0, i32 0), i64 18}, %..string* %1032
	%1033 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1029, i64 0, i32 1
	store %runtime.Type_Info* %1031, %runtime.Type_Info** %1033
	%1034 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1029, align 8
	%1035 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1025 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1034, %runtime.Type_Info_Named* %1035
	%1036 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1025, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1036
	%1037 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 35
	%1038 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1037, i64 0, i32 3
	%1039 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1037, i64 0, i32 0
	store i64 8, i64* %1039
	%1040 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1037, i64 0, i32 1
	store i64 8, i64* %1040
	%1041 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1037, i64 0, i32 2
	store %..typeid 1224979098644774947, %..typeid* %1041
	; Type_Info_Enum
	%1042 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1038 to %runtime.Type_Info_Enum*
	%1043 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%1044 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %1042, i64 0, i32 0
	store %runtime.Type_Info* %1043, %runtime.Type_Info** %1044
	%1045 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-23, i64 0, i32 0
	%1046 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-23, i64 0, i32 0
	%1047 = bitcast %runtime.Type_Info_Enum_Value* %1046 to i64*
	store i64 0, i64* %1047
	%1048 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1046, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %1048
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$750, i64 0, i32 0), i64 7}, %..string* %1045
	%1049 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-23, i64 0, i32 1
	%1050 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-23, i64 0, i32 1
	%1051 = bitcast %runtime.Type_Info_Enum_Value* %1050 to i64*
	store i64 1, i64* %1051
	%1052 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1050, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %1052
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$751, i64 0, i32 0), i64 4}, %..string* %1049
	%1053 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-23, i64 0, i32 2
	%1054 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-23, i64 0, i32 2
	%1055 = bitcast %runtime.Type_Info_Enum_Value* %1054 to i64*
	store i64 2, i64* %1055
	%1056 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1054, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %1056
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$752, i64 0, i32 0), i64 11}, %..string* %1053
	%1057 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-23, i64 0, i32 3
	%1058 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-23, i64 0, i32 3
	%1059 = bitcast %runtime.Type_Info_Enum_Value* %1058 to i64*
	store i64 3, i64* %1059
	%1060 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1058, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %1060
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$753, i64 0, i32 0), i64 1}, %..string* %1057
	%1061 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-23, i64 0, i32 4
	%1062 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-23, i64 0, i32 4
	%1063 = bitcast %runtime.Type_Info_Enum_Value* %1062 to i64*
	store i64 4, i64* %1063
	%1064 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1062, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %1064
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$754, i64 0, i32 0), i64 3}, %..string* %1061
	%1065 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-23, i64 0, i32 5
	%1066 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-23, i64 0, i32 5
	%1067 = bitcast %runtime.Type_Info_Enum_Value* %1066 to i64*
	store i64 5, i64* %1067
	%1068 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1066, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %1068
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$755, i64 0, i32 0), i64 4}, %..string* %1065
	%1069 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %1042, i64 0, i32 1
	%1070 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-23, i64 0, i32 0
	%1071 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1069, i64 0, i32 0
	store %..string* %1070, %..string** %1071
	%1072 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1069, i64 0, i32 1
	store i64 6, i64* %1072
	%1073 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %1042, i64 0, i32 2
	%1074 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-23, i64 0, i32 0
	%1075 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %1073, i64 0, i32 0
	store %runtime.Type_Info_Enum_Value* %1074, %runtime.Type_Info_Enum_Value** %1075
	%1076 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %1073, i64 0, i32 1
	store i64 6, i64* %1076
	%1077 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %1042, align 8
	%1078 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1038 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %1077, %runtime.Type_Info_Enum* %1078
	%1079 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1038, i64 0, i32 2 ; UnionTagPtr
	store i8 18, i8* %1079
	%1080 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 36
	%1081 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1080, i64 0, i32 3
	%1082 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1080, i64 0, i32 0
	store i64 24, i64* %1082
	%1083 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1080, i64 0, i32 1
	store i64 8, i64* %1083
	%1084 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1080, i64 0, i32 2
	store %..typeid 3386706919782613028, %..typeid* %1084
	; Type_Info_Named
	%1085 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1081 to %runtime.Type_Info_Named*
	%1086 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 37
	%1087 = bitcast %runtime.Type_Info* %1086 to %runtime.Type_Info*
	%1088 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1085, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$756, i64 0, i32 0), i64 15}, %..string* %1088
	%1089 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1085, i64 0, i32 1
	store %runtime.Type_Info* %1087, %runtime.Type_Info** %1089
	%1090 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1085, align 8
	%1091 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1081 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1090, %runtime.Type_Info_Named* %1091
	%1092 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1081, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1092
	%1093 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 37
	%1094 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1093, i64 0, i32 3
	%1095 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1093, i64 0, i32 0
	store i64 24, i64* %1095
	%1096 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1093, i64 0, i32 1
	store i64 8, i64* %1096
	%1097 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1093, i64 0, i32 2
	store %..typeid 1080863910568919077, %..typeid* %1097
	; Type_Info_Struct
	%1098 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1094 to %runtime.Type_Info_Struct*
	%1099 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1098, i64 0, i32 4
	store i8 0, i8* %1099
	%1100 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1098, i64 0, i32 5
	store i8 0, i8* %1100
	%1101 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1098, i64 0, i32 6
	store i8 0, i8* %1101
	%1102 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 34
	%1103 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 13
	%1104 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 13
	%1105 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 13
	%1106 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%1107 = bitcast %runtime.Type_Info* %1106 to %runtime.Type_Info*
	%1108 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1102, i64 0
	%1109 = getelementptr inbounds i64, i64* %1104, i64 0
	%1110 = getelementptr inbounds i8, i8* %1105, i64 0
	%1111 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	store %runtime.Type_Info* %1111, %runtime.Type_Info** %1108
	%1112 = getelementptr inbounds %..string, %..string* %1103, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$757, i64 0, i32 0), i64 4}, %..string* %1112
	store i64 0, i64* %1109
	store i8 0, i8* %1110
	%1113 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%1114 = bitcast %runtime.Type_Info* %1113 to %runtime.Type_Info*
	%1115 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1102, i64 1
	%1116 = getelementptr inbounds i64, i64* %1104, i64 1
	%1117 = getelementptr inbounds i8, i8* %1105, i64 1
	%1118 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %1118, %runtime.Type_Info** %1115
	%1119 = getelementptr inbounds %..string, %..string* %1103, i64 1
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$758, i64 0, i32 0), i64 9}, %..string* %1119
	store i64 8, i64* %1116
	store i8 0, i8* %1117
	%1120 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%1121 = bitcast %runtime.Type_Info* %1120 to %runtime.Type_Info*
	%1122 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1102, i64 2
	%1123 = getelementptr inbounds i64, i64* %1104, i64 2
	%1124 = getelementptr inbounds i8, i8* %1105, i64 2
	%1125 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %1125, %runtime.Type_Info** %1122
	%1126 = getelementptr inbounds %..string, %..string* %1103, i64 2
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$759, i64 0, i32 0), i64 5}, %..string* %1126
	store i64 16, i64* %1123
	store i8 0, i8* %1124
	%1127 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1098, i64 0, i32 0
	%1128 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1127, i64 0, i32 0
	store %runtime.Type_Info** %1102, %runtime.Type_Info*** %1128
	%1129 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1127, i64 0, i32 1
	store i64 3, i64* %1129
	%1130 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1098, i64 0, i32 1
	%1131 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1130, i64 0, i32 0
	store %..string* %1103, %..string** %1131
	%1132 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1130, i64 0, i32 1
	store i64 3, i64* %1132
	%1133 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1098, i64 0, i32 2
	%1134 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1133, i64 0, i32 0
	store i64* %1104, i64** %1134
	%1135 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1133, i64 0, i32 1
	store i64 3, i64* %1135
	%1136 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1098, i64 0, i32 3
	%1137 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1136, i64 0, i32 0
	store i8* %1105, i8** %1137
	%1138 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1136, i64 0, i32 1
	store i64 3, i64* %1138
	%1139 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1098, align 8
	%1140 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1094 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1139, %runtime.Type_Info_Struct* %1140
	%1141 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1094, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1141
	%1142 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 38
	%1143 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1142, i64 0, i32 3
	%1144 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1142, i64 0, i32 0
	store i64 16, i64* %1144
	%1145 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1142, i64 0, i32 1
	store i64 8, i64* %1145
	%1146 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1142, i64 0, i32 2
	store %..typeid 3386706919782613030, %..typeid* %1146
	; Type_Info_Named
	%1147 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1143 to %runtime.Type_Info_Named*
	%1148 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 39
	%1149 = bitcast %runtime.Type_Info* %1148 to %runtime.Type_Info*
	%1150 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1147, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$75a, i64 0, i32 0), i64 23}, %..string* %1150
	%1151 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1147, i64 0, i32 1
	store %runtime.Type_Info* %1149, %runtime.Type_Info** %1151
	%1152 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1147, align 8
	%1153 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1143 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1152, %runtime.Type_Info_Named* %1153
	%1154 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1143, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1154
	%1155 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 39
	%1156 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1155, i64 0, i32 3
	%1157 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1155, i64 0, i32 0
	store i64 16, i64* %1157
	%1158 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1155, i64 0, i32 1
	store i64 8, i64* %1158
	%1159 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1155, i64 0, i32 2
	store %..typeid 1080863910568919079, %..typeid* %1159
	; Type_Info_Struct
	%1160 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1156 to %runtime.Type_Info_Struct*
	%1161 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1160, i64 0, i32 4
	store i8 0, i8* %1161
	%1162 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1160, i64 0, i32 5
	store i8 0, i8* %1162
	%1163 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1160, i64 0, i32 6
	store i8 0, i8* %1163
	%1164 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 37
	%1165 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 16
	%1166 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 16
	%1167 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 16
	%1168 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%1169 = bitcast %runtime.Type_Info* %1168 to %runtime.Type_Info*
	%1170 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1164, i64 0
	%1171 = getelementptr inbounds i64, i64* %1166, i64 0
	%1172 = getelementptr inbounds i8, i8* %1167, i64 0
	%1173 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	store %runtime.Type_Info* %1173, %runtime.Type_Info** %1170
	%1174 = getelementptr inbounds %..string, %..string* %1165, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$75b, i64 0, i32 0), i64 4}, %..string* %1174
	store i64 0, i64* %1171
	store i8 0, i8* %1172
	%1175 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%1176 = bitcast %runtime.Type_Info* %1175 to %runtime.Type_Info*
	%1177 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1164, i64 1
	%1178 = getelementptr inbounds i64, i64* %1166, i64 1
	%1179 = getelementptr inbounds i8, i8* %1167, i64 1
	%1180 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %1180, %runtime.Type_Info** %1177
	%1181 = getelementptr inbounds %..string, %..string* %1165, i64 1
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$75c, i64 0, i32 0), i64 9}, %..string* %1181
	store i64 8, i64* %1178
	store i8 0, i8* %1179
	%1182 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1160, i64 0, i32 0
	%1183 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1182, i64 0, i32 0
	store %runtime.Type_Info** %1164, %runtime.Type_Info*** %1183
	%1184 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1182, i64 0, i32 1
	store i64 2, i64* %1184
	%1185 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1160, i64 0, i32 1
	%1186 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1185, i64 0, i32 0
	store %..string* %1165, %..string** %1186
	%1187 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1185, i64 0, i32 1
	store i64 2, i64* %1187
	%1188 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1160, i64 0, i32 2
	%1189 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1188, i64 0, i32 0
	store i64* %1166, i64** %1189
	%1190 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1188, i64 0, i32 1
	store i64 2, i64* %1190
	%1191 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1160, i64 0, i32 3
	%1192 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1191, i64 0, i32 0
	store i8* %1167, i8** %1192
	%1193 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1191, i64 0, i32 1
	store i64 2, i64* %1193
	%1194 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1160, align 8
	%1195 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1156 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1194, %runtime.Type_Info_Struct* %1195
	%1196 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1156, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1196
	%1197 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 40
	%1198 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1197, i64 0, i32 3
	%1199 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1197, i64 0, i32 0
	store i64 16, i64* %1199
	%1200 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1197, i64 0, i32 1
	store i64 8, i64* %1200
	%1201 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1197, i64 0, i32 2
	store %..typeid 3386706919782613032, %..typeid* %1201
	; Type_Info_Named
	%1202 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1198 to %runtime.Type_Info_Named*
	%1203 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 39
	%1204 = bitcast %runtime.Type_Info* %1203 to %runtime.Type_Info*
	%1205 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1202, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$75d, i64 0, i32 0), i64 15}, %..string* %1205
	%1206 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1202, i64 0, i32 1
	store %runtime.Type_Info* %1204, %runtime.Type_Info** %1206
	%1207 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1202, align 8
	%1208 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1198 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1207, %runtime.Type_Info_Named* %1208
	%1209 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1198, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1209
	%1210 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 41
	%1211 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1210, i64 0, i32 3
	%1212 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1210, i64 0, i32 0
	store i64 32, i64* %1212
	%1213 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1210, i64 0, i32 1
	store i64 8, i64* %1213
	%1214 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1210, i64 0, i32 2
	store %..typeid 3386706919782613033, %..typeid* %1214
	; Type_Info_Named
	%1215 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1211 to %runtime.Type_Info_Named*
	%1216 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 42
	%1217 = bitcast %runtime.Type_Info* %1216 to %runtime.Type_Info*
	%1218 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1215, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$75e, i64 0, i32 0), i64 15}, %..string* %1218
	%1219 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1215, i64 0, i32 1
	store %runtime.Type_Info* %1217, %runtime.Type_Info** %1219
	%1220 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1215, align 8
	%1221 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1211 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1220, %runtime.Type_Info_Named* %1221
	%1222 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1211, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1222
	%1223 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 42
	%1224 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1223, i64 0, i32 3
	%1225 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1223, i64 0, i32 0
	store i64 32, i64* %1225
	%1226 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1223, i64 0, i32 1
	store i64 8, i64* %1226
	%1227 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1223, i64 0, i32 2
	store %..typeid 1080863910568919082, %..typeid* %1227
	; Type_Info_Struct
	%1228 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1224 to %runtime.Type_Info_Struct*
	%1229 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1228, i64 0, i32 4
	store i8 0, i8* %1229
	%1230 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1228, i64 0, i32 5
	store i8 0, i8* %1230
	%1231 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1228, i64 0, i32 6
	store i8 0, i8* %1231
	%1232 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 39
	%1233 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 18
	%1234 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 18
	%1235 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 18
	%1236 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 43
	%1237 = bitcast %runtime.Type_Info* %1236 to %runtime.Type_Info*
	%1238 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1232, i64 0
	%1239 = getelementptr inbounds i64, i64* %1234, i64 0
	%1240 = getelementptr inbounds i8, i8* %1235, i64 0
	%1241 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 43
	store %runtime.Type_Info* %1241, %runtime.Type_Info** %1238
	%1242 = getelementptr inbounds %..string, %..string* %1233, i64 0
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$75f, i64 0, i32 0), i64 5}, %..string* %1242
	store i64 0, i64* %1239
	store i8 0, i8* %1240
	%1243 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 45
	%1244 = bitcast %runtime.Type_Info* %1243 to %runtime.Type_Info*
	%1245 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1232, i64 1
	%1246 = getelementptr inbounds i64, i64* %1234, i64 1
	%1247 = getelementptr inbounds i8, i8* %1235, i64 1
	%1248 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 45
	store %runtime.Type_Info* %1248, %runtime.Type_Info** %1245
	%1249 = getelementptr inbounds %..string, %..string* %1233, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$760, i64 0, i32 0), i64 5}, %..string* %1249
	store i64 16, i64* %1246
	store i8 0, i8* %1247
	%1250 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1228, i64 0, i32 0
	%1251 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1250, i64 0, i32 0
	store %runtime.Type_Info** %1232, %runtime.Type_Info*** %1251
	%1252 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1250, i64 0, i32 1
	store i64 2, i64* %1252
	%1253 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1228, i64 0, i32 1
	%1254 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1253, i64 0, i32 0
	store %..string* %1233, %..string** %1254
	%1255 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1253, i64 0, i32 1
	store i64 2, i64* %1255
	%1256 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1228, i64 0, i32 2
	%1257 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1256, i64 0, i32 0
	store i64* %1234, i64** %1257
	%1258 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1256, i64 0, i32 1
	store i64 2, i64* %1258
	%1259 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1228, i64 0, i32 3
	%1260 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1259, i64 0, i32 0
	store i8* %1235, i8** %1260
	%1261 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1259, i64 0, i32 1
	store i64 2, i64* %1261
	%1262 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1228, align 8
	%1263 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1224 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1262, %runtime.Type_Info_Struct* %1263
	%1264 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1224, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1264
	%1265 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 43
	%1266 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1265, i64 0, i32 3
	%1267 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1265, i64 0, i32 0
	store i64 16, i64* %1267
	%1268 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1265, i64 0, i32 1
	store i64 8, i64* %1268
	%1269 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1265, i64 0, i32 2
	store %..typeid 936748722493063211, %..typeid* %1269
	; Type_Info_Slice
	%1270 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1266 to %runtime.Type_Info_Slice*
	%1271 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%1272 = bitcast %runtime.Type_Info* %1271 to %runtime.Type_Info*
	%1273 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1270, i64 0, i32 0
	store %runtime.Type_Info* %1272, %runtime.Type_Info** %1273
	%1274 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1270, i64 0, i32 1
	store i64 8, i64* %1274
	%1275 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1270, align 8
	%1276 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1266 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1275, %runtime.Type_Info_Slice* %1276
	%1277 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1266, i64 0, i32 2 ; UnionTagPtr
	store i8 14, i8* %1277
	%1278 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 44
	%1279 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1278, i64 0, i32 3
	%1280 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1278, i64 0, i32 0
	store i64 8, i64* %1280
	%1281 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1278, i64 0, i32 1
	store i64 8, i64* %1281
	%1282 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1278, i64 0, i32 2
	store %..typeid 648518346341351468, %..typeid* %1282
	; Type_Info_Pointer
	%1283 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1279 to %runtime.Type_Info_Pointer*
	%1284 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%1285 = bitcast %runtime.Type_Info* %1284 to %runtime.Type_Info*
	%1286 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1283, i64 0, i32 0
	store %runtime.Type_Info* %1285, %runtime.Type_Info** %1286
	%1287 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1283, align 8
	%1288 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1279 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1287, %runtime.Type_Info_Pointer* %1288
	%1289 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1279, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %1289
	%1290 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 45
	%1291 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1290, i64 0, i32 3
	%1292 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1290, i64 0, i32 0
	store i64 16, i64* %1292
	%1293 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1290, i64 0, i32 1
	store i64 8, i64* %1293
	%1294 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1290, i64 0, i32 2
	store %..typeid 936748722493063213, %..typeid* %1294
	; Type_Info_Slice
	%1295 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1291 to %runtime.Type_Info_Slice*
	%1296 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%1297 = bitcast %runtime.Type_Info* %1296 to %runtime.Type_Info*
	%1298 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1295, i64 0, i32 0
	store %runtime.Type_Info* %1297, %runtime.Type_Info** %1298
	%1299 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1295, i64 0, i32 1
	store i64 16, i64* %1299
	%1300 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1295, align 8
	%1301 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1291 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1300, %runtime.Type_Info_Slice* %1301
	%1302 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1291, i64 0, i32 2 ; UnionTagPtr
	store i8 14, i8* %1302
	%1303 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 46
	%1304 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1303, i64 0, i32 3
	%1305 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1303, i64 0, i32 0
	store i64 8, i64* %1305
	%1306 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1303, i64 0, i32 1
	store i64 8, i64* %1306
	%1307 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1303, i64 0, i32 2
	store %..typeid 648518346341351470, %..typeid* %1307
	; Type_Info_Pointer
	%1308 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1304 to %runtime.Type_Info_Pointer*
	%1309 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%1310 = bitcast %runtime.Type_Info* %1309 to %runtime.Type_Info*
	%1311 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1308, i64 0, i32 0
	store %runtime.Type_Info* %1310, %runtime.Type_Info** %1311
	%1312 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1308, align 8
	%1313 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1304 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1312, %runtime.Type_Info_Pointer* %1313
	%1314 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1304, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %1314
	%1315 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 47
	%1316 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1315, i64 0, i32 3
	%1317 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1315, i64 0, i32 0
	store i64 72, i64* %1317
	%1318 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1315, i64 0, i32 1
	store i64 8, i64* %1318
	%1319 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1315, i64 0, i32 2
	store %..typeid 3386706919782613039, %..typeid* %1319
	; Type_Info_Named
	%1320 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1316 to %runtime.Type_Info_Named*
	%1321 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 48
	%1322 = bitcast %runtime.Type_Info* %1321 to %runtime.Type_Info*
	%1323 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1320, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$761, i64 0, i32 0), i64 16}, %..string* %1323
	%1324 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1320, i64 0, i32 1
	store %runtime.Type_Info* %1322, %runtime.Type_Info** %1324
	%1325 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1320, align 8
	%1326 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1316 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1325, %runtime.Type_Info_Named* %1326
	%1327 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1316, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1327
	%1328 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 48
	%1329 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1328, i64 0, i32 3
	%1330 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1328, i64 0, i32 0
	store i64 72, i64* %1330
	%1331 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1328, i64 0, i32 1
	store i64 8, i64* %1331
	%1332 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1328, i64 0, i32 2
	store %..typeid 1080863910568919088, %..typeid* %1332
	; Type_Info_Struct
	%1333 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1329 to %runtime.Type_Info_Struct*
	%1334 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1333, i64 0, i32 4
	store i8 0, i8* %1334
	%1335 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1333, i64 0, i32 5
	store i8 0, i8* %1335
	%1336 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1333, i64 0, i32 6
	store i8 0, i8* %1336
	%1337 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 41
	%1338 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 20
	%1339 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 20
	%1340 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 20
	%1341 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 43
	%1342 = bitcast %runtime.Type_Info* %1341 to %runtime.Type_Info*
	%1343 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1337, i64 0
	%1344 = getelementptr inbounds i64, i64* %1339, i64 0
	%1345 = getelementptr inbounds i8, i8* %1340, i64 0
	%1346 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 43
	store %runtime.Type_Info* %1346, %runtime.Type_Info** %1343
	%1347 = getelementptr inbounds %..string, %..string* %1338, i64 0
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$762, i64 0, i32 0), i64 5}, %..string* %1347
	store i64 0, i64* %1344
	store i8 0, i8* %1345
	%1348 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 45
	%1349 = bitcast %runtime.Type_Info* %1348 to %runtime.Type_Info*
	%1350 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1337, i64 1
	%1351 = getelementptr inbounds i64, i64* %1339, i64 1
	%1352 = getelementptr inbounds i8, i8* %1340, i64 1
	%1353 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 45
	store %runtime.Type_Info* %1353, %runtime.Type_Info** %1350
	%1354 = getelementptr inbounds %..string, %..string* %1338, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$763, i64 0, i32 0), i64 5}, %..string* %1354
	store i64 16, i64* %1351
	store i8 0, i8* %1352
	%1355 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 49
	%1356 = bitcast %runtime.Type_Info* %1355 to %runtime.Type_Info*
	%1357 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1337, i64 2
	%1358 = getelementptr inbounds i64, i64* %1339, i64 2
	%1359 = getelementptr inbounds i8, i8* %1340, i64 2
	%1360 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 49
	store %runtime.Type_Info* %1360, %runtime.Type_Info** %1357
	%1361 = getelementptr inbounds %..string, %..string* %1338, i64 2
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$764, i64 0, i32 0), i64 7}, %..string* %1361
	store i64 32, i64* %1358
	store i8 0, i8* %1359
	%1362 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 52
	%1363 = bitcast %runtime.Type_Info* %1362 to %runtime.Type_Info*
	%1364 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1337, i64 3
	%1365 = getelementptr inbounds i64, i64* %1339, i64 3
	%1366 = getelementptr inbounds i8, i8* %1340, i64 3
	%1367 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 52
	store %runtime.Type_Info* %1367, %runtime.Type_Info** %1364
	%1368 = getelementptr inbounds %..string, %..string* %1338, i64 3
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$765, i64 0, i32 0), i64 6}, %..string* %1368
	store i64 48, i64* %1365
	store i8 0, i8* %1366
	%1369 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	%1370 = bitcast %runtime.Type_Info* %1369 to %runtime.Type_Info*
	%1371 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1337, i64 4
	%1372 = getelementptr inbounds i64, i64* %1339, i64 4
	%1373 = getelementptr inbounds i8, i8* %1340, i64 4
	%1374 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	store %runtime.Type_Info* %1374, %runtime.Type_Info** %1371
	%1375 = getelementptr inbounds %..string, %..string* %1338, i64 4
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$766, i64 0, i32 0), i64 9}, %..string* %1375
	store i64 64, i64* %1372
	store i8 0, i8* %1373
	%1376 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	%1377 = bitcast %runtime.Type_Info* %1376 to %runtime.Type_Info*
	%1378 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1337, i64 5
	%1379 = getelementptr inbounds i64, i64* %1339, i64 5
	%1380 = getelementptr inbounds i8, i8* %1340, i64 5
	%1381 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	store %runtime.Type_Info* %1381, %runtime.Type_Info** %1378
	%1382 = getelementptr inbounds %..string, %..string* %1338, i64 5
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$767, i64 0, i32 0), i64 12}, %..string* %1382
	store i64 65, i64* %1379
	store i8 0, i8* %1380
	%1383 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	%1384 = bitcast %runtime.Type_Info* %1383 to %runtime.Type_Info*
	%1385 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1337, i64 6
	%1386 = getelementptr inbounds i64, i64* %1339, i64 6
	%1387 = getelementptr inbounds i8, i8* %1340, i64 6
	%1388 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	store %runtime.Type_Info* %1388, %runtime.Type_Info** %1385
	%1389 = getelementptr inbounds %..string, %..string* %1338, i64 6
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$768, i64 0, i32 0), i64 12}, %..string* %1389
	store i64 66, i64* %1386
	store i8 0, i8* %1387
	%1390 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1333, i64 0, i32 0
	%1391 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1390, i64 0, i32 0
	store %runtime.Type_Info** %1337, %runtime.Type_Info*** %1391
	%1392 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1390, i64 0, i32 1
	store i64 7, i64* %1392
	%1393 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1333, i64 0, i32 1
	%1394 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1393, i64 0, i32 0
	store %..string* %1338, %..string** %1394
	%1395 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1393, i64 0, i32 1
	store i64 7, i64* %1395
	%1396 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1333, i64 0, i32 2
	%1397 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1396, i64 0, i32 0
	store i64* %1339, i64** %1397
	%1398 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1396, i64 0, i32 1
	store i64 7, i64* %1398
	%1399 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1333, i64 0, i32 3
	%1400 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1399, i64 0, i32 0
	store i8* %1340, i8** %1400
	%1401 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1399, i64 0, i32 1
	store i64 7, i64* %1401
	%1402 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1333, align 8
	%1403 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1329 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1402, %runtime.Type_Info_Struct* %1403
	%1404 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1329, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1404
	%1405 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 49
	%1406 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1405, i64 0, i32 3
	%1407 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1405, i64 0, i32 0
	store i64 16, i64* %1407
	%1408 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1405, i64 0, i32 1
	store i64 8, i64* %1408
	%1409 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1405, i64 0, i32 2
	store %..typeid 936748722493063217, %..typeid* %1409
	; Type_Info_Slice
	%1410 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1406 to %runtime.Type_Info_Slice*
	%1411 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 50
	%1412 = bitcast %runtime.Type_Info* %1411 to %runtime.Type_Info*
	%1413 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1410, i64 0, i32 0
	store %runtime.Type_Info* %1412, %runtime.Type_Info** %1413
	%1414 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1410, i64 0, i32 1
	store i64 8, i64* %1414
	%1415 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1410, align 8
	%1416 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1406 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1415, %runtime.Type_Info_Slice* %1416
	%1417 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1406, i64 0, i32 2 ; UnionTagPtr
	store i8 14, i8* %1417
	%1418 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 50
	%1419 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1418, i64 0, i32 3
	%1420 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1418, i64 0, i32 0
	store i64 8, i64* %1420
	%1421 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1418, i64 0, i32 1
	store i64 8, i64* %1421
	%1422 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1418, i64 0, i32 2
	store %..typeid 72057594037927986, %..typeid* %1422
	; Type_Info_Basic
	%1423 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1419 to %runtime.Type_Info_Integer*
	%1424 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1423, i64 0, i32 0
	store i8 0, i8* %1424
	%1425 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1423, align 1
	%1426 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1419 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1425, %runtime.Type_Info_Integer* %1426
	%1427 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1419, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1427
	%1428 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 51
	%1429 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1428, i64 0, i32 3
	%1430 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1428, i64 0, i32 0
	store i64 8, i64* %1430
	%1431 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1428, i64 0, i32 1
	store i64 8, i64* %1431
	%1432 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1428, i64 0, i32 2
	store %..typeid 648518346341351475, %..typeid* %1432
	; Type_Info_Pointer
	%1433 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1429 to %runtime.Type_Info_Pointer*
	%1434 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 50
	%1435 = bitcast %runtime.Type_Info* %1434 to %runtime.Type_Info*
	%1436 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1433, i64 0, i32 0
	store %runtime.Type_Info* %1435, %runtime.Type_Info** %1436
	%1437 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1433, align 8
	%1438 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1429 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1437, %runtime.Type_Info_Pointer* %1438
	%1439 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1429, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %1439
	%1440 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 52
	%1441 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1440, i64 0, i32 3
	%1442 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1440, i64 0, i32 0
	store i64 16, i64* %1442
	%1443 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1440, i64 0, i32 1
	store i64 8, i64* %1443
	%1444 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1440, i64 0, i32 2
	store %..typeid 936748722493063220, %..typeid* %1444
	; Type_Info_Slice
	%1445 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1441 to %runtime.Type_Info_Slice*
	%1446 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	%1447 = bitcast %runtime.Type_Info* %1446 to %runtime.Type_Info*
	%1448 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1445, i64 0, i32 0
	store %runtime.Type_Info* %1447, %runtime.Type_Info** %1448
	%1449 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1445, i64 0, i32 1
	store i64 1, i64* %1449
	%1450 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1445, align 8
	%1451 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1441 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1450, %runtime.Type_Info_Slice* %1451
	%1452 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1441, i64 0, i32 2 ; UnionTagPtr
	store i8 14, i8* %1452
	%1453 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 53
	%1454 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1453, i64 0, i32 3
	%1455 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1453, i64 0, i32 0
	store i64 8, i64* %1455
	%1456 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1453, i64 0, i32 1
	store i64 8, i64* %1456
	%1457 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1453, i64 0, i32 2
	store %..typeid 648518346341351477, %..typeid* %1457
	; Type_Info_Pointer
	%1458 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1454 to %runtime.Type_Info_Pointer*
	%1459 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	%1460 = bitcast %runtime.Type_Info* %1459 to %runtime.Type_Info*
	%1461 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1458, i64 0, i32 0
	store %runtime.Type_Info* %1460, %runtime.Type_Info** %1461
	%1462 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1458, align 8
	%1463 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1454 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1462, %runtime.Type_Info_Pointer* %1463
	%1464 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1454, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %1464
	%1465 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 54
	%1466 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1465, i64 0, i32 3
	%1467 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1465, i64 0, i32 0
	store i64 40, i64* %1467
	%1468 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1465, i64 0, i32 1
	store i64 8, i64* %1468
	%1469 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1465, i64 0, i32 2
	store %..typeid 3386706919782613046, %..typeid* %1469
	; Type_Info_Named
	%1470 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1466 to %runtime.Type_Info_Named*
	%1471 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 55
	%1472 = bitcast %runtime.Type_Info* %1471 to %runtime.Type_Info*
	%1473 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1470, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$769, i64 0, i32 0), i64 15}, %..string* %1473
	%1474 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1470, i64 0, i32 1
	store %runtime.Type_Info* %1472, %runtime.Type_Info** %1474
	%1475 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1470, align 8
	%1476 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1466 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1475, %runtime.Type_Info_Named* %1476
	%1477 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1466, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1477
	%1478 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 55
	%1479 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1478, i64 0, i32 3
	%1480 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1478, i64 0, i32 0
	store i64 40, i64* %1480
	%1481 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1478, i64 0, i32 1
	store i64 8, i64* %1481
	%1482 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1478, i64 0, i32 2
	store %..typeid 1080863910568919095, %..typeid* %1482
	; Type_Info_Struct
	%1483 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1479 to %runtime.Type_Info_Struct*
	%1484 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1483, i64 0, i32 4
	store i8 0, i8* %1484
	%1485 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1483, i64 0, i32 5
	store i8 0, i8* %1485
	%1486 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1483, i64 0, i32 6
	store i8 0, i8* %1486
	%1487 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 48
	%1488 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 27
	%1489 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 27
	%1490 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 27
	%1491 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 43
	%1492 = bitcast %runtime.Type_Info* %1491 to %runtime.Type_Info*
	%1493 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1487, i64 0
	%1494 = getelementptr inbounds i64, i64* %1489, i64 0
	%1495 = getelementptr inbounds i8, i8* %1490, i64 0
	%1496 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 43
	store %runtime.Type_Info* %1496, %runtime.Type_Info** %1493
	%1497 = getelementptr inbounds %..string, %..string* %1488, i64 0
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$76a, i64 0, i32 0), i64 8}, %..string* %1497
	store i64 0, i64* %1494
	store i8 0, i8* %1495
	%1498 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 50
	%1499 = bitcast %runtime.Type_Info* %1498 to %runtime.Type_Info*
	%1500 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1487, i64 1
	%1501 = getelementptr inbounds i64, i64* %1489, i64 1
	%1502 = getelementptr inbounds i8, i8* %1490, i64 1
	%1503 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 50
	store %runtime.Type_Info* %1503, %runtime.Type_Info** %1500
	%1504 = getelementptr inbounds %..string, %..string* %1488, i64 1
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$76b, i64 0, i32 0), i64 10}, %..string* %1504
	store i64 16, i64* %1501
	store i8 0, i8* %1502
	%1505 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%1506 = bitcast %runtime.Type_Info* %1505 to %runtime.Type_Info*
	%1507 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1487, i64 2
	%1508 = getelementptr inbounds i64, i64* %1489, i64 2
	%1509 = getelementptr inbounds i8, i8* %1490, i64 2
	%1510 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	store %runtime.Type_Info* %1510, %runtime.Type_Info** %1507
	%1511 = getelementptr inbounds %..string, %..string* %1488, i64 2
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$76c, i64 0, i32 0), i64 8}, %..string* %1511
	store i64 24, i64* %1508
	store i8 0, i8* %1509
	%1512 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	%1513 = bitcast %runtime.Type_Info* %1512 to %runtime.Type_Info*
	%1514 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1487, i64 3
	%1515 = getelementptr inbounds i64, i64* %1489, i64 3
	%1516 = getelementptr inbounds i8, i8* %1490, i64 3
	%1517 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	store %runtime.Type_Info* %1517, %runtime.Type_Info** %1514
	%1518 = getelementptr inbounds %..string, %..string* %1488, i64 3
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$76d, i64 0, i32 0), i64 12}, %..string* %1518
	store i64 32, i64* %1515
	store i8 0, i8* %1516
	%1519 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1483, i64 0, i32 0
	%1520 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1519, i64 0, i32 0
	store %runtime.Type_Info** %1487, %runtime.Type_Info*** %1520
	%1521 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1519, i64 0, i32 1
	store i64 4, i64* %1521
	%1522 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1483, i64 0, i32 1
	%1523 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1522, i64 0, i32 0
	store %..string* %1488, %..string** %1523
	%1524 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1522, i64 0, i32 1
	store i64 4, i64* %1524
	%1525 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1483, i64 0, i32 2
	%1526 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1525, i64 0, i32 0
	store i64* %1489, i64** %1526
	%1527 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1525, i64 0, i32 1
	store i64 4, i64* %1527
	%1528 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1483, i64 0, i32 3
	%1529 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1528, i64 0, i32 0
	store i8* %1490, i8** %1529
	%1530 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1528, i64 0, i32 1
	store i64 4, i64* %1530
	%1531 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1483, align 8
	%1532 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1479 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1531, %runtime.Type_Info_Struct* %1532
	%1533 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1479, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1533
	%1534 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 56
	%1535 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1534, i64 0, i32 3
	%1536 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1534, i64 0, i32 0
	store i64 40, i64* %1536
	%1537 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1534, i64 0, i32 1
	store i64 8, i64* %1537
	%1538 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1534, i64 0, i32 2
	store %..typeid 3386706919782613048, %..typeid* %1538
	; Type_Info_Named
	%1539 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1535 to %runtime.Type_Info_Named*
	%1540 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 57
	%1541 = bitcast %runtime.Type_Info* %1540 to %runtime.Type_Info*
	%1542 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1539, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$76e, i64 0, i32 0), i64 14}, %..string* %1542
	%1543 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1539, i64 0, i32 1
	store %runtime.Type_Info* %1541, %runtime.Type_Info** %1543
	%1544 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1539, align 8
	%1545 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1535 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1544, %runtime.Type_Info_Named* %1545
	%1546 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1535, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1546
	%1547 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 57
	%1548 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1547, i64 0, i32 3
	%1549 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1547, i64 0, i32 0
	store i64 40, i64* %1549
	%1550 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1547, i64 0, i32 1
	store i64 8, i64* %1550
	%1551 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1547, i64 0, i32 2
	store %..typeid 1080863910568919097, %..typeid* %1551
	; Type_Info_Struct
	%1552 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1548 to %runtime.Type_Info_Struct*
	%1553 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1552, i64 0, i32 4
	store i8 0, i8* %1553
	%1554 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1552, i64 0, i32 5
	store i8 0, i8* %1554
	%1555 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1552, i64 0, i32 6
	store i8 0, i8* %1555
	%1556 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 52
	%1557 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 31
	%1558 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 31
	%1559 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 31
	%1560 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%1561 = bitcast %runtime.Type_Info* %1560 to %runtime.Type_Info*
	%1562 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1556, i64 0
	%1563 = getelementptr inbounds i64, i64* %1558, i64 0
	%1564 = getelementptr inbounds i8, i8* %1559, i64 0
	%1565 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	store %runtime.Type_Info* %1565, %runtime.Type_Info** %1562
	%1566 = getelementptr inbounds %..string, %..string* %1557, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$76f, i64 0, i32 0), i64 4}, %..string* %1566
	store i64 0, i64* %1563
	store i8 0, i8* %1564
	%1567 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 45
	%1568 = bitcast %runtime.Type_Info* %1567 to %runtime.Type_Info*
	%1569 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1556, i64 1
	%1570 = getelementptr inbounds i64, i64* %1558, i64 1
	%1571 = getelementptr inbounds i8, i8* %1559, i64 1
	%1572 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 45
	store %runtime.Type_Info* %1572, %runtime.Type_Info** %1569
	%1573 = getelementptr inbounds %..string, %..string* %1557, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$770, i64 0, i32 0), i64 5}, %..string* %1573
	store i64 8, i64* %1570
	store i8 0, i8* %1571
	%1574 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 58
	%1575 = bitcast %runtime.Type_Info* %1574 to %runtime.Type_Info*
	%1576 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1556, i64 2
	%1577 = getelementptr inbounds i64, i64* %1558, i64 2
	%1578 = getelementptr inbounds i8, i8* %1559, i64 2
	%1579 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 58
	store %runtime.Type_Info* %1579, %runtime.Type_Info** %1576
	%1580 = getelementptr inbounds %..string, %..string* %1557, i64 2
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$771, i64 0, i32 0), i64 6}, %..string* %1580
	store i64 24, i64* %1577
	store i8 0, i8* %1578
	%1581 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1552, i64 0, i32 0
	%1582 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1581, i64 0, i32 0
	store %runtime.Type_Info** %1556, %runtime.Type_Info*** %1582
	%1583 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1581, i64 0, i32 1
	store i64 3, i64* %1583
	%1584 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1552, i64 0, i32 1
	%1585 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1584, i64 0, i32 0
	store %..string* %1557, %..string** %1585
	%1586 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1584, i64 0, i32 1
	store i64 3, i64* %1586
	%1587 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1552, i64 0, i32 2
	%1588 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1587, i64 0, i32 0
	store i64* %1558, i64** %1588
	%1589 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1587, i64 0, i32 1
	store i64 3, i64* %1589
	%1590 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1552, i64 0, i32 3
	%1591 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1590, i64 0, i32 0
	store i8* %1559, i8** %1591
	%1592 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1590, i64 0, i32 1
	store i64 3, i64* %1592
	%1593 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1552, align 8
	%1594 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1548 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1593, %runtime.Type_Info_Struct* %1594
	%1595 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1548, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1595
	%1596 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 58
	%1597 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1596, i64 0, i32 3
	%1598 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1596, i64 0, i32 0
	store i64 16, i64* %1598
	%1599 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1596, i64 0, i32 1
	store i64 8, i64* %1599
	%1600 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1596, i64 0, i32 2
	store %..typeid 936748722493063226, %..typeid* %1600
	; Type_Info_Slice
	%1601 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1597 to %runtime.Type_Info_Slice*
	%1602 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 59
	%1603 = bitcast %runtime.Type_Info* %1602 to %runtime.Type_Info*
	%1604 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1601, i64 0, i32 0
	store %runtime.Type_Info* %1603, %runtime.Type_Info** %1604
	%1605 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1601, i64 0, i32 1
	store i64 16, i64* %1605
	%1606 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1601, align 8
	%1607 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1597 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1606, %runtime.Type_Info_Slice* %1607
	%1608 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1597, i64 0, i32 2 ; UnionTagPtr
	store i8 14, i8* %1608
	%1609 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 59
	%1610 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1609, i64 0, i32 3
	%1611 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1609, i64 0, i32 0
	store i64 16, i64* %1611
	%1612 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1609, i64 0, i32 1
	store i64 8, i64* %1612
	%1613 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1609, i64 0, i32 2
	store %..typeid 3458764513820540987, %..typeid* %1613
	; Type_Info_Named
	%1614 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1610 to %runtime.Type_Info_Named*
	%1615 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 60
	%1616 = bitcast %runtime.Type_Info* %1615 to %runtime.Type_Info*
	%1617 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1614, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$772, i64 0, i32 0), i64 20}, %..string* %1617
	%1618 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1614, i64 0, i32 1
	store %runtime.Type_Info* %1616, %runtime.Type_Info** %1618
	%1619 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1614, align 8
	%1620 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1610 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1619, %runtime.Type_Info_Named* %1620
	%1621 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1610, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1621
	%1622 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 60
	%1623 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1622, i64 0, i32 3
	%1624 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1622, i64 0, i32 0
	store i64 16, i64* %1624
	%1625 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1622, i64 0, i32 1
	store i64 8, i64* %1625
	%1626 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1622, i64 0, i32 2
	store %..typeid 1152921504606847036, %..typeid* %1626
	; Type_Info_Union
	%1627 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1623 to %runtime.Type_Info_Union*
	%1628 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1627, i64 0, i32 0
	%1629 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1627, i64 0, i32 1
	%1630 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1627, i64 0, i32 2
	%1631 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1627, i64 0, i32 3
	%1632 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 55
	%1633 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 61
	%1634 = bitcast %runtime.Type_Info* %1633 to %runtime.Type_Info*
	%1635 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1632, i64 0
	%1636 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 61
	store %runtime.Type_Info* %1636, %runtime.Type_Info** %1635
	%1637 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 62
	%1638 = bitcast %runtime.Type_Info* %1637 to %runtime.Type_Info*
	%1639 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1632, i64 1
	%1640 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 62
	store %runtime.Type_Info* %1640, %runtime.Type_Info** %1639
	%1641 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 63
	%1642 = bitcast %runtime.Type_Info* %1641 to %runtime.Type_Info*
	%1643 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1632, i64 2
	%1644 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 63
	store %runtime.Type_Info* %1644, %runtime.Type_Info** %1643
	%1645 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%1646 = bitcast %runtime.Type_Info* %1645 to %runtime.Type_Info*
	%1647 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1632, i64 3
	%1648 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	store %runtime.Type_Info* %1648, %runtime.Type_Info** %1647
	%1649 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 64
	%1650 = bitcast %runtime.Type_Info* %1649 to %runtime.Type_Info*
	%1651 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1632, i64 4
	%1652 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 64
	store %runtime.Type_Info* %1652, %runtime.Type_Info** %1651
	%1653 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%1654 = bitcast %runtime.Type_Info* %1653 to %runtime.Type_Info*
	%1655 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1632, i64 5
	%1656 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %1656, %runtime.Type_Info** %1655
	%1657 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	%1658 = bitcast %runtime.Type_Info* %1657 to %runtime.Type_Info*
	%1659 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1632, i64 6
	%1660 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	store %runtime.Type_Info* %1660, %runtime.Type_Info** %1659
	%1661 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 65
	%1662 = bitcast %runtime.Type_Info* %1661 to %runtime.Type_Info*
	%1663 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1632, i64 7
	%1664 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 65
	store %runtime.Type_Info* %1664, %runtime.Type_Info** %1663
	%1665 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 66
	%1666 = bitcast %runtime.Type_Info* %1665 to %runtime.Type_Info*
	%1667 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1632, i64 8
	%1668 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 66
	store %runtime.Type_Info* %1668, %runtime.Type_Info** %1667
	%1669 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 7
	%1670 = bitcast %runtime.Type_Info* %1669 to %runtime.Type_Info*
	%1671 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1632, i64 9
	%1672 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 7
	store %runtime.Type_Info* %1672, %runtime.Type_Info** %1671
	%1673 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 67
	%1674 = bitcast %runtime.Type_Info* %1673 to %runtime.Type_Info*
	%1675 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1632, i64 10
	%1676 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 67
	store %runtime.Type_Info* %1676, %runtime.Type_Info** %1675
	%1677 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 50
	%1678 = bitcast %runtime.Type_Info* %1677 to %runtime.Type_Info*
	%1679 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1632, i64 11
	%1680 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 50
	store %runtime.Type_Info* %1680, %runtime.Type_Info** %1679
	%1681 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1628, i64 0, i32 0
	store %runtime.Type_Info** %1632, %runtime.Type_Info*** %1681
	%1682 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1628, i64 0, i32 1
	store i64 12, i64* %1682
	store i64 8, i64* %1629
	%1683 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	store %runtime.Type_Info* %1683, %runtime.Type_Info** %1630
	store i8 0, i8* %1631
	%1684 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1627, align 8
	%1685 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1623 to %runtime.Type_Info_Union*
	store %runtime.Type_Info_Union %1684, %runtime.Type_Info_Union* %1685
	%1686 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1623, i64 0, i32 2 ; UnionTagPtr
	store i8 17, i8* %1686
	%1687 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 61
	%1688 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1687, i64 0, i32 3
	%1689 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1687, i64 0, i32 0
	store i64 4, i64* %1689
	%1690 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1687, i64 0, i32 1
	store i64 4, i64* %1690
	%1691 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1687, i64 0, i32 2
	store %..typeid 4755801206503243837, %..typeid* %1691
	; Type_Info_Basic
	%1692 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1688 to %runtime.Type_Info_Rune*
	%1693 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %1692, align 1
	%1694 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1688 to %runtime.Type_Info_Rune*
	store %runtime.Type_Info_Rune %1693, %runtime.Type_Info_Rune* %1694
	%1695 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1688, i64 0, i32 2 ; UnionTagPtr
	store i8 3, i8* %1695
	%1696 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 62
	%1697 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1696, i64 0, i32 3
	%1698 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1696, i64 0, i32 0
	store i64 1, i64* %1698
	%1699 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1696, i64 0, i32 1
	store i64 1, i64* %1699
	%1700 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1696, i64 0, i32 2
	store %..typeid 4683743612465315902, %..typeid* %1700
	; Type_Info_Basic
	%1701 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1697 to %runtime.Type_Info_Integer*
	%1702 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1701, i64 0, i32 0
	store i8 1, i8* %1702
	%1703 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1701, align 1
	%1704 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1697 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1703, %runtime.Type_Info_Integer* %1704
	%1705 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1697, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1705
	%1706 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 63
	%1707 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1706, i64 0, i32 3
	%1708 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1706, i64 0, i32 0
	store i64 2, i64* %1708
	%1709 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1706, i64 0, i32 1
	store i64 2, i64* %1709
	%1710 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1706, i64 0, i32 2
	store %..typeid 4683743612465315903, %..typeid* %1710
	; Type_Info_Basic
	%1711 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1707 to %runtime.Type_Info_Integer*
	%1712 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1711, i64 0, i32 0
	store i8 1, i8* %1712
	%1713 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1711, align 1
	%1714 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1707 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1713, %runtime.Type_Info_Integer* %1714
	%1715 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1707, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1715
	%1716 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 64
	%1717 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1716, i64 0, i32 3
	%1718 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1716, i64 0, i32 0
	store i64 8, i64* %1718
	%1719 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1716, i64 0, i32 1
	store i64 8, i64* %1719
	%1720 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1716, i64 0, i32 2
	store %..typeid 4683743612465315904, %..typeid* %1720
	; Type_Info_Basic
	%1721 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1717 to %runtime.Type_Info_Integer*
	%1722 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1721, i64 0, i32 0
	store i8 1, i8* %1722
	%1723 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1721, align 1
	%1724 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1717 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1723, %runtime.Type_Info_Integer* %1724
	%1725 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1717, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1725
	%1726 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 65
	%1727 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1726, i64 0, i32 3
	%1728 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1726, i64 0, i32 0
	store i64 2, i64* %1728
	%1729 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1726, i64 0, i32 1
	store i64 2, i64* %1729
	%1730 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1726, i64 0, i32 2
	store %..typeid 72057594037928001, %..typeid* %1730
	; Type_Info_Basic
	%1731 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1727 to %runtime.Type_Info_Integer*
	%1732 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1731, i64 0, i32 0
	store i8 0, i8* %1732
	%1733 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1731, align 1
	%1734 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1727 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1733, %runtime.Type_Info_Integer* %1734
	%1735 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1727, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1735
	%1736 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 66
	%1737 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1736, i64 0, i32 3
	%1738 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1736, i64 0, i32 0
	store i64 4, i64* %1738
	%1739 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1736, i64 0, i32 1
	store i64 4, i64* %1739
	%1740 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1736, i64 0, i32 2
	store %..typeid 72057594037928002, %..typeid* %1740
	; Type_Info_Basic
	%1741 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1737 to %runtime.Type_Info_Integer*
	%1742 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1741, i64 0, i32 0
	store i8 0, i8* %1742
	%1743 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1741, align 1
	%1744 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1737 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1743, %runtime.Type_Info_Integer* %1744
	%1745 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1737, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1745
	%1746 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 7
	%1747 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1746, i64 0, i32 3
	%1748 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1746, i64 0, i32 0
	store i64 8, i64* %1748
	%1749 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1746, i64 0, i32 1
	store i64 8, i64* %1749
	%1750 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1746, i64 0, i32 2
	store %..typeid 72057594037927943, %..typeid* %1750
	; Type_Info_Basic
	%1751 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1747 to %runtime.Type_Info_Integer*
	%1752 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1751, i64 0, i32 0
	store i8 0, i8* %1752
	%1753 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1751, align 1
	%1754 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1747 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1753, %runtime.Type_Info_Integer* %1754
	%1755 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1747, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1755
	%1756 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 67
	%1757 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1756, i64 0, i32 3
	%1758 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1756, i64 0, i32 0
	store i64 8, i64* %1758
	%1759 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1756, i64 0, i32 1
	store i64 8, i64* %1759
	%1760 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1756, i64 0, i32 2
	store %..typeid 72057594037928003, %..typeid* %1760
	; Type_Info_Basic
	%1761 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1757 to %runtime.Type_Info_Integer*
	%1762 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1761, i64 0, i32 0
	store i8 0, i8* %1762
	%1763 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1761, align 1
	%1764 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1757 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1763, %runtime.Type_Info_Integer* %1764
	%1765 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1757, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1765
	%1766 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 68
	%1767 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1766, i64 0, i32 3
	%1768 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1766, i64 0, i32 0
	store i64 8, i64* %1768
	%1769 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1766, i64 0, i32 1
	store i64 8, i64* %1769
	%1770 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1766, i64 0, i32 2
	store %..typeid 648518346341351492, %..typeid* %1770
	; Type_Info_Pointer
	%1771 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1767 to %runtime.Type_Info_Pointer*
	%1772 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 59
	%1773 = bitcast %runtime.Type_Info* %1772 to %runtime.Type_Info*
	%1774 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1771, i64 0, i32 0
	store %runtime.Type_Info* %1773, %runtime.Type_Info** %1774
	%1775 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1771, align 8
	%1776 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1767 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1775, %runtime.Type_Info_Pointer* %1776
	%1777 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1767, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %1777
	%1778 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 69
	%1779 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1778, i64 0, i32 3
	%1780 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1778, i64 0, i32 0
	store i64 24, i64* %1780
	%1781 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1778, i64 0, i32 1
	store i64 8, i64* %1781
	%1782 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1778, i64 0, i32 2
	store %..typeid 3386706919782613061, %..typeid* %1782
	; Type_Info_Named
	%1783 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1779 to %runtime.Type_Info_Named*
	%1784 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 70
	%1785 = bitcast %runtime.Type_Info* %1784 to %runtime.Type_Info*
	%1786 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1783, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$773, i64 0, i32 0), i64 13}, %..string* %1786
	%1787 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1783, i64 0, i32 1
	store %runtime.Type_Info* %1785, %runtime.Type_Info** %1787
	%1788 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1783, align 8
	%1789 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1779 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1788, %runtime.Type_Info_Named* %1789
	%1790 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1779, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1790
	%1791 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 70
	%1792 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1791, i64 0, i32 3
	%1793 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1791, i64 0, i32 0
	store i64 24, i64* %1793
	%1794 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1791, i64 0, i32 1
	store i64 8, i64* %1794
	%1795 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1791, i64 0, i32 2
	store %..typeid 1080863910568919110, %..typeid* %1795
	; Type_Info_Struct
	%1796 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1792 to %runtime.Type_Info_Struct*
	%1797 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1796, i64 0, i32 4
	store i8 0, i8* %1797
	%1798 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1796, i64 0, i32 5
	store i8 0, i8* %1798
	%1799 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1796, i64 0, i32 6
	store i8 0, i8* %1799
	%1800 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 67
	%1801 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 34
	%1802 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 34
	%1803 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 34
	%1804 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%1805 = bitcast %runtime.Type_Info* %1804 to %runtime.Type_Info*
	%1806 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1800, i64 0
	%1807 = getelementptr inbounds i64, i64* %1802, i64 0
	%1808 = getelementptr inbounds i8, i8* %1803, i64 0
	%1809 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	store %runtime.Type_Info* %1809, %runtime.Type_Info** %1806
	%1810 = getelementptr inbounds %..string, %..string* %1801, i64 0
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$774, i64 0, i32 0), i64 3}, %..string* %1810
	store i64 0, i64* %1807
	store i8 0, i8* %1808
	%1811 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%1812 = bitcast %runtime.Type_Info* %1811 to %runtime.Type_Info*
	%1813 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1800, i64 1
	%1814 = getelementptr inbounds i64, i64* %1802, i64 1
	%1815 = getelementptr inbounds i8, i8* %1803, i64 1
	%1816 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	store %runtime.Type_Info* %1816, %runtime.Type_Info** %1813
	%1817 = getelementptr inbounds %..string, %..string* %1801, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$775, i64 0, i32 0), i64 5}, %..string* %1817
	store i64 8, i64* %1814
	store i8 0, i8* %1815
	%1818 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%1819 = bitcast %runtime.Type_Info* %1818 to %runtime.Type_Info*
	%1820 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1800, i64 2
	%1821 = getelementptr inbounds i64, i64* %1802, i64 2
	%1822 = getelementptr inbounds i8, i8* %1803, i64 2
	%1823 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	store %runtime.Type_Info* %1823, %runtime.Type_Info** %1820
	%1824 = getelementptr inbounds %..string, %..string* %1801, i64 2
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$776, i64 0, i32 0), i64 16}, %..string* %1824
	store i64 16, i64* %1821
	store i8 0, i8* %1822
	%1825 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1796, i64 0, i32 0
	%1826 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1825, i64 0, i32 0
	store %runtime.Type_Info** %1800, %runtime.Type_Info*** %1826
	%1827 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1825, i64 0, i32 1
	store i64 3, i64* %1827
	%1828 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1796, i64 0, i32 1
	%1829 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1828, i64 0, i32 0
	store %..string* %1801, %..string** %1829
	%1830 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1828, i64 0, i32 1
	store i64 3, i64* %1830
	%1831 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1796, i64 0, i32 2
	%1832 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1831, i64 0, i32 0
	store i64* %1802, i64** %1832
	%1833 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1831, i64 0, i32 1
	store i64 3, i64* %1833
	%1834 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1796, i64 0, i32 3
	%1835 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1834, i64 0, i32 0
	store i8* %1803, i8** %1835
	%1836 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1834, i64 0, i32 1
	store i64 3, i64* %1836
	%1837 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1796, align 8
	%1838 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1792 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1837, %runtime.Type_Info_Struct* %1838
	%1839 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1792, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1839
	%1840 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 71
	%1841 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1840, i64 0, i32 3
	%1842 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1840, i64 0, i32 0
	store i64 48, i64* %1842
	%1843 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1840, i64 0, i32 1
	store i64 8, i64* %1843
	%1844 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1840, i64 0, i32 2
	store %..typeid 3386706919782613063, %..typeid* %1844
	; Type_Info_Named
	%1845 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1841 to %runtime.Type_Info_Named*
	%1846 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 72
	%1847 = bitcast %runtime.Type_Info* %1846 to %runtime.Type_Info*
	%1848 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1845, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$777, i64 0, i32 0), i64 19}, %..string* %1848
	%1849 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1845, i64 0, i32 1
	store %runtime.Type_Info* %1847, %runtime.Type_Info** %1849
	%1850 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1845, align 8
	%1851 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1841 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1850, %runtime.Type_Info_Named* %1851
	%1852 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1841, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1852
	%1853 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 72
	%1854 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1853, i64 0, i32 3
	%1855 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1853, i64 0, i32 0
	store i64 48, i64* %1855
	%1856 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1853, i64 0, i32 1
	store i64 8, i64* %1856
	%1857 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1853, i64 0, i32 2
	store %..typeid 1080863910568919112, %..typeid* %1857
	; Type_Info_Struct
	%1858 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1854 to %runtime.Type_Info_Struct*
	%1859 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1858, i64 0, i32 4
	store i8 0, i8* %1859
	%1860 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1858, i64 0, i32 5
	store i8 0, i8* %1860
	%1861 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1858, i64 0, i32 6
	store i8 0, i8* %1861
	%1862 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 70
	%1863 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 37
	%1864 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 37
	%1865 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 37
	%1866 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 45
	%1867 = bitcast %runtime.Type_Info* %1866 to %runtime.Type_Info*
	%1868 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1862, i64 0
	%1869 = getelementptr inbounds i64, i64* %1864, i64 0
	%1870 = getelementptr inbounds i8, i8* %1865, i64 0
	%1871 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 45
	store %runtime.Type_Info* %1871, %runtime.Type_Info** %1868
	%1872 = getelementptr inbounds %..string, %..string* %1863, i64 0
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$778, i64 0, i32 0), i64 5}, %..string* %1872
	store i64 0, i64* %1869
	store i8 0, i8* %1870
	%1873 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 73
	%1874 = bitcast %runtime.Type_Info* %1873 to %runtime.Type_Info*
	%1875 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1862, i64 1
	%1876 = getelementptr inbounds i64, i64* %1864, i64 1
	%1877 = getelementptr inbounds i8, i8* %1865, i64 1
	%1878 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 73
	store %runtime.Type_Info* %1878, %runtime.Type_Info** %1875
	%1879 = getelementptr inbounds %..string, %..string* %1863, i64 1
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$779, i64 0, i32 0), i64 4}, %..string* %1879
	store i64 16, i64* %1876
	store i8 0, i8* %1877
	%1880 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 73
	%1881 = bitcast %runtime.Type_Info* %1880 to %runtime.Type_Info*
	%1882 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1862, i64 2
	%1883 = getelementptr inbounds i64, i64* %1864, i64 2
	%1884 = getelementptr inbounds i8, i8* %1865, i64 2
	%1885 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 73
	store %runtime.Type_Info* %1885, %runtime.Type_Info** %1882
	%1886 = getelementptr inbounds %..string, %..string* %1863, i64 2
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$77a, i64 0, i32 0), i64 7}, %..string* %1886
	store i64 32, i64* %1883
	store i8 0, i8* %1884
	%1887 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1858, i64 0, i32 0
	%1888 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1887, i64 0, i32 0
	store %runtime.Type_Info** %1862, %runtime.Type_Info*** %1888
	%1889 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1887, i64 0, i32 1
	store i64 3, i64* %1889
	%1890 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1858, i64 0, i32 1
	%1891 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1890, i64 0, i32 0
	store %..string* %1863, %..string** %1891
	%1892 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1890, i64 0, i32 1
	store i64 3, i64* %1892
	%1893 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1858, i64 0, i32 2
	%1894 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1893, i64 0, i32 0
	store i64* %1864, i64** %1894
	%1895 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1893, i64 0, i32 1
	store i64 3, i64* %1895
	%1896 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1858, i64 0, i32 3
	%1897 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1896, i64 0, i32 0
	store i8* %1865, i8** %1897
	%1898 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1896, i64 0, i32 1
	store i64 3, i64* %1898
	%1899 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1858, align 8
	%1900 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1854 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1899, %runtime.Type_Info_Struct* %1900
	%1901 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1854, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1901
	%1902 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 73
	%1903 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1902, i64 0, i32 3
	%1904 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1902, i64 0, i32 0
	store i64 16, i64* %1904
	%1905 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1902, i64 0, i32 1
	store i64 8, i64* %1905
	%1906 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1902, i64 0, i32 2
	store %..typeid 936748722493063241, %..typeid* %1906
	; Type_Info_Slice
	%1907 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1903 to %runtime.Type_Info_Slice*
	%1908 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%1909 = bitcast %runtime.Type_Info* %1908 to %runtime.Type_Info*
	%1910 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1907, i64 0, i32 0
	store %runtime.Type_Info* %1909, %runtime.Type_Info** %1910
	%1911 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1907, i64 0, i32 1
	store i64 4, i64* %1911
	%1912 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1907, align 8
	%1913 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1903 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1912, %runtime.Type_Info_Slice* %1913
	%1914 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1903, i64 0, i32 2 ; UnionTagPtr
	store i8 14, i8* %1914
	%1915 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 74
	%1916 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1915, i64 0, i32 3
	%1917 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1915, i64 0, i32 0
	store i64 8, i64* %1917
	%1918 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1915, i64 0, i32 1
	store i64 8, i64* %1918
	%1919 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1915, i64 0, i32 2
	store %..typeid 648518346341351498, %..typeid* %1919
	; Type_Info_Pointer
	%1920 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1916 to %runtime.Type_Info_Pointer*
	%1921 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%1922 = bitcast %runtime.Type_Info* %1921 to %runtime.Type_Info*
	%1923 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1920, i64 0, i32 0
	store %runtime.Type_Info* %1922, %runtime.Type_Info** %1923
	%1924 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1920, align 8
	%1925 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1916 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1924, %runtime.Type_Info_Pointer* %1925
	%1926 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1916, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %1926
	%1927 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 75
	%1928 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1927, i64 0, i32 3
	%1929 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1927, i64 0, i32 0
	store i64 32, i64* %1929
	%1930 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1927, i64 0, i32 1
	store i64 8, i64* %1930
	%1931 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1927, i64 0, i32 2
	store %..typeid 3386706919782613067, %..typeid* %1931
	; Type_Info_Named
	%1932 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1928 to %runtime.Type_Info_Named*
	%1933 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 76
	%1934 = bitcast %runtime.Type_Info* %1933 to %runtime.Type_Info*
	%1935 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1932, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$77b, i64 0, i32 0), i64 17}, %..string* %1935
	%1936 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1932, i64 0, i32 1
	store %runtime.Type_Info* %1934, %runtime.Type_Info** %1936
	%1937 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1932, align 8
	%1938 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1928 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1937, %runtime.Type_Info_Named* %1938
	%1939 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1928, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1939
	%1940 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 76
	%1941 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1940, i64 0, i32 3
	%1942 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1940, i64 0, i32 0
	store i64 32, i64* %1942
	%1943 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1940, i64 0, i32 1
	store i64 8, i64* %1943
	%1944 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1940, i64 0, i32 2
	store %..typeid 1080863910568919116, %..typeid* %1944
	; Type_Info_Struct
	%1945 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1941 to %runtime.Type_Info_Struct*
	%1946 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1945, i64 0, i32 4
	store i8 0, i8* %1946
	%1947 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1945, i64 0, i32 5
	store i8 0, i8* %1947
	%1948 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1945, i64 0, i32 6
	store i8 0, i8* %1948
	%1949 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 73
	%1950 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 40
	%1951 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 40
	%1952 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 40
	%1953 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%1954 = bitcast %runtime.Type_Info* %1953 to %runtime.Type_Info*
	%1955 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1949, i64 0
	%1956 = getelementptr inbounds i64, i64* %1951, i64 0
	%1957 = getelementptr inbounds i8, i8* %1952, i64 0
	%1958 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	store %runtime.Type_Info* %1958, %runtime.Type_Info** %1955
	%1959 = getelementptr inbounds %..string, %..string* %1950, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$77c, i64 0, i32 0), i64 4}, %..string* %1959
	store i64 0, i64* %1956
	store i8 0, i8* %1957
	%1960 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%1961 = bitcast %runtime.Type_Info* %1960 to %runtime.Type_Info*
	%1962 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1949, i64 1
	%1963 = getelementptr inbounds i64, i64* %1951, i64 1
	%1964 = getelementptr inbounds i8, i8* %1952, i64 1
	%1965 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	store %runtime.Type_Info* %1965, %runtime.Type_Info** %1962
	%1966 = getelementptr inbounds %..string, %..string* %1950, i64 1
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$77d, i64 0, i32 0), i64 10}, %..string* %1966
	store i64 8, i64* %1963
	store i8 0, i8* %1964
	%1967 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 64
	%1968 = bitcast %runtime.Type_Info* %1967 to %runtime.Type_Info*
	%1969 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1949, i64 2
	%1970 = getelementptr inbounds i64, i64* %1951, i64 2
	%1971 = getelementptr inbounds i8, i8* %1952, i64 2
	%1972 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 64
	store %runtime.Type_Info* %1972, %runtime.Type_Info** %1969
	%1973 = getelementptr inbounds %..string, %..string* %1950, i64 2
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$77e, i64 0, i32 0), i64 5}, %..string* %1973
	store i64 16, i64* %1970
	store i8 0, i8* %1971
	%1974 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 64
	%1975 = bitcast %runtime.Type_Info* %1974 to %runtime.Type_Info*
	%1976 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1949, i64 3
	%1977 = getelementptr inbounds i64, i64* %1951, i64 3
	%1978 = getelementptr inbounds i8, i8* %1952, i64 3
	%1979 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 64
	store %runtime.Type_Info* %1979, %runtime.Type_Info** %1976
	%1980 = getelementptr inbounds %..string, %..string* %1950, i64 3
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$77f, i64 0, i32 0), i64 5}, %..string* %1980
	store i64 24, i64* %1977
	store i8 0, i8* %1978
	%1981 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1945, i64 0, i32 0
	%1982 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1981, i64 0, i32 0
	store %runtime.Type_Info** %1949, %runtime.Type_Info*** %1982
	%1983 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1981, i64 0, i32 1
	store i64 4, i64* %1983
	%1984 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1945, i64 0, i32 1
	%1985 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1984, i64 0, i32 0
	store %..string* %1950, %..string** %1985
	%1986 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1984, i64 0, i32 1
	store i64 4, i64* %1986
	%1987 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1945, i64 0, i32 2
	%1988 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1987, i64 0, i32 0
	store i64* %1951, i64** %1988
	%1989 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1987, i64 0, i32 1
	store i64 4, i64* %1989
	%1990 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1945, i64 0, i32 3
	%1991 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1990, i64 0, i32 0
	store i8* %1952, i8** %1991
	%1992 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1990, i64 0, i32 1
	store i64 4, i64* %1992
	%1993 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1945, align 8
	%1994 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1941 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1993, %runtime.Type_Info_Struct* %1994
	%1995 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1941, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1995
	%1996 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 1
	%1997 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1996, i64 0, i32 3
	%1998 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1996, i64 0, i32 0
	store i64 1, i64* %1998
	%1999 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1996, i64 0, i32 1
	store i64 1, i64* %1999
	%2000 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1996, i64 0, i32 2
	store %..typeid 3530822107858468865, %..typeid* %2000
	; Type_Info_Named
	%2001 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1997 to %runtime.Type_Info_Named*
	%2002 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 2
	%2003 = bitcast %runtime.Type_Info* %2002 to %runtime.Type_Info*
	%2004 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2001, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$780, i64 0, i32 0), i64 14}, %..string* %2004
	%2005 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2001, i64 0, i32 1
	store %runtime.Type_Info* %2003, %runtime.Type_Info** %2005
	%2006 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2001, align 8
	%2007 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1997 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %2006, %runtime.Type_Info_Named* %2007
	%2008 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1997, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %2008
	%2009 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 2
	%2010 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2009, i64 0, i32 3
	%2011 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2009, i64 0, i32 0
	store i64 1, i64* %2011
	%2012 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2009, i64 0, i32 1
	store i64 1, i64* %2012
	%2013 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2009, i64 0, i32 2
	store %..typeid 1224979098644774914, %..typeid* %2013
	; Type_Info_Enum
	%2014 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2010 to %runtime.Type_Info_Enum*
	%2015 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	%2016 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2014, i64 0, i32 0
	store %runtime.Type_Info* %2015, %runtime.Type_Info** %2016
	%2017 = getelementptr inbounds [4 x %..string], [4 x %..string]* @$enum_names-2, i64 0, i32 0
	%2018 = getelementptr inbounds [4 x %runtime.Type_Info_Enum_Value], [4 x %runtime.Type_Info_Enum_Value]* @$enum_values-2, i64 0, i32 0
	%2019 = bitcast %runtime.Type_Info_Enum_Value* %2018 to i8*
	store i8 0, i8* %2019
	%2020 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2018, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %2020
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$781, i64 0, i32 0), i64 5}, %..string* %2017
	%2021 = getelementptr inbounds [4 x %..string], [4 x %..string]* @$enum_names-2, i64 0, i32 1
	%2022 = getelementptr inbounds [4 x %runtime.Type_Info_Enum_Value], [4 x %runtime.Type_Info_Enum_Value]* @$enum_values-2, i64 0, i32 1
	%2023 = bitcast %runtime.Type_Info_Enum_Value* %2022 to i8*
	store i8 1, i8* %2023
	%2024 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2022, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %2024
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$782, i64 0, i32 0), i64 4}, %..string* %2021
	%2025 = getelementptr inbounds [4 x %..string], [4 x %..string]* @$enum_names-2, i64 0, i32 2
	%2026 = getelementptr inbounds [4 x %runtime.Type_Info_Enum_Value], [4 x %runtime.Type_Info_Enum_Value]* @$enum_values-2, i64 0, i32 2
	%2027 = bitcast %runtime.Type_Info_Enum_Value* %2026 to i8*
	store i8 2, i8* %2027
	%2028 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2026, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %2028
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$783, i64 0, i32 0), i64 8}, %..string* %2025
	%2029 = getelementptr inbounds [4 x %..string], [4 x %..string]* @$enum_names-2, i64 0, i32 3
	%2030 = getelementptr inbounds [4 x %runtime.Type_Info_Enum_Value], [4 x %runtime.Type_Info_Enum_Value]* @$enum_values-2, i64 0, i32 3
	%2031 = bitcast %runtime.Type_Info_Enum_Value* %2030 to i8*
	store i8 3, i8* %2031
	%2032 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2030, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %2032
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$784, i64 0, i32 0), i64 6}, %..string* %2029
	%2033 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2014, i64 0, i32 1
	%2034 = getelementptr inbounds [4 x %..string], [4 x %..string]* @$enum_names-2, i64 0, i32 0
	%2035 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2033, i64 0, i32 0
	store %..string* %2034, %..string** %2035
	%2036 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2033, i64 0, i32 1
	store i64 4, i64* %2036
	%2037 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2014, i64 0, i32 2
	%2038 = getelementptr inbounds [4 x %runtime.Type_Info_Enum_Value], [4 x %runtime.Type_Info_Enum_Value]* @$enum_values-2, i64 0, i32 0
	%2039 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %2037, i64 0, i32 0
	store %runtime.Type_Info_Enum_Value* %2038, %runtime.Type_Info_Enum_Value** %2039
	%2040 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %2037, i64 0, i32 1
	store i64 4, i64* %2040
	%2041 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2014, align 8
	%2042 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2010 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %2041, %runtime.Type_Info_Enum* %2042
	%2043 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2010, i64 0, i32 2 ; UnionTagPtr
	store i8 18, i8* %2043
	%2044 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%2045 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2044, i64 0, i32 3
	%2046 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2044, i64 0, i32 0
	store i64 16, i64* %2046
	%2047 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2044, i64 0, i32 1
	store i64 8, i64* %2047
	%2048 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2044, i64 0, i32 2
	store %..typeid 936748722493063177, %..typeid* %2048
	; Type_Info_Slice
	%2049 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2045 to %runtime.Type_Info_Slice*
	%2050 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 10
	%2051 = bitcast %runtime.Type_Info* %2050 to %runtime.Type_Info*
	%2052 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %2049, i64 0, i32 0
	store %runtime.Type_Info* %2051, %runtime.Type_Info** %2052
	%2053 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %2049, i64 0, i32 1
	store i64 16, i64* %2053
	%2054 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %2049, align 8
	%2055 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2045 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %2054, %runtime.Type_Info_Slice* %2055
	%2056 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2045, i64 0, i32 2 ; UnionTagPtr
	store i8 14, i8* %2056
	%2057 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 10
	%2058 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2057, i64 0, i32 3
	%2059 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2057, i64 0, i32 0
	store i64 16, i64* %2059
	%2060 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2057, i64 0, i32 1
	store i64 8, i64* %2060
	%2061 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2057, i64 0, i32 2
	store %..typeid 10, %..typeid* %2061
	; Type_Info_Basic
	%2062 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2058 to %runtime.Type_Info_Any*
	%2063 = load %runtime.Type_Info_Any, %runtime.Type_Info_Any* %2062, align 1
	%2064 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2058 to %runtime.Type_Info_Any*
	store %runtime.Type_Info_Any %2063, %runtime.Type_Info_Any* %2064
	%2065 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2058, i64 0, i32 2 ; UnionTagPtr
	store i8 8, i8* %2065
	%2066 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 77
	%2067 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2066, i64 0, i32 3
	%2068 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2066, i64 0, i32 0
	store i64 8, i64* %2068
	%2069 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2066, i64 0, i32 1
	store i64 8, i64* %2069
	%2070 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2066, i64 0, i32 2
	store %..typeid 648518346341351501, %..typeid* %2070
	; Type_Info_Basic
	%2071 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2067 to %runtime.Type_Info_Pointer*
	%2072 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %2071, align 8
	%2073 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2067 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %2072, %runtime.Type_Info_Pointer* %2073
	%2074 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2067, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %2074
	%2075 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 78
	%2076 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2075, i64 0, i32 3
	%2077 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2075, i64 0, i32 0
	store i64 8, i64* %2077
	%2078 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2075, i64 0, i32 1
	store i64 8, i64* %2078
	%2079 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2075, i64 0, i32 2
	store %..typeid 648518346341351502, %..typeid* %2079
	; Type_Info_Pointer
	%2080 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2076 to %runtime.Type_Info_Pointer*
	%2081 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 10
	%2082 = bitcast %runtime.Type_Info* %2081 to %runtime.Type_Info*
	%2083 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %2080, i64 0, i32 0
	store %runtime.Type_Info* %2082, %runtime.Type_Info** %2083
	%2084 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %2080, align 8
	%2085 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2076 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %2084, %runtime.Type_Info_Pointer* %2085
	%2086 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2076, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %2086
	%2087 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 93
	%2088 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2087, i64 0, i32 3
	%2089 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2087, i64 0, i32 0
	store i64 4, i64* %2089
	%2090 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2087, i64 0, i32 1
	store i64 4, i64* %2090
	%2091 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2087, i64 0, i32 2
	store %..typeid 3530822107858468957, %..typeid* %2091
	; Type_Info_Named
	%2092 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2088 to %runtime.Type_Info_Named*
	%2093 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 94
	%2094 = bitcast %runtime.Type_Info* %2093 to %runtime.Type_Info*
	%2095 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2092, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$785, i64 0, i32 0), i64 3}, %..string* %2095
	%2096 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2092, i64 0, i32 1
	store %runtime.Type_Info* %2094, %runtime.Type_Info** %2096
	%2097 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2092, align 8
	%2098 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2088 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %2097, %runtime.Type_Info_Named* %2098
	%2099 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2088, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %2099
	%2100 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 94
	%2101 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2100, i64 0, i32 3
	%2102 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2100, i64 0, i32 0
	store i64 4, i64* %2102
	%2103 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2100, i64 0, i32 1
	store i64 4, i64* %2103
	%2104 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2100, i64 0, i32 2
	store %..typeid 1224979098644775006, %..typeid* %2104
	; Type_Info_Enum
	%2105 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2101 to %runtime.Type_Info_Enum*
	%2106 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%2107 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2105, i64 0, i32 0
	store %runtime.Type_Info* %2106, %runtime.Type_Info** %2107
	%2108 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 0
	%2109 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 0
	%2110 = bitcast %runtime.Type_Info_Enum_Value* %2109 to i32*
	store i32 -1, i32* %2110
	%2111 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2109, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2111
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$786, i64 0, i32 0), i64 7}, %..string* %2108
	%2112 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 1
	%2113 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 1
	%2114 = bitcast %runtime.Type_Info_Enum_Value* %2113 to i32*
	store i32 32, i32* %2114
	%2115 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2113, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2115
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$787, i64 0, i32 0), i64 5}, %..string* %2112
	%2116 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 2
	%2117 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 2
	%2118 = bitcast %runtime.Type_Info_Enum_Value* %2117 to i32*
	store i32 39, i32* %2118
	%2119 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2117, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2119
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$788, i64 0, i32 0), i64 10}, %..string* %2116
	%2120 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 3
	%2121 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 3
	%2122 = bitcast %runtime.Type_Info_Enum_Value* %2121 to i32*
	store i32 44, i32* %2122
	%2123 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2121, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2123
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$789, i64 0, i32 0), i64 5}, %..string* %2120
	%2124 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 4
	%2125 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 4
	%2126 = bitcast %runtime.Type_Info_Enum_Value* %2125 to i32*
	store i32 45, i32* %2126
	%2127 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2125, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2127
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$78a, i64 0, i32 0), i64 5}, %..string* %2124
	%2128 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 5
	%2129 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 5
	%2130 = bitcast %runtime.Type_Info_Enum_Value* %2129 to i32*
	store i32 46, i32* %2130
	%2131 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2129, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2131
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$78b, i64 0, i32 0), i64 6}, %..string* %2128
	%2132 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 6
	%2133 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 6
	%2134 = bitcast %runtime.Type_Info_Enum_Value* %2133 to i32*
	store i32 47, i32* %2134
	%2135 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2133, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2135
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$78c, i64 0, i32 0), i64 5}, %..string* %2132
	%2136 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 7
	%2137 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 7
	%2138 = bitcast %runtime.Type_Info_Enum_Value* %2137 to i32*
	store i32 59, i32* %2138
	%2139 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2137, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2139
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$78d, i64 0, i32 0), i64 9}, %..string* %2136
	%2140 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 8
	%2141 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 8
	%2142 = bitcast %runtime.Type_Info_Enum_Value* %2141 to i32*
	store i32 61, i32* %2142
	%2143 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2141, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2143
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$78e, i64 0, i32 0), i64 5}, %..string* %2140
	%2144 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 9
	%2145 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 9
	%2146 = bitcast %runtime.Type_Info_Enum_Value* %2145 to i32*
	store i32 91, i32* %2146
	%2147 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2145, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2147
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$78f, i64 0, i32 0), i64 12}, %..string* %2144
	%2148 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 10
	%2149 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 10
	%2150 = bitcast %runtime.Type_Info_Enum_Value* %2149 to i32*
	store i32 92, i32* %2150
	%2151 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2149, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2151
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$790, i64 0, i32 0), i64 9}, %..string* %2148
	%2152 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 11
	%2153 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 11
	%2154 = bitcast %runtime.Type_Info_Enum_Value* %2153 to i32*
	store i32 93, i32* %2154
	%2155 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2153, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2155
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$791, i64 0, i32 0), i64 13}, %..string* %2152
	%2156 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 12
	%2157 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 12
	%2158 = bitcast %runtime.Type_Info_Enum_Value* %2157 to i32*
	store i32 96, i32* %2158
	%2159 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2157, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2159
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$792, i64 0, i32 0), i64 12}, %..string* %2156
	%2160 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 13
	%2161 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 13
	%2162 = bitcast %runtime.Type_Info_Enum_Value* %2161 to i32*
	store i32 161, i32* %2162
	%2163 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2161, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2163
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$793, i64 0, i32 0), i64 7}, %..string* %2160
	%2164 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 14
	%2165 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 14
	%2166 = bitcast %runtime.Type_Info_Enum_Value* %2165 to i32*
	store i32 162, i32* %2166
	%2167 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2165, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2167
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$794, i64 0, i32 0), i64 7}, %..string* %2164
	%2168 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 15
	%2169 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 15
	%2170 = bitcast %runtime.Type_Info_Enum_Value* %2169 to i32*
	store i32 48, i32* %2170
	%2171 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2169, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2171
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$795, i64 0, i32 0), i64 4}, %..string* %2168
	%2172 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 16
	%2173 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 16
	%2174 = bitcast %runtime.Type_Info_Enum_Value* %2173 to i32*
	store i32 49, i32* %2174
	%2175 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2173, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2175
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$796, i64 0, i32 0), i64 4}, %..string* %2172
	%2176 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 17
	%2177 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 17
	%2178 = bitcast %runtime.Type_Info_Enum_Value* %2177 to i32*
	store i32 50, i32* %2178
	%2179 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2177, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2179
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$797, i64 0, i32 0), i64 4}, %..string* %2176
	%2180 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 18
	%2181 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 18
	%2182 = bitcast %runtime.Type_Info_Enum_Value* %2181 to i32*
	store i32 51, i32* %2182
	%2183 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2181, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2183
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$798, i64 0, i32 0), i64 4}, %..string* %2180
	%2184 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 19
	%2185 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 19
	%2186 = bitcast %runtime.Type_Info_Enum_Value* %2185 to i32*
	store i32 52, i32* %2186
	%2187 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2185, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2187
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$799, i64 0, i32 0), i64 4}, %..string* %2184
	%2188 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 20
	%2189 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 20
	%2190 = bitcast %runtime.Type_Info_Enum_Value* %2189 to i32*
	store i32 53, i32* %2190
	%2191 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2189, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2191
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$79a, i64 0, i32 0), i64 4}, %..string* %2188
	%2192 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 21
	%2193 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 21
	%2194 = bitcast %runtime.Type_Info_Enum_Value* %2193 to i32*
	store i32 54, i32* %2194
	%2195 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2193, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2195
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$79b, i64 0, i32 0), i64 4}, %..string* %2192
	%2196 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 22
	%2197 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 22
	%2198 = bitcast %runtime.Type_Info_Enum_Value* %2197 to i32*
	store i32 55, i32* %2198
	%2199 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2197, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2199
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$79c, i64 0, i32 0), i64 4}, %..string* %2196
	%2200 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 23
	%2201 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 23
	%2202 = bitcast %runtime.Type_Info_Enum_Value* %2201 to i32*
	store i32 56, i32* %2202
	%2203 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2201, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2203
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$79d, i64 0, i32 0), i64 4}, %..string* %2200
	%2204 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 24
	%2205 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 24
	%2206 = bitcast %runtime.Type_Info_Enum_Value* %2205 to i32*
	store i32 57, i32* %2206
	%2207 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2205, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2207
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$79e, i64 0, i32 0), i64 4}, %..string* %2204
	%2208 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 25
	%2209 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 25
	%2210 = bitcast %runtime.Type_Info_Enum_Value* %2209 to i32*
	store i32 65, i32* %2210
	%2211 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2209, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2211
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$79f, i64 0, i32 0), i64 1}, %..string* %2208
	%2212 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 26
	%2213 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 26
	%2214 = bitcast %runtime.Type_Info_Enum_Value* %2213 to i32*
	store i32 66, i32* %2214
	%2215 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2213, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2215
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7a0, i64 0, i32 0), i64 1}, %..string* %2212
	%2216 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 27
	%2217 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 27
	%2218 = bitcast %runtime.Type_Info_Enum_Value* %2217 to i32*
	store i32 67, i32* %2218
	%2219 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2217, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2219
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7a1, i64 0, i32 0), i64 1}, %..string* %2216
	%2220 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 28
	%2221 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 28
	%2222 = bitcast %runtime.Type_Info_Enum_Value* %2221 to i32*
	store i32 68, i32* %2222
	%2223 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2221, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2223
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7a2, i64 0, i32 0), i64 1}, %..string* %2220
	%2224 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 29
	%2225 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 29
	%2226 = bitcast %runtime.Type_Info_Enum_Value* %2225 to i32*
	store i32 69, i32* %2226
	%2227 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2225, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2227
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7a3, i64 0, i32 0), i64 1}, %..string* %2224
	%2228 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 30
	%2229 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 30
	%2230 = bitcast %runtime.Type_Info_Enum_Value* %2229 to i32*
	store i32 70, i32* %2230
	%2231 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2229, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2231
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7a4, i64 0, i32 0), i64 1}, %..string* %2228
	%2232 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 31
	%2233 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 31
	%2234 = bitcast %runtime.Type_Info_Enum_Value* %2233 to i32*
	store i32 71, i32* %2234
	%2235 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2233, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2235
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7a5, i64 0, i32 0), i64 1}, %..string* %2232
	%2236 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 32
	%2237 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 32
	%2238 = bitcast %runtime.Type_Info_Enum_Value* %2237 to i32*
	store i32 72, i32* %2238
	%2239 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2237, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2239
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7a6, i64 0, i32 0), i64 1}, %..string* %2236
	%2240 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 33
	%2241 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 33
	%2242 = bitcast %runtime.Type_Info_Enum_Value* %2241 to i32*
	store i32 73, i32* %2242
	%2243 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2241, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2243
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7a7, i64 0, i32 0), i64 1}, %..string* %2240
	%2244 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 34
	%2245 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 34
	%2246 = bitcast %runtime.Type_Info_Enum_Value* %2245 to i32*
	store i32 74, i32* %2246
	%2247 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2245, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2247
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7a8, i64 0, i32 0), i64 1}, %..string* %2244
	%2248 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 35
	%2249 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 35
	%2250 = bitcast %runtime.Type_Info_Enum_Value* %2249 to i32*
	store i32 75, i32* %2250
	%2251 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2249, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2251
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7a9, i64 0, i32 0), i64 1}, %..string* %2248
	%2252 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 36
	%2253 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 36
	%2254 = bitcast %runtime.Type_Info_Enum_Value* %2253 to i32*
	store i32 76, i32* %2254
	%2255 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2253, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2255
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7aa, i64 0, i32 0), i64 1}, %..string* %2252
	%2256 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 37
	%2257 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 37
	%2258 = bitcast %runtime.Type_Info_Enum_Value* %2257 to i32*
	store i32 77, i32* %2258
	%2259 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2257, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2259
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7ab, i64 0, i32 0), i64 1}, %..string* %2256
	%2260 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 38
	%2261 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 38
	%2262 = bitcast %runtime.Type_Info_Enum_Value* %2261 to i32*
	store i32 78, i32* %2262
	%2263 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2261, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2263
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7ac, i64 0, i32 0), i64 1}, %..string* %2260
	%2264 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 39
	%2265 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 39
	%2266 = bitcast %runtime.Type_Info_Enum_Value* %2265 to i32*
	store i32 79, i32* %2266
	%2267 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2265, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2267
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7ad, i64 0, i32 0), i64 1}, %..string* %2264
	%2268 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 40
	%2269 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 40
	%2270 = bitcast %runtime.Type_Info_Enum_Value* %2269 to i32*
	store i32 80, i32* %2270
	%2271 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2269, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2271
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7ae, i64 0, i32 0), i64 1}, %..string* %2268
	%2272 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 41
	%2273 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 41
	%2274 = bitcast %runtime.Type_Info_Enum_Value* %2273 to i32*
	store i32 81, i32* %2274
	%2275 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2273, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2275
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7af, i64 0, i32 0), i64 1}, %..string* %2272
	%2276 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 42
	%2277 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 42
	%2278 = bitcast %runtime.Type_Info_Enum_Value* %2277 to i32*
	store i32 82, i32* %2278
	%2279 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2277, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2279
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7b0, i64 0, i32 0), i64 1}, %..string* %2276
	%2280 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 43
	%2281 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 43
	%2282 = bitcast %runtime.Type_Info_Enum_Value* %2281 to i32*
	store i32 83, i32* %2282
	%2283 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2281, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2283
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7b1, i64 0, i32 0), i64 1}, %..string* %2280
	%2284 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 44
	%2285 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 44
	%2286 = bitcast %runtime.Type_Info_Enum_Value* %2285 to i32*
	store i32 84, i32* %2286
	%2287 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2285, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2287
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7b2, i64 0, i32 0), i64 1}, %..string* %2284
	%2288 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 45
	%2289 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 45
	%2290 = bitcast %runtime.Type_Info_Enum_Value* %2289 to i32*
	store i32 85, i32* %2290
	%2291 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2289, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2291
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7b3, i64 0, i32 0), i64 1}, %..string* %2288
	%2292 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 46
	%2293 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 46
	%2294 = bitcast %runtime.Type_Info_Enum_Value* %2293 to i32*
	store i32 86, i32* %2294
	%2295 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2293, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2295
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7b4, i64 0, i32 0), i64 1}, %..string* %2292
	%2296 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 47
	%2297 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 47
	%2298 = bitcast %runtime.Type_Info_Enum_Value* %2297 to i32*
	store i32 87, i32* %2298
	%2299 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2297, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2299
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7b5, i64 0, i32 0), i64 1}, %..string* %2296
	%2300 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 48
	%2301 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 48
	%2302 = bitcast %runtime.Type_Info_Enum_Value* %2301 to i32*
	store i32 88, i32* %2302
	%2303 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2301, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2303
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7b6, i64 0, i32 0), i64 1}, %..string* %2300
	%2304 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 49
	%2305 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 49
	%2306 = bitcast %runtime.Type_Info_Enum_Value* %2305 to i32*
	store i32 89, i32* %2306
	%2307 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2305, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2307
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7b7, i64 0, i32 0), i64 1}, %..string* %2304
	%2308 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 50
	%2309 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 50
	%2310 = bitcast %runtime.Type_Info_Enum_Value* %2309 to i32*
	store i32 90, i32* %2310
	%2311 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2309, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2311
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$7b8, i64 0, i32 0), i64 1}, %..string* %2308
	%2312 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 51
	%2313 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 51
	%2314 = bitcast %runtime.Type_Info_Enum_Value* %2313 to i32*
	store i32 256, i32* %2314
	%2315 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2313, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2315
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$7b9, i64 0, i32 0), i64 6}, %..string* %2312
	%2316 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 52
	%2317 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 52
	%2318 = bitcast %runtime.Type_Info_Enum_Value* %2317 to i32*
	store i32 257, i32* %2318
	%2319 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2317, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2319
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$7ba, i64 0, i32 0), i64 5}, %..string* %2316
	%2320 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 53
	%2321 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 53
	%2322 = bitcast %runtime.Type_Info_Enum_Value* %2321 to i32*
	store i32 258, i32* %2322
	%2323 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2321, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2323
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7bb, i64 0, i32 0), i64 3}, %..string* %2320
	%2324 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 54
	%2325 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 54
	%2326 = bitcast %runtime.Type_Info_Enum_Value* %2325 to i32*
	store i32 259, i32* %2326
	%2327 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2325, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2327
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$7bc, i64 0, i32 0), i64 9}, %..string* %2324
	%2328 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 55
	%2329 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 55
	%2330 = bitcast %runtime.Type_Info_Enum_Value* %2329 to i32*
	store i32 260, i32* %2330
	%2331 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2329, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2331
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$7bd, i64 0, i32 0), i64 6}, %..string* %2328
	%2332 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 56
	%2333 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 56
	%2334 = bitcast %runtime.Type_Info_Enum_Value* %2333 to i32*
	store i32 261, i32* %2334
	%2335 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2333, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2335
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$7be, i64 0, i32 0), i64 6}, %..string* %2332
	%2336 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 57
	%2337 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 57
	%2338 = bitcast %runtime.Type_Info_Enum_Value* %2337 to i32*
	store i32 262, i32* %2338
	%2339 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2337, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2339
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$7bf, i64 0, i32 0), i64 5}, %..string* %2336
	%2340 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 58
	%2341 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 58
	%2342 = bitcast %runtime.Type_Info_Enum_Value* %2341 to i32*
	store i32 263, i32* %2342
	%2343 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2341, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2343
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$7c0, i64 0, i32 0), i64 4}, %..string* %2340
	%2344 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 59
	%2345 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 59
	%2346 = bitcast %runtime.Type_Info_Enum_Value* %2345 to i32*
	store i32 264, i32* %2346
	%2347 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2345, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2347
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$7c1, i64 0, i32 0), i64 4}, %..string* %2344
	%2348 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 60
	%2349 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 60
	%2350 = bitcast %runtime.Type_Info_Enum_Value* %2349 to i32*
	store i32 265, i32* %2350
	%2351 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2349, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2351
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7c2, i64 0, i32 0), i64 2}, %..string* %2348
	%2352 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 61
	%2353 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 61
	%2354 = bitcast %runtime.Type_Info_Enum_Value* %2353 to i32*
	store i32 266, i32* %2354
	%2355 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2353, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2355
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$7c3, i64 0, i32 0), i64 7}, %..string* %2352
	%2356 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 62
	%2357 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 62
	%2358 = bitcast %runtime.Type_Info_Enum_Value* %2357 to i32*
	store i32 267, i32* %2358
	%2359 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2357, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2359
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$7c4, i64 0, i32 0), i64 9}, %..string* %2356
	%2360 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 63
	%2361 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 63
	%2362 = bitcast %runtime.Type_Info_Enum_Value* %2361 to i32*
	store i32 268, i32* %2362
	%2363 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2361, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2363
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$7c5, i64 0, i32 0), i64 4}, %..string* %2360
	%2364 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 64
	%2365 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 64
	%2366 = bitcast %runtime.Type_Info_Enum_Value* %2365 to i32*
	store i32 269, i32* %2366
	%2367 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2365, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2367
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7c6, i64 0, i32 0), i64 3}, %..string* %2364
	%2368 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 65
	%2369 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 65
	%2370 = bitcast %runtime.Type_Info_Enum_Value* %2369 to i32*
	store i32 280, i32* %2370
	%2371 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2369, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2371
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$7c7, i64 0, i32 0), i64 9}, %..string* %2368
	%2372 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 66
	%2373 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 66
	%2374 = bitcast %runtime.Type_Info_Enum_Value* %2373 to i32*
	store i32 281, i32* %2374
	%2375 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2373, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2375
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$7c8, i64 0, i32 0), i64 11}, %..string* %2372
	%2376 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 67
	%2377 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 67
	%2378 = bitcast %runtime.Type_Info_Enum_Value* %2377 to i32*
	store i32 282, i32* %2378
	%2379 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2377, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2379
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$7c9, i64 0, i32 0), i64 8}, %..string* %2376
	%2380 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 68
	%2381 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 68
	%2382 = bitcast %runtime.Type_Info_Enum_Value* %2381 to i32*
	store i32 283, i32* %2382
	%2383 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2381, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2383
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$7ca, i64 0, i32 0), i64 12}, %..string* %2380
	%2384 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 69
	%2385 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 69
	%2386 = bitcast %runtime.Type_Info_Enum_Value* %2385 to i32*
	store i32 284, i32* %2386
	%2387 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2385, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2387
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$7cb, i64 0, i32 0), i64 5}, %..string* %2384
	%2388 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 70
	%2389 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 70
	%2390 = bitcast %runtime.Type_Info_Enum_Value* %2389 to i32*
	store i32 290, i32* %2390
	%2391 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2389, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2391
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7cc, i64 0, i32 0), i64 2}, %..string* %2388
	%2392 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 71
	%2393 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 71
	%2394 = bitcast %runtime.Type_Info_Enum_Value* %2393 to i32*
	store i32 291, i32* %2394
	%2395 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2393, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2395
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7cd, i64 0, i32 0), i64 2}, %..string* %2392
	%2396 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 72
	%2397 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 72
	%2398 = bitcast %runtime.Type_Info_Enum_Value* %2397 to i32*
	store i32 292, i32* %2398
	%2399 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2397, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2399
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7ce, i64 0, i32 0), i64 2}, %..string* %2396
	%2400 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 73
	%2401 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 73
	%2402 = bitcast %runtime.Type_Info_Enum_Value* %2401 to i32*
	store i32 293, i32* %2402
	%2403 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2401, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2403
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7cf, i64 0, i32 0), i64 2}, %..string* %2400
	%2404 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 74
	%2405 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 74
	%2406 = bitcast %runtime.Type_Info_Enum_Value* %2405 to i32*
	store i32 294, i32* %2406
	%2407 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2405, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2407
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7d0, i64 0, i32 0), i64 2}, %..string* %2404
	%2408 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 75
	%2409 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 75
	%2410 = bitcast %runtime.Type_Info_Enum_Value* %2409 to i32*
	store i32 295, i32* %2410
	%2411 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2409, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2411
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7d1, i64 0, i32 0), i64 2}, %..string* %2408
	%2412 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 76
	%2413 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 76
	%2414 = bitcast %runtime.Type_Info_Enum_Value* %2413 to i32*
	store i32 296, i32* %2414
	%2415 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2413, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2415
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7d2, i64 0, i32 0), i64 2}, %..string* %2412
	%2416 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 77
	%2417 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 77
	%2418 = bitcast %runtime.Type_Info_Enum_Value* %2417 to i32*
	store i32 297, i32* %2418
	%2419 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2417, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2419
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7d3, i64 0, i32 0), i64 2}, %..string* %2416
	%2420 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 78
	%2421 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 78
	%2422 = bitcast %runtime.Type_Info_Enum_Value* %2421 to i32*
	store i32 298, i32* %2422
	%2423 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2421, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2423
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7d4, i64 0, i32 0), i64 2}, %..string* %2420
	%2424 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 79
	%2425 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 79
	%2426 = bitcast %runtime.Type_Info_Enum_Value* %2425 to i32*
	store i32 299, i32* %2426
	%2427 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2425, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2427
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7d5, i64 0, i32 0), i64 3}, %..string* %2424
	%2428 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 80
	%2429 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 80
	%2430 = bitcast %runtime.Type_Info_Enum_Value* %2429 to i32*
	store i32 300, i32* %2430
	%2431 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2429, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2431
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7d6, i64 0, i32 0), i64 3}, %..string* %2428
	%2432 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 81
	%2433 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 81
	%2434 = bitcast %runtime.Type_Info_Enum_Value* %2433 to i32*
	store i32 301, i32* %2434
	%2435 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2433, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2435
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7d7, i64 0, i32 0), i64 3}, %..string* %2432
	%2436 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 82
	%2437 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 82
	%2438 = bitcast %runtime.Type_Info_Enum_Value* %2437 to i32*
	store i32 302, i32* %2438
	%2439 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2437, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2439
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7d8, i64 0, i32 0), i64 3}, %..string* %2436
	%2440 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 83
	%2441 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 83
	%2442 = bitcast %runtime.Type_Info_Enum_Value* %2441 to i32*
	store i32 303, i32* %2442
	%2443 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2441, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2443
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7d9, i64 0, i32 0), i64 3}, %..string* %2440
	%2444 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 84
	%2445 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 84
	%2446 = bitcast %runtime.Type_Info_Enum_Value* %2445 to i32*
	store i32 304, i32* %2446
	%2447 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2445, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2447
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7da, i64 0, i32 0), i64 3}, %..string* %2444
	%2448 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 85
	%2449 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 85
	%2450 = bitcast %runtime.Type_Info_Enum_Value* %2449 to i32*
	store i32 305, i32* %2450
	%2451 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2449, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2451
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7db, i64 0, i32 0), i64 3}, %..string* %2448
	%2452 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 86
	%2453 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 86
	%2454 = bitcast %runtime.Type_Info_Enum_Value* %2453 to i32*
	store i32 306, i32* %2454
	%2455 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2453, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2455
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7dc, i64 0, i32 0), i64 3}, %..string* %2452
	%2456 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 87
	%2457 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 87
	%2458 = bitcast %runtime.Type_Info_Enum_Value* %2457 to i32*
	store i32 307, i32* %2458
	%2459 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2457, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2459
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7dd, i64 0, i32 0), i64 3}, %..string* %2456
	%2460 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 88
	%2461 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 88
	%2462 = bitcast %runtime.Type_Info_Enum_Value* %2461 to i32*
	store i32 308, i32* %2462
	%2463 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2461, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2463
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7de, i64 0, i32 0), i64 3}, %..string* %2460
	%2464 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 89
	%2465 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 89
	%2466 = bitcast %runtime.Type_Info_Enum_Value* %2465 to i32*
	store i32 309, i32* %2466
	%2467 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2465, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2467
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7df, i64 0, i32 0), i64 3}, %..string* %2464
	%2468 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 90
	%2469 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 90
	%2470 = bitcast %runtime.Type_Info_Enum_Value* %2469 to i32*
	store i32 310, i32* %2470
	%2471 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2469, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2471
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7e0, i64 0, i32 0), i64 3}, %..string* %2468
	%2472 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 91
	%2473 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 91
	%2474 = bitcast %runtime.Type_Info_Enum_Value* %2473 to i32*
	store i32 311, i32* %2474
	%2475 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2473, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2475
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7e1, i64 0, i32 0), i64 3}, %..string* %2472
	%2476 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 92
	%2477 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 92
	%2478 = bitcast %runtime.Type_Info_Enum_Value* %2477 to i32*
	store i32 312, i32* %2478
	%2479 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2477, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2479
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7e2, i64 0, i32 0), i64 3}, %..string* %2476
	%2480 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 93
	%2481 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 93
	%2482 = bitcast %runtime.Type_Info_Enum_Value* %2481 to i32*
	store i32 313, i32* %2482
	%2483 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2481, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2483
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7e3, i64 0, i32 0), i64 3}, %..string* %2480
	%2484 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 94
	%2485 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 94
	%2486 = bitcast %runtime.Type_Info_Enum_Value* %2485 to i32*
	store i32 314, i32* %2486
	%2487 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2485, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2487
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$7e4, i64 0, i32 0), i64 3}, %..string* %2484
	%2488 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 95
	%2489 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 95
	%2490 = bitcast %runtime.Type_Info_Enum_Value* %2489 to i32*
	store i32 320, i32* %2490
	%2491 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2489, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2491
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$7e5, i64 0, i32 0), i64 4}, %..string* %2488
	%2492 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 96
	%2493 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 96
	%2494 = bitcast %runtime.Type_Info_Enum_Value* %2493 to i32*
	store i32 321, i32* %2494
	%2495 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2493, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2495
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$7e6, i64 0, i32 0), i64 4}, %..string* %2492
	%2496 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 97
	%2497 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 97
	%2498 = bitcast %runtime.Type_Info_Enum_Value* %2497 to i32*
	store i32 322, i32* %2498
	%2499 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2497, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2499
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$7e7, i64 0, i32 0), i64 4}, %..string* %2496
	%2500 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 98
	%2501 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 98
	%2502 = bitcast %runtime.Type_Info_Enum_Value* %2501 to i32*
	store i32 323, i32* %2502
	%2503 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2501, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2503
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$7e8, i64 0, i32 0), i64 4}, %..string* %2500
	%2504 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 99
	%2505 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 99
	%2506 = bitcast %runtime.Type_Info_Enum_Value* %2505 to i32*
	store i32 324, i32* %2506
	%2507 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2505, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2507
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$7e9, i64 0, i32 0), i64 4}, %..string* %2504
	%2508 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 100
	%2509 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 100
	%2510 = bitcast %runtime.Type_Info_Enum_Value* %2509 to i32*
	store i32 325, i32* %2510
	%2511 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2509, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2511
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$7ea, i64 0, i32 0), i64 4}, %..string* %2508
	%2512 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 101
	%2513 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 101
	%2514 = bitcast %runtime.Type_Info_Enum_Value* %2513 to i32*
	store i32 326, i32* %2514
	%2515 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2513, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2515
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$7eb, i64 0, i32 0), i64 4}, %..string* %2512
	%2516 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 102
	%2517 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 102
	%2518 = bitcast %runtime.Type_Info_Enum_Value* %2517 to i32*
	store i32 327, i32* %2518
	%2519 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2517, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2519
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$7ec, i64 0, i32 0), i64 4}, %..string* %2516
	%2520 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 103
	%2521 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 103
	%2522 = bitcast %runtime.Type_Info_Enum_Value* %2521 to i32*
	store i32 328, i32* %2522
	%2523 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2521, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2523
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$7ed, i64 0, i32 0), i64 4}, %..string* %2520
	%2524 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 104
	%2525 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 104
	%2526 = bitcast %runtime.Type_Info_Enum_Value* %2525 to i32*
	store i32 329, i32* %2526
	%2527 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2525, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2527
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$7ee, i64 0, i32 0), i64 4}, %..string* %2524
	%2528 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 105
	%2529 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 105
	%2530 = bitcast %runtime.Type_Info_Enum_Value* %2529 to i32*
	store i32 330, i32* %2530
	%2531 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2529, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2531
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$7ef, i64 0, i32 0), i64 10}, %..string* %2528
	%2532 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 106
	%2533 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 106
	%2534 = bitcast %runtime.Type_Info_Enum_Value* %2533 to i32*
	store i32 331, i32* %2534
	%2535 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2533, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2535
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$7f0, i64 0, i32 0), i64 9}, %..string* %2532
	%2536 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 107
	%2537 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 107
	%2538 = bitcast %runtime.Type_Info_Enum_Value* %2537 to i32*
	store i32 332, i32* %2538
	%2539 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2537, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2539
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$7f1, i64 0, i32 0), i64 11}, %..string* %2536
	%2540 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 108
	%2541 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 108
	%2542 = bitcast %runtime.Type_Info_Enum_Value* %2541 to i32*
	store i32 333, i32* %2542
	%2543 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2541, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2543
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$7f2, i64 0, i32 0), i64 11}, %..string* %2540
	%2544 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 109
	%2545 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 109
	%2546 = bitcast %runtime.Type_Info_Enum_Value* %2545 to i32*
	store i32 334, i32* %2546
	%2547 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2545, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2547
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$7f3, i64 0, i32 0), i64 6}, %..string* %2544
	%2548 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 110
	%2549 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 110
	%2550 = bitcast %runtime.Type_Info_Enum_Value* %2549 to i32*
	store i32 335, i32* %2550
	%2551 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2549, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2551
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$7f4, i64 0, i32 0), i64 8}, %..string* %2548
	%2552 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 111
	%2553 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 111
	%2554 = bitcast %runtime.Type_Info_Enum_Value* %2553 to i32*
	store i32 336, i32* %2554
	%2555 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2553, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2555
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$7f5, i64 0, i32 0), i64 8}, %..string* %2552
	%2556 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 112
	%2557 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 112
	%2558 = bitcast %runtime.Type_Info_Enum_Value* %2557 to i32*
	store i32 340, i32* %2558
	%2559 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2557, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2559
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$7f6, i64 0, i32 0), i64 10}, %..string* %2556
	%2560 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 113
	%2561 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 113
	%2562 = bitcast %runtime.Type_Info_Enum_Value* %2561 to i32*
	store i32 341, i32* %2562
	%2563 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2561, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2563
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$7f7, i64 0, i32 0), i64 12}, %..string* %2560
	%2564 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 114
	%2565 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 114
	%2566 = bitcast %runtime.Type_Info_Enum_Value* %2565 to i32*
	store i32 342, i32* %2566
	%2567 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2565, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2567
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$7f8, i64 0, i32 0), i64 8}, %..string* %2564
	%2568 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 115
	%2569 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 115
	%2570 = bitcast %runtime.Type_Info_Enum_Value* %2569 to i32*
	store i32 343, i32* %2570
	%2571 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2569, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2571
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$7f9, i64 0, i32 0), i64 10}, %..string* %2568
	%2572 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 116
	%2573 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 116
	%2574 = bitcast %runtime.Type_Info_Enum_Value* %2573 to i32*
	store i32 344, i32* %2574
	%2575 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2573, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2575
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$7fa, i64 0, i32 0), i64 11}, %..string* %2572
	%2576 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 117
	%2577 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 117
	%2578 = bitcast %runtime.Type_Info_Enum_Value* %2577 to i32*
	store i32 345, i32* %2578
	%2579 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2577, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2579
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$7fb, i64 0, i32 0), i64 13}, %..string* %2576
	%2580 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 118
	%2581 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 118
	%2582 = bitcast %runtime.Type_Info_Enum_Value* %2581 to i32*
	store i32 346, i32* %2582
	%2583 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2581, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2583
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$7fc, i64 0, i32 0), i64 9}, %..string* %2580
	%2584 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 119
	%2585 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 119
	%2586 = bitcast %runtime.Type_Info_Enum_Value* %2585 to i32*
	store i32 347, i32* %2586
	%2587 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2585, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2587
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$7fd, i64 0, i32 0), i64 11}, %..string* %2584
	%2588 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 120
	%2589 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 120
	%2590 = bitcast %runtime.Type_Info_Enum_Value* %2589 to i32*
	store i32 348, i32* %2590
	%2591 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2589, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2591
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$7fe, i64 0, i32 0), i64 8}, %..string* %2588
	%2592 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 121
	%2593 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 121
	%2594 = bitcast %runtime.Type_Info_Enum_Value* %2593 to i32*
	store i32 348, i32* %2594
	%2595 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2593, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2595
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$7ff, i64 0, i32 0), i64 4}, %..string* %2592
	%2596 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2105, i64 0, i32 1
	%2597 = getelementptr inbounds [122 x %..string], [122 x %..string]* @$enum_names-5e, i64 0, i32 0
	%2598 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2596, i64 0, i32 0
	store %..string* %2597, %..string** %2598
	%2599 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2596, i64 0, i32 1
	store i64 122, i64* %2599
	%2600 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2105, i64 0, i32 2
	%2601 = getelementptr inbounds [122 x %runtime.Type_Info_Enum_Value], [122 x %runtime.Type_Info_Enum_Value]* @$enum_values-5e, i64 0, i32 0
	%2602 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %2600, i64 0, i32 0
	store %runtime.Type_Info_Enum_Value* %2601, %runtime.Type_Info_Enum_Value** %2602
	%2603 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %2600, i64 0, i32 1
	store i64 122, i64* %2603
	%2604 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2105, align 8
	%2605 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2101 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %2604, %runtime.Type_Info_Enum* %2605
	%2606 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2101, i64 0, i32 2 ; UnionTagPtr
	store i8 18, i8* %2606
	%2607 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 79
	%2608 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2607, i64 0, i32 3
	%2609 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2607, i64 0, i32 0
	store i64 1, i64* %2609
	%2610 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2607, i64 0, i32 1
	store i64 1, i64* %2610
	%2611 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2607, i64 0, i32 2
	store %..typeid 432345564227567695, %..typeid* %2611
	; Type_Info_Basic
	%2612 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2608 to %runtime.Type_Info_Boolean*
	%2613 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %2612, align 1
	%2614 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2608 to %runtime.Type_Info_Boolean*
	store %runtime.Type_Info_Boolean %2613, %runtime.Type_Info_Boolean* %2614
	%2615 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2608, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %2615
	%2616 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 80
	%2617 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2616, i64 0, i32 3
	%2618 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2616, i64 0, i32 0
	store i64 2, i64* %2618
	%2619 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2616, i64 0, i32 1
	store i64 2, i64* %2619
	%2620 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2616, i64 0, i32 2
	store %..typeid 432345564227567696, %..typeid* %2620
	; Type_Info_Basic
	%2621 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2617 to %runtime.Type_Info_Boolean*
	%2622 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %2621, align 1
	%2623 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2617 to %runtime.Type_Info_Boolean*
	store %runtime.Type_Info_Boolean %2622, %runtime.Type_Info_Boolean* %2623
	%2624 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2617, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %2624
	%2625 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 81
	%2626 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2625, i64 0, i32 3
	%2627 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2625, i64 0, i32 0
	store i64 4, i64* %2627
	%2628 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2625, i64 0, i32 1
	store i64 4, i64* %2628
	%2629 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2625, i64 0, i32 2
	store %..typeid 432345564227567697, %..typeid* %2629
	; Type_Info_Basic
	%2630 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2626 to %runtime.Type_Info_Boolean*
	%2631 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %2630, align 1
	%2632 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2626 to %runtime.Type_Info_Boolean*
	store %runtime.Type_Info_Boolean %2631, %runtime.Type_Info_Boolean* %2632
	%2633 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2626, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %2633
	%2634 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 82
	%2635 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2634, i64 0, i32 3
	%2636 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2634, i64 0, i32 0
	store i64 8, i64* %2636
	%2637 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2634, i64 0, i32 1
	store i64 8, i64* %2637
	%2638 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2634, i64 0, i32 2
	store %..typeid 432345564227567698, %..typeid* %2638
	; Type_Info_Basic
	%2639 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2635 to %runtime.Type_Info_Boolean*
	%2640 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %2639, align 1
	%2641 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2635 to %runtime.Type_Info_Boolean*
	store %runtime.Type_Info_Boolean %2640, %runtime.Type_Info_Boolean* %2641
	%2642 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2635, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %2642
	%2643 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%2644 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2643, i64 0, i32 3
	%2645 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2643, i64 0, i32 0
	store i64 4, i64* %2645
	%2646 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2643, i64 0, i32 1
	store i64 4, i64* %2646
	%2647 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2643, i64 0, i32 2
	store %..typeid 216172782113783891, %..typeid* %2647
	; Type_Info_Basic
	%2648 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2644 to %runtime.Type_Info_Float*
	%2649 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %2648, align 1
	%2650 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2644 to %runtime.Type_Info_Float*
	store %runtime.Type_Info_Float %2649, %runtime.Type_Info_Float* %2650
	%2651 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2644, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2651
	%2652 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 84
	%2653 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2652, i64 0, i32 3
	%2654 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2652, i64 0, i32 0
	store i64 8, i64* %2654
	%2655 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2652, i64 0, i32 1
	store i64 8, i64* %2655
	%2656 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2652, i64 0, i32 2
	store %..typeid 216172782113783892, %..typeid* %2656
	; Type_Info_Basic
	%2657 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2653 to %runtime.Type_Info_Float*
	%2658 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %2657, align 1
	%2659 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2653 to %runtime.Type_Info_Float*
	store %runtime.Type_Info_Float %2658, %runtime.Type_Info_Float* %2659
	%2660 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2653, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2660
	%2661 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 85
	%2662 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2661, i64 0, i32 3
	%2663 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2661, i64 0, i32 0
	store i64 8, i64* %2663
	%2664 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2661, i64 0, i32 1
	store i64 4, i64* %2664
	%2665 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2661, i64 0, i32 2
	store %..typeid 288230376151711829, %..typeid* %2665
	; Type_Info_Basic
	%2666 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2662 to %runtime.Type_Info_Complex*
	%2667 = load %runtime.Type_Info_Complex, %runtime.Type_Info_Complex* %2666, align 1
	%2668 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2662 to %runtime.Type_Info_Complex*
	store %runtime.Type_Info_Complex %2667, %runtime.Type_Info_Complex* %2668
	%2669 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2662, i64 0, i32 2 ; UnionTagPtr
	store i8 5, i8* %2669
	%2670 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 86
	%2671 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2670, i64 0, i32 3
	%2672 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2670, i64 0, i32 0
	store i64 16, i64* %2672
	%2673 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2670, i64 0, i32 1
	store i64 8, i64* %2673
	%2674 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2670, i64 0, i32 2
	store %..typeid 288230376151711830, %..typeid* %2674
	; Type_Info_Basic
	%2675 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2671 to %runtime.Type_Info_Complex*
	%2676 = load %runtime.Type_Info_Complex, %runtime.Type_Info_Complex* %2675, align 1
	%2677 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2671 to %runtime.Type_Info_Complex*
	store %runtime.Type_Info_Complex %2676, %runtime.Type_Info_Complex* %2677
	%2678 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2671, i64 0, i32 2 ; UnionTagPtr
	store i8 5, i8* %2678
	%2679 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 87
	%2680 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2679, i64 0, i32 3
	%2681 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2679, i64 0, i32 0
	store i64 8, i64* %2681
	%2682 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2679, i64 0, i32 1
	store i64 8, i64* %2682
	%2683 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2679, i64 0, i32 2
	store %..typeid 4971973988617027671, %..typeid* %2683
	; Type_Info_Basic
	%2684 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2680 to %runtime.Type_Info_String*
	%2685 = getelementptr inbounds %runtime.Type_Info_String, %runtime.Type_Info_String* %2684, i64 0, i32 0
	store i8 1, i8* %2685
	%2686 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %2684, align 1
	%2687 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2680 to %runtime.Type_Info_String*
	store %runtime.Type_Info_String %2686, %runtime.Type_Info_String* %2687
	%2688 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2680, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %2688
	%2689 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 90
	%2690 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2689, i64 0, i32 3
	%2691 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2689, i64 0, i32 0
	store i64 4, i64* %2691
	%2692 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2689, i64 0, i32 1
	store i64 4, i64* %2692
	%2693 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2689, i64 0, i32 2
	store %..typeid 3530822107858468954, %..typeid* %2693
	; Type_Info_Named
	%2694 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2690 to %runtime.Type_Info_Named*
	%2695 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 91
	%2696 = bitcast %runtime.Type_Info* %2695 to %runtime.Type_Info*
	%2697 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2694, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$800, i64 0, i32 0), i64 6}, %..string* %2697
	%2698 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2694, i64 0, i32 1
	store %runtime.Type_Info* %2696, %runtime.Type_Info** %2698
	%2699 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2694, align 8
	%2700 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2690 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %2699, %runtime.Type_Info_Named* %2700
	%2701 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2690, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %2701
	%2702 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 91
	%2703 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2702, i64 0, i32 3
	%2704 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2702, i64 0, i32 0
	store i64 4, i64* %2704
	%2705 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2702, i64 0, i32 1
	store i64 4, i64* %2705
	%2706 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2702, i64 0, i32 2
	store %..typeid 1224979098644775003, %..typeid* %2706
	; Type_Info_Enum
	%2707 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2703 to %runtime.Type_Info_Enum*
	%2708 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%2709 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2707, i64 0, i32 0
	store %runtime.Type_Info* %2708, %runtime.Type_Info** %2709
	%2710 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-5b, i64 0, i32 0
	%2711 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-5b, i64 0, i32 0
	%2712 = bitcast %runtime.Type_Info_Enum_Value* %2711 to i32*
	store i32 0, i32* %2712
	%2713 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2711, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2713
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$801, i64 0, i32 0), i64 7}, %..string* %2710
	%2714 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-5b, i64 0, i32 1
	%2715 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-5b, i64 0, i32 1
	%2716 = bitcast %runtime.Type_Info_Enum_Value* %2715 to i32*
	store i32 1, i32* %2716
	%2717 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2715, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2717
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$802, i64 0, i32 0), i64 5}, %..string* %2714
	%2718 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-5b, i64 0, i32 2
	%2719 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-5b, i64 0, i32 2
	%2720 = bitcast %runtime.Type_Info_Enum_Value* %2719 to i32*
	store i32 2, i32* %2720
	%2721 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2719, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2721
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$803, i64 0, i32 0), i64 6}, %..string* %2718
	%2722 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2707, i64 0, i32 1
	%2723 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-5b, i64 0, i32 0
	%2724 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2722, i64 0, i32 0
	store %..string* %2723, %..string** %2724
	%2725 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2722, i64 0, i32 1
	store i64 3, i64* %2725
	%2726 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2707, i64 0, i32 2
	%2727 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-5b, i64 0, i32 0
	%2728 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %2726, i64 0, i32 0
	store %runtime.Type_Info_Enum_Value* %2727, %runtime.Type_Info_Enum_Value** %2728
	%2729 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %2726, i64 0, i32 1
	store i64 3, i64* %2729
	%2730 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2707, align 8
	%2731 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2703 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %2730, %runtime.Type_Info_Enum* %2731
	%2732 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2703, i64 0, i32 2 ; UnionTagPtr
	store i8 18, i8* %2732
	%2733 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 92
	%2734 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2733, i64 0, i32 3
	%2735 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2733, i64 0, i32 0
	store i64 8, i64* %2735
	%2736 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2733, i64 0, i32 1
	store i64 4, i64* %2736
	%2737 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2733, i64 0, i32 2
	store %..typeid 1152921504606847068, %..typeid* %2737
	; Type_Info_Union
	%2738 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2734 to %runtime.Type_Info_Union*
	%2739 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %2738, i64 0, i32 0
	%2740 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %2738, i64 0, i32 1
	%2741 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %2738, i64 0, i32 2
	%2742 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %2738, i64 0, i32 3
	%2743 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 77
	%2744 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 93
	%2745 = bitcast %runtime.Type_Info* %2744 to %runtime.Type_Info*
	%2746 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %2743, i64 0
	%2747 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 93
	store %runtime.Type_Info* %2747, %runtime.Type_Info** %2746
	%2748 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 95
	%2749 = bitcast %runtime.Type_Info* %2748 to %runtime.Type_Info*
	%2750 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %2743, i64 1
	%2751 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 95
	store %runtime.Type_Info* %2751, %runtime.Type_Info** %2750
	%2752 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %2739, i64 0, i32 0
	store %runtime.Type_Info** %2743, %runtime.Type_Info*** %2752
	%2753 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %2739, i64 0, i32 1
	store i64 2, i64* %2753
	store i64 4, i64* %2740
	%2754 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	store %runtime.Type_Info* %2754, %runtime.Type_Info** %2741
	store i8 0, i8* %2742
	%2755 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %2738, align 8
	%2756 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2734 to %runtime.Type_Info_Union*
	store %runtime.Type_Info_Union %2755, %runtime.Type_Info_Union* %2756
	%2757 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2734, i64 0, i32 2 ; UnionTagPtr
	store i8 17, i8* %2757
	%2758 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 95
	%2759 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2758, i64 0, i32 3
	%2760 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2758, i64 0, i32 0
	store i64 4, i64* %2760
	%2761 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2758, i64 0, i32 1
	store i64 4, i64* %2761
	%2762 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2758, i64 0, i32 2
	store %..typeid 3530822107858468959, %..typeid* %2762
	; Type_Info_Named
	%2763 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2759 to %runtime.Type_Info_Named*
	%2764 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 96
	%2765 = bitcast %runtime.Type_Info* %2764 to %runtime.Type_Info*
	%2766 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2763, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$804, i64 0, i32 0), i64 5}, %..string* %2766
	%2767 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2763, i64 0, i32 1
	store %runtime.Type_Info* %2765, %runtime.Type_Info** %2767
	%2768 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2763, align 8
	%2769 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2759 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %2768, %runtime.Type_Info_Named* %2769
	%2770 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2759, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %2770
	%2771 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 96
	%2772 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2771, i64 0, i32 3
	%2773 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2771, i64 0, i32 0
	store i64 4, i64* %2773
	%2774 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2771, i64 0, i32 1
	store i64 4, i64* %2774
	%2775 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2771, i64 0, i32 2
	store %..typeid 1224979098644775008, %..typeid* %2775
	; Type_Info_Enum
	%2776 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2772 to %runtime.Type_Info_Enum*
	%2777 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%2778 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2776, i64 0, i32 0
	store %runtime.Type_Info* %2777, %runtime.Type_Info** %2778
	%2779 = getelementptr inbounds [12 x %..string], [12 x %..string]* @$enum_names-60, i64 0, i32 0
	%2780 = getelementptr inbounds [12 x %runtime.Type_Info_Enum_Value], [12 x %runtime.Type_Info_Enum_Value]* @$enum_values-60, i64 0, i32 0
	%2781 = bitcast %runtime.Type_Info_Enum_Value* %2780 to i32*
	store i32 0, i32* %2781
	%2782 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2780, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2782
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$805, i64 0, i32 0), i64 8}, %..string* %2779
	%2783 = getelementptr inbounds [12 x %..string], [12 x %..string]* @$enum_names-60, i64 0, i32 1
	%2784 = getelementptr inbounds [12 x %runtime.Type_Info_Enum_Value], [12 x %runtime.Type_Info_Enum_Value]* @$enum_values-60, i64 0, i32 1
	%2785 = bitcast %runtime.Type_Info_Enum_Value* %2784 to i32*
	store i32 1, i32* %2785
	%2786 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2784, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2786
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$806, i64 0, i32 0), i64 8}, %..string* %2783
	%2787 = getelementptr inbounds [12 x %..string], [12 x %..string]* @$enum_names-60, i64 0, i32 2
	%2788 = getelementptr inbounds [12 x %runtime.Type_Info_Enum_Value], [12 x %runtime.Type_Info_Enum_Value]* @$enum_values-60, i64 0, i32 2
	%2789 = bitcast %runtime.Type_Info_Enum_Value* %2788 to i32*
	store i32 2, i32* %2789
	%2790 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2788, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2790
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$807, i64 0, i32 0), i64 8}, %..string* %2787
	%2791 = getelementptr inbounds [12 x %..string], [12 x %..string]* @$enum_names-60, i64 0, i32 3
	%2792 = getelementptr inbounds [12 x %runtime.Type_Info_Enum_Value], [12 x %runtime.Type_Info_Enum_Value]* @$enum_values-60, i64 0, i32 3
	%2793 = bitcast %runtime.Type_Info_Enum_Value* %2792 to i32*
	store i32 3, i32* %2793
	%2794 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2792, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2794
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$808, i64 0, i32 0), i64 8}, %..string* %2791
	%2795 = getelementptr inbounds [12 x %..string], [12 x %..string]* @$enum_names-60, i64 0, i32 4
	%2796 = getelementptr inbounds [12 x %runtime.Type_Info_Enum_Value], [12 x %runtime.Type_Info_Enum_Value]* @$enum_values-60, i64 0, i32 4
	%2797 = bitcast %runtime.Type_Info_Enum_Value* %2796 to i32*
	store i32 4, i32* %2797
	%2798 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2796, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2798
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$809, i64 0, i32 0), i64 8}, %..string* %2795
	%2799 = getelementptr inbounds [12 x %..string], [12 x %..string]* @$enum_names-60, i64 0, i32 5
	%2800 = getelementptr inbounds [12 x %runtime.Type_Info_Enum_Value], [12 x %runtime.Type_Info_Enum_Value]* @$enum_values-60, i64 0, i32 5
	%2801 = bitcast %runtime.Type_Info_Enum_Value* %2800 to i32*
	store i32 5, i32* %2801
	%2802 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2800, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2802
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$80a, i64 0, i32 0), i64 8}, %..string* %2799
	%2803 = getelementptr inbounds [12 x %..string], [12 x %..string]* @$enum_names-60, i64 0, i32 6
	%2804 = getelementptr inbounds [12 x %runtime.Type_Info_Enum_Value], [12 x %runtime.Type_Info_Enum_Value]* @$enum_values-60, i64 0, i32 6
	%2805 = bitcast %runtime.Type_Info_Enum_Value* %2804 to i32*
	store i32 6, i32* %2805
	%2806 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2804, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2806
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$80b, i64 0, i32 0), i64 8}, %..string* %2803
	%2807 = getelementptr inbounds [12 x %..string], [12 x %..string]* @$enum_names-60, i64 0, i32 7
	%2808 = getelementptr inbounds [12 x %runtime.Type_Info_Enum_Value], [12 x %runtime.Type_Info_Enum_Value]* @$enum_values-60, i64 0, i32 7
	%2809 = bitcast %runtime.Type_Info_Enum_Value* %2808 to i32*
	store i32 7, i32* %2809
	%2810 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2808, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2810
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$80c, i64 0, i32 0), i64 8}, %..string* %2807
	%2811 = getelementptr inbounds [12 x %..string], [12 x %..string]* @$enum_names-60, i64 0, i32 8
	%2812 = getelementptr inbounds [12 x %runtime.Type_Info_Enum_Value], [12 x %runtime.Type_Info_Enum_Value]* @$enum_values-60, i64 0, i32 8
	%2813 = bitcast %runtime.Type_Info_Enum_Value* %2812 to i32*
	store i32 7, i32* %2813
	%2814 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2812, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2814
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$80d, i64 0, i32 0), i64 4}, %..string* %2811
	%2815 = getelementptr inbounds [12 x %..string], [12 x %..string]* @$enum_names-60, i64 0, i32 9
	%2816 = getelementptr inbounds [12 x %runtime.Type_Info_Enum_Value], [12 x %runtime.Type_Info_Enum_Value]* @$enum_values-60, i64 0, i32 9
	%2817 = bitcast %runtime.Type_Info_Enum_Value* %2816 to i32*
	store i32 0, i32* %2817
	%2818 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2816, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2818
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$80e, i64 0, i32 0), i64 4}, %..string* %2815
	%2819 = getelementptr inbounds [12 x %..string], [12 x %..string]* @$enum_names-60, i64 0, i32 10
	%2820 = getelementptr inbounds [12 x %runtime.Type_Info_Enum_Value], [12 x %runtime.Type_Info_Enum_Value]* @$enum_values-60, i64 0, i32 10
	%2821 = bitcast %runtime.Type_Info_Enum_Value* %2820 to i32*
	store i32 1, i32* %2821
	%2822 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2820, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2822
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$80f, i64 0, i32 0), i64 5}, %..string* %2819
	%2823 = getelementptr inbounds [12 x %..string], [12 x %..string]* @$enum_names-60, i64 0, i32 11
	%2824 = getelementptr inbounds [12 x %runtime.Type_Info_Enum_Value], [12 x %runtime.Type_Info_Enum_Value]* @$enum_values-60, i64 0, i32 11
	%2825 = bitcast %runtime.Type_Info_Enum_Value* %2824 to i32*
	store i32 2, i32* %2825
	%2826 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2824, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %2826
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$810, i64 0, i32 0), i64 6}, %..string* %2823
	%2827 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2776, i64 0, i32 1
	%2828 = getelementptr inbounds [12 x %..string], [12 x %..string]* @$enum_names-60, i64 0, i32 0
	%2829 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2827, i64 0, i32 0
	store %..string* %2828, %..string** %2829
	%2830 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2827, i64 0, i32 1
	store i64 12, i64* %2830
	%2831 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2776, i64 0, i32 2
	%2832 = getelementptr inbounds [12 x %runtime.Type_Info_Enum_Value], [12 x %runtime.Type_Info_Enum_Value]* @$enum_values-60, i64 0, i32 0
	%2833 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %2831, i64 0, i32 0
	store %runtime.Type_Info_Enum_Value* %2832, %runtime.Type_Info_Enum_Value** %2833
	%2834 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %2831, i64 0, i32 1
	store i64 12, i64* %2834
	%2835 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2776, align 8
	%2836 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2772 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %2835, %runtime.Type_Info_Enum* %2836
	%2837 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2772, i64 0, i32 2 ; UnionTagPtr
	store i8 18, i8* %2837
	%2838 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 124
	%2839 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2838, i64 0, i32 3
	%2840 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2838, i64 0, i32 0
	store i64 48, i64* %2840
	%2841 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2838, i64 0, i32 1
	store i64 8, i64* %2841
	%2842 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2838, i64 0, i32 2
	store %..typeid 3386706919782613116, %..typeid* %2842
	; Type_Info_Named
	%2843 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2839 to %runtime.Type_Info_Named*
	%2844 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 125
	%2845 = bitcast %runtime.Type_Info* %2844 to %runtime.Type_Info*
	%2846 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2843, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$811, i64 0, i32 0), i64 20}, %..string* %2846
	%2847 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2843, i64 0, i32 1
	store %runtime.Type_Info* %2845, %runtime.Type_Info** %2847
	%2848 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2843, align 8
	%2849 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2839 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %2848, %runtime.Type_Info_Named* %2849
	%2850 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2839, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %2850
	%2851 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 125
	%2852 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2851, i64 0, i32 3
	%2853 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2851, i64 0, i32 0
	store i64 48, i64* %2853
	%2854 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2851, i64 0, i32 1
	store i64 8, i64* %2854
	%2855 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2851, i64 0, i32 2
	store %..typeid 1080863910568919165, %..typeid* %2855
	; Type_Info_Struct
	%2856 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2852 to %runtime.Type_Info_Struct*
	%2857 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2856, i64 0, i32 4
	store i8 0, i8* %2857
	%2858 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2856, i64 0, i32 5
	store i8 0, i8* %2858
	%2859 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2856, i64 0, i32 6
	store i8 0, i8* %2859
	%2860 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 79
	%2861 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 44
	%2862 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 44
	%2863 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 44
	%2864 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%2865 = bitcast %runtime.Type_Info* %2864 to %runtime.Type_Info*
	%2866 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %2860, i64 0
	%2867 = getelementptr inbounds i64, i64* %2862, i64 0
	%2868 = getelementptr inbounds i8, i8* %2863, i64 0
	%2869 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	store %runtime.Type_Info* %2869, %runtime.Type_Info** %2866
	%2870 = getelementptr inbounds %..string, %..string* %2861, i64 0
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$812, i64 0, i32 0), i64 9}, %..string* %2870
	store i64 0, i64* %2867
	store i8 0, i8* %2868
	%2871 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%2872 = bitcast %runtime.Type_Info* %2871 to %runtime.Type_Info*
	%2873 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %2860, i64 1
	%2874 = getelementptr inbounds i64, i64* %2862, i64 1
	%2875 = getelementptr inbounds i8, i8* %2863, i64 1
	%2876 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %2876, %runtime.Type_Info** %2873
	%2877 = getelementptr inbounds %..string, %..string* %2861, i64 1
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$813, i64 0, i32 0), i64 4}, %..string* %2877
	store i64 16, i64* %2874
	store i8 0, i8* %2875
	%2878 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%2879 = bitcast %runtime.Type_Info* %2878 to %runtime.Type_Info*
	%2880 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %2860, i64 2
	%2881 = getelementptr inbounds i64, i64* %2862, i64 2
	%2882 = getelementptr inbounds i8, i8* %2863, i64 2
	%2883 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %2883, %runtime.Type_Info** %2880
	%2884 = getelementptr inbounds %..string, %..string* %2861, i64 2
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$814, i64 0, i32 0), i64 6}, %..string* %2884
	store i64 24, i64* %2881
	store i8 0, i8* %2882
	%2885 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%2886 = bitcast %runtime.Type_Info* %2885 to %runtime.Type_Info*
	%2887 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %2860, i64 3
	%2888 = getelementptr inbounds i64, i64* %2862, i64 3
	%2889 = getelementptr inbounds i8, i8* %2863, i64 3
	%2890 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	store %runtime.Type_Info* %2890, %runtime.Type_Info** %2887
	%2891 = getelementptr inbounds %..string, %..string* %2861, i64 3
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$815, i64 0, i32 0), i64 9}, %..string* %2891
	store i64 32, i64* %2888
	store i8 0, i8* %2889
	%2892 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2856, i64 0, i32 0
	%2893 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %2892, i64 0, i32 0
	store %runtime.Type_Info** %2860, %runtime.Type_Info*** %2893
	%2894 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %2892, i64 0, i32 1
	store i64 4, i64* %2894
	%2895 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2856, i64 0, i32 1
	%2896 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2895, i64 0, i32 0
	store %..string* %2861, %..string** %2896
	%2897 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2895, i64 0, i32 1
	store i64 4, i64* %2897
	%2898 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2856, i64 0, i32 2
	%2899 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %2898, i64 0, i32 0
	store i64* %2862, i64** %2899
	%2900 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %2898, i64 0, i32 1
	store i64 4, i64* %2900
	%2901 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2856, i64 0, i32 3
	%2902 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2901, i64 0, i32 0
	store i8* %2863, i8** %2902
	%2903 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2901, i64 0, i32 1
	store i64 4, i64* %2903
	%2904 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2856, align 8
	%2905 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2852 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %2904, %runtime.Type_Info_Struct* %2905
	%2906 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2852, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %2906
	%2907 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 152
	%2908 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2907, i64 0, i32 3
	%2909 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2907, i64 0, i32 0
	store i64 4, i64* %2909
	%2910 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2907, i64 0, i32 1
	store i64 4, i64* %2910
	%2911 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2907, i64 0, i32 2
	store %..typeid 3530822107858469016, %..typeid* %2911
	; Type_Info_Named
	%2912 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2908 to %runtime.Type_Info_Named*
	%2913 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 153
	%2914 = bitcast %runtime.Type_Info* %2913 to %runtime.Type_Info*
	%2915 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2912, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$816, i64 0, i32 0), i64 18}, %..string* %2915
	%2916 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2912, i64 0, i32 1
	store %runtime.Type_Info* %2914, %runtime.Type_Info** %2916
	%2917 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2912, align 8
	%2918 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2908 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %2917, %runtime.Type_Info_Named* %2918
	%2919 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2908, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %2919
	%2920 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 153
	%2921 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2920, i64 0, i32 3
	%2922 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2920, i64 0, i32 0
	store i64 4, i64* %2922
	%2923 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2920, i64 0, i32 1
	store i64 4, i64* %2923
	%2924 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2920, i64 0, i32 2
	store %..typeid 1224979098644775065, %..typeid* %2924
	; Type_Info_Enum
	%2925 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2921 to %runtime.Type_Info_Enum*
	%2926 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 66
	%2927 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2925, i64 0, i32 0
	store %runtime.Type_Info* %2926, %runtime.Type_Info** %2927
	%2928 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 0
	%2929 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 0
	%2930 = bitcast %runtime.Type_Info_Enum_Value* %2929 to i32*
	store i32 1, i32* %2930
	%2931 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2929, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2931
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$817, i64 0, i32 0), i64 16}, %..string* %2928
	%2932 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 1
	%2933 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 1
	%2934 = bitcast %runtime.Type_Info_Enum_Value* %2933 to i32*
	store i32 2, i32* %2934
	%2935 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2933, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2935
	store %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$818, i64 0, i32 0), i64 21}, %..string* %2932
	%2936 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 2
	%2937 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 2
	%2938 = bitcast %runtime.Type_Info_Enum_Value* %2937 to i32*
	store i32 4, i32* %2938
	%2939 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2937, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2939
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$819, i64 0, i32 0), i64 14}, %..string* %2936
	%2940 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 3
	%2941 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 3
	%2942 = bitcast %runtime.Type_Info_Enum_Value* %2941 to i32*
	store i32 8, i32* %2942
	%2943 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2941, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2943
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$81a, i64 0, i32 0), i64 11}, %..string* %2940
	%2944 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 4
	%2945 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 4
	%2946 = bitcast %runtime.Type_Info_Enum_Value* %2945 to i32*
	store i32 16, i32* %2946
	%2947 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2945, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2947
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$81b, i64 0, i32 0), i64 15}, %..string* %2944
	%2948 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 5
	%2949 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 5
	%2950 = bitcast %runtime.Type_Info_Enum_Value* %2949 to i32*
	store i32 32, i32* %2950
	%2951 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2949, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2951
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$81c, i64 0, i32 0), i64 10}, %..string* %2948
	%2952 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 6
	%2953 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 6
	%2954 = bitcast %runtime.Type_Info_Enum_Value* %2953 to i32*
	store i32 64, i32* %2954
	%2955 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2953, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2955
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$81d, i64 0, i32 0), i64 16}, %..string* %2952
	%2956 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 7
	%2957 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 7
	%2958 = bitcast %runtime.Type_Info_Enum_Value* %2957 to i32*
	store i32 128, i32* %2958
	%2959 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2957, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2959
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$81e, i64 0, i32 0), i64 16}, %..string* %2956
	%2960 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 8
	%2961 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 8
	%2962 = bitcast %runtime.Type_Info_Enum_Value* %2961 to i32*
	store i32 256, i32* %2962
	%2963 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2961, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2963
	store %..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$81f, i64 0, i32 0), i64 20}, %..string* %2960
	%2964 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 9
	%2965 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 9
	%2966 = bitcast %runtime.Type_Info_Enum_Value* %2965 to i32*
	store i32 512, i32* %2966
	%2967 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2965, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2967
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$820, i64 0, i32 0), i64 16}, %..string* %2964
	%2968 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 10
	%2969 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 10
	%2970 = bitcast %runtime.Type_Info_Enum_Value* %2969 to i32*
	store i32 1024, i32* %2970
	%2971 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2969, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2971
	store %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$821, i64 0, i32 0), i64 21}, %..string* %2968
	%2972 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 11
	%2973 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 11
	%2974 = bitcast %runtime.Type_Info_Enum_Value* %2973 to i32*
	store i32 2048, i32* %2974
	%2975 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2973, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2975
	store %..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$822, i64 0, i32 0), i64 20}, %..string* %2972
	%2976 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 12
	%2977 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 12
	%2978 = bitcast %runtime.Type_Info_Enum_Value* %2977 to i32*
	store i32 4096, i32* %2978
	%2979 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2977, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2979
	store %..string {i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$823, i64 0, i32 0), i64 24}, %..string* %2976
	%2980 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 13
	%2981 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 13
	%2982 = bitcast %runtime.Type_Info_Enum_Value* %2981 to i32*
	store i32 8192, i32* %2982
	%2983 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2981, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2983
	store %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$824, i64 0, i32 0), i64 18}, %..string* %2980
	%2984 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 14
	%2985 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 14
	%2986 = bitcast %runtime.Type_Info_Enum_Value* %2985 to i32*
	store i32 32768, i32* %2986
	%2987 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2985, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2987
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$825, i64 0, i32 0), i64 11}, %..string* %2984
	%2988 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 15
	%2989 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 15
	%2990 = bitcast %runtime.Type_Info_Enum_Value* %2989 to i32*
	store i32 65536, i32* %2990
	%2991 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2989, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2991
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$826, i64 0, i32 0), i64 15}, %..string* %2988
	%2992 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 16
	%2993 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 16
	%2994 = bitcast %runtime.Type_Info_Enum_Value* %2993 to i32*
	store i32 131072, i32* %2994
	%2995 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2993, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2995
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$827, i64 0, i32 0), i64 15}, %..string* %2992
	%2996 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 17
	%2997 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 17
	%2998 = bitcast %runtime.Type_Info_Enum_Value* %2997 to i32*
	store i32 262144, i32* %2998
	%2999 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2997, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %2999
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$828, i64 0, i32 0), i64 11}, %..string* %2996
	%3000 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 18
	%3001 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 18
	%3002 = bitcast %runtime.Type_Info_Enum_Value* %3001 to i32*
	store i32 524288, i32* %3002
	%3003 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3001, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %3003
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$829, i64 0, i32 0), i64 17}, %..string* %3000
	%3004 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 19
	%3005 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 19
	%3006 = bitcast %runtime.Type_Info_Enum_Value* %3005 to i32*
	store i32 1048576, i32* %3006
	%3007 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3005, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %3007
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$82a, i64 0, i32 0), i64 13}, %..string* %3004
	%3008 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 20
	%3009 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 20
	%3010 = bitcast %runtime.Type_Info_Enum_Value* %3009 to i32*
	store i32 2097152, i32* %3010
	%3011 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3009, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %3011
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$82b, i64 0, i32 0), i64 14}, %..string* %3008
	%3012 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 21
	%3013 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 21
	%3014 = bitcast %runtime.Type_Info_Enum_Value* %3013 to i32*
	store i32 4194304, i32* %3014
	%3015 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3013, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %3015
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$82c, i64 0, i32 0), i64 13}, %..string* %3012
	%3016 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 22
	%3017 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 22
	%3018 = bitcast %runtime.Type_Info_Enum_Value* %3017 to i32*
	store i32 8388608, i32* %3018
	%3019 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3017, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %3019
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$82d, i64 0, i32 0), i64 7}, %..string* %3016
	%3020 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 23
	%3021 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 23
	%3022 = bitcast %runtime.Type_Info_Enum_Value* %3021 to i32*
	store i32 16777216, i32* %3022
	%3023 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3021, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %3023
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$82e, i64 0, i32 0), i64 16}, %..string* %3020
	%3024 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2925, i64 0, i32 1
	%3025 = getelementptr inbounds [24 x %..string], [24 x %..string]* @$enum_names-99, i64 0, i32 0
	%3026 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3024, i64 0, i32 0
	store %..string* %3025, %..string** %3026
	%3027 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3024, i64 0, i32 1
	store i64 24, i64* %3027
	%3028 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2925, i64 0, i32 2
	%3029 = getelementptr inbounds [24 x %runtime.Type_Info_Enum_Value], [24 x %runtime.Type_Info_Enum_Value]* @$enum_values-99, i64 0, i32 0
	%3030 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %3028, i64 0, i32 0
	store %runtime.Type_Info_Enum_Value* %3029, %runtime.Type_Info_Enum_Value** %3030
	%3031 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %3028, i64 0, i32 1
	store i64 24, i64* %3031
	%3032 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2925, align 8
	%3033 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2921 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %3032, %runtime.Type_Info_Enum* %3033
	%3034 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2921, i64 0, i32 2 ; UnionTagPtr
	store i8 18, i8* %3034
	%3035 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 97
	%3036 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3035, i64 0, i32 3
	%3037 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3035, i64 0, i32 0
	store i64 4, i64* %3037
	%3038 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3035, i64 0, i32 1
	store i64 4, i64* %3038
	%3039 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3035, i64 0, i32 2
	store %..typeid 3530822107858468961, %..typeid* %3039
	; Type_Info_Named
	%3040 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3036 to %runtime.Type_Info_Named*
	%3041 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 98
	%3042 = bitcast %runtime.Type_Info* %3041 to %runtime.Type_Info*
	%3043 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3040, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$82f, i64 0, i32 0), i64 11}, %..string* %3043
	%3044 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3040, i64 0, i32 1
	store %runtime.Type_Info* %3042, %runtime.Type_Info** %3044
	%3045 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3040, align 8
	%3046 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3036 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %3045, %runtime.Type_Info_Named* %3046
	%3047 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3036, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %3047
	%3048 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 98
	%3049 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3048, i64 0, i32 3
	%3050 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3048, i64 0, i32 0
	store i64 4, i64* %3050
	%3051 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3048, i64 0, i32 1
	store i64 4, i64* %3051
	%3052 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3048, i64 0, i32 2
	store %..typeid 1224979098644775010, %..typeid* %3052
	; Type_Info_Enum
	%3053 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3049 to %runtime.Type_Info_Enum*
	%3054 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%3055 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %3053, i64 0, i32 0
	store %runtime.Type_Info* %3054, %runtime.Type_Info** %3055
	%3056 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-62, i64 0, i32 0
	%3057 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-62, i64 0, i32 0
	%3058 = bitcast %runtime.Type_Info_Enum_Value* %3057 to i32*
	store i32 35632, i32* %3058
	%3059 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3057, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %3059
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$830, i64 0, i32 0), i64 15}, %..string* %3056
	%3060 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-62, i64 0, i32 1
	%3061 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-62, i64 0, i32 1
	%3062 = bitcast %runtime.Type_Info_Enum_Value* %3061 to i32*
	store i32 35633, i32* %3062
	%3063 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3061, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %3063
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$831, i64 0, i32 0), i64 13}, %..string* %3060
	%3064 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-62, i64 0, i32 2
	%3065 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-62, i64 0, i32 2
	%3066 = bitcast %runtime.Type_Info_Enum_Value* %3065 to i32*
	store i32 36313, i32* %3066
	%3067 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3065, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %3067
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$832, i64 0, i32 0), i64 15}, %..string* %3064
	%3068 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-62, i64 0, i32 3
	%3069 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-62, i64 0, i32 3
	%3070 = bitcast %runtime.Type_Info_Enum_Value* %3069 to i32*
	store i32 37305, i32* %3070
	%3071 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3069, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %3071
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$833, i64 0, i32 0), i64 14}, %..string* %3068
	%3072 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-62, i64 0, i32 4
	%3073 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-62, i64 0, i32 4
	%3074 = bitcast %runtime.Type_Info_Enum_Value* %3073 to i32*
	store i32 36487, i32* %3074
	%3075 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3073, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %3075
	store %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$834, i64 0, i32 0), i64 22}, %..string* %3072
	%3076 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-62, i64 0, i32 5
	%3077 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-62, i64 0, i32 5
	%3078 = bitcast %runtime.Type_Info_Enum_Value* %3077 to i32*
	store i32 36488, i32* %3078
	%3079 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3077, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %3079
	store %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$835, i64 0, i32 0), i64 19}, %..string* %3076
	%3080 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-62, i64 0, i32 6
	%3081 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-62, i64 0, i32 6
	%3082 = bitcast %runtime.Type_Info_Enum_Value* %3081 to i32*
	store i32 0, i32* %3082
	%3083 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3081, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %3083
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$836, i64 0, i32 0), i64 11}, %..string* %3080
	%3084 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %3053, i64 0, i32 1
	%3085 = getelementptr inbounds [7 x %..string], [7 x %..string]* @$enum_names-62, i64 0, i32 0
	%3086 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3084, i64 0, i32 0
	store %..string* %3085, %..string** %3086
	%3087 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3084, i64 0, i32 1
	store i64 7, i64* %3087
	%3088 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %3053, i64 0, i32 2
	%3089 = getelementptr inbounds [7 x %runtime.Type_Info_Enum_Value], [7 x %runtime.Type_Info_Enum_Value]* @$enum_values-62, i64 0, i32 0
	%3090 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %3088, i64 0, i32 0
	store %runtime.Type_Info_Enum_Value* %3089, %runtime.Type_Info_Enum_Value** %3090
	%3091 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %3088, i64 0, i32 1
	store i64 7, i64* %3091
	%3092 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %3053, align 8
	%3093 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3049 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %3092, %runtime.Type_Info_Enum* %3093
	%3094 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3049, i64 0, i32 2 ; UnionTagPtr
	store i8 18, i8* %3094
	%3095 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 103
	%3096 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3095, i64 0, i32 3
	%3097 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3095, i64 0, i32 0
	store i64 16, i64* %3097
	%3098 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3095, i64 0, i32 1
	store i64 8, i64* %3098
	%3099 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3095, i64 0, i32 2
	store %..typeid 1152921504606847079, %..typeid* %3099
	; Type_Info_Union
	%3100 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3096 to %runtime.Type_Info_Union*
	%3101 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %3100, i64 0, i32 0
	%3102 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %3100, i64 0, i32 1
	%3103 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %3100, i64 0, i32 2
	%3104 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %3100, i64 0, i32 3
	%3105 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 83
	%3106 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 104
	%3107 = bitcast %runtime.Type_Info* %3106 to %runtime.Type_Info*
	%3108 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3105, i64 0
	%3109 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 104
	store %runtime.Type_Info* %3109, %runtime.Type_Info** %3108
	%3110 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 105
	%3111 = bitcast %runtime.Type_Info* %3110 to %runtime.Type_Info*
	%3112 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3105, i64 1
	%3113 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 105
	store %runtime.Type_Info* %3113, %runtime.Type_Info** %3112
	%3114 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 108
	%3115 = bitcast %runtime.Type_Info* %3114 to %runtime.Type_Info*
	%3116 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3105, i64 2
	%3117 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 108
	store %runtime.Type_Info* %3117, %runtime.Type_Info** %3116
	%3118 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 111
	%3119 = bitcast %runtime.Type_Info* %3118 to %runtime.Type_Info*
	%3120 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3105, i64 3
	%3121 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 111
	store %runtime.Type_Info* %3121, %runtime.Type_Info** %3120
	%3122 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3101, i64 0, i32 0
	store %runtime.Type_Info** %3105, %runtime.Type_Info*** %3122
	%3123 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3101, i64 0, i32 1
	store i64 4, i64* %3123
	store i64 8, i64* %3102
	%3124 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	store %runtime.Type_Info* %3124, %runtime.Type_Info** %3103
	store i8 0, i8* %3104
	%3125 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %3100, align 8
	%3126 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3096 to %runtime.Type_Info_Union*
	store %runtime.Type_Info_Union %3125, %runtime.Type_Info_Union* %3126
	%3127 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3096, i64 0, i32 2 ; UnionTagPtr
	store i8 17, i8* %3127
	%3128 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 104
	%3129 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3128, i64 0, i32 3
	%3130 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3128, i64 0, i32 0
	store i64 8, i64* %3130
	%3131 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3128, i64 0, i32 1
	store i64 8, i64* %3131
	%3132 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3128, i64 0, i32 2
	store %..typeid 648518346341351528, %..typeid* %3132
	; Type_Info_Pointer
	%3133 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3129 to %runtime.Type_Info_Pointer*
	%3134 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%3135 = bitcast %runtime.Type_Info* %3134 to %runtime.Type_Info*
	%3136 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %3133, i64 0, i32 0
	store %runtime.Type_Info* %3135, %runtime.Type_Info** %3136
	%3137 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %3133, align 8
	%3138 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3129 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %3137, %runtime.Type_Info_Pointer* %3138
	%3139 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3129, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %3139
	%3140 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 105
	%3141 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3140, i64 0, i32 3
	%3142 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3140, i64 0, i32 0
	store i64 8, i64* %3142
	%3143 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3140, i64 0, i32 1
	store i64 8, i64* %3143
	%3144 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3140, i64 0, i32 2
	store %..typeid 648518346341351529, %..typeid* %3144
	; Type_Info_Pointer
	%3145 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3141 to %runtime.Type_Info_Pointer*
	%3146 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 106
	%3147 = bitcast %runtime.Type_Info* %3146 to %runtime.Type_Info*
	%3148 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %3145, i64 0, i32 0
	store %runtime.Type_Info* %3147, %runtime.Type_Info** %3148
	%3149 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %3145, align 8
	%3150 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3141 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %3149, %runtime.Type_Info_Pointer* %3150
	%3151 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3141, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %3151
	%3152 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 106
	%3153 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3152, i64 0, i32 3
	%3154 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3152, i64 0, i32 0
	store i64 8, i64* %3154
	%3155 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3152, i64 0, i32 1
	store i64 4, i64* %3155
	%3156 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3152, i64 0, i32 2
	store %..typeid 3098476543630901354, %..typeid* %3156
	; Type_Info_Named
	%3157 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3153 to %runtime.Type_Info_Named*
	%3158 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 107
	%3159 = bitcast %runtime.Type_Info* %3158 to %runtime.Type_Info*
	%3160 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3157, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$837, i64 0, i32 0), i64 4}, %..string* %3160
	%3161 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3157, i64 0, i32 1
	store %runtime.Type_Info* %3159, %runtime.Type_Info** %3161
	%3162 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3157, align 8
	%3163 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3153 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %3162, %runtime.Type_Info_Named* %3163
	%3164 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3153, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %3164
	%3165 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 107
	%3166 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3165, i64 0, i32 3
	%3167 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3165, i64 0, i32 0
	store i64 8, i64* %3167
	%3168 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3165, i64 0, i32 1
	store i64 4, i64* %3168
	%3169 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3165, i64 0, i32 2
	store %..typeid 792633534417207403, %..typeid* %3169
	; Type_Info_Array
	%3170 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3166 to %runtime.Type_Info_Array*
	%3171 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%3172 = bitcast %runtime.Type_Info* %3171 to %runtime.Type_Info*
	%3173 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %3170, i64 0, i32 0
	store %runtime.Type_Info* %3172, %runtime.Type_Info** %3173
	%3174 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %3170, i64 0, i32 1
	store i64 4, i64* %3174
	%3175 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %3170, i64 0, i32 2
	store i64 2, i64* %3175
	%3176 = load %runtime.Type_Info_Array, %runtime.Type_Info_Array* %3170, align 8
	%3177 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3166 to %runtime.Type_Info_Array*
	store %runtime.Type_Info_Array %3176, %runtime.Type_Info_Array* %3177
	%3178 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3166, i64 0, i32 2 ; UnionTagPtr
	store i8 12, i8* %3178
	%3179 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 108
	%3180 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3179, i64 0, i32 3
	%3181 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3179, i64 0, i32 0
	store i64 8, i64* %3181
	%3182 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3179, i64 0, i32 1
	store i64 8, i64* %3182
	%3183 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3179, i64 0, i32 2
	store %..typeid 648518346341351532, %..typeid* %3183
	; Type_Info_Pointer
	%3184 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3180 to %runtime.Type_Info_Pointer*
	%3185 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 109
	%3186 = bitcast %runtime.Type_Info* %3185 to %runtime.Type_Info*
	%3187 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %3184, i64 0, i32 0
	store %runtime.Type_Info* %3186, %runtime.Type_Info** %3187
	%3188 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %3184, align 8
	%3189 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3180 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %3188, %runtime.Type_Info_Pointer* %3189
	%3190 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3180, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %3190
	%3191 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 109
	%3192 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3191, i64 0, i32 3
	%3193 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3191, i64 0, i32 0
	store i64 12, i64* %3193
	%3194 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3191, i64 0, i32 1
	store i64 4, i64* %3194
	%3195 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3191, i64 0, i32 2
	store %..typeid 3098476543630901357, %..typeid* %3195
	; Type_Info_Named
	%3196 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3192 to %runtime.Type_Info_Named*
	%3197 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 110
	%3198 = bitcast %runtime.Type_Info* %3197 to %runtime.Type_Info*
	%3199 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3196, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$838, i64 0, i32 0), i64 4}, %..string* %3199
	%3200 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3196, i64 0, i32 1
	store %runtime.Type_Info* %3198, %runtime.Type_Info** %3200
	%3201 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3196, align 8
	%3202 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3192 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %3201, %runtime.Type_Info_Named* %3202
	%3203 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3192, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %3203
	%3204 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 110
	%3205 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3204, i64 0, i32 3
	%3206 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3204, i64 0, i32 0
	store i64 12, i64* %3206
	%3207 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3204, i64 0, i32 1
	store i64 4, i64* %3207
	%3208 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3204, i64 0, i32 2
	store %..typeid 792633534417207406, %..typeid* %3208
	; Type_Info_Array
	%3209 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3205 to %runtime.Type_Info_Array*
	%3210 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%3211 = bitcast %runtime.Type_Info* %3210 to %runtime.Type_Info*
	%3212 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %3209, i64 0, i32 0
	store %runtime.Type_Info* %3211, %runtime.Type_Info** %3212
	%3213 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %3209, i64 0, i32 1
	store i64 4, i64* %3213
	%3214 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %3209, i64 0, i32 2
	store i64 3, i64* %3214
	%3215 = load %runtime.Type_Info_Array, %runtime.Type_Info_Array* %3209, align 8
	%3216 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3205 to %runtime.Type_Info_Array*
	store %runtime.Type_Info_Array %3215, %runtime.Type_Info_Array* %3216
	%3217 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3205, i64 0, i32 2 ; UnionTagPtr
	store i8 12, i8* %3217
	%3218 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 111
	%3219 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3218, i64 0, i32 3
	%3220 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3218, i64 0, i32 0
	store i64 8, i64* %3220
	%3221 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3218, i64 0, i32 1
	store i64 8, i64* %3221
	%3222 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3218, i64 0, i32 2
	store %..typeid 648518346341351535, %..typeid* %3222
	; Type_Info_Pointer
	%3223 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3219 to %runtime.Type_Info_Pointer*
	%3224 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 112
	%3225 = bitcast %runtime.Type_Info* %3224 to %runtime.Type_Info*
	%3226 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %3223, i64 0, i32 0
	store %runtime.Type_Info* %3225, %runtime.Type_Info** %3226
	%3227 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %3223, align 8
	%3228 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3219 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %3227, %runtime.Type_Info_Pointer* %3228
	%3229 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3219, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %3229
	%3230 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 112
	%3231 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3230, i64 0, i32 3
	%3232 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3230, i64 0, i32 0
	store i64 16, i64* %3232
	%3233 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3230, i64 0, i32 1
	store i64 4, i64* %3233
	%3234 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3230, i64 0, i32 2
	store %..typeid 3098476543630901360, %..typeid* %3234
	; Type_Info_Named
	%3235 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3231 to %runtime.Type_Info_Named*
	%3236 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 113
	%3237 = bitcast %runtime.Type_Info* %3236 to %runtime.Type_Info*
	%3238 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3235, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$839, i64 0, i32 0), i64 4}, %..string* %3238
	%3239 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3235, i64 0, i32 1
	store %runtime.Type_Info* %3237, %runtime.Type_Info** %3239
	%3240 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3235, align 8
	%3241 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3231 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %3240, %runtime.Type_Info_Named* %3241
	%3242 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3231, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %3242
	%3243 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 113
	%3244 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3243, i64 0, i32 3
	%3245 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3243, i64 0, i32 0
	store i64 16, i64* %3245
	%3246 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3243, i64 0, i32 1
	store i64 4, i64* %3246
	%3247 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3243, i64 0, i32 2
	store %..typeid 792633534417207409, %..typeid* %3247
	; Type_Info_Array
	%3248 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3244 to %runtime.Type_Info_Array*
	%3249 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%3250 = bitcast %runtime.Type_Info* %3249 to %runtime.Type_Info*
	%3251 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %3248, i64 0, i32 0
	store %runtime.Type_Info* %3250, %runtime.Type_Info** %3251
	%3252 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %3248, i64 0, i32 1
	store i64 4, i64* %3252
	%3253 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %3248, i64 0, i32 2
	store i64 4, i64* %3253
	%3254 = load %runtime.Type_Info_Array, %runtime.Type_Info_Array* %3248, align 8
	%3255 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3244 to %runtime.Type_Info_Array*
	store %runtime.Type_Info_Array %3254, %runtime.Type_Info_Array* %3255
	%3256 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3244, i64 0, i32 2 ; UnionTagPtr
	store i8 12, i8* %3256
	%3257 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 88
	%3258 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3257, i64 0, i32 3
	%3259 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3257, i64 0, i32 0
	store i64 8, i64* %3259
	%3260 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3257, i64 0, i32 1
	store i64 8, i64* %3260
	%3261 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3257, i64 0, i32 2
	store %..typeid 3530822107858468952, %..typeid* %3261
	; Type_Info_Named
	%3262 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3258 to %runtime.Type_Info_Named*
	%3263 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 89
	%3264 = bitcast %runtime.Type_Info* %3263 to %runtime.Type_Info*
	%3265 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3262, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$83a, i64 0, i32 0), i64 8}, %..string* %3265
	%3266 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3262, i64 0, i32 1
	store %runtime.Type_Info* %3264, %runtime.Type_Info** %3266
	%3267 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3262, align 8
	%3268 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3258 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %3267, %runtime.Type_Info_Named* %3268
	%3269 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3258, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %3269
	%3270 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 89
	%3271 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3270, i64 0, i32 3
	%3272 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3270, i64 0, i32 0
	store i64 8, i64* %3272
	%3273 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3270, i64 0, i32 1
	store i64 8, i64* %3273
	%3274 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3270, i64 0, i32 2
	store %..typeid 1224979098644775001, %..typeid* %3274
	; Type_Info_Enum
	%3275 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3271 to %runtime.Type_Info_Enum*
	%3276 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%3277 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %3275, i64 0, i32 0
	store %runtime.Type_Info* %3276, %runtime.Type_Info** %3277
	%3278 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-59, i64 0, i32 0
	%3279 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-59, i64 0, i32 0
	%3280 = bitcast %runtime.Type_Info_Enum_Value* %3279 to i64*
	store i64 0, i64* %3280
	%3281 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3279, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %3281
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$83b, i64 0, i32 0), i64 6}, %..string* %3278
	%3282 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-59, i64 0, i32 1
	%3283 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-59, i64 0, i32 1
	%3284 = bitcast %runtime.Type_Info_Enum_Value* %3283 to i64*
	store i64 1, i64* %3284
	%3285 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3283, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %3285
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$83c, i64 0, i32 0), i64 4}, %..string* %3282
	%3286 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-59, i64 0, i32 2
	%3287 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-59, i64 0, i32 2
	%3288 = bitcast %runtime.Type_Info_Enum_Value* %3287 to i64*
	store i64 2, i64* %3288
	%3289 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %3287, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %3289
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$83d, i64 0, i32 0), i64 5}, %..string* %3286
	%3290 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %3275, i64 0, i32 1
	%3291 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-59, i64 0, i32 0
	%3292 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3290, i64 0, i32 0
	store %..string* %3291, %..string** %3292
	%3293 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3290, i64 0, i32 1
	store i64 3, i64* %3293
	%3294 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %3275, i64 0, i32 2
	%3295 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-59, i64 0, i32 0
	%3296 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %3294, i64 0, i32 0
	store %runtime.Type_Info_Enum_Value* %3295, %runtime.Type_Info_Enum_Value** %3296
	%3297 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %3294, i64 0, i32 1
	store i64 3, i64* %3297
	%3298 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %3275, align 8
	%3299 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3271 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %3298, %runtime.Type_Info_Enum* %3299
	%3300 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3271, i64 0, i32 2 ; UnionTagPtr
	store i8 18, i8* %3300
	%3301 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 136
	%3302 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3301, i64 0, i32 3
	%3303 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3301, i64 0, i32 0
	store i64 24, i64* %3303
	%3304 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3301, i64 0, i32 1
	store i64 8, i64* %3304
	%3305 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3301, i64 0, i32 2
	store %..typeid 3386706919782613128, %..typeid* %3305
	; Type_Info_Named
	%3306 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3302 to %runtime.Type_Info_Named*
	%3307 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 137
	%3308 = bitcast %runtime.Type_Info* %3307 to %runtime.Type_Info*
	%3309 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3306, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$83e, i64 0, i32 0), i64 9}, %..string* %3309
	%3310 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3306, i64 0, i32 1
	store %runtime.Type_Info* %3308, %runtime.Type_Info** %3310
	%3311 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3306, align 8
	%3312 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3302 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %3311, %runtime.Type_Info_Named* %3312
	%3313 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3302, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %3313
	%3314 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 137
	%3315 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3314, i64 0, i32 3
	%3316 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3314, i64 0, i32 0
	store i64 24, i64* %3316
	%3317 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3314, i64 0, i32 1
	store i64 8, i64* %3317
	%3318 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3314, i64 0, i32 2
	store %..typeid 1080863910568919177, %..typeid* %3318
	; Type_Info_Struct
	%3319 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3315 to %runtime.Type_Info_Struct*
	%3320 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3319, i64 0, i32 4
	store i8 0, i8* %3320
	%3321 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3319, i64 0, i32 5
	store i8 0, i8* %3321
	%3322 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3319, i64 0, i32 6
	store i8 0, i8* %3322
	%3323 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 87
	%3324 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 48
	%3325 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 48
	%3326 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 48
	%3327 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%3328 = bitcast %runtime.Type_Info* %3327 to %runtime.Type_Info*
	%3329 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3323, i64 0
	%3330 = getelementptr inbounds i64, i64* %3325, i64 0
	%3331 = getelementptr inbounds i8, i8* %3326, i64 0
	%3332 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %3332, %runtime.Type_Info** %3329
	%3333 = getelementptr inbounds %..string, %..string* %3324, i64 0
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$83f, i64 0, i32 0), i64 6}, %..string* %3333
	store i64 0, i64* %3330
	store i8 0, i8* %3331
	%3334 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 109
	%3335 = bitcast %runtime.Type_Info* %3334 to %runtime.Type_Info*
	%3336 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3323, i64 1
	%3337 = getelementptr inbounds i64, i64* %3325, i64 1
	%3338 = getelementptr inbounds i8, i8* %3326, i64 1
	%3339 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 109
	store %runtime.Type_Info* %3339, %runtime.Type_Info** %3336
	%3340 = getelementptr inbounds %..string, %..string* %3324, i64 1
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$840, i64 0, i32 0), i64 8}, %..string* %3340
	store i64 8, i64* %3337
	store i8 0, i8* %3338
	%3341 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3319, i64 0, i32 0
	%3342 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3341, i64 0, i32 0
	store %runtime.Type_Info** %3323, %runtime.Type_Info*** %3342
	%3343 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3341, i64 0, i32 1
	store i64 2, i64* %3343
	%3344 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3319, i64 0, i32 1
	%3345 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3344, i64 0, i32 0
	store %..string* %3324, %..string** %3345
	%3346 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3344, i64 0, i32 1
	store i64 2, i64* %3346
	%3347 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3319, i64 0, i32 2
	%3348 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3347, i64 0, i32 0
	store i64* %3325, i64** %3348
	%3349 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3347, i64 0, i32 1
	store i64 2, i64* %3349
	%3350 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3319, i64 0, i32 3
	%3351 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3350, i64 0, i32 0
	store i8* %3326, i8** %3351
	%3352 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3350, i64 0, i32 1
	store i64 2, i64* %3352
	%3353 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3319, align 8
	%3354 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3315 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %3353, %runtime.Type_Info_Struct* %3354
	%3355 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3315, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %3355
	%3356 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 138
	%3357 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3356, i64 0, i32 3
	%3358 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3356, i64 0, i32 0
	store i64 48, i64* %3358
	%3359 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3356, i64 0, i32 1
	store i64 8, i64* %3359
	%3360 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3356, i64 0, i32 2
	store %..typeid 3386706919782613130, %..typeid* %3360
	; Type_Info_Named
	%3361 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3357 to %runtime.Type_Info_Named*
	%3362 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 139
	%3363 = bitcast %runtime.Type_Info* %3362 to %runtime.Type_Info*
	%3364 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3361, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$841, i64 0, i32 0), i64 13}, %..string* %3364
	%3365 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3361, i64 0, i32 1
	store %runtime.Type_Info* %3363, %runtime.Type_Info** %3365
	%3366 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3361, align 8
	%3367 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3357 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %3366, %runtime.Type_Info_Named* %3367
	%3368 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3357, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %3368
	%3369 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 139
	%3370 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3369, i64 0, i32 3
	%3371 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3369, i64 0, i32 0
	store i64 48, i64* %3371
	%3372 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3369, i64 0, i32 1
	store i64 8, i64* %3372
	%3373 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3369, i64 0, i32 2
	store %..typeid 1080863910568919179, %..typeid* %3373
	; Type_Info_Struct
	%3374 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3370 to %runtime.Type_Info_Struct*
	%3375 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3374, i64 0, i32 4
	store i8 0, i8* %3375
	%3376 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3374, i64 0, i32 5
	store i8 0, i8* %3376
	%3377 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3374, i64 0, i32 6
	store i8 0, i8* %3377
	%3378 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 89
	%3379 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 50
	%3380 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 50
	%3381 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 50
	%3382 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%3383 = bitcast %runtime.Type_Info* %3382 to %runtime.Type_Info*
	%3384 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3378, i64 0
	%3385 = getelementptr inbounds i64, i64* %3380, i64 0
	%3386 = getelementptr inbounds i8, i8* %3381, i64 0
	%3387 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %3387, %runtime.Type_Info** %3384
	%3388 = getelementptr inbounds %..string, %..string* %3379, i64 0
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$842, i64 0, i32 0), i64 6}, %..string* %3388
	store i64 0, i64* %3385
	store i8 0, i8* %3386
	%3389 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 140
	%3390 = bitcast %runtime.Type_Info* %3389 to %runtime.Type_Info*
	%3391 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3378, i64 1
	%3392 = getelementptr inbounds i64, i64* %3380, i64 1
	%3393 = getelementptr inbounds i8, i8* %3381, i64 1
	%3394 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 140
	store %runtime.Type_Info* %3394, %runtime.Type_Info** %3391
	%3395 = getelementptr inbounds %..string, %..string* %3379, i64 1
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$843, i64 0, i32 0), i64 8}, %..string* %3395
	store i64 8, i64* %3392
	store i8 0, i8* %3393
	%3396 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3374, i64 0, i32 0
	%3397 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3396, i64 0, i32 0
	store %runtime.Type_Info** %3378, %runtime.Type_Info*** %3397
	%3398 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3396, i64 0, i32 1
	store i64 2, i64* %3398
	%3399 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3374, i64 0, i32 1
	%3400 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3399, i64 0, i32 0
	store %..string* %3379, %..string** %3400
	%3401 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3399, i64 0, i32 1
	store i64 2, i64* %3401
	%3402 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3374, i64 0, i32 2
	%3403 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3402, i64 0, i32 0
	store i64* %3380, i64** %3403
	%3404 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3402, i64 0, i32 1
	store i64 2, i64* %3404
	%3405 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3374, i64 0, i32 3
	%3406 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3405, i64 0, i32 0
	store i8* %3381, i8** %3406
	%3407 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3405, i64 0, i32 1
	store i64 2, i64* %3407
	%3408 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3374, align 8
	%3409 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3370 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %3408, %runtime.Type_Info_Struct* %3409
	%3410 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3370, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %3410
	%3411 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 140
	%3412 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3411, i64 0, i32 3
	%3413 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3411, i64 0, i32 0
	store i64 40, i64* %3413
	%3414 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3411, i64 0, i32 1
	store i64 8, i64* %3414
	%3415 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3411, i64 0, i32 2
	store %..typeid 864691128455135372, %..typeid* %3415
	; Type_Info_Dynamic_Array
	%3416 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3412 to %runtime.Type_Info_Dynamic_Array*
	%3417 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%3418 = bitcast %runtime.Type_Info* %3417 to %runtime.Type_Info*
	%3419 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %3416, i64 0, i32 0
	store %runtime.Type_Info* %3418, %runtime.Type_Info** %3419
	%3420 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %3416, i64 0, i32 1
	store i64 8, i64* %3420
	%3421 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %3416, align 8
	%3422 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3412 to %runtime.Type_Info_Dynamic_Array*
	store %runtime.Type_Info_Dynamic_Array %3421, %runtime.Type_Info_Dynamic_Array* %3422
	%3423 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3412, i64 0, i32 2 ; UnionTagPtr
	store i8 13, i8* %3423
	%3424 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 141
	%3425 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3424, i64 0, i32 3
	%3426 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3424, i64 0, i32 0
	store i64 8, i64* %3426
	%3427 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3424, i64 0, i32 1
	store i64 8, i64* %3427
	%3428 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3424, i64 0, i32 2
	store %..typeid 648518346341351565, %..typeid* %3428
	; Type_Info_Pointer
	%3429 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3425 to %runtime.Type_Info_Pointer*
	%3430 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%3431 = bitcast %runtime.Type_Info* %3430 to %runtime.Type_Info*
	%3432 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %3429, i64 0, i32 0
	store %runtime.Type_Info* %3431, %runtime.Type_Info** %3432
	%3433 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %3429, align 8
	%3434 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3425 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %3433, %runtime.Type_Info_Pointer* %3434
	%3435 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3425, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %3435
	%3436 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 142
	%3437 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3436, i64 0, i32 3
	%3438 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3436, i64 0, i32 0
	store i64 16, i64* %3438
	%3439 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3436, i64 0, i32 1
	store i64 8, i64* %3439
	%3440 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3436, i64 0, i32 2
	store %..typeid 3386706919782613134, %..typeid* %3440
	; Type_Info_Named
	%3441 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3437 to %runtime.Type_Info_Named*
	%3442 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 143
	%3443 = bitcast %runtime.Type_Info* %3442 to %runtime.Type_Info*
	%3444 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3441, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$844, i64 0, i32 0), i64 9}, %..string* %3444
	%3445 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3441, i64 0, i32 1
	store %runtime.Type_Info* %3443, %runtime.Type_Info** %3445
	%3446 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3441, align 8
	%3447 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3437 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %3446, %runtime.Type_Info_Named* %3447
	%3448 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3437, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %3448
	%3449 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 143
	%3450 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3449, i64 0, i32 3
	%3451 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3449, i64 0, i32 0
	store i64 16, i64* %3451
	%3452 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3449, i64 0, i32 1
	store i64 8, i64* %3452
	%3453 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3449, i64 0, i32 2
	store %..typeid 1080863910568919183, %..typeid* %3453
	; Type_Info_Struct
	%3454 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3450 to %runtime.Type_Info_Struct*
	%3455 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3454, i64 0, i32 4
	store i8 0, i8* %3455
	%3456 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3454, i64 0, i32 5
	store i8 0, i8* %3456
	%3457 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3454, i64 0, i32 6
	store i8 0, i8* %3457
	%3458 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 91
	%3459 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 52
	%3460 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 52
	%3461 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 52
	%3462 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 144
	%3463 = bitcast %runtime.Type_Info* %3462 to %runtime.Type_Info*
	%3464 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3458, i64 0
	%3465 = getelementptr inbounds i64, i64* %3460, i64 0
	%3466 = getelementptr inbounds i8, i8* %3461, i64 0
	%3467 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 144
	store %runtime.Type_Info* %3467, %runtime.Type_Info** %3464
	%3468 = getelementptr inbounds %..string, %..string* %3459, i64 0
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$845, i64 0, i32 0), i64 9}, %..string* %3468
	store i64 0, i64* %3465
	store i8 0, i8* %3466
	%3469 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 77
	%3470 = bitcast %runtime.Type_Info* %3469 to %runtime.Type_Info*
	%3471 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3458, i64 1
	%3472 = getelementptr inbounds i64, i64* %3460, i64 1
	%3473 = getelementptr inbounds i8, i8* %3461, i64 1
	%3474 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 77
	store %runtime.Type_Info* %3474, %runtime.Type_Info** %3471
	%3475 = getelementptr inbounds %..string, %..string* %3459, i64 1
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$846, i64 0, i32 0), i64 4}, %..string* %3475
	store i64 8, i64* %3472
	store i8 0, i8* %3473
	%3476 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3454, i64 0, i32 0
	%3477 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3476, i64 0, i32 0
	store %runtime.Type_Info** %3458, %runtime.Type_Info*** %3477
	%3478 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3476, i64 0, i32 1
	store i64 2, i64* %3478
	%3479 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3454, i64 0, i32 1
	%3480 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3479, i64 0, i32 0
	store %..string* %3459, %..string** %3480
	%3481 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3479, i64 0, i32 1
	store i64 2, i64* %3481
	%3482 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3454, i64 0, i32 2
	%3483 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3482, i64 0, i32 0
	store i64* %3460, i64** %3483
	%3484 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3482, i64 0, i32 1
	store i64 2, i64* %3484
	%3485 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3454, i64 0, i32 3
	%3486 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3485, i64 0, i32 0
	store i8* %3461, i8** %3486
	%3487 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3485, i64 0, i32 1
	store i64 2, i64* %3487
	%3488 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3454, align 8
	%3489 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3450 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %3488, %runtime.Type_Info_Struct* %3489
	%3490 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3450, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %3490
	%3491 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 144
	%3492 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3491, i64 0, i32 3
	%3493 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3491, i64 0, i32 0
	store i64 8, i64* %3493
	%3494 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3491, i64 0, i32 1
	store i64 8, i64* %3494
	%3495 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3491, i64 0, i32 2
	store %..typeid 3026418949592973456, %..typeid* %3495
	; Type_Info_Named
	%3496 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3492 to %runtime.Type_Info_Named*
	%3497 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 145
	%3498 = bitcast %runtime.Type_Info* %3497 to %runtime.Type_Info*
	%3499 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3496, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$847, i64 0, i32 0), i64 14}, %..string* %3499
	%3500 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3496, i64 0, i32 1
	store %runtime.Type_Info* %3498, %runtime.Type_Info** %3500
	%3501 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3496, align 8
	%3502 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3492 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %3501, %runtime.Type_Info_Named* %3502
	%3503 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3492, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %3503
	%3504 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 145
	%3505 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3504, i64 0, i32 3
	%3506 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3504, i64 0, i32 0
	store i64 8, i64* %3506
	%3507 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3504, i64 0, i32 1
	store i64 8, i64* %3507
	%3508 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3504, i64 0, i32 2
	store %..typeid 720575940379279505, %..typeid* %3508
	; Type_Info_Proc
	%3509 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3505 to %runtime.Type_Info_Procedure*
	%3510 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %3509, i64 0, i32 0
	%3511 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %3509, i64 0, i32 1
	%3512 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %3509, i64 0, i32 2
	%3513 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %3509, i64 0, i32 3
	%3514 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 146
	%3515 = bitcast %runtime.Type_Info* %3514 to %runtime.Type_Info*
	store %runtime.Type_Info* %3515, %runtime.Type_Info** %3510
	%3516 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 147
	%3517 = bitcast %runtime.Type_Info* %3516 to %runtime.Type_Info*
	store %runtime.Type_Info* %3517, %runtime.Type_Info** %3511
	store i8 0, i8* %3512
	store i64 1, i64* %3513
	%3518 = load %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %3509, align 8
	%3519 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3505 to %runtime.Type_Info_Procedure*
	store %runtime.Type_Info_Procedure %3518, %runtime.Type_Info_Procedure* %3519
	%3520 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3505, i64 0, i32 2 ; UnionTagPtr
	store i8 11, i8* %3520
	%3521 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 146
	%3522 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3521, i64 0, i32 3
	%3523 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3521, i64 0, i32 0
	store i64 104, i64* %3523
	%3524 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3521, i64 0, i32 1
	store i64 8, i64* %3524
	%3525 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3521, i64 0, i32 2
	store %..typeid 1008806316530991250, %..typeid* %3525
	; Type_Info_Tuple
	%3526 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3522 to %runtime.Type_Info_Tuple*
	%3527 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 93
	%3528 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 54
	%3529 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3527, i64 0
	%3530 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 77
	store %runtime.Type_Info* %3530, %runtime.Type_Info** %3529
	%3531 = getelementptr inbounds %..string, %..string* %3528, i64 0
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$848, i64 0, i32 0), i64 14}, %..string* %3531
	%3532 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3527, i64 1
	%3533 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 1
	store %runtime.Type_Info* %3533, %runtime.Type_Info** %3532
	%3534 = getelementptr inbounds %..string, %..string* %3528, i64 1
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$849, i64 0, i32 0), i64 4}, %..string* %3534
	%3535 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3527, i64 2
	%3536 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %3536, %runtime.Type_Info** %3535
	%3537 = getelementptr inbounds %..string, %..string* %3528, i64 2
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$84a, i64 0, i32 0), i64 4}, %..string* %3537
	%3538 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3527, i64 3
	%3539 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %3539, %runtime.Type_Info** %3538
	%3540 = getelementptr inbounds %..string, %..string* %3528, i64 3
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$84b, i64 0, i32 0), i64 9}, %..string* %3540
	%3541 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3527, i64 4
	%3542 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 77
	store %runtime.Type_Info* %3542, %runtime.Type_Info** %3541
	%3543 = getelementptr inbounds %..string, %..string* %3528, i64 4
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$84c, i64 0, i32 0), i64 10}, %..string* %3543
	%3544 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3527, i64 5
	%3545 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %3545, %runtime.Type_Info** %3544
	%3546 = getelementptr inbounds %..string, %..string* %3528, i64 5
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$84d, i64 0, i32 0), i64 8}, %..string* %3546
	%3547 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3527, i64 6
	%3548 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 7
	store %runtime.Type_Info* %3548, %runtime.Type_Info** %3547
	%3549 = getelementptr inbounds %..string, %..string* %3528, i64 6
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$84e, i64 0, i32 0), i64 5}, %..string* %3549
	%3550 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3527, i64 7
	%3551 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 124
	store %runtime.Type_Info* %3551, %runtime.Type_Info** %3550
	%3552 = getelementptr inbounds %..string, %..string* %3528, i64 7
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$84f, i64 0, i32 0), i64 8}, %..string* %3552
	%3553 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %3526, i64 0, i32 0
	%3554 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3553, i64 0, i32 0
	store %runtime.Type_Info** %3527, %runtime.Type_Info*** %3554
	%3555 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3553, i64 0, i32 1
	store i64 8, i64* %3555
	%3556 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %3526, i64 0, i32 1
	%3557 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3556, i64 0, i32 0
	store %..string* %3528, %..string** %3557
	%3558 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3556, i64 0, i32 1
	store i64 8, i64* %3558
	%3559 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %3526, align 8
	%3560 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3522 to %runtime.Type_Info_Tuple*
	store %runtime.Type_Info_Tuple %3559, %runtime.Type_Info_Tuple* %3560
	%3561 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3522, i64 0, i32 2 ; UnionTagPtr
	store i8 15, i8* %3561
	%3562 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 147
	%3563 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3562, i64 0, i32 3
	%3564 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3562, i64 0, i32 0
	store i64 8, i64* %3564
	%3565 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3562, i64 0, i32 1
	store i64 8, i64* %3565
	%3566 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3562, i64 0, i32 2
	store %..typeid 1008806316530991251, %..typeid* %3566
	; Type_Info_Tuple
	%3567 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3563 to %runtime.Type_Info_Tuple*
	%3568 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 101
	%3569 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 62
	%3570 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3568, i64 0
	%3571 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 77
	store %runtime.Type_Info* %3571, %runtime.Type_Info** %3570
	%3572 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %3567, i64 0, i32 0
	%3573 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3572, i64 0, i32 0
	store %runtime.Type_Info** %3568, %runtime.Type_Info*** %3573
	%3574 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3572, i64 0, i32 1
	store i64 1, i64* %3574
	%3575 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %3567, i64 0, i32 1
	%3576 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3575, i64 0, i32 0
	store %..string* %3569, %..string** %3576
	%3577 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3575, i64 0, i32 1
	store i64 1, i64* %3577
	%3578 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %3567, align 8
	%3579 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3563 to %runtime.Type_Info_Tuple*
	store %runtime.Type_Info_Tuple %3578, %runtime.Type_Info_Tuple* %3579
	%3580 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3563, i64 0, i32 2 ; UnionTagPtr
	store i8 15, i8* %3580
	%3581 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 148
	%3582 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3581, i64 0, i32 3
	%3583 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3581, i64 0, i32 0
	store i64 24, i64* %3583
	%3584 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3581, i64 0, i32 1
	store i64 8, i64* %3584
	%3585 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3581, i64 0, i32 2
	store %..typeid 3386706919782613140, %..typeid* %3585
	; Type_Info_Named
	%3586 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3582 to %runtime.Type_Info_Named*
	%3587 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 149
	%3588 = bitcast %runtime.Type_Info* %3587 to %runtime.Type_Info*
	%3589 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3586, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$850, i64 0, i32 0), i64 15}, %..string* %3589
	%3590 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3586, i64 0, i32 1
	store %runtime.Type_Info* %3588, %runtime.Type_Info** %3590
	%3591 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3586, align 8
	%3592 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3582 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %3591, %runtime.Type_Info_Named* %3592
	%3593 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3582, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %3593
	%3594 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 149
	%3595 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3594, i64 0, i32 3
	%3596 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3594, i64 0, i32 0
	store i64 24, i64* %3596
	%3597 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3594, i64 0, i32 1
	store i64 8, i64* %3597
	%3598 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3594, i64 0, i32 2
	store %..typeid 1080863910568919189, %..typeid* %3598
	; Type_Info_Struct
	%3599 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3595 to %runtime.Type_Info_Struct*
	%3600 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3599, i64 0, i32 4
	store i8 0, i8* %3600
	%3601 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3599, i64 0, i32 5
	store i8 0, i8* %3601
	%3602 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3599, i64 0, i32 6
	store i8 0, i8* %3602
	%3603 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 102
	%3604 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 63
	%3605 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 54
	%3606 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 54
	%3607 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%3608 = bitcast %runtime.Type_Info* %3607 to %runtime.Type_Info*
	%3609 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3603, i64 0
	%3610 = getelementptr inbounds i64, i64* %3605, i64 0
	%3611 = getelementptr inbounds i8, i8* %3606, i64 0
	%3612 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %3612, %runtime.Type_Info** %3609
	%3613 = getelementptr inbounds %..string, %..string* %3604, i64 0
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$851, i64 0, i32 0), i64 6}, %..string* %3613
	store i64 0, i64* %3610
	store i8 0, i8* %3611
	%3614 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 132
	%3615 = bitcast %runtime.Type_Info* %3614 to %runtime.Type_Info*
	%3616 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3603, i64 1
	%3617 = getelementptr inbounds i64, i64* %3605, i64 1
	%3618 = getelementptr inbounds i8, i8* %3606, i64 1
	%3619 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 132
	store %runtime.Type_Info* %3619, %runtime.Type_Info** %3616
	%3620 = getelementptr inbounds %..string, %..string* %3604, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$852, i64 0, i32 0), i64 5}, %..string* %3620
	store i64 8, i64* %3617
	store i8 0, i8* %3618
	%3621 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3599, i64 0, i32 0
	%3622 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3621, i64 0, i32 0
	store %runtime.Type_Info** %3603, %runtime.Type_Info*** %3622
	%3623 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3621, i64 0, i32 1
	store i64 2, i64* %3623
	%3624 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3599, i64 0, i32 1
	%3625 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3624, i64 0, i32 0
	store %..string* %3604, %..string** %3625
	%3626 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3624, i64 0, i32 1
	store i64 2, i64* %3626
	%3627 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3599, i64 0, i32 2
	%3628 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3627, i64 0, i32 0
	store i64* %3605, i64** %3628
	%3629 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3627, i64 0, i32 1
	store i64 2, i64* %3629
	%3630 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3599, i64 0, i32 3
	%3631 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3630, i64 0, i32 0
	store i8* %3606, i8** %3631
	%3632 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3630, i64 0, i32 1
	store i64 2, i64* %3632
	%3633 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3599, align 8
	%3634 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3595 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %3633, %runtime.Type_Info_Struct* %3634
	%3635 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3595, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %3635
	%3636 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 132
	%3637 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3636, i64 0, i32 3
	%3638 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3636, i64 0, i32 0
	store i64 16, i64* %3638
	%3639 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3636, i64 0, i32 1
	store i64 4, i64* %3639
	%3640 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3636, i64 0, i32 2
	store %..typeid 3386706919782613124, %..typeid* %3640
	; Type_Info_Named
	%3641 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3637 to %runtime.Type_Info_Named*
	%3642 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 133
	%3643 = bitcast %runtime.Type_Info* %3642 to %runtime.Type_Info*
	%3644 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3641, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$853, i64 0, i32 0), i64 6}, %..string* %3644
	%3645 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3641, i64 0, i32 1
	store %runtime.Type_Info* %3643, %runtime.Type_Info** %3645
	%3646 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3641, align 8
	%3647 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3637 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %3646, %runtime.Type_Info_Named* %3647
	%3648 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3637, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %3648
	%3649 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 133
	%3650 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3649, i64 0, i32 3
	%3651 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3649, i64 0, i32 0
	store i64 16, i64* %3651
	%3652 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3649, i64 0, i32 1
	store i64 4, i64* %3652
	%3653 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3649, i64 0, i32 2
	store %..typeid 1080863910568919173, %..typeid* %3653
	; Type_Info_Struct
	%3654 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3650 to %runtime.Type_Info_Struct*
	%3655 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3654, i64 0, i32 4
	store i8 0, i8* %3655
	%3656 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3654, i64 0, i32 5
	store i8 0, i8* %3656
	%3657 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3654, i64 0, i32 6
	store i8 0, i8* %3657
	%3658 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 104
	%3659 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 65
	%3660 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 56
	%3661 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 56
	%3662 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%3663 = bitcast %runtime.Type_Info* %3662 to %runtime.Type_Info*
	%3664 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3658, i64 0
	%3665 = getelementptr inbounds i64, i64* %3660, i64 0
	%3666 = getelementptr inbounds i8, i8* %3661, i64 0
	%3667 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %3667, %runtime.Type_Info** %3664
	%3668 = getelementptr inbounds %..string, %..string* %3659, i64 0
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$854, i64 0, i32 0), i64 1}, %..string* %3668
	store i64 0, i64* %3665
	store i8 0, i8* %3666
	%3669 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%3670 = bitcast %runtime.Type_Info* %3669 to %runtime.Type_Info*
	%3671 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3658, i64 1
	%3672 = getelementptr inbounds i64, i64* %3660, i64 1
	%3673 = getelementptr inbounds i8, i8* %3661, i64 1
	%3674 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %3674, %runtime.Type_Info** %3671
	%3675 = getelementptr inbounds %..string, %..string* %3659, i64 1
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$855, i64 0, i32 0), i64 1}, %..string* %3675
	store i64 4, i64* %3672
	store i8 0, i8* %3673
	%3676 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%3677 = bitcast %runtime.Type_Info* %3676 to %runtime.Type_Info*
	%3678 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3658, i64 2
	%3679 = getelementptr inbounds i64, i64* %3660, i64 2
	%3680 = getelementptr inbounds i8, i8* %3661, i64 2
	%3681 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %3681, %runtime.Type_Info** %3678
	%3682 = getelementptr inbounds %..string, %..string* %3659, i64 2
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$856, i64 0, i32 0), i64 1}, %..string* %3682
	store i64 8, i64* %3679
	store i8 0, i8* %3680
	%3683 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%3684 = bitcast %runtime.Type_Info* %3683 to %runtime.Type_Info*
	%3685 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3658, i64 3
	%3686 = getelementptr inbounds i64, i64* %3660, i64 3
	%3687 = getelementptr inbounds i8, i8* %3661, i64 3
	%3688 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %3688, %runtime.Type_Info** %3685
	%3689 = getelementptr inbounds %..string, %..string* %3659, i64 3
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$857, i64 0, i32 0), i64 1}, %..string* %3689
	store i64 12, i64* %3686
	store i8 0, i8* %3687
	%3690 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3654, i64 0, i32 0
	%3691 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3690, i64 0, i32 0
	store %runtime.Type_Info** %3658, %runtime.Type_Info*** %3691
	%3692 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3690, i64 0, i32 1
	store i64 4, i64* %3692
	%3693 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3654, i64 0, i32 1
	%3694 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3693, i64 0, i32 0
	store %..string* %3659, %..string** %3694
	%3695 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3693, i64 0, i32 1
	store i64 4, i64* %3695
	%3696 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3654, i64 0, i32 2
	%3697 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3696, i64 0, i32 0
	store i64* %3660, i64** %3697
	%3698 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3696, i64 0, i32 1
	store i64 4, i64* %3698
	%3699 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3654, i64 0, i32 3
	%3700 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3699, i64 0, i32 0
	store i8* %3661, i8** %3700
	%3701 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3699, i64 0, i32 1
	store i64 4, i64* %3701
	%3702 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3654, align 8
	%3703 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3650 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %3702, %runtime.Type_Info_Struct* %3703
	%3704 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3650, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %3704
	%3705 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 150
	%3706 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3705, i64 0, i32 3
	%3707 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3705, i64 0, i32 0
	store i64 16, i64* %3707
	%3708 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3705, i64 0, i32 1
	store i64 8, i64* %3708
	%3709 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3705, i64 0, i32 2
	store %..typeid 3386706919782613142, %..typeid* %3709
	; Type_Info_Named
	%3710 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3706 to %runtime.Type_Info_Named*
	%3711 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 151
	%3712 = bitcast %runtime.Type_Info* %3711 to %runtime.Type_Info*
	%3713 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3710, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$858, i64 0, i32 0), i64 17}, %..string* %3713
	%3714 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3710, i64 0, i32 1
	store %runtime.Type_Info* %3712, %runtime.Type_Info** %3714
	%3715 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3710, align 8
	%3716 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3706 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %3715, %runtime.Type_Info_Named* %3716
	%3717 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3706, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %3717
	%3718 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 151
	%3719 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3718, i64 0, i32 3
	%3720 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3718, i64 0, i32 0
	store i64 16, i64* %3720
	%3721 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3718, i64 0, i32 1
	store i64 8, i64* %3721
	%3722 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3718, i64 0, i32 2
	store %..typeid 1080863910568919191, %..typeid* %3722
	; Type_Info_Struct
	%3723 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3719 to %runtime.Type_Info_Struct*
	%3724 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3723, i64 0, i32 4
	store i8 0, i8* %3724
	%3725 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3723, i64 0, i32 5
	store i8 0, i8* %3725
	%3726 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3723, i64 0, i32 6
	store i8 0, i8* %3726
	%3727 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 108
	%3728 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 69
	%3729 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 60
	%3730 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 60
	%3731 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%3732 = bitcast %runtime.Type_Info* %3731 to %runtime.Type_Info*
	%3733 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3727, i64 0
	%3734 = getelementptr inbounds i64, i64* %3729, i64 0
	%3735 = getelementptr inbounds i8, i8* %3730, i64 0
	%3736 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %3736, %runtime.Type_Info** %3733
	%3737 = getelementptr inbounds %..string, %..string* %3728, i64 0
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$859, i64 0, i32 0), i64 6}, %..string* %3737
	store i64 0, i64* %3734
	store i8 0, i8* %3735
	%3738 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%3739 = bitcast %runtime.Type_Info* %3738 to %runtime.Type_Info*
	%3740 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3727, i64 1
	%3741 = getelementptr inbounds i64, i64* %3729, i64 1
	%3742 = getelementptr inbounds i8, i8* %3730, i64 1
	%3743 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %3743, %runtime.Type_Info** %3740
	%3744 = getelementptr inbounds %..string, %..string* %3728, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$85a, i64 0, i32 0), i64 5}, %..string* %3744
	store i64 8, i64* %3741
	store i8 0, i8* %3742
	%3745 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%3746 = bitcast %runtime.Type_Info* %3745 to %runtime.Type_Info*
	%3747 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3727, i64 2
	%3748 = getelementptr inbounds i64, i64* %3729, i64 2
	%3749 = getelementptr inbounds i8, i8* %3730, i64 2
	%3750 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %3750, %runtime.Type_Info** %3747
	%3751 = getelementptr inbounds %..string, %..string* %3728, i64 2
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$85b, i64 0, i32 0), i64 6}, %..string* %3751
	store i64 12, i64* %3748
	store i8 0, i8* %3749
	%3752 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3723, i64 0, i32 0
	%3753 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3752, i64 0, i32 0
	store %runtime.Type_Info** %3727, %runtime.Type_Info*** %3753
	%3754 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3752, i64 0, i32 1
	store i64 3, i64* %3754
	%3755 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3723, i64 0, i32 1
	%3756 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3755, i64 0, i32 0
	store %..string* %3728, %..string** %3756
	%3757 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3755, i64 0, i32 1
	store i64 3, i64* %3757
	%3758 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3723, i64 0, i32 2
	%3759 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3758, i64 0, i32 0
	store i64* %3729, i64** %3759
	%3760 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3758, i64 0, i32 1
	store i64 3, i64* %3760
	%3761 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3723, i64 0, i32 3
	%3762 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3761, i64 0, i32 0
	store i8* %3730, i8** %3762
	%3763 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3761, i64 0, i32 1
	store i64 3, i64* %3763
	%3764 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3723, align 8
	%3765 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3719 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %3764, %runtime.Type_Info_Struct* %3765
	%3766 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3719, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %3766
	%3767 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 117
	%3768 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3767, i64 0, i32 3
	%3769 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3767, i64 0, i32 0
	store i64 40, i64* %3769
	%3770 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3767, i64 0, i32 1
	store i64 8, i64* %3770
	%3771 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3767, i64 0, i32 2
	store %..typeid 3386706919782613109, %..typeid* %3771
	; Type_Info_Named
	%3772 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3768 to %runtime.Type_Info_Named*
	%3773 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 118
	%3774 = bitcast %runtime.Type_Info* %3773 to %runtime.Type_Info*
	%3775 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3772, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$85c, i64 0, i32 0), i64 13}, %..string* %3775
	%3776 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3772, i64 0, i32 1
	store %runtime.Type_Info* %3774, %runtime.Type_Info** %3776
	%3777 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3772, align 8
	%3778 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3768 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %3777, %runtime.Type_Info_Named* %3778
	%3779 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3768, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %3779
	%3780 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 118
	%3781 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3780, i64 0, i32 3
	%3782 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3780, i64 0, i32 0
	store i64 40, i64* %3782
	%3783 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3780, i64 0, i32 1
	store i64 8, i64* %3783
	%3784 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3780, i64 0, i32 2
	store %..typeid 1080863910568919158, %..typeid* %3784
	; Type_Info_Struct
	%3785 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3781 to %runtime.Type_Info_Struct*
	%3786 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3785, i64 0, i32 4
	store i8 0, i8* %3786
	%3787 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3785, i64 0, i32 5
	store i8 0, i8* %3787
	%3788 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3785, i64 0, i32 6
	store i8 0, i8* %3788
	%3789 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 111
	%3790 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 72
	%3791 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 63
	%3792 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 63
	%3793 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 109
	%3794 = bitcast %runtime.Type_Info* %3793 to %runtime.Type_Info*
	%3795 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3789, i64 0
	%3796 = getelementptr inbounds i64, i64* %3791, i64 0
	%3797 = getelementptr inbounds i8, i8* %3792, i64 0
	%3798 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 109
	store %runtime.Type_Info* %3798, %runtime.Type_Info** %3795
	%3799 = getelementptr inbounds %..string, %..string* %3790, i64 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$85d, i64 0, i32 0), i64 15}, %..string* %3799
	store i64 0, i64* %3796
	store i8 0, i8* %3797
	%3800 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 84
	%3801 = bitcast %runtime.Type_Info* %3800 to %runtime.Type_Info*
	%3802 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3789, i64 1
	%3803 = getelementptr inbounds i64, i64* %3791, i64 1
	%3804 = getelementptr inbounds i8, i8* %3792, i64 1
	%3805 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 84
	store %runtime.Type_Info* %3805, %runtime.Type_Info** %3802
	%3806 = getelementptr inbounds %..string, %..string* %3790, i64 1
	store %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$85e, i64 0, i32 0), i64 21}, %..string* %3806
	store i64 16, i64* %3803
	store i8 0, i8* %3804
	%3807 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%3808 = bitcast %runtime.Type_Info* %3807 to %runtime.Type_Info*
	%3809 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3789, i64 2
	%3810 = getelementptr inbounds i64, i64* %3791, i64 2
	%3811 = getelementptr inbounds i8, i8* %3792, i64 2
	%3812 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %3812, %runtime.Type_Info** %3809
	%3813 = getelementptr inbounds %..string, %..string* %3790, i64 2
	store %..string {i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$85f, i64 0, i32 0), i64 24}, %..string* %3813
	store i64 24, i64* %3810
	store i8 0, i8* %3811
	%3814 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%3815 = bitcast %runtime.Type_Info* %3814 to %runtime.Type_Info*
	%3816 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3789, i64 3
	%3817 = getelementptr inbounds i64, i64* %3791, i64 3
	%3818 = getelementptr inbounds i8, i8* %3792, i64 3
	%3819 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %3819, %runtime.Type_Info** %3816
	%3820 = getelementptr inbounds %..string, %..string* %3790, i64 3
	store %..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$860, i64 0, i32 0), i64 23}, %..string* %3820
	store i64 28, i64* %3817
	store i8 0, i8* %3818
	%3821 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%3822 = bitcast %runtime.Type_Info* %3821 to %runtime.Type_Info*
	%3823 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3789, i64 4
	%3824 = getelementptr inbounds i64, i64* %3791, i64 4
	%3825 = getelementptr inbounds i8, i8* %3792, i64 4
	%3826 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	store %runtime.Type_Info* %3826, %runtime.Type_Info** %3823
	%3827 = getelementptr inbounds %..string, %..string* %3790, i64 4
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$861, i64 0, i32 0), i64 10}, %..string* %3827
	store i64 32, i64* %3824
	store i8 0, i8* %3825
	%3828 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3785, i64 0, i32 0
	%3829 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3828, i64 0, i32 0
	store %runtime.Type_Info** %3789, %runtime.Type_Info*** %3829
	%3830 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3828, i64 0, i32 1
	store i64 5, i64* %3830
	%3831 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3785, i64 0, i32 1
	%3832 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3831, i64 0, i32 0
	store %..string* %3790, %..string** %3832
	%3833 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3831, i64 0, i32 1
	store i64 5, i64* %3833
	%3834 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3785, i64 0, i32 2
	%3835 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3834, i64 0, i32 0
	store i64* %3791, i64** %3835
	%3836 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3834, i64 0, i32 1
	store i64 5, i64* %3836
	%3837 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3785, i64 0, i32 3
	%3838 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3837, i64 0, i32 0
	store i8* %3792, i8** %3838
	%3839 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3837, i64 0, i32 1
	store i64 5, i64* %3839
	%3840 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3785, align 8
	%3841 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3781 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %3840, %runtime.Type_Info_Struct* %3841
	%3842 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3781, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %3842
	%3843 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 114
	%3844 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3843, i64 0, i32 3
	%3845 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3843, i64 0, i32 0
	store i64 20, i64* %3845
	%3846 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3843, i64 0, i32 1
	store i64 4, i64* %3846
	%3847 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3843, i64 0, i32 2
	store %..typeid 1152921504606847090, %..typeid* %3847
	; Type_Info_Union
	%3848 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3844 to %runtime.Type_Info_Union*
	%3849 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %3848, i64 0, i32 0
	%3850 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %3848, i64 0, i32 1
	%3851 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %3848, i64 0, i32 2
	%3852 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %3848, i64 0, i32 3
	%3853 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 116
	%3854 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 106
	%3855 = bitcast %runtime.Type_Info* %3854 to %runtime.Type_Info*
	%3856 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3853, i64 0
	%3857 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 106
	store %runtime.Type_Info* %3857, %runtime.Type_Info** %3856
	%3858 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%3859 = bitcast %runtime.Type_Info* %3858 to %runtime.Type_Info*
	%3860 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3853, i64 1
	%3861 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %3861, %runtime.Type_Info** %3860
	%3862 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 109
	%3863 = bitcast %runtime.Type_Info* %3862 to %runtime.Type_Info*
	%3864 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3853, i64 2
	%3865 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 109
	store %runtime.Type_Info* %3865, %runtime.Type_Info** %3864
	%3866 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 112
	%3867 = bitcast %runtime.Type_Info* %3866 to %runtime.Type_Info*
	%3868 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3853, i64 3
	%3869 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 112
	store %runtime.Type_Info* %3869, %runtime.Type_Info** %3868
	%3870 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3849, i64 0, i32 0
	store %runtime.Type_Info** %3853, %runtime.Type_Info*** %3870
	%3871 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3849, i64 0, i32 1
	store i64 4, i64* %3871
	store i64 16, i64* %3850
	%3872 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	store %runtime.Type_Info* %3872, %runtime.Type_Info** %3851
	store i8 0, i8* %3852
	%3873 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %3848, align 8
	%3874 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3844 to %runtime.Type_Info_Union*
	store %runtime.Type_Info_Union %3873, %runtime.Type_Info_Union* %3874
	%3875 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3844, i64 0, i32 2 ; UnionTagPtr
	store i8 17, i8* %3875
	%3876 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 120
	%3877 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3876, i64 0, i32 3
	%3878 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3876, i64 0, i32 0
	store i64 4, i64* %3878
	%3879 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3876, i64 0, i32 1
	store i64 4, i64* %3879
	%3880 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3876, i64 0, i32 2
	store %..typeid 3386706919782613112, %..typeid* %3880
	; Type_Info_Named
	%3881 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3877 to %runtime.Type_Info_Named*
	%3882 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 121
	%3883 = bitcast %runtime.Type_Info* %3882 to %runtime.Type_Info*
	%3884 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3881, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$862, i64 0, i32 0), i64 13}, %..string* %3884
	%3885 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3881, i64 0, i32 1
	store %runtime.Type_Info* %3883, %runtime.Type_Info** %3885
	%3886 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3881, align 8
	%3887 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3877 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %3886, %runtime.Type_Info_Named* %3887
	%3888 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3877, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %3888
	%3889 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 121
	%3890 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3889, i64 0, i32 3
	%3891 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3889, i64 0, i32 0
	store i64 4, i64* %3891
	%3892 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3889, i64 0, i32 1
	store i64 4, i64* %3892
	%3893 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3889, i64 0, i32 2
	store %..typeid 1080863910568919161, %..typeid* %3893
	; Type_Info_Struct
	%3894 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3890 to %runtime.Type_Info_Struct*
	%3895 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3894, i64 0, i32 4
	store i8 0, i8* %3895
	%3896 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3894, i64 0, i32 5
	store i8 0, i8* %3896
	%3897 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3894, i64 0, i32 6
	store i8 0, i8* %3897
	%3898 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 120
	%3899 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 77
	%3900 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 68
	%3901 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 68
	%3902 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%3903 = bitcast %runtime.Type_Info* %3902 to %runtime.Type_Info*
	%3904 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3898, i64 0
	%3905 = getelementptr inbounds i64, i64* %3900, i64 0
	%3906 = getelementptr inbounds i8, i8* %3901, i64 0
	%3907 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	store %runtime.Type_Info* %3907, %runtime.Type_Info** %3904
	%3908 = getelementptr inbounds %..string, %..string* %3899, i64 0
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$863, i64 0, i32 0), i64 12}, %..string* %3908
	store i64 0, i64* %3905
	store i8 0, i8* %3906
	%3909 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3894, i64 0, i32 0
	%3910 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3909, i64 0, i32 0
	store %runtime.Type_Info** %3898, %runtime.Type_Info*** %3910
	%3911 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %3909, i64 0, i32 1
	store i64 1, i64* %3911
	%3912 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3894, i64 0, i32 1
	%3913 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3912, i64 0, i32 0
	store %..string* %3899, %..string** %3913
	%3914 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %3912, i64 0, i32 1
	store i64 1, i64* %3914
	%3915 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3894, i64 0, i32 2
	%3916 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3915, i64 0, i32 0
	store i64* %3900, i64** %3916
	%3917 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %3915, i64 0, i32 1
	store i64 1, i64* %3917
	%3918 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3894, i64 0, i32 3
	%3919 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3918, i64 0, i32 0
	store i8* %3901, i8** %3919
	%3920 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3918, i64 0, i32 1
	store i64 1, i64* %3920
	%3921 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3894, align 8
	%3922 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3890 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %3921, %runtime.Type_Info_Struct* %3922
	%3923 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3890, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %3923
	%3924 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 122
	%3925 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3924, i64 0, i32 3
	%3926 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3924, i64 0, i32 0
	store i64 176, i64* %3926
	%3927 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3924, i64 0, i32 1
	store i64 8, i64* %3927
	%3928 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3924, i64 0, i32 2
	store %..typeid 3386706919782613114, %..typeid* %3928
	; Type_Info_Named
	%3929 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3925 to %runtime.Type_Info_Named*
	%3930 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 123
	%3931 = bitcast %runtime.Type_Info* %3930 to %runtime.Type_Info*
	%3932 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3929, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$864, i64 0, i32 0), i64 10}, %..string* %3932
	%3933 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3929, i64 0, i32 1
	store %runtime.Type_Info* %3931, %runtime.Type_Info** %3933
	%3934 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3929, align 8
	%3935 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3925 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %3934, %runtime.Type_Info_Named* %3935
	%3936 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3925, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %3936
	%3937 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 123
	%3938 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3937, i64 0, i32 3
	%3939 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3937, i64 0, i32 0
	store i64 176, i64* %3939
	%3940 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3937, i64 0, i32 1
	store i64 8, i64* %3940
	%3941 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3937, i64 0, i32 2
	store %..typeid 1080863910568919163, %..typeid* %3941
	; Type_Info_Struct
	%3942 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3938 to %runtime.Type_Info_Struct*
	%3943 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3942, i64 0, i32 4
	store i8 0, i8* %3943
	%3944 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3942, i64 0, i32 5
	store i8 0, i8* %3944
	%3945 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3942, i64 0, i32 6
	store i8 0, i8* %3945
	%3946 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 121
	%3947 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 78
	%3948 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 69
	%3949 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 69
	%3950 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%3951 = bitcast %runtime.Type_Info* %3950 to %runtime.Type_Info*
	%3952 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3946, i64 0
	%3953 = getelementptr inbounds i64, i64* %3948, i64 0
	%3954 = getelementptr inbounds i8, i8* %3949, i64 0
	%3955 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %3955, %runtime.Type_Info** %3952
	%3956 = getelementptr inbounds %..string, %..string* %3947, i64 0
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$865, i64 0, i32 0), i64 8}, %..string* %3956
	store i64 0, i64* %3953
	store i8 0, i8* %3954
	%3957 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 115
	%3958 = bitcast %runtime.Type_Info* %3957 to %runtime.Type_Info*
	%3959 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3946, i64 1
	%3960 = getelementptr inbounds i64, i64* %3948, i64 1
	%3961 = getelementptr inbounds i8, i8* %3949, i64 1
	%3962 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 115
	store %runtime.Type_Info* %3962, %runtime.Type_Info** %3959
	%3963 = getelementptr inbounds %..string, %..string* %3947, i64 1
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$866, i64 0, i32 0), i64 4}, %..string* %3963
	store i64 8, i64* %3960
	store i8 0, i8* %3961
	%3964 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%3965 = bitcast %runtime.Type_Info* %3964 to %runtime.Type_Info*
	%3966 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3946, i64 2
	%3967 = getelementptr inbounds i64, i64* %3948, i64 2
	%3968 = getelementptr inbounds i8, i8* %3949, i64 2
	%3969 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	store %runtime.Type_Info* %3969, %runtime.Type_Info** %3966
	%3970 = getelementptr inbounds %..string, %..string* %3947, i64 2
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$867, i64 0, i32 0), i64 9}, %..string* %3970
	store i64 16, i64* %3967
	store i8 0, i8* %3968
	%3971 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 124
	%3972 = bitcast %runtime.Type_Info* %3971 to %runtime.Type_Info*
	%3973 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3946, i64 3
	%3974 = getelementptr inbounds i64, i64* %3948, i64 3
	%3975 = getelementptr inbounds i8, i8* %3949, i64 3
	%3976 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 124
	store %runtime.Type_Info* %3976, %runtime.Type_Info** %3973
	%3977 = getelementptr inbounds %..string, %..string* %3947, i64 3
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$868, i64 0, i32 0), i64 8}, %..string* %3977
	store i64 32, i64* %3974
	store i8 0, i8* %3975
	%3978 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 126
	%3979 = bitcast %runtime.Type_Info* %3978 to %runtime.Type_Info*
	%3980 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3946, i64 4
	%3981 = getelementptr inbounds i64, i64* %3948, i64 4
	%3982 = getelementptr inbounds i8, i8* %3949, i64 4
	%3983 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 126
	store %runtime.Type_Info* %3983, %runtime.Type_Info** %3980
	%3984 = getelementptr inbounds %..string, %..string* %3947, i64 4
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$869, i64 0, i32 0), i64 9}, %..string* %3984
	store i64 80, i64* %3981
	store i8 0, i8* %3982
	%3985 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 128
	%3986 = bitcast %runtime.Type_Info* %3985 to %runtime.Type_Info*
	%3987 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3946, i64 5
	%3988 = getelementptr inbounds i64, i64* %3948, i64 5
	%3989 = getelementptr inbounds i8, i8* %3949, i64 5
	%3990 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 128
	store %runtime.Type_Info* %3990, %runtime.Type_Info** %3987
	%3991 = getelementptr inbounds %..string, %..string* %3947, i64 5
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$86a, i64 0, i32 0), i64 10}, %..string* %3991
	store i64 96, i64* %3988
	store i8 0, i8* %3989
	%3992 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%3993 = bitcast %runtime.Type_Info* %3992 to %runtime.Type_Info*
	%3994 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3946, i64 6
	%3995 = getelementptr inbounds i64, i64* %3948, i64 6
	%3996 = getelementptr inbounds i8, i8* %3949, i64 6
	%3997 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %3997, %runtime.Type_Info** %3994
	%3998 = getelementptr inbounds %..string, %..string* %3947, i64 6
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$86b, i64 0, i32 0), i64 13}, %..string* %3998
	store i64 128, i64* %3995
	store i8 0, i8* %3996
	%3999 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%4000 = bitcast %runtime.Type_Info* %3999 to %runtime.Type_Info*
	%4001 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3946, i64 7
	%4002 = getelementptr inbounds i64, i64* %3948, i64 7
	%4003 = getelementptr inbounds i8, i8* %3949, i64 7
	%4004 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %4004, %runtime.Type_Info** %4001
	%4005 = getelementptr inbounds %..string, %..string* %3947, i64 7
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$86c, i64 0, i32 0), i64 13}, %..string* %4005
	store i64 132, i64* %4002
	store i8 0, i8* %4003
	%4006 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%4007 = bitcast %runtime.Type_Info* %4006 to %runtime.Type_Info*
	%4008 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3946, i64 8
	%4009 = getelementptr inbounds i64, i64* %3948, i64 8
	%4010 = getelementptr inbounds i8, i8* %3949, i64 8
	%4011 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %4011, %runtime.Type_Info** %4008
	%4012 = getelementptr inbounds %..string, %..string* %3947, i64 8
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$86d, i64 0, i32 0), i64 13}, %..string* %4012
	store i64 136, i64* %4009
	store i8 0, i8* %4010
	%4013 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%4014 = bitcast %runtime.Type_Info* %4013 to %runtime.Type_Info*
	%4015 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3946, i64 9
	%4016 = getelementptr inbounds i64, i64* %3948, i64 9
	%4017 = getelementptr inbounds i8, i8* %3949, i64 9
	%4018 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %4018, %runtime.Type_Info** %4015
	%4019 = getelementptr inbounds %..string, %..string* %3947, i64 9
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$86e, i64 0, i32 0), i64 13}, %..string* %4019
	store i64 140, i64* %4016
	store i8 0, i8* %4017
	%4020 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%4021 = bitcast %runtime.Type_Info* %4020 to %runtime.Type_Info*
	%4022 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3946, i64 10
	%4023 = getelementptr inbounds i64, i64* %3948, i64 10
	%4024 = getelementptr inbounds i8, i8* %3949, i64 10
	%4025 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %4025, %runtime.Type_Info** %4022
	%4026 = getelementptr inbounds %..string, %..string* %3947, i64 10
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$86f, i64 0, i32 0), i64 15}, %..string* %4026
	store i64 144, i64* %4023
	store i8 0, i8* %4024
	%4027 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%4028 = bitcast %runtime.Type_Info* %4027 to %runtime.Type_Info*
	%4029 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3946, i64 11
	%4030 = getelementptr inbounds i64, i64* %3948, i64 11
	%4031 = getelementptr inbounds i8, i8* %3949, i64 11
	%4032 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %4032, %runtime.Type_Info** %4029
	%4033 = getelementptr inbounds %..string, %..string* %3947, i64 11
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$870, i64 0, i32 0), i64 17}, %..string* %4033
	store i64 152, i64* %4030
	store i8 0, i8* %4031
	%4034 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%4035 = bitcast %runtime.Type_Info* %4034 to %runtime.Type_Info*
	%4036 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3946, i64 12
	%4037 = getelementptr inbounds i64, i64* %3948, i64 12
	%4038 = getelementptr inbounds i8, i8* %3949, i64 12
	%4039 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %4039, %runtime.Type_Info** %4036
	%4040 = getelementptr inbounds %..string, %..string* %3947, i64 12
	store %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$871, i64 0, i32 0), i64 18}, %..string* %4040
	store i64 160, i64* %4037
	store i8 0, i8* %4038
	%4041 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%4042 = bitcast %runtime.Type_Info* %4041 to %runtime.Type_Info*
	%4043 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %3946, i64 13
	%4044 = getelementptr inbounds i64, i64* %3948, i64 13
	%4045 = getelementptr inbounds i8, i8* %3949, i64 13
	%4046 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %4046, %runtime.Type_Info** %4043
	%4047 = getelementptr inbounds %..string, %..string* %3947, i64 13
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$872, i64 0, i32 0), i64 16}, %..string* %4047
	store i64 168, i64* %4044
	store i8 0, i8* %4045
	%4048 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3942, i64 0, i32 0
	%4049 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %4048, i64 0, i32 0
	store %runtime.Type_Info** %3946, %runtime.Type_Info*** %4049
	%4050 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %4048, i64 0, i32 1
	store i64 14, i64* %4050
	%4051 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3942, i64 0, i32 1
	%4052 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %4051, i64 0, i32 0
	store %..string* %3947, %..string** %4052
	%4053 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %4051, i64 0, i32 1
	store i64 14, i64* %4053
	%4054 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3942, i64 0, i32 2
	%4055 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %4054, i64 0, i32 0
	store i64* %3948, i64** %4055
	%4056 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %4054, i64 0, i32 1
	store i64 14, i64* %4056
	%4057 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3942, i64 0, i32 3
	%4058 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4057, i64 0, i32 0
	store i8* %3949, i8** %4058
	%4059 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4057, i64 0, i32 1
	store i64 14, i64* %4059
	%4060 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %3942, align 8
	%4061 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %3938 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %4060, %runtime.Type_Info_Struct* %4061
	%4062 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %3938, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %4062
	%4063 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 126
	%4064 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4063, i64 0, i32 3
	%4065 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4063, i64 0, i32 0
	store i64 16, i64* %4065
	%4066 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4063, i64 0, i32 1
	store i64 4, i64* %4066
	%4067 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4063, i64 0, i32 2
	store %..typeid 3386706919782613118, %..typeid* %4067
	; Type_Info_Named
	%4068 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4064 to %runtime.Type_Info_Named*
	%4069 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 127
	%4070 = bitcast %runtime.Type_Info* %4069 to %runtime.Type_Info*
	%4071 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4068, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$873, i64 0, i32 0), i64 9}, %..string* %4071
	%4072 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4068, i64 0, i32 1
	store %runtime.Type_Info* %4070, %runtime.Type_Info** %4072
	%4073 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4068, align 8
	%4074 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4064 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %4073, %runtime.Type_Info_Named* %4074
	%4075 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %4064, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %4075
	%4076 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 127
	%4077 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4076, i64 0, i32 3
	%4078 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4076, i64 0, i32 0
	store i64 16, i64* %4078
	%4079 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4076, i64 0, i32 1
	store i64 4, i64* %4079
	%4080 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4076, i64 0, i32 2
	store %..typeid 1080863910568919167, %..typeid* %4080
	; Type_Info_Struct
	%4081 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4077 to %runtime.Type_Info_Struct*
	%4082 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4081, i64 0, i32 4
	store i8 0, i8* %4082
	%4083 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4081, i64 0, i32 5
	store i8 0, i8* %4083
	%4084 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4081, i64 0, i32 6
	store i8 0, i8* %4084
	%4085 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 135
	%4086 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 92
	%4087 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 83
	%4088 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 83
	%4089 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%4090 = bitcast %runtime.Type_Info* %4089 to %runtime.Type_Info*
	%4091 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4085, i64 0
	%4092 = getelementptr inbounds i64, i64* %4087, i64 0
	%4093 = getelementptr inbounds i8, i8* %4088, i64 0
	%4094 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %4094, %runtime.Type_Info** %4091
	%4095 = getelementptr inbounds %..string, %..string* %4086, i64 0
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$874, i64 0, i32 0), i64 2}, %..string* %4095
	store i64 0, i64* %4092
	store i8 0, i8* %4093
	%4096 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%4097 = bitcast %runtime.Type_Info* %4096 to %runtime.Type_Info*
	%4098 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4085, i64 1
	%4099 = getelementptr inbounds i64, i64* %4087, i64 1
	%4100 = getelementptr inbounds i8, i8* %4088, i64 1
	%4101 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %4101, %runtime.Type_Info** %4098
	%4102 = getelementptr inbounds %..string, %..string* %4086, i64 1
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$875, i64 0, i32 0), i64 2}, %..string* %4102
	store i64 4, i64* %4099
	store i8 0, i8* %4100
	%4103 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%4104 = bitcast %runtime.Type_Info* %4103 to %runtime.Type_Info*
	%4105 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4085, i64 2
	%4106 = getelementptr inbounds i64, i64* %4087, i64 2
	%4107 = getelementptr inbounds i8, i8* %4088, i64 2
	%4108 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %4108, %runtime.Type_Info** %4105
	%4109 = getelementptr inbounds %..string, %..string* %4086, i64 2
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$876, i64 0, i32 0), i64 2}, %..string* %4109
	store i64 8, i64* %4106
	store i8 0, i8* %4107
	%4110 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%4111 = bitcast %runtime.Type_Info* %4110 to %runtime.Type_Info*
	%4112 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4085, i64 3
	%4113 = getelementptr inbounds i64, i64* %4087, i64 3
	%4114 = getelementptr inbounds i8, i8* %4088, i64 3
	%4115 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	store %runtime.Type_Info* %4115, %runtime.Type_Info** %4112
	%4116 = getelementptr inbounds %..string, %..string* %4086, i64 3
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$877, i64 0, i32 0), i64 2}, %..string* %4116
	store i64 12, i64* %4113
	store i8 0, i8* %4114
	%4117 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4081, i64 0, i32 0
	%4118 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %4117, i64 0, i32 0
	store %runtime.Type_Info** %4085, %runtime.Type_Info*** %4118
	%4119 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %4117, i64 0, i32 1
	store i64 4, i64* %4119
	%4120 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4081, i64 0, i32 1
	%4121 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %4120, i64 0, i32 0
	store %..string* %4086, %..string** %4121
	%4122 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %4120, i64 0, i32 1
	store i64 4, i64* %4122
	%4123 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4081, i64 0, i32 2
	%4124 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %4123, i64 0, i32 0
	store i64* %4087, i64** %4124
	%4125 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %4123, i64 0, i32 1
	store i64 4, i64* %4125
	%4126 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4081, i64 0, i32 3
	%4127 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4126, i64 0, i32 0
	store i8* %4088, i8** %4127
	%4128 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4126, i64 0, i32 1
	store i64 4, i64* %4128
	%4129 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4081, align 8
	%4130 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4077 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %4129, %runtime.Type_Info_Struct* %4130
	%4131 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %4077, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %4131
	%4132 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 128
	%4133 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4132, i64 0, i32 3
	%4134 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4132, i64 0, i32 0
	store i64 32, i64* %4134
	%4135 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4132, i64 0, i32 1
	store i64 8, i64* %4135
	%4136 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4132, i64 0, i32 2
	store %..typeid 3386706919782613120, %..typeid* %4136
	; Type_Info_Named
	%4137 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4133 to %runtime.Type_Info_Named*
	%4138 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 129
	%4139 = bitcast %runtime.Type_Info* %4138 to %runtime.Type_Info*
	%4140 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4137, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$878, i64 0, i32 0), i64 9}, %..string* %4140
	%4141 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4137, i64 0, i32 1
	store %runtime.Type_Info* %4139, %runtime.Type_Info** %4141
	%4142 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4137, align 8
	%4143 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4133 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %4142, %runtime.Type_Info_Named* %4143
	%4144 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %4133, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %4144
	%4145 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 129
	%4146 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4145, i64 0, i32 3
	%4147 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4145, i64 0, i32 0
	store i64 32, i64* %4147
	%4148 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4145, i64 0, i32 1
	store i64 8, i64* %4148
	%4149 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4145, i64 0, i32 2
	store %..typeid 1080863910568919169, %..typeid* %4149
	; Type_Info_Struct
	%4150 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4146 to %runtime.Type_Info_Struct*
	%4151 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4150, i64 0, i32 4
	store i8 0, i8* %4151
	%4152 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4150, i64 0, i32 5
	store i8 0, i8* %4152
	%4153 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4150, i64 0, i32 6
	store i8 0, i8* %4153
	%4154 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 139
	%4155 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 96
	%4156 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 87
	%4157 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 87
	%4158 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%4159 = bitcast %runtime.Type_Info* %4158 to %runtime.Type_Info*
	%4160 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4154, i64 0
	%4161 = getelementptr inbounds i64, i64* %4156, i64 0
	%4162 = getelementptr inbounds i8, i8* %4157, i64 0
	%4163 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %4163, %runtime.Type_Info** %4160
	%4164 = getelementptr inbounds %..string, %..string* %4155, i64 0
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$879, i64 0, i32 0), i64 2}, %..string* %4164
	store i64 0, i64* %4161
	store i8 0, i8* %4162
	%4165 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%4166 = bitcast %runtime.Type_Info* %4165 to %runtime.Type_Info*
	%4167 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4154, i64 1
	%4168 = getelementptr inbounds i64, i64* %4156, i64 1
	%4169 = getelementptr inbounds i8, i8* %4157, i64 1
	%4170 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %4170, %runtime.Type_Info** %4167
	%4171 = getelementptr inbounds %..string, %..string* %4155, i64 1
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$87a, i64 0, i32 0), i64 2}, %..string* %4171
	store i64 8, i64* %4168
	store i8 0, i8* %4169
	%4172 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%4173 = bitcast %runtime.Type_Info* %4172 to %runtime.Type_Info*
	%4174 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4154, i64 2
	%4175 = getelementptr inbounds i64, i64* %4156, i64 2
	%4176 = getelementptr inbounds i8, i8* %4157, i64 2
	%4177 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %4177, %runtime.Type_Info** %4174
	%4178 = getelementptr inbounds %..string, %..string* %4155, i64 2
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$87b, i64 0, i32 0), i64 2}, %..string* %4178
	store i64 16, i64* %4175
	store i8 0, i8* %4176
	%4179 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%4180 = bitcast %runtime.Type_Info* %4179 to %runtime.Type_Info*
	%4181 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4154, i64 3
	%4182 = getelementptr inbounds i64, i64* %4156, i64 3
	%4183 = getelementptr inbounds i8, i8* %4157, i64 3
	%4184 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %4184, %runtime.Type_Info** %4181
	%4185 = getelementptr inbounds %..string, %..string* %4155, i64 3
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$87c, i64 0, i32 0), i64 2}, %..string* %4185
	store i64 24, i64* %4182
	store i8 0, i8* %4183
	%4186 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4150, i64 0, i32 0
	%4187 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %4186, i64 0, i32 0
	store %runtime.Type_Info** %4154, %runtime.Type_Info*** %4187
	%4188 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %4186, i64 0, i32 1
	store i64 4, i64* %4188
	%4189 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4150, i64 0, i32 1
	%4190 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %4189, i64 0, i32 0
	store %..string* %4155, %..string** %4190
	%4191 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %4189, i64 0, i32 1
	store i64 4, i64* %4191
	%4192 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4150, i64 0, i32 2
	%4193 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %4192, i64 0, i32 0
	store i64* %4156, i64** %4193
	%4194 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %4192, i64 0, i32 1
	store i64 4, i64* %4194
	%4195 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4150, i64 0, i32 3
	%4196 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4195, i64 0, i32 0
	store i8* %4157, i8** %4196
	%4197 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4195, i64 0, i32 1
	store i64 4, i64* %4197
	%4198 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4150, align 8
	%4199 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4146 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %4198, %runtime.Type_Info_Struct* %4199
	%4200 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %4146, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %4200
	%4201 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 130
	%4202 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4201, i64 0, i32 3
	%4203 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4201, i64 0, i32 0
	store i64 36, i64* %4203
	%4204 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4201, i64 0, i32 1
	store i64 4, i64* %4204
	%4205 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4201, i64 0, i32 2
	store %..typeid 3386706919782613122, %..typeid* %4205
	; Type_Info_Named
	%4206 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4202 to %runtime.Type_Info_Named*
	%4207 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 131
	%4208 = bitcast %runtime.Type_Info* %4207 to %runtime.Type_Info*
	%4209 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4206, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$87d, i64 0, i32 0), i64 8}, %..string* %4209
	%4210 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4206, i64 0, i32 1
	store %runtime.Type_Info* %4208, %runtime.Type_Info** %4210
	%4211 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4206, align 8
	%4212 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4202 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %4211, %runtime.Type_Info_Named* %4212
	%4213 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %4202, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %4213
	%4214 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 131
	%4215 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4214, i64 0, i32 3
	%4216 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4214, i64 0, i32 0
	store i64 36, i64* %4216
	%4217 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4214, i64 0, i32 1
	store i64 4, i64* %4217
	%4218 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4214, i64 0, i32 2
	store %..typeid 1080863910568919171, %..typeid* %4218
	; Type_Info_Struct
	%4219 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4215 to %runtime.Type_Info_Struct*
	%4220 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4219, i64 0, i32 4
	store i8 0, i8* %4220
	%4221 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4219, i64 0, i32 5
	store i8 0, i8* %4221
	%4222 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4219, i64 0, i32 6
	store i8 0, i8* %4222
	%4223 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 143
	%4224 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 100
	%4225 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 91
	%4226 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 91
	%4227 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 109
	%4228 = bitcast %runtime.Type_Info* %4227 to %runtime.Type_Info*
	%4229 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4223, i64 0
	%4230 = getelementptr inbounds i64, i64* %4225, i64 0
	%4231 = getelementptr inbounds i8, i8* %4226, i64 0
	%4232 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 109
	store %runtime.Type_Info* %4232, %runtime.Type_Info** %4229
	%4233 = getelementptr inbounds %..string, %..string* %4224, i64 0
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$87e, i64 0, i32 0), i64 8}, %..string* %4233
	store i64 0, i64* %4230
	store i8 0, i8* %4231
	%4234 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 106
	%4235 = bitcast %runtime.Type_Info* %4234 to %runtime.Type_Info*
	%4236 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4223, i64 1
	%4237 = getelementptr inbounds i64, i64* %4225, i64 1
	%4238 = getelementptr inbounds i8, i8* %4226, i64 1
	%4239 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 106
	store %runtime.Type_Info* %4239, %runtime.Type_Info** %4236
	%4240 = getelementptr inbounds %..string, %..string* %4224, i64 1
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$87f, i64 0, i32 0), i64 9}, %..string* %4240
	store i64 12, i64* %4237
	store i8 0, i8* %4238
	%4241 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 132
	%4242 = bitcast %runtime.Type_Info* %4241 to %runtime.Type_Info*
	%4243 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4223, i64 2
	%4244 = getelementptr inbounds i64, i64* %4225, i64 2
	%4245 = getelementptr inbounds i8, i8* %4226, i64 2
	%4246 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 132
	store %runtime.Type_Info* %4246, %runtime.Type_Info** %4243
	%4247 = getelementptr inbounds %..string, %..string* %4224, i64 2
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$880, i64 0, i32 0), i64 5}, %..string* %4247
	store i64 20, i64* %4244
	store i8 0, i8* %4245
	%4248 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4219, i64 0, i32 0
	%4249 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %4248, i64 0, i32 0
	store %runtime.Type_Info** %4223, %runtime.Type_Info*** %4249
	%4250 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %4248, i64 0, i32 1
	store i64 3, i64* %4250
	%4251 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4219, i64 0, i32 1
	%4252 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %4251, i64 0, i32 0
	store %..string* %4224, %..string** %4252
	%4253 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %4251, i64 0, i32 1
	store i64 3, i64* %4253
	%4254 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4219, i64 0, i32 2
	%4255 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %4254, i64 0, i32 0
	store i64* %4225, i64** %4255
	%4256 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %4254, i64 0, i32 1
	store i64 3, i64* %4256
	%4257 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4219, i64 0, i32 3
	%4258 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4257, i64 0, i32 0
	store i8* %4226, i8** %4258
	%4259 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4257, i64 0, i32 1
	store i64 3, i64* %4259
	%4260 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4219, align 8
	%4261 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4215 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %4260, %runtime.Type_Info_Struct* %4261
	%4262 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %4215, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %4262
	%4263 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 134
	%4264 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4263, i64 0, i32 3
	%4265 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4263, i64 0, i32 0
	store i64 4, i64* %4265
	%4266 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4263, i64 0, i32 1
	store i64 1, i64* %4266
	%4267 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4263, i64 0, i32 2
	store %..typeid 3386706919782613126, %..typeid* %4267
	; Type_Info_Named
	%4268 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4264 to %runtime.Type_Info_Named*
	%4269 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 135
	%4270 = bitcast %runtime.Type_Info* %4269 to %runtime.Type_Info*
	%4271 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4268, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$881, i64 0, i32 0), i64 6}, %..string* %4271
	%4272 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4268, i64 0, i32 1
	store %runtime.Type_Info* %4270, %runtime.Type_Info** %4272
	%4273 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4268, align 8
	%4274 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4264 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %4273, %runtime.Type_Info_Named* %4274
	%4275 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %4264, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %4275
	%4276 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 135
	%4277 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4276, i64 0, i32 3
	%4278 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4276, i64 0, i32 0
	store i64 4, i64* %4278
	%4279 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4276, i64 0, i32 1
	store i64 1, i64* %4279
	%4280 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4276, i64 0, i32 2
	store %..typeid 1080863910568919175, %..typeid* %4280
	; Type_Info_Struct
	%4281 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4277 to %runtime.Type_Info_Struct*
	%4282 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4281, i64 0, i32 4
	store i8 0, i8* %4282
	%4283 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4281, i64 0, i32 5
	store i8 0, i8* %4283
	%4284 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4281, i64 0, i32 6
	store i8 0, i8* %4284
	%4285 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 146
	%4286 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 103
	%4287 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 94
	%4288 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 94
	%4289 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	%4290 = bitcast %runtime.Type_Info* %4289 to %runtime.Type_Info*
	%4291 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4285, i64 0
	%4292 = getelementptr inbounds i64, i64* %4287, i64 0
	%4293 = getelementptr inbounds i8, i8* %4288, i64 0
	%4294 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	store %runtime.Type_Info* %4294, %runtime.Type_Info** %4291
	%4295 = getelementptr inbounds %..string, %..string* %4286, i64 0
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$882, i64 0, i32 0), i64 1}, %..string* %4295
	store i64 0, i64* %4292
	store i8 0, i8* %4293
	%4296 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	%4297 = bitcast %runtime.Type_Info* %4296 to %runtime.Type_Info*
	%4298 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4285, i64 1
	%4299 = getelementptr inbounds i64, i64* %4287, i64 1
	%4300 = getelementptr inbounds i8, i8* %4288, i64 1
	%4301 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	store %runtime.Type_Info* %4301, %runtime.Type_Info** %4298
	%4302 = getelementptr inbounds %..string, %..string* %4286, i64 1
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$883, i64 0, i32 0), i64 1}, %..string* %4302
	store i64 1, i64* %4299
	store i8 0, i8* %4300
	%4303 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	%4304 = bitcast %runtime.Type_Info* %4303 to %runtime.Type_Info*
	%4305 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4285, i64 2
	%4306 = getelementptr inbounds i64, i64* %4287, i64 2
	%4307 = getelementptr inbounds i8, i8* %4288, i64 2
	%4308 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	store %runtime.Type_Info* %4308, %runtime.Type_Info** %4305
	%4309 = getelementptr inbounds %..string, %..string* %4286, i64 2
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$884, i64 0, i32 0), i64 1}, %..string* %4309
	store i64 2, i64* %4306
	store i8 0, i8* %4307
	%4310 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	%4311 = bitcast %runtime.Type_Info* %4310 to %runtime.Type_Info*
	%4312 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4285, i64 3
	%4313 = getelementptr inbounds i64, i64* %4287, i64 3
	%4314 = getelementptr inbounds i8, i8* %4288, i64 3
	%4315 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	store %runtime.Type_Info* %4315, %runtime.Type_Info** %4312
	%4316 = getelementptr inbounds %..string, %..string* %4286, i64 3
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$885, i64 0, i32 0), i64 1}, %..string* %4316
	store i64 3, i64* %4313
	store i8 0, i8* %4314
	%4317 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4281, i64 0, i32 0
	%4318 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %4317, i64 0, i32 0
	store %runtime.Type_Info** %4285, %runtime.Type_Info*** %4318
	%4319 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %4317, i64 0, i32 1
	store i64 4, i64* %4319
	%4320 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4281, i64 0, i32 1
	%4321 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %4320, i64 0, i32 0
	store %..string* %4286, %..string** %4321
	%4322 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %4320, i64 0, i32 1
	store i64 4, i64* %4322
	%4323 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4281, i64 0, i32 2
	%4324 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %4323, i64 0, i32 0
	store i64* %4287, i64** %4324
	%4325 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %4323, i64 0, i32 1
	store i64 4, i64* %4325
	%4326 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4281, i64 0, i32 3
	%4327 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4326, i64 0, i32 0
	store i8* %4288, i8** %4327
	%4328 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4326, i64 0, i32 1
	store i64 4, i64* %4328
	%4329 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4281, align 8
	%4330 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4277 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %4329, %runtime.Type_Info_Struct* %4330
	%4331 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %4277, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %4331
	%4332 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 154
	%4333 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4332, i64 0, i32 3
	%4334 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4332, i64 0, i32 0
	store i64 48, i64* %4334
	%4335 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4332, i64 0, i32 1
	store i64 4, i64* %4335
	%4336 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4332, i64 0, i32 2
	store %..typeid 3386706919782613146, %..typeid* %4336
	; Type_Info_Named
	%4337 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4333 to %runtime.Type_Info_Named*
	%4338 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 155
	%4339 = bitcast %runtime.Type_Info* %4338 to %runtime.Type_Info*
	%4340 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4337, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$886, i64 0, i32 0), i64 8}, %..string* %4340
	%4341 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4337, i64 0, i32 1
	store %runtime.Type_Info* %4339, %runtime.Type_Info** %4341
	%4342 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4337, align 8
	%4343 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4333 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %4342, %runtime.Type_Info_Named* %4343
	%4344 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %4333, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %4344
	%4345 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 155
	%4346 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4345, i64 0, i32 3
	%4347 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4345, i64 0, i32 0
	store i64 48, i64* %4347
	%4348 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4345, i64 0, i32 1
	store i64 4, i64* %4348
	%4349 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4345, i64 0, i32 2
	store %..typeid 1080863910568919195, %..typeid* %4349
	; Type_Info_Struct
	%4350 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4346 to %runtime.Type_Info_Struct*
	%4351 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4350, i64 0, i32 4
	store i8 0, i8* %4351
	%4352 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4350, i64 0, i32 5
	store i8 0, i8* %4352
	%4353 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4350, i64 0, i32 6
	store i8 0, i8* %4353
	%4354 = getelementptr inbounds [154 x %runtime.Type_Info*], [154 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 150
	%4355 = getelementptr inbounds [154 x %..string], [154 x %..string]* @__$type_info_names_data, i64 0, i32 107
	%4356 = getelementptr inbounds [154 x i64], [154 x i64]* @__$type_info_offsets_data, i64 0, i32 98
	%4357 = getelementptr inbounds [154 x i8], [154 x i8]* @__$type_info_usings_data, i64 0, i32 98
	%4358 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 109
	%4359 = bitcast %runtime.Type_Info* %4358 to %runtime.Type_Info*
	%4360 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4354, i64 0
	%4361 = getelementptr inbounds i64, i64* %4356, i64 0
	%4362 = getelementptr inbounds i8, i8* %4357, i64 0
	%4363 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 109
	store %runtime.Type_Info* %4363, %runtime.Type_Info** %4360
	%4364 = getelementptr inbounds %..string, %..string* %4355, i64 0
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$887, i64 0, i32 0), i64 8}, %..string* %4364
	store i64 0, i64* %4361
	store i8 0, i8* %4362
	%4365 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 106
	%4366 = bitcast %runtime.Type_Info* %4365 to %runtime.Type_Info*
	%4367 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4354, i64 1
	%4368 = getelementptr inbounds i64, i64* %4356, i64 1
	%4369 = getelementptr inbounds i8, i8* %4357, i64 1
	%4370 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 106
	store %runtime.Type_Info* %4370, %runtime.Type_Info** %4367
	%4371 = getelementptr inbounds %..string, %..string* %4355, i64 1
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$888, i64 0, i32 0), i64 9}, %..string* %4371
	store i64 12, i64* %4368
	store i8 0, i8* %4369
	%4372 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 132
	%4373 = bitcast %runtime.Type_Info* %4372 to %runtime.Type_Info*
	%4374 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4354, i64 2
	%4375 = getelementptr inbounds i64, i64* %4356, i64 2
	%4376 = getelementptr inbounds i8, i8* %4357, i64 2
	%4377 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 132
	store %runtime.Type_Info* %4377, %runtime.Type_Info** %4374
	%4378 = getelementptr inbounds %..string, %..string* %4355, i64 2
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$889, i64 0, i32 0), i64 5}, %..string* %4378
	store i64 20, i64* %4375
	store i8 0, i8* %4376
	%4379 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 109
	%4380 = bitcast %runtime.Type_Info* %4379 to %runtime.Type_Info*
	%4381 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %4354, i64 3
	%4382 = getelementptr inbounds i64, i64* %4356, i64 3
	%4383 = getelementptr inbounds i8, i8* %4357, i64 3
	%4384 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 109
	store %runtime.Type_Info* %4384, %runtime.Type_Info** %4381
	%4385 = getelementptr inbounds %..string, %..string* %4355, i64 3
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$88a, i64 0, i32 0), i64 6}, %..string* %4385
	store i64 36, i64* %4382
	store i8 0, i8* %4383
	%4386 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4350, i64 0, i32 0
	%4387 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %4386, i64 0, i32 0
	store %runtime.Type_Info** %4354, %runtime.Type_Info*** %4387
	%4388 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %4386, i64 0, i32 1
	store i64 4, i64* %4388
	%4389 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4350, i64 0, i32 1
	%4390 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %4389, i64 0, i32 0
	store %..string* %4355, %..string** %4390
	%4391 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %4389, i64 0, i32 1
	store i64 4, i64* %4391
	%4392 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4350, i64 0, i32 2
	%4393 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %4392, i64 0, i32 0
	store i64* %4356, i64** %4393
	%4394 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %4392, i64 0, i32 1
	store i64 4, i64* %4394
	%4395 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4350, i64 0, i32 3
	%4396 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4395, i64 0, i32 0
	store i8* %4357, i8** %4396
	%4397 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4395, i64 0, i32 1
	store i64 4, i64* %4397
	%4398 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %4350, align 8
	%4399 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4346 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %4398, %runtime.Type_Info_Struct* %4399
	%4400 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %4346, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %4400
	%4401 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 119
	%4402 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4401, i64 0, i32 3
	%4403 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4401, i64 0, i32 0
	store i64 8, i64* %4403
	%4404 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4401, i64 0, i32 1
	store i64 8, i64* %4404
	%4405 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %4401, i64 0, i32 2
	store %..typeid 6989586621679009911, %..typeid* %4405
	; Type_Info_Named
	%4406 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4402 to %runtime.Type_Info_Named*
	%4407 = getelementptr inbounds [156 x %runtime.Type_Info], [156 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%4408 = bitcast %runtime.Type_Info* %4407 to %runtime.Type_Info*
	%4409 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4406, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$88b, i64 0, i32 0), i64 8}, %..string* %4409
	%4410 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4406, i64 0, i32 1
	store %runtime.Type_Info* %4408, %runtime.Type_Info** %4410
	%4411 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4406, align 8
	%4412 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4402 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %4411, %runtime.Type_Info_Named* %4412
	%4413 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %4402, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %4413
	store i32 1, i32* @os.stdout
	store i32 2, i32* @os.stderr
	store [5 x %utf8.Accept_Range] [%utf8.Accept_Range {i8 128, i8 191}, %utf8.Accept_Range {i8 160, i8 191}, %utf8.Accept_Range {i8 128, i8 159}, %utf8.Accept_Range {i8 144, i8 191}, %utf8.Accept_Range {i8 128, i8 143}], [5 x %utf8.Accept_Range]* @utf8.accept_ranges
	store [256 x i8] [i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 19, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 35, i8 3, i8 3, i8 52, i8 4, i8 4, i8 4, i8 68, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241], [256 x i8]* @utf8.accept_sizes
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$88c, i64 0, i32 0), i64 17}, %..string* @fmt.__DIGITS_LOWER
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$88d, i64 0, i32 0), i64 17}, %..string* @fmt.__DIGITS_UPPER
	store i8 1, i8* @workbench.window_is_focused
	store i8 1, i8* @workbench._new_window_is_focused
	store float 0x3ff0000000000000, float* @workbench.camera_size
	store %workbench.Colorf {float 0x0000000000000000, float 0x3ff0000000000000, float 0x0000000000000000, float 0x3ff0000000000000}, %workbench.Colorf* @workbench.COLOR_GREEN
	store i32 -1, i32* @workbench.debugging_rendering_max_draw_calls
	store i8 0, i8* @workbench.do_log_frame_boundaries
	store i64 -1, i64* @workbench.hot
	store i64 -1, i64* @workbench.warm
	store i64 -1, i64* @workbench.previously_hot
	store i64 -1, i64* @workbench.previously_warm
	store %strconv.FloatInfo {i64 23, i64 8, i64 -127}, %strconv.FloatInfo* @strconv._f32_info
	store %strconv.FloatInfo {i64 52, i64 11, i64 -1023}, %strconv.FloatInfo* @strconv._f64_info
	store %..string {i8* getelementptr inbounds ([37 x i8], [37 x i8]* @str$88e, i64 0, i32 0), i64 36}, %..string* @strconv.digits
	store i64 0, i64* @gl.loaded_up_to_major
	store i64 0, i64* @gl.loaded_up_to_minor
	; SelectorExpr
	%4414 = getelementptr inbounds %runtime.Context, %runtime.Context* %0, i64 0, i32 0
	%4415 = load %mem.Allocator, %mem.Allocator* %4414, align 8
	%4416 = bitcast %mem.Allocator* %4 to %..rawptr
	%4417 = call %..rawptr @mem.zero(%..rawptr %4416, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %4
	store %mem.Allocator %4415, %mem.Allocator* %4
	%4418 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	%4419 = call %..rawptr @mem.zero(%..rawptr %4418, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$88f, i64 0, i32 0), i64 63}, i64 52, i64 10, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$890, i64 0, i32 0), i64 18}}, %runtime.Source_Code_Location* %5
	%4420 = call {%workbench.Key_Press*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-6385(i64 0, i64 5, %mem.Allocator* %4, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %0) noinline
	store {%workbench.Key_Press*, i64, i64, %mem.Allocator} %4420, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held
	; SelectorExpr
	%4421 = getelementptr inbounds %runtime.Context, %runtime.Context* %0, i64 0, i32 0
	%4422 = load %mem.Allocator, %mem.Allocator* %4421, align 8
	%4423 = bitcast %mem.Allocator* %6 to %..rawptr
	%4424 = call %..rawptr @mem.zero(%..rawptr %4423, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %6
	store %mem.Allocator %4422, %mem.Allocator* %6
	%4425 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%4426 = call %..rawptr @mem.zero(%..rawptr %4425, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$891, i64 0, i32 0), i64 63}, i64 53, i64 10, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$892, i64 0, i32 0), i64 18}}, %runtime.Source_Code_Location* %7
	%4427 = call {%workbench.Key_Press*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-6385(i64 0, i64 5, %mem.Allocator* %6, %runtime.Source_Code_Location* %7, %runtime.Context* noalias nonnull nocapture inreg %0) noinline
	store {%workbench.Key_Press*, i64, i64, %mem.Allocator} %4427, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._down
	; SelectorExpr
	%4428 = getelementptr inbounds %runtime.Context, %runtime.Context* %0, i64 0, i32 0
	%4429 = load %mem.Allocator, %mem.Allocator* %4428, align 8
	%4430 = bitcast %mem.Allocator* %8 to %..rawptr
	%4431 = call %..rawptr @mem.zero(%..rawptr %4430, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %8
	store %mem.Allocator %4429, %mem.Allocator* %8
	%4432 = bitcast %runtime.Source_Code_Location* %9 to %..rawptr
	%4433 = call %..rawptr @mem.zero(%..rawptr %4432, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %9
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$893, i64 0, i32 0), i64 63}, i64 54, i64 10, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$894, i64 0, i32 0), i64 18}}, %runtime.Source_Code_Location* %9
	%4434 = call {%workbench.Key_Press*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-6385(i64 0, i64 5, %mem.Allocator* %8, %runtime.Source_Code_Location* %9, %runtime.Context* noalias nonnull nocapture inreg %0) noinline
	store {%workbench.Key_Press*, i64, i64, %mem.Allocator} %4434, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._up
	; SelectorExpr
	%4435 = getelementptr inbounds %runtime.Context, %runtime.Context* %0, i64 0, i32 0
	%4436 = load %mem.Allocator, %mem.Allocator* %4435, align 8
	%4437 = bitcast %mem.Allocator* %10 to %..rawptr
	%4438 = call %..rawptr @mem.zero(%..rawptr %4437, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %10
	store %mem.Allocator %4436, %mem.Allocator* %10
	%4439 = bitcast %runtime.Source_Code_Location* %11 to %..rawptr
	%4440 = call %..rawptr @mem.zero(%..rawptr %4439, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %11
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$895, i64 0, i32 0), i64 63}, i64 56, i64 20, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$896, i64 0, i32 0), i64 18}}, %runtime.Source_Code_Location* %11
	%4441 = call {%workbench.Key_Press*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-6385(i64 0, i64 5, %mem.Allocator* %10, %runtime.Source_Code_Location* %11, %runtime.Context* noalias nonnull nocapture inreg %0) noinline
	store {%workbench.Key_Press*, i64, i64, %mem.Allocator} %4441, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._held_mid_frame
	; SelectorExpr
	%4442 = getelementptr inbounds %runtime.Context, %runtime.Context* %0, i64 0, i32 0
	%4443 = load %mem.Allocator, %mem.Allocator* %4442, align 8
	%4444 = bitcast %mem.Allocator* %12 to %..rawptr
	%4445 = call %..rawptr @mem.zero(%..rawptr %4444, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %12
	store %mem.Allocator %4443, %mem.Allocator* %12
	%4446 = bitcast %runtime.Source_Code_Location* %13 to %..rawptr
	%4447 = call %..rawptr @mem.zero(%..rawptr %4446, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %13
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$897, i64 0, i32 0), i64 63}, i64 57, i64 20, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$898, i64 0, i32 0), i64 18}}, %runtime.Source_Code_Location* %13
	%4448 = call {%workbench.Key_Press*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-6385(i64 0, i64 5, %mem.Allocator* %12, %runtime.Source_Code_Location* %13, %runtime.Context* noalias nonnull nocapture inreg %0) noinline
	store {%workbench.Key_Press*, i64, i64, %mem.Allocator} %4448, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._down_mid_frame
	; SelectorExpr
	%4449 = getelementptr inbounds %runtime.Context, %runtime.Context* %0, i64 0, i32 0
	%4450 = load %mem.Allocator, %mem.Allocator* %4449, align 8
	%4451 = bitcast %mem.Allocator* %14 to %..rawptr
	%4452 = call %..rawptr @mem.zero(%..rawptr %4451, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %14
	store %mem.Allocator %4450, %mem.Allocator* %14
	%4453 = bitcast %runtime.Source_Code_Location* %15 to %..rawptr
	%4454 = call %..rawptr @mem.zero(%..rawptr %4453, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %15
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$899, i64 0, i32 0), i64 63}, i64 58, i64 20, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$89a, i64 0, i32 0), i64 18}}, %runtime.Source_Code_Location* %15
	%4455 = call {%workbench.Key_Press*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-6385(i64 0, i64 5, %mem.Allocator* %14, %runtime.Source_Code_Location* %15, %runtime.Context* noalias nonnull nocapture inreg %0) noinline
	store {%workbench.Key_Press*, i64, i64, %mem.Allocator} %4455, {%workbench.Key_Press*, i64, i64, %mem.Allocator}* @workbench._up_mid_frame
	ret void
}
@__$type_info_data = private global [156 x %runtime.Type_Info] zeroinitializer
@__$type_info_types_data = global [154 x %runtime.Type_Info*] zeroinitializer
@__$type_info_names_data = global [154 x %..string] zeroinitializer
@__$type_info_offsets_data = global [154 x i64] zeroinitializer
@__$type_info_usings_data = global [154 x i8] zeroinitializer
@ggv$0 = global %runtime.Context zeroinitializer
@runtime.type_table = global {%runtime.Type_Info*, i64} zeroinitializer
@runtime.args__ = global {i8**, i64} zeroinitializer
@runtime.global_scratch_allocator_data = global %mem.Scratch_Allocator zeroinitializer
@main.mesh_entity = global i64 zeroinitializer
@main.last_entity_id = global i64 zeroinitializer
@main.all_transforms = global {%main.Transform*, i64, i64, %mem.Allocator} zeroinitializer
@main.all_sprite_renderers = global {%main.Sprite_Renderer*, i64, i64, %mem.Allocator} zeroinitializer
@main.all_spinners = global {%main.Spinner_Component*, i64, i64, %mem.Allocator} zeroinitializer
@main.all_mesh_renderers = global {%main.Mesh_Renderer*, i64, i64, %mem.Allocator} zeroinitializer
@os.stdout = global i32 1
@os.stderr = global i32 2
@utf8.accept_ranges = global [5 x %utf8.Accept_Range] [%utf8.Accept_Range {i8 128, i8 191}, %utf8.Accept_Range {i8 160, i8 191}, %utf8.Accept_Range {i8 128, i8 159}, %utf8.Accept_Range {i8 144, i8 191}, %utf8.Accept_Range {i8 128, i8 143}]
@utf8.accept_sizes = global [256 x i8] [i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 19, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 35, i8 3, i8 3, i8 52, i8 4, i8 4, i8 4, i8 68, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241]
@fmt.__DIGITS_LOWER = global %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$89b, i64 0, i32 0), i64 17}
@fmt.__DIGITS_UPPER = global %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$89c, i64 0, i32 0), i64 17}
@workbench.rstate = global %rand.Rand zeroinitializer
@workbench.main_window = global %..rawptr zeroinitializer
@workbench.window_is_focused = global i8 1
@workbench.current_window_width = global float zeroinitializer
@workbench.current_window_height = global float zeroinitializer
@workbench.current_aspect_ratio = global float zeroinitializer
@workbench.cursor_scroll = global float zeroinitializer
@workbench.cursor_screen_position = global [2 x float] zeroinitializer
@workbench.cursor_unit_position = global [2 x float] zeroinitializer
@workbench.frame_count = global i64 zeroinitializer
@workbench.time = global float zeroinitializer
@workbench.lossy_delta_time = global float zeroinitializer
@workbench._new_window_width = global float zeroinitializer
@workbench._new_window_height = global float zeroinitializer
@workbench._new_aspect_ratio = global float zeroinitializer
@workbench._new_cursor_scroll = global float zeroinitializer
@workbench._new_cursor_screen_position = global [2 x float] zeroinitializer
@workbench._new_window_is_focused = global i8 1
@workbench.all_items = global {%workbench.Catalog_Item**, i64, i64, %mem.Allocator} zeroinitializer
@workbench.mvp_matrix = global [4 x [4 x float]] zeroinitializer
@workbench.view_matrix = global [4 x [4 x float]] zeroinitializer
@workbench.model_matrix = global [4 x [4 x float]] zeroinitializer
@workbench.perspective_projection_matrix = global [4 x [4 x float]] zeroinitializer
@workbench.orthographic_projection_matrix = global [4 x [4 x float]] zeroinitializer
@workbench.unit_to_pixel_matrix = global [4 x [4 x float]] zeroinitializer
@workbench.unit_to_viewport_matrix = global [4 x [4 x float]] zeroinitializer
@workbench.pixel_to_viewport_matrix = global [4 x [4 x float]] zeroinitializer
@workbench.viewport_to_pixel_matrix = global [4 x [4 x float]] zeroinitializer
@workbench.viewport_to_unit_matrix = global [4 x [4 x float]] zeroinitializer
@workbench.is_perspective = global i8 zeroinitializer
@workbench.camera_size = global float 0x3ff0000000000000
@workbench.camera_position = global [3 x float] zeroinitializer
@workbench.COLOR_GREEN = global %workbench.Colorf {float 0x0000000000000000, float 0x3ff0000000000000, float 0x0000000000000000, float 0x3ff0000000000000}
@workbench.current_render_layer = global i64 zeroinitializer
@workbench.do_scissor = global i8 zeroinitializer
@workbench.scissor_rect1 = global [4 x i64] zeroinitializer
@workbench.im_buffered_verts = global {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} zeroinitializer
@workbench.im_queued_for_drawing = global {%workbench.Vertex2D*, i64, i64, %mem.Allocator} zeroinitializer
@workbench.is_scissor = global i8 zeroinitializer
@workbench.current_shader = global i32 zeroinitializer
@workbench.current_texture = global i32 zeroinitializer
@workbench.current_rendermode = global void (%runtime.Context*)* zeroinitializer
@workbench.debugging_rendering = global i8 zeroinitializer
@workbench.debugging_rendering_max_draw_calls = global i32 -1
@workbench.num_draw_calls = global i32 zeroinitializer
@workbench.debug_vertices = global {%workbench.Buffered_Vertex*, i64, i64, %mem.Allocator} zeroinitializer
@workbench.all_meshes = global {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench.Mesh}*, i64, i64, %mem.Allocator}} zeroinitializer
@workbench.cur_mesh_id = global i64 zeroinitializer
@workbench.client_target_framerate = global float zeroinitializer
@workbench.client_target_delta_time = global float zeroinitializer
@workbench.whole_frame_time_ra = global %"workbench.Rolling_Average-1020.Rolling_Average\28f64\2C\20100\29" zeroinitializer
@workbench.do_log_frame_boundaries = global i8 0
@workbench.wb_should_close = global i8 zeroinitializer
@workbench.cur_scene_serial = global i64 zeroinitializer
@workbench.all_scenes = global {{i64*, i64}, {{%runtime.Map_Key, i64, %workbench._Scene_Internal}*, i64, i64, %mem.Allocator}} zeroinitializer
@workbench.new_scenes = global {%workbench._Scene_Internal*, i64, i64, %mem.Allocator} zeroinitializer
@workbench.end_scenes = global {i64*, i64, i64, %mem.Allocator} zeroinitializer
@workbench.debug_window_open = global i8 zeroinitializer
@workbench.vao = global i32 zeroinitializer
@workbench.vbo = global i32 zeroinitializer
@workbench.shader_rgba = global i32 zeroinitializer
@workbench.shader_text = global i32 zeroinitializer
@workbench.shader_texture = global i32 zeroinitializer
@workbench.shader_rgba_3d = global i32 zeroinitializer
@workbench.tweeners = global {%workbench.Tweener**, i64, i64, %mem.Allocator} zeroinitializer
@workbench.updating_tweens = global i8 zeroinitializer
@workbench.imgui_program = global i32 zeroinitializer
@workbench.imgui_uniform_texture = global i32 zeroinitializer
@workbench.imgui_uniform_projection = global i32 zeroinitializer
@workbench.imgui_attrib_position = global i32 zeroinitializer
@workbench.imgui_attrib_uv = global i32 zeroinitializer
@workbench.imgui_attrib_color = global i32 zeroinitializer
@workbench.imgui_vbo_handle = global i32 zeroinitializer
@workbench.imgui_ebo_handle = global i32 zeroinitializer
@workbench.imgui_font_default = global %imgui.Font* zeroinitializer
@workbench.imgui_font_mono = global %imgui.Font* zeroinitializer
@workbench.hot = global i64 -1
@workbench.warm = global i64 -1
@workbench.previously_hot = global i64 -1
@workbench.previously_warm = global i64 -1
@workbench.cursor_pixel_position_on_clicked = global [2 x float] zeroinitializer
@workbench.all_imgui_mappings = global {%workbench.Location_ID_Mapping*, i64, i64, %mem.Allocator} zeroinitializer
@workbench.ui_rect_stack = global {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} zeroinitializer
@workbench.all_imgui_rects = global {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} zeroinitializer
@workbench.new_imgui_rects = global {%workbench.IMGUI_Rect*, i64, i64, %mem.Allocator} zeroinitializer
@workbench.ui_current_rect_unit = global %"workbench.Rect-1229.Rect\28f32\29" zeroinitializer
@workbench.ui_current_rect_pixels = global %"workbench.Rect-1229.Rect\28int\29" zeroinitializer
@workbench.current_scroll_view = global %workbench.Scroll_View* zeroinitializer
@workbench.ui_debug_cur_idx = global i64 zeroinitializer
@workbench.debugging_ui = global i8 zeroinitializer
@workbench.all_ui_debug_file_lines = global {%workbench.UI_Debug_File_Line*, i64, i64, %mem.Allocator} zeroinitializer
@strconv._f32_info = global %strconv.FloatInfo {i64 23, i64 8, i64 -127}
@strconv._f64_info = global %strconv.FloatInfo {i64 52, i64 11, i64 -1023}
@strconv.digits = global %..string {i8* getelementptr inbounds ([37 x i8], [37 x i8]* @str$89d, i64 0, i32 0), i64 36}
@gl.loaded_up_to = global %..string zeroinitializer
@gl.loaded_up_to_major = global i64 0
@gl.loaded_up_to_minor = global i64 0
@gl.CullFace = global void (i32)* zeroinitializer
@gl.FrontFace = global void (i32)* zeroinitializer
@gl.Hint = global void (i32, i32)* zeroinitializer
@gl.LineWidth = global void (float)* zeroinitializer
@gl.PointSize = global void (float)* zeroinitializer
@gl.PolygonMode = global void (i32, i32)* zeroinitializer
@gl.Scissor = global void (i32, i32, i32, i32)* zeroinitializer
@gl.TexParameterf = global void (i32, i32, float)* zeroinitializer
@gl.TexParameterfv = global void (i32, i32, float*)* zeroinitializer
@gl.TexParameteri = global void (i32, i32, i32)* zeroinitializer
@gl.TexParameteriv = global void (i32, i32, i32*)* zeroinitializer
@gl.TexImage1D = global void (i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.TexImage2D = global void (i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.DrawBuffer = global void (i32)* zeroinitializer
@gl.Clear = global void (i32)* zeroinitializer
@gl.ClearColor = global void (float, float, float, float)* zeroinitializer
@gl.ClearStencil = global void (i32)* zeroinitializer
@gl.ClearDepth = global void (double)* zeroinitializer
@gl.StencilMask = global void (i32)* zeroinitializer
@gl.ColorMask = global void (i8, i8, i8, i8)* zeroinitializer
@gl.DepthMask = global void (i8)* zeroinitializer
@gl.Disable = global void (i32)* zeroinitializer
@gl.Enable = global void (i32)* zeroinitializer
@gl.Finish = global void ()* zeroinitializer
@gl.Flush = global void ()* zeroinitializer
@gl.BlendFunc = global void (i32, i32)* zeroinitializer
@gl.LogicOp = global void (i32)* zeroinitializer
@gl.StencilFunc = global void (i32, i32, i32)* zeroinitializer
@gl.StencilOp = global void (i32, i32, i32)* zeroinitializer
@gl.DepthFunc = global void (i32)* zeroinitializer
@gl.PixelStoref = global void (i32, float)* zeroinitializer
@gl.PixelStorei = global void (i32, i32)* zeroinitializer
@gl.ReadBuffer = global void (i32)* zeroinitializer
@gl.ReadPixels = global void (i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.GetBooleanv = global void (i32, i8*)* zeroinitializer
@gl.GetDoublev = global void (i32, double*)* zeroinitializer
@gl.GetError = global i32 ()* zeroinitializer
@gl.GetFloatv = global void (i32, float*)* zeroinitializer
@gl.GetIntegerv = global void (i32, i32*)* zeroinitializer
@gl.GetString = global i8* (i32)* zeroinitializer
@gl.GetTexImage = global void (i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.GetTexParameterfv = global void (i32, i32, float*)* zeroinitializer
@gl.GetTexParameteriv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetTexLevelParameterfv = global void (i32, i32, i32, float*)* zeroinitializer
@gl.GetTexLevelParameteriv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.IsEnabled = global i8 (i32)* zeroinitializer
@gl.DepthRange = global void (double, double)* zeroinitializer
@gl.Viewport = global void (i32, i32, i32, i32)* zeroinitializer
@gl.DrawArrays = global void (i32, i32, i32)* zeroinitializer
@gl.DrawElements = global void (i32, i32, i32, %..rawptr)* zeroinitializer
@gl.PolygonOffset = global void (float, float)* zeroinitializer
@gl.CopyTexImage1D = global void (i32, i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.CopyTexImage2D = global void (i32, i32, i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.CopyTexSubImage1D = global void (i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.CopyTexSubImage2D = global void (i32, i32, i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.TexSubImage1D = global void (i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.TexSubImage2D = global void (i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.BindTexture = global void (i32, i32)* zeroinitializer
@gl.DeleteTextures = global void (i32, i32*)* zeroinitializer
@gl.GenTextures = global void (i32, i32*)* zeroinitializer
@gl.IsTexture = global i8 (i32)* zeroinitializer
@gl.DrawRangeElements = global void (i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.TexImage3D = global void (i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.TexSubImage3D = global void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.CopyTexSubImage3D = global void (i32, i32, i32, i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.ActiveTexture = global void (i32)* zeroinitializer
@gl.SampleCoverage = global void (float, i8)* zeroinitializer
@gl.CompressedTexImage3D = global void (i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.CompressedTexImage2D = global void (i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.CompressedTexImage1D = global void (i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.CompressedTexSubImage3D = global void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.CompressedTexSubImage2D = global void (i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.CompressedTexSubImage1D = global void (i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.GetCompressedTexImage = global void (i32, i32, %..rawptr)* zeroinitializer
@gl.BlendFuncSeparate = global void (i32, i32, i32, i32)* zeroinitializer
@gl.MultiDrawArrays = global void (i32, i32*, i32*, i32)* zeroinitializer
@gl.MultiDrawElements = global void (i32, i32*, i32, %..rawptr*, i32)* zeroinitializer
@gl.PointParameterf = global void (i32, float)* zeroinitializer
@gl.PointParameterfv = global void (i32, float*)* zeroinitializer
@gl.PointParameteri = global void (i32, i32)* zeroinitializer
@gl.PointParameteriv = global void (i32, i32*)* zeroinitializer
@gl.BlendColor = global void (float, float, float, float)* zeroinitializer
@gl.BlendEquation = global void (i32)* zeroinitializer
@gl.GenQueries = global void (i32, i32*)* zeroinitializer
@gl.DeleteQueries = global void (i32, i32*)* zeroinitializer
@gl.IsQuery = global i8 (i32)* zeroinitializer
@gl.BeginQuery = global void (i32, i32)* zeroinitializer
@gl.EndQuery = global void (i32)* zeroinitializer
@gl.GetQueryiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetQueryObjectiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetQueryObjectuiv = global void (i32, i32, i32*)* zeroinitializer
@gl.BindBuffer = global void (i32, i32)* zeroinitializer
@gl.DeleteBuffers = global void (i32, i32*)* zeroinitializer
@gl.GenBuffers = global void (i32, i32*)* zeroinitializer
@gl.IsBuffer = global i8 (i32)* zeroinitializer
@gl.BufferData = global void (i32, i64, %..rawptr, i32)* zeroinitializer
@gl.BufferSubData = global void (i32, i64, i64, %..rawptr)* zeroinitializer
@gl.GetBufferSubData = global void (i32, i64, i64, %..rawptr)* zeroinitializer
@gl.MapBuffer = global %..rawptr (i32, i32)* zeroinitializer
@gl.UnmapBuffer = global i8 (i32)* zeroinitializer
@gl.GetBufferParameteriv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetBufferPointerv = global void (i32, i32, %..rawptr*)* zeroinitializer
@gl.BlendEquationSeparate = global void (i32, i32)* zeroinitializer
@gl.DrawBuffers = global void (i32, i32*)* zeroinitializer
@gl.StencilOpSeparate = global void (i32, i32, i32, i32)* zeroinitializer
@gl.StencilFuncSeparate = global void (i32, i32, i32, i32)* zeroinitializer
@gl.StencilMaskSeparate = global void (i32, i32)* zeroinitializer
@gl.AttachShader = global void (i32, i32)* zeroinitializer
@gl.BindAttribLocation = global void (i32, i32, i8*)* zeroinitializer
@gl.CompileShader = global void (i32)* zeroinitializer
@gl.CreateProgram = global i32 ()* zeroinitializer
@gl.CreateShader = global i32 (i32)* zeroinitializer
@gl.DeleteProgram = global void (i32)* zeroinitializer
@gl.DeleteShader = global void (i32)* zeroinitializer
@gl.DetachShader = global void (i32, i32)* zeroinitializer
@gl.DisableVertexAttribArray = global void (i32)* zeroinitializer
@gl.EnableVertexAttribArray = global void (i32)* zeroinitializer
@gl.GetActiveAttrib = global void (i32, i32, i32, i32*, i32*, i32*, i8*)* zeroinitializer
@gl.GetActiveUniform = global void (i32, i32, i32, i32*, i32*, i32*, i8*)* zeroinitializer
@gl.GetAttachedShaders = global void (i32, i32, i32*, i32*)* zeroinitializer
@gl.GetAttribLocation = global i32 (i32, i8*)* zeroinitializer
@gl.GetProgramiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetProgramInfoLog = global void (i32, i32, i32*, i8*)* zeroinitializer
@gl.GetShaderiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetShaderInfoLog = global void (i32, i32, i32*, i8*)* zeroinitializer
@gl.GetShaderSource = global void (i32, i32, i32*, i8*)* zeroinitializer
@gl.GetUniformLocation = global i32 (i32, i8*)* zeroinitializer
@gl.GetUniformfv = global void (i32, i32, float*)* zeroinitializer
@gl.GetUniformiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetVertexAttribdv = global void (i32, i32, double*)* zeroinitializer
@gl.GetVertexAttribfv = global void (i32, i32, float*)* zeroinitializer
@gl.GetVertexAttribiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetVertexAttribPointerv = global void (i32, i32, %..rawptr*)* zeroinitializer
@gl.IsProgram = global i8 (i32)* zeroinitializer
@gl.IsShader = global i8 (i32)* zeroinitializer
@gl.LinkProgram = global void (i32)* zeroinitializer
@gl.ShaderSource = global void (i32, i32, i8**, i32*)* zeroinitializer
@gl.UseProgram = global void (i32)* zeroinitializer
@gl.Uniform1f = global void (i32, float)* zeroinitializer
@gl.Uniform2f = global void (i32, float, float)* zeroinitializer
@gl.Uniform3f = global void (i32, float, float, float)* zeroinitializer
@gl.Uniform4f = global void (i32, float, float, float, float)* zeroinitializer
@gl.Uniform1i = global void (i32, i32)* zeroinitializer
@gl.Uniform2i = global void (i32, i32, i32)* zeroinitializer
@gl.Uniform3i = global void (i32, i32, i32, i32)* zeroinitializer
@gl.Uniform4i = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.Uniform1fv = global void (i32, i32, float*)* zeroinitializer
@gl.Uniform2fv = global void (i32, i32, float*)* zeroinitializer
@gl.Uniform3fv = global void (i32, i32, float*)* zeroinitializer
@gl.Uniform4fv = global void (i32, i32, float*)* zeroinitializer
@gl.Uniform1iv = global void (i32, i32, i32*)* zeroinitializer
@gl.Uniform2iv = global void (i32, i32, i32*)* zeroinitializer
@gl.Uniform3iv = global void (i32, i32, i32*)* zeroinitializer
@gl.Uniform4iv = global void (i32, i32, i32*)* zeroinitializer
@gl.UniformMatrix2fv = global void (i32, i32, i8, float*)* zeroinitializer
@gl.UniformMatrix3fv = global void (i32, i32, i8, float*)* zeroinitializer
@gl.UniformMatrix4fv = global void (i32, i32, i8, float*)* zeroinitializer
@gl.ValidateProgram = global void (i32)* zeroinitializer
@gl.VertexAttrib1d = global void (i32, double)* zeroinitializer
@gl.VertexAttrib1dv = global void (i32, double*)* zeroinitializer
@gl.VertexAttrib1f = global void (i32, float)* zeroinitializer
@gl.VertexAttrib1fv = global void (i32, float*)* zeroinitializer
@gl.VertexAttrib1s = global void (i32, i16)* zeroinitializer
@gl.VertexAttrib1sv = global void (i32, i16*)* zeroinitializer
@gl.VertexAttrib2d = global void (i32, double, double)* zeroinitializer
@gl.VertexAttrib2dv = global void (i32, double*)* zeroinitializer
@gl.VertexAttrib2f = global void (i32, float, float)* zeroinitializer
@gl.VertexAttrib2fv = global void (i32, float*)* zeroinitializer
@gl.VertexAttrib2s = global void (i32, i16, i16)* zeroinitializer
@gl.VertexAttrib2sv = global void (i32, i16*)* zeroinitializer
@gl.VertexAttrib3d = global void (i32, double, double, double)* zeroinitializer
@gl.VertexAttrib3dv = global void (i32, double*)* zeroinitializer
@gl.VertexAttrib3f = global void (i32, float, float, float)* zeroinitializer
@gl.VertexAttrib3fv = global void (i32, float*)* zeroinitializer
@gl.VertexAttrib3s = global void (i32, i16, i16, i16)* zeroinitializer
@gl.VertexAttrib3sv = global void (i32, i16*)* zeroinitializer
@gl.VertexAttrib4Nbv = global void (i32, i8*)* zeroinitializer
@gl.VertexAttrib4Niv = global void (i32, i32*)* zeroinitializer
@gl.VertexAttrib4Nsv = global void (i32, i16*)* zeroinitializer
@gl.VertexAttrib4Nub = global void (i32, i8, i8, i8, i8)* zeroinitializer
@gl.VertexAttrib4Nubv = global void (i32, i8*)* zeroinitializer
@gl.VertexAttrib4Nuiv = global void (i32, i32*)* zeroinitializer
@gl.VertexAttrib4Nusv = global void (i32, i16*)* zeroinitializer
@gl.VertexAttrib4bv = global void (i32, i8*)* zeroinitializer
@gl.VertexAttrib4d = global void (i32, double, double, double, double)* zeroinitializer
@gl.VertexAttrib4dv = global void (i32, double*)* zeroinitializer
@gl.VertexAttrib4f = global void (i32, float, float, float, float)* zeroinitializer
@gl.VertexAttrib4fv = global void (i32, float*)* zeroinitializer
@gl.VertexAttrib4iv = global void (i32, i32*)* zeroinitializer
@gl.VertexAttrib4s = global void (i32, i16, i16, i16, i16)* zeroinitializer
@gl.VertexAttrib4sv = global void (i32, i16*)* zeroinitializer
@gl.VertexAttrib4ubv = global void (i32, i8*)* zeroinitializer
@gl.VertexAttrib4uiv = global void (i32, i32*)* zeroinitializer
@gl.VertexAttrib4usv = global void (i32, i16*)* zeroinitializer
@gl.VertexAttribPointer = global void (i32, i32, i32, i8, i32, %..rawptr)* zeroinitializer
@gl.UniformMatrix2x3fv = global void (i32, i32, i8, float*)* zeroinitializer
@gl.UniformMatrix3x2fv = global void (i32, i32, i8, float*)* zeroinitializer
@gl.UniformMatrix2x4fv = global void (i32, i32, i8, float*)* zeroinitializer
@gl.UniformMatrix4x2fv = global void (i32, i32, i8, float*)* zeroinitializer
@gl.UniformMatrix3x4fv = global void (i32, i32, i8, float*)* zeroinitializer
@gl.UniformMatrix4x3fv = global void (i32, i32, i8, float*)* zeroinitializer
@gl.ColorMaski = global void (i32, i8, i8, i8, i8)* zeroinitializer
@gl.GetBooleani_v = global void (i32, i32, i8*)* zeroinitializer
@gl.GetIntegeri_v = global void (i32, i32, i32*)* zeroinitializer
@gl.Enablei = global void (i32, i32)* zeroinitializer
@gl.Disablei = global void (i32, i32)* zeroinitializer
@gl.IsEnabledi = global i8 (i32, i32)* zeroinitializer
@gl.BeginTransformFeedback = global void (i32)* zeroinitializer
@gl.EndTransformFeedback = global void ()* zeroinitializer
@gl.BindBufferRange = global void (i32, i32, i32, i64, i64)* zeroinitializer
@gl.BindBufferBase = global void (i32, i32, i32)* zeroinitializer
@gl.TransformFeedbackVaryings = global void (i32, i32, i8*, i32)* zeroinitializer
@gl.GetTransformFeedbackVarying = global void (i32, i32, i32, i32*, i32*, i32*, i8*)* zeroinitializer
@gl.ClampColor = global void (i32, i32)* zeroinitializer
@gl.BeginConditionalRender = global void (i32, i32)* zeroinitializer
@gl.EndConditionalRender = global void ()* zeroinitializer
@gl.VertexAttribIPointer = global void (i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.GetVertexAttribIiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetVertexAttribIuiv = global void (i32, i32, i32*)* zeroinitializer
@gl.VertexAttribI1i = global void (i32, i32)* zeroinitializer
@gl.VertexAttribI2i = global void (i32, i32, i32)* zeroinitializer
@gl.VertexAttribI3i = global void (i32, i32, i32, i32)* zeroinitializer
@gl.VertexAttribI4i = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.VertexAttribI1ui = global void (i32, i32)* zeroinitializer
@gl.VertexAttribI2ui = global void (i32, i32, i32)* zeroinitializer
@gl.VertexAttribI3ui = global void (i32, i32, i32, i32)* zeroinitializer
@gl.VertexAttribI4ui = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.VertexAttribI1iv = global void (i32, i32*)* zeroinitializer
@gl.VertexAttribI2iv = global void (i32, i32*)* zeroinitializer
@gl.VertexAttribI3iv = global void (i32, i32*)* zeroinitializer
@gl.VertexAttribI4iv = global void (i32, i32*)* zeroinitializer
@gl.VertexAttribI1uiv = global void (i32, i32*)* zeroinitializer
@gl.VertexAttribI2uiv = global void (i32, i32*)* zeroinitializer
@gl.VertexAttribI3uiv = global void (i32, i32*)* zeroinitializer
@gl.VertexAttribI4uiv = global void (i32, i32*)* zeroinitializer
@gl.VertexAttribI4bv = global void (i32, i8*)* zeroinitializer
@gl.VertexAttribI4sv = global void (i32, i16*)* zeroinitializer
@gl.VertexAttribI4ubv = global void (i32, i8*)* zeroinitializer
@gl.VertexAttribI4usv = global void (i32, i16*)* zeroinitializer
@gl.GetUniformuiv = global void (i32, i32, i32*)* zeroinitializer
@gl.BindFragDataLocation = global void (i32, i32, i8*)* zeroinitializer
@gl.GetFragDataLocation = global i32 (i32, i8*)* zeroinitializer
@gl.Uniform1ui = global void (i32, i32)* zeroinitializer
@gl.Uniform2ui = global void (i32, i32, i32)* zeroinitializer
@gl.Uniform3ui = global void (i32, i32, i32, i32)* zeroinitializer
@gl.Uniform4ui = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.Uniform1uiv = global void (i32, i32, i32*)* zeroinitializer
@gl.Uniform2uiv = global void (i32, i32, i32*)* zeroinitializer
@gl.Uniform3uiv = global void (i32, i32, i32*)* zeroinitializer
@gl.Uniform4uiv = global void (i32, i32, i32*)* zeroinitializer
@gl.TexParameterIiv = global void (i32, i32, i32*)* zeroinitializer
@gl.TexParameterIuiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetTexParameterIiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetTexParameterIuiv = global void (i32, i32, i32*)* zeroinitializer
@gl.ClearBufferiv = global void (i32, i32, i32*)* zeroinitializer
@gl.ClearBufferuiv = global void (i32, i32, i32*)* zeroinitializer
@gl.ClearBufferfv = global void (i32, i32, float*)* zeroinitializer
@gl.ClearBufferfi = global %..rawptr (i32, i32, float, i32)* zeroinitializer
@gl.GetStringi = global i8 (i32, i32)* zeroinitializer
@gl.IsRenderbuffer = global i8 (i32)* zeroinitializer
@gl.BindRenderbuffer = global void (i32, i32)* zeroinitializer
@gl.DeleteRenderbuffers = global void (i32, i32*)* zeroinitializer
@gl.GenRenderbuffers = global void (i32, i32*)* zeroinitializer
@gl.RenderbufferStorage = global void (i32, i32, i32, i32)* zeroinitializer
@gl.GetRenderbufferParameteriv = global void (i32, i32, i32*)* zeroinitializer
@gl.IsFramebuffer = global i8 (i32)* zeroinitializer
@gl.BindFramebuffer = global void (i32, i32)* zeroinitializer
@gl.DeleteFramebuffers = global void (i32, i32*)* zeroinitializer
@gl.GenFramebuffers = global void (i32, i32*)* zeroinitializer
@gl.CheckFramebufferStatus = global i32 (i32)* zeroinitializer
@gl.FramebufferTexture1D = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.FramebufferTexture2D = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.FramebufferTexture3D = global void (i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.FramebufferRenderbuffer = global void (i32, i32, i32, i32)* zeroinitializer
@gl.GetFramebufferAttachmentParameteriv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.GenerateMipmap = global void (i32)* zeroinitializer
@gl.BlitFramebuffer = global void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.RenderbufferStorageMultisample = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.FramebufferTextureLayer = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.MapBufferRange = global %..rawptr (i32, i64, i64, i32)* zeroinitializer
@gl.FlushMappedBufferRange = global void (i32, i64, i64)* zeroinitializer
@gl.BindVertexArray = global void (i32)* zeroinitializer
@gl.DeleteVertexArrays = global void (i32, i32*)* zeroinitializer
@gl.GenVertexArrays = global void (i32, i32*)* zeroinitializer
@gl.IsVertexArray = global i8 (i32)* zeroinitializer
@gl.DrawArraysInstanced = global void (i32, i32, i32, i32)* zeroinitializer
@gl.DrawElementsInstanced = global void (i32, i32, i32, %..rawptr, i32)* zeroinitializer
@gl.TexBuffer = global void (i32, i32, i32)* zeroinitializer
@gl.PrimitiveRestartIndex = global void (i32)* zeroinitializer
@gl.CopyBufferSubData = global void (i32, i32, i64, i64, i64)* zeroinitializer
@gl.GetUniformIndices = global void (i32, i32, i8*, i32*)* zeroinitializer
@gl.GetActiveUniformsiv = global void (i32, i32, i32*, i32, i32*)* zeroinitializer
@gl.GetActiveUniformName = global void (i32, i32, i32, i32*, i8*)* zeroinitializer
@gl.GetUniformBlockIndex = global i32 (i32, i8*)* zeroinitializer
@gl.GetActiveUniformBlockiv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.GetActiveUniformBlockName = global void (i32, i32, i32, i32*, i8*)* zeroinitializer
@gl.UniformBlockBinding = global void (i32, i32, i32)* zeroinitializer
@gl.DrawElementsBaseVertex = global void (i32, i32, i32, %..rawptr, i32)* zeroinitializer
@gl.DrawRangeElementsBaseVertex = global void (i32, i32, i32, i32, i32, %..rawptr, i32)* zeroinitializer
@gl.DrawElementsInstancedBaseVertex = global void (i32, i32, i32, %..rawptr, i32, i32)* zeroinitializer
@gl.MultiDrawElementsBaseVertex = global void (i32, i32*, i32, %..rawptr*, i32, i32*)* zeroinitializer
@gl.ProvokingVertex = global void (i32)* zeroinitializer
@gl.FenceSync = global %..rawptr (i32, i32)* zeroinitializer
@gl.IsSync = global i8 (%..rawptr)* zeroinitializer
@gl.DeleteSync = global void (%..rawptr)* zeroinitializer
@gl.ClientWaitSync = global i32 (%..rawptr, i32, i64)* zeroinitializer
@gl.WaitSync = global void (%..rawptr, i32, i64)* zeroinitializer
@gl.GetInteger64v = global void (i32, i64*)* zeroinitializer
@gl.GetSynciv = global void (%..rawptr, i32, i32, i32*, i32*)* zeroinitializer
@gl.GetInteger64i_v = global void (i32, i32, i64*)* zeroinitializer
@gl.GetBufferParameteri64v = global void (i32, i32, i64*)* zeroinitializer
@gl.FramebufferTexture = global void (i32, i32, i32, i32)* zeroinitializer
@gl.TexImage2DMultisample = global void (i32, i32, i32, i32, i32, i8)* zeroinitializer
@gl.TexImage3DMultisample = global void (i32, i32, i32, i32, i32, i32, i8)* zeroinitializer
@gl.GetMultisamplefv = global void (i32, i32, float*)* zeroinitializer
@gl.SampleMaski = global void (i32, i32)* zeroinitializer
@gl.BindFragDataLocationIndexed = global void (i32, i32, i32, i8*)* zeroinitializer
@gl.GetFragDataIndex = global i32 (i32, i8*)* zeroinitializer
@gl.GenSamplers = global void (i32, i32*)* zeroinitializer
@gl.DeleteSamplers = global void (i32, i32*)* zeroinitializer
@gl.IsSampler = global i8 (i32)* zeroinitializer
@gl.BindSampler = global void (i32, i32)* zeroinitializer
@gl.SamplerParameteri = global void (i32, i32, i32)* zeroinitializer
@gl.SamplerParameteriv = global void (i32, i32, i32*)* zeroinitializer
@gl.SamplerParameterf = global void (i32, i32, float)* zeroinitializer
@gl.SamplerParameterfv = global void (i32, i32, float*)* zeroinitializer
@gl.SamplerParameterIiv = global void (i32, i32, i32*)* zeroinitializer
@gl.SamplerParameterIuiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetSamplerParameteriv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetSamplerParameterIiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetSamplerParameterfv = global void (i32, i32, float*)* zeroinitializer
@gl.GetSamplerParameterIuiv = global void (i32, i32, i32*)* zeroinitializer
@gl.QueryCounter = global void (i32, i32)* zeroinitializer
@gl.GetQueryObjecti64v = global void (i32, i32, i64*)* zeroinitializer
@gl.GetQueryObjectui64v = global void (i32, i32, i64*)* zeroinitializer
@gl.VertexAttribDivisor = global void (i32, i32)* zeroinitializer
@gl.VertexAttribP1ui = global void (i32, i32, i8, i32)* zeroinitializer
@gl.VertexAttribP1uiv = global void (i32, i32, i8, i32*)* zeroinitializer
@gl.VertexAttribP2ui = global void (i32, i32, i8, i32)* zeroinitializer
@gl.VertexAttribP2uiv = global void (i32, i32, i8, i32*)* zeroinitializer
@gl.VertexAttribP3ui = global void (i32, i32, i8, i32)* zeroinitializer
@gl.VertexAttribP3uiv = global void (i32, i32, i8, i32*)* zeroinitializer
@gl.VertexAttribP4ui = global void (i32, i32, i8, i32)* zeroinitializer
@gl.VertexAttribP4uiv = global void (i32, i32, i8, i32*)* zeroinitializer
@gl.VertexP2ui = global void (i32, i32)* zeroinitializer
@gl.VertexP2uiv = global void (i32, i32*)* zeroinitializer
@gl.VertexP3ui = global void (i32, i32)* zeroinitializer
@gl.VertexP3uiv = global void (i32, i32*)* zeroinitializer
@gl.VertexP4ui = global void (i32, i32)* zeroinitializer
@gl.VertexP4uiv = global void (i32, i32*)* zeroinitializer
@gl.TexCoordP1ui = global void (i32, i32)* zeroinitializer
@gl.TexCoordP1uiv = global void (i32, i32*)* zeroinitializer
@gl.TexCoordP2ui = global void (i32, i32)* zeroinitializer
@gl.TexCoordP2uiv = global void (i32, i32*)* zeroinitializer
@gl.TexCoordP3ui = global void (i32, i32)* zeroinitializer
@gl.TexCoordP3uiv = global void (i32, i32*)* zeroinitializer
@gl.TexCoordP4ui = global void (i32, i32)* zeroinitializer
@gl.TexCoordP4uiv = global void (i32, i32*)* zeroinitializer
@gl.MultiTexCoordP1ui = global void (i32, i32, i32)* zeroinitializer
@gl.MultiTexCoordP1uiv = global void (i32, i32, i32*)* zeroinitializer
@gl.MultiTexCoordP2ui = global void (i32, i32, i32)* zeroinitializer
@gl.MultiTexCoordP2uiv = global void (i32, i32, i32*)* zeroinitializer
@gl.MultiTexCoordP3ui = global void (i32, i32, i32)* zeroinitializer
@gl.MultiTexCoordP3uiv = global void (i32, i32, i32*)* zeroinitializer
@gl.MultiTexCoordP4ui = global void (i32, i32, i32)* zeroinitializer
@gl.MultiTexCoordP4uiv = global void (i32, i32, i32*)* zeroinitializer
@gl.NormalP3ui = global void (i32, i32)* zeroinitializer
@gl.NormalP3uiv = global void (i32, i32*)* zeroinitializer
@gl.ColorP3ui = global void (i32, i32)* zeroinitializer
@gl.ColorP3uiv = global void (i32, i32*)* zeroinitializer
@gl.ColorP4ui = global void (i32, i32)* zeroinitializer
@gl.ColorP4uiv = global void (i32, i32*)* zeroinitializer
@gl.SecondaryColorP3ui = global void (i32, i32)* zeroinitializer
@gl.SecondaryColorP3uiv = global void (i32, i32*)* zeroinitializer
@gl.MinSampleShading = global void (float)* zeroinitializer
@gl.BlendEquationi = global void (i32, i32)* zeroinitializer
@gl.BlendEquationSeparatei = global void (i32, i32, i32)* zeroinitializer
@gl.BlendFunci = global void (i32, i32, i32)* zeroinitializer
@gl.BlendFuncSeparatei = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.DrawArraysIndirect = global void (i32, %..rawptr)* zeroinitializer
@gl.DrawElementsIndirect = global void (i32, i32, %..rawptr)* zeroinitializer
@gl.Uniform1d = global void (i32, double)* zeroinitializer
@gl.Uniform2d = global void (i32, double, double)* zeroinitializer
@gl.Uniform3d = global void (i32, double, double, double)* zeroinitializer
@gl.Uniform4d = global void (i32, double, double, double, double)* zeroinitializer
@gl.Uniform1dv = global void (i32, i32, double*)* zeroinitializer
@gl.Uniform2dv = global void (i32, i32, double*)* zeroinitializer
@gl.Uniform3dv = global void (i32, i32, double*)* zeroinitializer
@gl.Uniform4dv = global void (i32, i32, double*)* zeroinitializer
@gl.UniformMatrix2dv = global void (i32, i32, i8, double*)* zeroinitializer
@gl.UniformMatrix3dv = global void (i32, i32, i8, double*)* zeroinitializer
@gl.UniformMatrix4dv = global void (i32, i32, i8, double*)* zeroinitializer
@gl.UniformMatrix2x3dv = global void (i32, i32, i8, double*)* zeroinitializer
@gl.UniformMatrix2x4dv = global void (i32, i32, i8, double*)* zeroinitializer
@gl.UniformMatrix3x2dv = global void (i32, i32, i8, double*)* zeroinitializer
@gl.UniformMatrix3x4dv = global void (i32, i32, i8, double*)* zeroinitializer
@gl.UniformMatrix4x2dv = global void (i32, i32, i8, double*)* zeroinitializer
@gl.UniformMatrix4x3dv = global void (i32, i32, i8, double*)* zeroinitializer
@gl.GetUniformdv = global void (i32, i32, double*)* zeroinitializer
@gl.GetSubroutineUniformLocation = global i32 (i32, i32, i8*)* zeroinitializer
@gl.GetSubroutineIndex = global i32 (i32, i32, i8*)* zeroinitializer
@gl.GetActiveSubroutineUniformiv = global void (i32, i32, i32, i32, i32*)* zeroinitializer
@gl.GetActiveSubroutineUniformName = global void (i32, i32, i32, i32, i32*, i8*)* zeroinitializer
@gl.GetActiveSubroutineName = global void (i32, i32, i32, i32, i32*, i8*)* zeroinitializer
@gl.UniformSubroutinesuiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetUniformSubroutineuiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetProgramStageiv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.PatchParameteri = global void (i32, i32)* zeroinitializer
@gl.PatchParameterfv = global void (i32, float*)* zeroinitializer
@gl.BindTransformFeedback = global void (i32, i32)* zeroinitializer
@gl.DeleteTransformFeedbacks = global void (i32, i32*)* zeroinitializer
@gl.GenTransformFeedbacks = global void (i32, i32*)* zeroinitializer
@gl.IsTransformFeedback = global i8 (i32)* zeroinitializer
@gl.PauseTransformFeedback = global void ()* zeroinitializer
@gl.ResumeTransformFeedback = global void ()* zeroinitializer
@gl.DrawTransformFeedback = global void (i32, i32)* zeroinitializer
@gl.DrawTransformFeedbackStream = global void (i32, i32, i32)* zeroinitializer
@gl.BeginQueryIndexed = global void (i32, i32, i32)* zeroinitializer
@gl.EndQueryIndexed = global void (i32, i32)* zeroinitializer
@gl.GetQueryIndexediv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.ReleaseShaderCompiler = global void ()* zeroinitializer
@gl.ShaderBinary = global void (i32, i32*, i32, %..rawptr, i32)* zeroinitializer
@gl.GetShaderPrecisionFormat = global void (i32, i32, i32*, i32*)* zeroinitializer
@gl.DepthRangef = global void (float, float)* zeroinitializer
@gl.ClearDepthf = global void (float)* zeroinitializer
@gl.GetProgramBinary = global void (i32, i32, i32*, i32*, %..rawptr)* zeroinitializer
@gl.ProgramBinary = global void (i32, i32, %..rawptr, i32)* zeroinitializer
@gl.ProgramParameteri = global void (i32, i32, i32)* zeroinitializer
@gl.UseProgramStages = global void (i32, i32, i32)* zeroinitializer
@gl.ActiveShaderProgram = global void (i32, i32)* zeroinitializer
@gl.CreateShaderProgramv = global i32 (i32, i32, i8*)* zeroinitializer
@gl.BindProgramPipeline = global void (i32)* zeroinitializer
@gl.DeleteProgramPipelines = global void (i32, i32*)* zeroinitializer
@gl.GenProgramPipelines = global void (i32, i32*)* zeroinitializer
@gl.IsProgramPipeline = global i8 (i32)* zeroinitializer
@gl.GetProgramPipelineiv = global void (i32, i32, i32*)* zeroinitializer
@gl.ProgramUniform1i = global void (i32, i32, i32)* zeroinitializer
@gl.ProgramUniform1iv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.ProgramUniform1f = global void (i32, i32, float)* zeroinitializer
@gl.ProgramUniform1fv = global void (i32, i32, i32, float*)* zeroinitializer
@gl.ProgramUniform1d = global void (i32, i32, double)* zeroinitializer
@gl.ProgramUniform1dv = global void (i32, i32, i32, double*)* zeroinitializer
@gl.ProgramUniform1ui = global void (i32, i32, i32)* zeroinitializer
@gl.ProgramUniform1uiv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.ProgramUniform2i = global void (i32, i32, i32, i32)* zeroinitializer
@gl.ProgramUniform2iv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.ProgramUniform2f = global void (i32, i32, float, float)* zeroinitializer
@gl.ProgramUniform2fv = global void (i32, i32, i32, float*)* zeroinitializer
@gl.ProgramUniform2d = global void (i32, i32, double, double)* zeroinitializer
@gl.ProgramUniform2dv = global void (i32, i32, i32, double*)* zeroinitializer
@gl.ProgramUniform2ui = global void (i32, i32, i32, i32)* zeroinitializer
@gl.ProgramUniform2uiv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.ProgramUniform3i = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.ProgramUniform3iv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.ProgramUniform3f = global void (i32, i32, float, float, float)* zeroinitializer
@gl.ProgramUniform3fv = global void (i32, i32, i32, float*)* zeroinitializer
@gl.ProgramUniform3d = global void (i32, i32, double, double, double)* zeroinitializer
@gl.ProgramUniform3dv = global void (i32, i32, i32, double*)* zeroinitializer
@gl.ProgramUniform3ui = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.ProgramUniform3uiv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.ProgramUniform4i = global void (i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.ProgramUniform4iv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.ProgramUniform4f = global void (i32, i32, float, float, float, float)* zeroinitializer
@gl.ProgramUniform4fv = global void (i32, i32, i32, float*)* zeroinitializer
@gl.ProgramUniform4d = global void (i32, i32, double, double, double, double)* zeroinitializer
@gl.ProgramUniform4dv = global void (i32, i32, i32, double*)* zeroinitializer
@gl.ProgramUniform4ui = global void (i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.ProgramUniform4uiv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.ProgramUniformMatrix2fv = global void (i32, i32, i32, i8, float*)* zeroinitializer
@gl.ProgramUniformMatrix3fv = global void (i32, i32, i32, i8, float*)* zeroinitializer
@gl.ProgramUniformMatrix4fv = global void (i32, i32, i32, i8, float*)* zeroinitializer
@gl.ProgramUniformMatrix2dv = global void (i32, i32, i32, i8, double*)* zeroinitializer
@gl.ProgramUniformMatrix3dv = global void (i32, i32, i32, i8, double*)* zeroinitializer
@gl.ProgramUniformMatrix4dv = global void (i32, i32, i32, i8, double*)* zeroinitializer
@gl.ProgramUniformMatrix2x3fv = global void (i32, i32, i32, i8, float*)* zeroinitializer
@gl.ProgramUniformMatrix3x2fv = global void (i32, i32, i32, i8, float*)* zeroinitializer
@gl.ProgramUniformMatrix2x4fv = global void (i32, i32, i32, i8, float*)* zeroinitializer
@gl.ProgramUniformMatrix4x2fv = global void (i32, i32, i32, i8, float*)* zeroinitializer
@gl.ProgramUniformMatrix3x4fv = global void (i32, i32, i32, i8, float*)* zeroinitializer
@gl.ProgramUniformMatrix4x3fv = global void (i32, i32, i32, i8, float*)* zeroinitializer
@gl.ProgramUniformMatrix2x3dv = global void (i32, i32, i32, i8, double*)* zeroinitializer
@gl.ProgramUniformMatrix3x2dv = global void (i32, i32, i32, i8, double*)* zeroinitializer
@gl.ProgramUniformMatrix2x4dv = global void (i32, i32, i32, i8, double*)* zeroinitializer
@gl.ProgramUniformMatrix4x2dv = global void (i32, i32, i32, i8, double*)* zeroinitializer
@gl.ProgramUniformMatrix3x4dv = global void (i32, i32, i32, i8, double*)* zeroinitializer
@gl.ProgramUniformMatrix4x3dv = global void (i32, i32, i32, i8, double*)* zeroinitializer
@gl.ValidateProgramPipeline = global void (i32)* zeroinitializer
@gl.GetProgramPipelineInfoLog = global void (i32, i32, i32*, i8*)* zeroinitializer
@gl.VertexAttribL1d = global void (i32, double)* zeroinitializer
@gl.VertexAttribL2d = global void (i32, double, double)* zeroinitializer
@gl.VertexAttribL3d = global void (i32, double, double, double)* zeroinitializer
@gl.VertexAttribL4d = global void (i32, double, double, double, double)* zeroinitializer
@gl.VertexAttribL1dv = global void (i32, double*)* zeroinitializer
@gl.VertexAttribL2dv = global void (i32, double*)* zeroinitializer
@gl.VertexAttribL3dv = global void (i32, double*)* zeroinitializer
@gl.VertexAttribL4dv = global void (i32, double*)* zeroinitializer
@gl.VertexAttribLPointer = global void (i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.GetVertexAttribLdv = global void (i32, i32, double*)* zeroinitializer
@gl.ViewportArrayv = global void (i32, i32, float*)* zeroinitializer
@gl.ViewportIndexedf = global void (i32, float, float, float, float)* zeroinitializer
@gl.ViewportIndexedfv = global void (i32, float*)* zeroinitializer
@gl.ScissorArrayv = global void (i32, i32, i32*)* zeroinitializer
@gl.ScissorIndexed = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.ScissorIndexedv = global void (i32, i32*)* zeroinitializer
@gl.DepthRangeArrayv = global void (i32, i32, double*)* zeroinitializer
@gl.DepthRangeIndexed = global void (i32, double, double)* zeroinitializer
@gl.GetFloati_v = global void (i32, i32, float*)* zeroinitializer
@gl.GetDoublei_v = global void (i32, i32, double*)* zeroinitializer
@gl.DrawArraysInstancedBaseInstance = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.DrawElementsInstancedBaseInstance = global void (i32, i32, i32, %..rawptr, i32, i32)* zeroinitializer
@gl.DrawElementsInstancedBaseVertexBaseInstance = global void (i32, i32, i32, %..rawptr, i32, i32, i32)* zeroinitializer
@gl.GetInternalformativ = global void (i32, i32, i32, i32, i32*)* zeroinitializer
@gl.GetActiveAtomicCounterBufferiv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.BindImageTexture = global void (i32, i32, i32, i8, i32, i32, i32)* zeroinitializer
@gl.MemoryBarrier = global void (i32)* zeroinitializer
@gl.TexStorage1D = global void (i32, i32, i32, i32)* zeroinitializer
@gl.TexStorage2D = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.TexStorage3D = global void (i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.DrawTransformFeedbackInstanced = global void (i32, i32, i32)* zeroinitializer
@gl.DrawTransformFeedbackStreamInstanced = global void (i32, i32, i32, i32)* zeroinitializer
@gl.ClearBufferData = global void (i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.ClearBufferSubData = global void (i32, i32, i64, i64, i32, i32, %..rawptr)* zeroinitializer
@gl.DispatchCompute = global void (i32, i32, i32)* zeroinitializer
@gl.DispatchComputeIndirect = global void (i64)* zeroinitializer
@gl.CopyImageSubData = global void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.FramebufferParameteri = global void (i32, i32, i32)* zeroinitializer
@gl.GetFramebufferParameteriv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetInternalformati64v = global void (i32, i32, i32, i32, i64*)* zeroinitializer
@gl.InvalidateTexSubImage = global void (i32, i32, i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.InvalidateTexImage = global void (i32, i32)* zeroinitializer
@gl.InvalidateBufferSubData = global void (i32, i64, i64)* zeroinitializer
@gl.InvalidateBufferData = global void (i32)* zeroinitializer
@gl.InvalidateFramebuffer = global void (i32, i32, i32*)* zeroinitializer
@gl.InvalidateSubFramebuffer = global void (i32, i32, i32*, i32, i32, i32, i32)* zeroinitializer
@gl.MultiDrawArraysIndirect = global void (i32, %..rawptr, i32, i32)* zeroinitializer
@gl.MultiDrawElementsIndirect = global void (i32, i32, %..rawptr, i32, i32)* zeroinitializer
@gl.GetProgramInterfaceiv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.GetProgramResourceIndex = global i32 (i32, i32, i8*)* zeroinitializer
@gl.GetProgramResourceName = global void (i32, i32, i32, i32, i32*, i8*)* zeroinitializer
@gl.GetProgramResourceiv = global void (i32, i32, i32, i32, i32*, i32, i32*, i32*)* zeroinitializer
@gl.GetProgramResourceLocation = global i32 (i32, i32, i8*)* zeroinitializer
@gl.GetProgramResourceLocationIndex = global i32 (i32, i32, i8*)* zeroinitializer
@gl.ShaderStorageBlockBinding = global void (i32, i32, i32)* zeroinitializer
@gl.TexBufferRange = global void (i32, i32, i32, i64, i64)* zeroinitializer
@gl.TexStorage2DMultisample = global void (i32, i32, i32, i32, i32, i8)* zeroinitializer
@gl.TexStorage3DMultisample = global void (i32, i32, i32, i32, i32, i32, i8)* zeroinitializer
@gl.TextureView = global void (i32, i32, i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.BindVertexBuffer = global void (i32, i32, i64, i32)* zeroinitializer
@gl.VertexAttribFormat = global void (i32, i32, i32, i8, i32)* zeroinitializer
@gl.VertexAttribIFormat = global void (i32, i32, i32, i32)* zeroinitializer
@gl.VertexAttribLFormat = global void (i32, i32, i32, i32)* zeroinitializer
@gl.VertexAttribBinding = global void (i32, i32)* zeroinitializer
@gl.VertexBindingDivisor = global void (i32, i32)* zeroinitializer
@gl.DebugMessageControl = global void (i32, i32, i32, i32, i32*, i8)* zeroinitializer
@gl.DebugMessageInsert = global void (i32, i32, i32, i32, i32, i8*)* zeroinitializer
@gl.DebugMessageCallback = global void (void (i32, i32, i32, i32, i32, i8*, %..rawptr)*, %..rawptr)* zeroinitializer
@gl.GetDebugMessageLog = global i32 (i32, i32, i32*, i32*, i32*, i32*, i32*, i8*)* zeroinitializer
@gl.PushDebugGroup = global void (i32, i32, i32, i8*)* zeroinitializer
@gl.PopDebugGroup = global void ()* zeroinitializer
@gl.ObjectLabel = global void (i32, i32, i32, i8*)* zeroinitializer
@gl.GetObjectLabel = global void (i32, i32, i32, i32*, i8*)* zeroinitializer
@gl.ObjectPtrLabel = global void (%..rawptr, i32, i8*)* zeroinitializer
@gl.GetObjectPtrLabel = global void (%..rawptr, i32, i32*, i8*)* zeroinitializer
@gl.BufferStorage = global void (i32, i64, %..rawptr, i32)* zeroinitializer
@gl.ClearTexImage = global void (i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.ClearTexSubImage = global void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.BindBuffersBase = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.BindBuffersRange = global void (i32, i32, i32, i32*, i64*, i64*)* zeroinitializer
@gl.BindTextures = global void (i32, i32, i32*)* zeroinitializer
@gl.BindSamplers = global void (i32, i32, i32*)* zeroinitializer
@gl.BindImageTextures = global void (i32, i32, i32*)* zeroinitializer
@gl.BindVertexBuffers = global void (i32, i32, i32*, i64*, i32*)* zeroinitializer
@gl.ClipControl = global void (i32, i32)* zeroinitializer
@gl.CreateTransformFeedbacks = global void (i32, i32*)* zeroinitializer
@gl.TransformFeedbackBufferBase = global void (i32, i32, i32)* zeroinitializer
@gl.TransformFeedbackBufferRange = global void (i32, i32, i32, i64, i64)* zeroinitializer
@gl.GetTransformFeedbackiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetTransformFeedbacki_v = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.GetTransformFeedbacki64_v = global void (i32, i32, i32, i64*)* zeroinitializer
@gl.CreateBuffers = global void (i32, i32*)* zeroinitializer
@gl.NamedBufferStorage = global void (i32, i64, %..rawptr, i32)* zeroinitializer
@gl.NamedBufferData = global void (i32, i64, %..rawptr, i32)* zeroinitializer
@gl.NamedBufferSubData = global void (i32, i64, i64, %..rawptr)* zeroinitializer
@gl.CopyNamedBufferSubData = global void (i32, i32, i64, i64, i64)* zeroinitializer
@gl.ClearNamedBufferData = global void (i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.ClearNamedBufferSubData = global void (i32, i32, i64, i64, i32, i32, %..rawptr)* zeroinitializer
@gl.MapNamedBuffer = global %..rawptr (i32, i32)* zeroinitializer
@gl.MapNamedBufferRange = global %..rawptr (i32, i64, i64, i32)* zeroinitializer
@gl.UnmapNamedBuffer = global i8 (i32)* zeroinitializer
@gl.FlushMappedNamedBufferRange = global void (i32, i64, i64)* zeroinitializer
@gl.GetNamedBufferParameteriv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetNamedBufferParameteri64v = global void (i32, i32, i64*)* zeroinitializer
@gl.GetNamedBufferPointerv = global void (i32, i32, %..rawptr*)* zeroinitializer
@gl.GetNamedBufferSubData = global void (i32, i64, i64, %..rawptr)* zeroinitializer
@gl.CreateFramebuffers = global void (i32, i32*)* zeroinitializer
@gl.NamedFramebufferRenderbuffer = global void (i32, i32, i32, i32)* zeroinitializer
@gl.NamedFramebufferParameteri = global void (i32, i32, i32)* zeroinitializer
@gl.NamedFramebufferTexture = global void (i32, i32, i32, i32)* zeroinitializer
@gl.NamedFramebufferTextureLayer = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.NamedFramebufferDrawBuffer = global void (i32, i32)* zeroinitializer
@gl.NamedFramebufferDrawBuffers = global void (i32, i32, i32*)* zeroinitializer
@gl.NamedFramebufferReadBuffer = global void (i32, i32)* zeroinitializer
@gl.InvalidateNamedFramebufferData = global void (i32, i32, i32*)* zeroinitializer
@gl.InvalidateNamedFramebufferSubData = global void (i32, i32, i32*, i32, i32, i32, i32)* zeroinitializer
@gl.ClearNamedFramebufferiv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.ClearNamedFramebufferuiv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.ClearNamedFramebufferfv = global void (i32, i32, i32, float*)* zeroinitializer
@gl.ClearNamedFramebufferfi = global void (i32, i32, i32, float, i32)* zeroinitializer
@gl.BlitNamedFramebuffer = global void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.CheckNamedFramebufferStatus = global i32 (i32, i32)* zeroinitializer
@gl.GetNamedFramebufferParameteriv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetNamedFramebufferAttachmentParameteriv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.CreateRenderbuffers = global void (i32, i32*)* zeroinitializer
@gl.NamedRenderbufferStorage = global void (i32, i32, i32, i32)* zeroinitializer
@gl.NamedRenderbufferStorageMultisample = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.GetNamedRenderbufferParameteriv = global void (i32, i32, i32*)* zeroinitializer
@gl.CreateTextures = global void (i32, i32, i32*)* zeroinitializer
@gl.TextureBuffer = global void (i32, i32, i32)* zeroinitializer
@gl.TextureBufferRange = global void (i32, i32, i32, i64, i64)* zeroinitializer
@gl.TextureStorage1D = global void (i32, i32, i32, i32)* zeroinitializer
@gl.TextureStorage2D = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.TextureStorage3D = global void (i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.TextureStorage2DMultisample = global void (i32, i32, i32, i32, i32, i8)* zeroinitializer
@gl.TextureStorage3DMultisample = global void (i32, i32, i32, i32, i32, i32, i8)* zeroinitializer
@gl.TextureSubImage1D = global void (i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.TextureSubImage2D = global void (i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.TextureSubImage3D = global void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.CompressedTextureSubImage1D = global void (i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.CompressedTextureSubImage2D = global void (i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.CompressedTextureSubImage3D = global void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.CopyTextureSubImage1D = global void (i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.CopyTextureSubImage2D = global void (i32, i32, i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.CopyTextureSubImage3D = global void (i32, i32, i32, i32, i32, i32, i32, i32, i32)* zeroinitializer
@gl.TextureParameterf = global void (i32, i32, float)* zeroinitializer
@gl.TextureParameterfv = global void (i32, i32, float*)* zeroinitializer
@gl.TextureParameteri = global void (i32, i32, i32)* zeroinitializer
@gl.TextureParameterIiv = global void (i32, i32, i32*)* zeroinitializer
@gl.TextureParameterIuiv = global void (i32, i32, i32*)* zeroinitializer
@gl.TextureParameteriv = global void (i32, i32, i32*)* zeroinitializer
@gl.GenerateTextureMipmap = global void (i32)* zeroinitializer
@gl.BindTextureUnit = global void (i32, i32)* zeroinitializer
@gl.GetTextureImage = global void (i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.GetCompressedTextureImage = global void (i32, i32, i32, %..rawptr)* zeroinitializer
@gl.GetTextureLevelParameterfv = global void (i32, i32, i32, float*)* zeroinitializer
@gl.GetTextureLevelParameteriv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.GetTextureParameterfv = global void (i32, i32, float*)* zeroinitializer
@gl.GetTextureParameterIiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetTextureParameterIuiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetTextureParameteriv = global void (i32, i32, i32*)* zeroinitializer
@gl.CreateVertexArrays = global void (i32, i32*)* zeroinitializer
@gl.DisableVertexArrayAttrib = global void (i32, i32)* zeroinitializer
@gl.EnableVertexArrayAttrib = global void (i32, i32)* zeroinitializer
@gl.VertexArrayElementBuffer = global void (i32, i32)* zeroinitializer
@gl.VertexArrayVertexBuffer = global void (i32, i32, i32, i64, i32)* zeroinitializer
@gl.VertexArrayVertexBuffers = global void (i32, i32, i32, i32*, i64*, i32*)* zeroinitializer
@gl.VertexArrayAttribBinding = global void (i32, i32, i32)* zeroinitializer
@gl.VertexArrayAttribFormat = global void (i32, i32, i32, i32, i8, i32)* zeroinitializer
@gl.VertexArrayAttribIFormat = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.VertexArrayAttribLFormat = global void (i32, i32, i32, i32, i32)* zeroinitializer
@gl.VertexArrayBindingDivisor = global void (i32, i32, i32)* zeroinitializer
@gl.GetVertexArrayiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetVertexArrayIndexediv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.GetVertexArrayIndexed64iv = global void (i32, i32, i32, i64*)* zeroinitializer
@gl.CreateSamplers = global void (i32, i32*)* zeroinitializer
@gl.CreateProgramPipelines = global void (i32, i32*)* zeroinitializer
@gl.CreateQueries = global void (i32, i32, i32*)* zeroinitializer
@gl.GetQueryBufferObjecti64v = global void (i32, i32, i32, i64)* zeroinitializer
@gl.GetQueryBufferObjectiv = global void (i32, i32, i32, i64)* zeroinitializer
@gl.GetQueryBufferObjectui64v = global void (i32, i32, i32, i64)* zeroinitializer
@gl.GetQueryBufferObjectuiv = global void (i32, i32, i32, i64)* zeroinitializer
@gl.MemoryBarrierByRegion = global void (i32)* zeroinitializer
@gl.GetTextureSubImage = global void (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.GetCompressedTextureSubImage = global void (i32, i32, i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.GetGraphicsResetStatus = global i32 ()* zeroinitializer
@gl.GetnCompressedTexImage = global void (i32, i32, i32, %..rawptr)* zeroinitializer
@gl.GetnTexImage = global void (i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.GetnUniformdv = global void (i32, i32, i32, double*)* zeroinitializer
@gl.GetnUniformfv = global void (i32, i32, i32, float*)* zeroinitializer
@gl.GetnUniformiv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.GetnUniformuiv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.ReadnPixels = global void (i32, i32, i32, i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.GetnMapdv = global void (i32, i32, i32, double*)* zeroinitializer
@gl.GetnMapfv = global void (i32, i32, i32, float*)* zeroinitializer
@gl.GetnMapiv = global void (i32, i32, i32, i32*)* zeroinitializer
@gl.GetnPixelMapusv = global void (i32, i32, i16*)* zeroinitializer
@gl.GetnPixelMapfv = global void (i32, i32, float*)* zeroinitializer
@gl.GetnPixelMapuiv = global void (i32, i32, i32*)* zeroinitializer
@gl.GetnPolygonStipple = global void (i32, i8*)* zeroinitializer
@gl.GetnColorTable = global void (i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.GetnConvolutionFilter = global void (i32, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.GetnSeparableFilter = global void (i32, i32, i32, i32, %..rawptr, i32, %..rawptr, %..rawptr)* zeroinitializer
@gl.GetnHistogram = global void (i32, i8, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.GetnMinmax = global void (i32, i8, i32, i32, i32, %..rawptr)* zeroinitializer
@gl.TextureBarrier = global void ()* zeroinitializer
@gl.SpecializeShader = global void (i32, i8*, i32, i32*, i32*)* zeroinitializer
@gl.MultiDrawArraysIndirectCount = global void (i32, %..rawptr, i64, i32, i32)* zeroinitializer
@gl.MultiDrawElementsIndirectCount = global void (i32, i32, %..rawptr, i64, i32, i32)* zeroinitializer
@gl.PolygonOffsetClamp = global void (float, float, float)* zeroinitializer
@workbench._held = global {%workbench.Key_Press*, i64, i64, %mem.Allocator} zeroinitializer
@workbench._down = global {%workbench.Key_Press*, i64, i64, %mem.Allocator} zeroinitializer
@workbench._up = global {%workbench.Key_Press*, i64, i64, %mem.Allocator} zeroinitializer
@workbench._held_mid_frame = global {%workbench.Key_Press*, i64, i64, %mem.Allocator} zeroinitializer
@workbench._down_mid_frame = global {%workbench.Key_Press*, i64, i64, %mem.Allocator} zeroinitializer
@workbench._up_mid_frame = global {%workbench.Key_Press*, i64, i64, %mem.Allocator} zeroinitializer
@workbench.controllers = global [16 x %workbench.Controller_State] zeroinitializer
@imgui._text_buf = thread_local global [8192 x i8] zeroinitializer
@imgui._label_buf = thread_local global [4096 x i8] zeroinitializer
@imgui._misc_buf = thread_local global [1024 x i8] zeroinitializer
@workbench.id_counts = global {{i64*, i64}, {{%runtime.Map_Key, i64, i64}*, i64, i64, %mem.Allocator}} zeroinitializer
@csba$0 = global [1 x i8] [i8 zeroinitializer]
@csba$1 = global [2 x i32] [i32 zeroinitializer, i32 zeroinitializer]
@$enum_names-74 = private global [7 x %..string] zeroinitializer
@$enum_values-74 = private global [7 x %runtime.Type_Info_Enum_Value] zeroinitializer
@$enum_names-66 = private global [48 x %..string] zeroinitializer
@$enum_values-66 = private global [48 x %runtime.Type_Info_Enum_Value] zeroinitializer
@$enum_names-64 = private global [20 x %..string] zeroinitializer
@$enum_values-64 = private global [20 x %runtime.Type_Info_Enum_Value] zeroinitializer
@$enum_names-23 = private global [6 x %..string] zeroinitializer
@$enum_values-23 = private global [6 x %runtime.Type_Info_Enum_Value] zeroinitializer
@$enum_names-2 = private global [4 x %..string] zeroinitializer
@$enum_values-2 = private global [4 x %runtime.Type_Info_Enum_Value] zeroinitializer
@$enum_names-5e = private global [122 x %..string] zeroinitializer
@$enum_values-5e = private global [122 x %runtime.Type_Info_Enum_Value] zeroinitializer
@$enum_names-5b = private global [3 x %..string] zeroinitializer
@$enum_values-5b = private global [3 x %runtime.Type_Info_Enum_Value] zeroinitializer
@$enum_names-60 = private global [12 x %..string] zeroinitializer
@$enum_values-60 = private global [12 x %runtime.Type_Info_Enum_Value] zeroinitializer
@$enum_names-99 = private global [24 x %..string] zeroinitializer
@$enum_values-99 = private global [24 x %runtime.Type_Info_Enum_Value] zeroinitializer
@$enum_names-62 = private global [7 x %..string] zeroinitializer
@$enum_values-62 = private global [7 x %runtime.Type_Info_Enum_Value] zeroinitializer
@$enum_names-59 = private global [3 x %..string] zeroinitializer
@$enum_values-59 = private global [3 x %runtime.Type_Info_Enum_Value] zeroinitializer
@str$0 = private global [11 x i8] c"0123456789\00"
@str$1 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$2 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$3 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$4 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$5 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$6 = private global [11 x i8] c"0123456789\00"
@str$7 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$8 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$9 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$a = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$b = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$c = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$d = private global [4 x i8] c"nil\00"
@str$e = private global [4 x i8] c"int\00"
@str$f = private global [5 x i8] c"uint\00"
@str$10 = private global [8 x i8] c"uintptr\00"
@str$11 = private global [5 x i8] c"rune\00"
@str$12 = private global [8 x i8] c"complex\00"
@str$13 = private global [7 x i8] c"string\00"
@str$14 = private global [5 x i8] c"bool\00"
@str$15 = private global [4 x i8] c"any\00"
@str$16 = private global [7 x i8] c"typeid\00"
@str$17 = private global [7 x i8] c"rawptr\00"
@str$18 = private global [2 x i8] c"\5E\00"
@str$19 = private global [5 x i8] c"proc\00"
@str$1a = private global [3 x i8] c"\28\29\00"
@str$1b = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$1c = private global [2 x i8] c"\28\00"
@str$1d = private global [3 x i8] c"\2C\20\00"
@str$1e = private global [2 x i8] c"\29\00"
@str$1f = private global [5 x i8] c"\20-\3E\20\00"
@str$20 = private global [2 x i8] c"\28\00"
@str$21 = private global [3 x i8] c"\2C\20\00"
@str$22 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$23 = private global [3 x i8] c"\3A\20\00"
@str$24 = private global [2 x i8] c"\29\00"
@str$25 = private global [2 x i8] c"\5B\00"
@str$26 = private global [2 x i8] c"\5D\00"
@str$27 = private global [10 x i8] c"\5Bdynamic\5D\00"
@str$28 = private global [3 x i8] c"\5B\5D\00"
@str$29 = private global [5 x i8] c"map\5B\00"
@str$2a = private global [8 x i8] c"struct\20\00"
@str$2b = private global [9 x i8] c"\23packed\20\00"
@str$2c = private global [12 x i8] c"\23raw_union\20\00"
@str$2d = private global [8 x i8] c"\23align\20\00"
@str$2e = private global [3 x i8] c"\2C\20\00"
@str$2f = private global [3 x i8] c"\3A\20\00"
@str$30 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$31 = private global [8 x i8] c"union\20\7B\00"
@str$32 = private global [3 x i8] c"\2C\20\00"
@str$33 = private global [2 x i8] c"\7D\00"
@str$34 = private global [6 x i8] c"enum\20\00"
@str$35 = private global [3 x i8] c"\20\7B\00"
@str$36 = private global [3 x i8] c"\2C\20\00"
@str$37 = private global [2 x i8] c"\7D\00"
@str$38 = private global [11 x i8] c"bit_field\20\00"
@str$39 = private global [8 x i8] c"\23align\20\00"
@str$3a = private global [3 x i8] c"\20\7B\00"
@str$3b = private global [3 x i8] c"\2C\20\00"
@str$3c = private global [3 x i8] c"\3A\20\00"
@str$3d = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$3e = private global [2 x i8] c"\7D\00"
@str$3f = private global [9 x i8] c"bit_set\5B\00"
@str$40 = private global [3 x i8] c"..\00"
@str$41 = private global [3 x i8] c"..\00"
@str$42 = private global [3 x i8] c"\3B\20\00"
@str$43 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$44 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$45 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$46 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$47 = private global [8 x i8] c"\20Index\20\00"
@str$48 = private global [27 x i8] c"\20is\20out\20of\20bounds\20range\200\3A\00"
@str$49 = private global [25 x i8] c"\20Invalid\20slice\20indices\3A\20\00"
@str$4a = private global [2 x i8] c"\3A\00"
@str$4b = private global [2 x i8] c"\3A\00"
@str$4c = private global [32 x i8] c"\20Invalid\20dynamic\20array\20values\3A\20\00"
@str$4d = private global [2 x i8] c"\3A\00"
@str$4e = private global [2 x i8] c"\3A\00"
@str$4f = private global [30 x i8] c"\20Invalid\20type\20assertion\20from\20\00"
@str$50 = private global [5 x i8] c"\20to\20\00"
@str$51 = private global [33 x i8] c"\20Invalid\20slice\20length\20for\20make\3A\20\00"
@str$52 = private global [45 x i8] c"\20Invalid\20dynamic\20array\20parameters\20for\20make\3A\20\00"
@str$53 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$54 = private global [2 x i8] c"\20\00"
@str$55 = private global [3 x i8] c"\3A\20\00"
@str$56 = private global [18 x i8] c"Runtime\20assertion\00"
@str$57 = private global [6 x i8] c"Panic\00"
@str$58 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$59 = private global [24 x i8] c"__dynamic_array_reserve\00"
@str$5a = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$5b = private global [31 x i8] c"__dynamic_array_append_nothing\00"
@str$5c = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$5d = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$5e = private global [18 x i8] c"__dynamic_map_set\00"
@str$5f = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$60 = private global [24 x i8] c"__dynamic_map_get_entry\00"
@str$61 = private global [5 x i8] c"Main\00"
@str$62 = private global [10 x i8] c"OdinScape\00"
@str$63 = private global [26 x i8] c"Resources\2FModels\2Fcube.fbx\00"
@str$64 = private global [55 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fmain.odin\00"
@str$65 = private global [12 x i8] c"main_render\00"
@str$66 = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$67 = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$68 = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$69 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fentities.odin\00"
@str$6a = private global [21 x i8] c"render_mesh_renderer\00"
@str$6b = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Fmem.odin\00"
@str$6c = private global [22 x i8] c"align_forward_uintptr\00"
@str$6d = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$6e = private global [23 x i8] c"scratch_allocator_proc\00"
@str$6f = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$70 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$71 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$72 = private global [23 x i8] c"scratch_allocator_proc\00"
@str$73 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$74 = private global [23 x i8] c"scratch_allocator_proc\00"
@str$75 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$76 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$77 = private global [23 x i8] c"scratch_allocator_proc\00"
@str$78 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$79 = private global [52 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos.odin\00"
@str$7a = private global [3 x i8] c"\5Ca\00"
@str$7b = private global [3 x i8] c"\5Cb\00"
@str$7c = private global [3 x i8] c"\5Ce\00"
@str$7d = private global [3 x i8] c"\5Cf\00"
@str$7e = private global [3 x i8] c"\5Cn\00"
@str$7f = private global [3 x i8] c"\5Cr\00"
@str$80 = private global [3 x i8] c"\5Ct\00"
@str$81 = private global [3 x i8] c"\5Cv\00"
@str$82 = private global [3 x i8] c"\5Cx\00"
@str$83 = private global [52 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos.odin\00"
@str$84 = private global [3 x i8] c"00\00"
@str$85 = private global [52 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos.odin\00"
@str$86 = private global [17 x i8] c"read_entire_file\00"
@str$87 = private global [52 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos.odin\00"
@str$88 = private global [17 x i8] c"read_entire_file\00"
@str$89 = private global [52 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos.odin\00"
@str$8a = private global [52 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos.odin\00"
@str$8b = private global [20 x i8] c"heap_allocator_proc\00"
@str$8c = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$8d = private global [12 x i8] c"open_simple\00"
@str$8e = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$8f = private global [12 x i8] c"open_simple\00"
@str$90 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$91 = private global [6 x i8] c"write\00"
@str$92 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$93 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$94 = private global [5 x i8] c"read\00"
@str$95 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$96 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$97 = private global [5 x i8] c"seek\00"
@str$98 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$99 = private global [11 x i8] c"heap_alloc\00"
@str$9a = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$9b = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$9c = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$9d = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$9e = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$9f = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$a0 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$a1 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$a2 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$a3 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$a4 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$a5 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$a6 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$a7 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$a8 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$a9 = private global [13 x i8] c"write_string\00"
@str$aa = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$ab = private global [12 x i8] c"write_bytes\00"
@str$ac = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$ad = private global [11 x i8] c"write_byte\00"
@str$ae = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$af = private global [3 x i8] c"\5Ca\00"
@str$b0 = private global [3 x i8] c"\5Cb\00"
@str$b1 = private global [3 x i8] c"\5Ce\00"
@str$b2 = private global [3 x i8] c"\5Cf\00"
@str$b3 = private global [3 x i8] c"\5Cn\00"
@str$b4 = private global [3 x i8] c"\5Cr\00"
@str$b5 = private global [3 x i8] c"\5Ct\00"
@str$b6 = private global [3 x i8] c"\5Cv\00"
@str$b7 = private global [3 x i8] c"\5Cx\00"
@str$b8 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$b9 = private global [3 x i8] c"00\00"
@str$ba = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$bb = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$bc = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$bd = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$be = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$bf = private global [7 x i8] c"tprint\00"
@str$c0 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$c1 = private global [8 x i8] c"tprintf\00"
@str$c2 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$c3 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$c4 = private global [4 x i8] c"nil\00"
@str$c5 = private global [4 x i8] c"int\00"
@str$c6 = private global [5 x i8] c"uint\00"
@str$c7 = private global [8 x i8] c"uintptr\00"
@str$c8 = private global [5 x i8] c"rune\00"
@str$c9 = private global [8 x i8] c"complex\00"
@str$ca = private global [8 x i8] c"cstring\00"
@str$cb = private global [7 x i8] c"string\00"
@str$cc = private global [5 x i8] c"bool\00"
@str$cd = private global [4 x i8] c"any\00"
@str$ce = private global [7 x i8] c"typeid\00"
@str$cf = private global [7 x i8] c"rawptr\00"
@str$d0 = private global [2 x i8] c"\5E\00"
@str$d1 = private global [5 x i8] c"proc\00"
@str$d2 = private global [3 x i8] c"\28\29\00"
@str$d3 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$d4 = private global [2 x i8] c"\28\00"
@str$d5 = private global [3 x i8] c"\2C\20\00"
@str$d6 = private global [2 x i8] c"\29\00"
@str$d7 = private global [5 x i8] c"\20-\3E\20\00"
@str$d8 = private global [2 x i8] c"\28\00"
@str$d9 = private global [3 x i8] c"\2C\20\00"
@str$da = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$db = private global [3 x i8] c"\3A\20\00"
@str$dc = private global [2 x i8] c"\29\00"
@str$dd = private global [2 x i8] c"\5B\00"
@str$de = private global [2 x i8] c"\5D\00"
@str$df = private global [10 x i8] c"\5Bdynamic\5D\00"
@str$e0 = private global [3 x i8] c"\5B\5D\00"
@str$e1 = private global [5 x i8] c"map\5B\00"
@str$e2 = private global [8 x i8] c"struct\20\00"
@str$e3 = private global [9 x i8] c"\23packed\20\00"
@str$e4 = private global [12 x i8] c"\23raw_union\20\00"
@str$e5 = private global [8 x i8] c"\23align\20\00"
@str$e6 = private global [3 x i8] c"\2C\20\00"
@str$e7 = private global [3 x i8] c"\3A\20\00"
@str$e8 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$e9 = private global [7 x i8] c"union\20\00"
@str$ea = private global [8 x i8] c"\23align\20\00"
@str$eb = private global [3 x i8] c"\2C\20\00"
@str$ec = private global [2 x i8] c"\7D\00"
@str$ed = private global [6 x i8] c"enum\20\00"
@str$ee = private global [3 x i8] c"\20\7B\00"
@str$ef = private global [3 x i8] c"\2C\20\00"
@str$f0 = private global [2 x i8] c"\7D\00"
@str$f1 = private global [11 x i8] c"bit_field\20\00"
@str$f2 = private global [8 x i8] c"\23align\20\00"
@str$f3 = private global [3 x i8] c"\20\7B\00"
@str$f4 = private global [3 x i8] c"\2C\20\00"
@str$f5 = private global [3 x i8] c"\3A\20\00"
@str$f6 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$f7 = private global [2 x i8] c"\7D\00"
@str$f8 = private global [9 x i8] c"bit_set\5B\00"
@str$f9 = private global [3 x i8] c"..\00"
@str$fa = private global [3 x i8] c"..\00"
@str$fb = private global [3 x i8] c"\3B\20\00"
@str$fc = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$fd = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$fe = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$ff = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$100 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$101 = private global [3 x i8] c"\25\21\00"
@str$102 = private global [6 x i8] c"\3Cnil\3E\00"
@str$103 = private global [5 x i8] c"true\00"
@str$104 = private global [6 x i8] c"false\00"
@str$105 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$106 = private global [9 x i8] c"_fmt_int\00"
@str$107 = private global [54 x i8] c"_fmt_int\3A\20buffer\20overrun.\20Width\20and\20precision\20too\20big\00"
@str$108 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$109 = private global [9 x i8] c"_fmt_int\00"
@str$10a = private global [31 x i8] c"_fmt_int\3A\20unknown\20base\2C\20whoops\00"
@str$10b = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$10c = private global [3 x i8] c"U\2B\00"
@str$10d = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$10e = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$10f = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$110 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$111 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$112 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$113 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$114 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$115 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$116 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$117 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$118 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$119 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$11a = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$11b = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$11c = private global [3 x i8] c"0x\00"
@str$11d = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$11e = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$11f = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$120 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$121 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$122 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$123 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$124 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$125 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$126 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$127 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$128 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$129 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$12a = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$12b = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$12c = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$12d = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$12e = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$12f = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$130 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$131 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$132 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$133 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$134 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$135 = private global [6 x i8] c"\3Cnil\3E\00"
@str$136 = private global [19 x i8] c"\21\25\28BAD\20ENUM\20VALUE\29\00"
@str$137 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$138 = private global [12 x i8] c"fmt_bit_set\00"
@str$139 = private global [22 x i8] c"unknown\20bit_size\20size\00"
@str$13a = private global [3 x i8] c"\2C\20\00"
@str$13b = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$13c = private global [5 x i8] c"HERE\00"
@str$13d = private global [11 x i8] c"bit_field\7B\00"
@str$13e = private global [3 x i8] c"\2C\20\00"
@str$13f = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$140 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$141 = private global [4 x i8] c"\20\3D\20\00"
@str$142 = private global [6 x i8] c"\3Cnil\3E\00"
@str$143 = private global [3 x i8] c"\7B\7D\00"
@str$144 = private global [3 x i8] c"\2C\20\00"
@str$145 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$146 = private global [4 x i8] c"\20\3D\20\00"
@str$147 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$148 = private global [6 x i8] c"any\7B\7D\00"
@str$149 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$14a = private global [3 x i8] c"\2C\0A\00"
@str$14b = private global [3 x i8] c"\2C\20\00"
@str$14c = private global [3 x i8] c"\2C\20\00"
@str$14d = private global [3 x i8] c"\2C\20\00"
@str$14e = private global [5 x i8] c"map\5B\00"
@str$14f = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$150 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$151 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$152 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$153 = private global [3 x i8] c"\2C\20\00"
@str$154 = private global [2 x i8] c"\3D\00"
@str$155 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$156 = private global [12 x i8] c"\28raw_union\29\00"
@str$157 = private global [3 x i8] c"\2C\20\00"
@str$158 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$159 = private global [4 x i8] c"\20\3D\20\00"
@str$15a = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$15b = private global [6 x i8] c"any\7B\7D\00"
@str$15c = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$15d = private global [3 x i8] c"\2C\0A\00"
@str$15e = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$15f = private global [10 x i8] c"fmt_value\00"
@str$160 = private global [23 x i8] c"Invalid\20union\20tag\20type\00"
@str$161 = private global [4 x i8] c"nil\00"
@str$162 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$163 = private global [4 x i8] c"nil\00"
@str$164 = private global [4 x i8] c"\20\40\20\00"
@str$165 = private global [6 x i8] c"\3Cnil\3E\00"
@str$166 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$167 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$168 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$169 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$16a = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$16b = private global [14 x i8] c"\25\21\28BAD\20WIDTH\29\00"
@str$16c = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$16d = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$16e = private global [18 x i8] c"\25\21\28BAD\20PRECISION\29\00"
@str$16f = private global [12 x i8] c"\25\21\28NO\20VERB\29\00"
@str$170 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$171 = private global [24 x i8] c"\25\21\28BAD\20ARGUMENT\20NUMBER\29\00"
@str$172 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$173 = private global [21 x i8] c"\25\21\28MISSING\20ARGUMENT\29\00"
@str$174 = private global [10 x i8] c"\25\21\28EXTRA\20\00"
@str$175 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$176 = private global [3 x i8] c"\2C\20\00"
@str$177 = private global [6 x i8] c"\3Cnil\3E\00"
@str$178 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$179 = private global [2 x i8] c"\29\00"
@str$17a = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmath\2Fmath.odin\00"
@str$17b = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmath\2Fmath.odin\00"
@str$17c = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmath\2Fmath.odin\00"
@str$17d = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmath\2Fmath.odin\00"
@str$17e = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmath\2Fmath.odin\00"
@str$17f = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmath\2Fmath.odin\00"
@str$180 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmath\2Fmath.odin\00"
@str$181 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmath\2Fmath.odin\00"
@str$182 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmath\2Fmath.odin\00"
@str$183 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmath\2Fmath.odin\00"
@str$184 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$185 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$186 = private global [14 x i8] c"_update_input\00"
@str$187 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$188 = private global [14 x i8] c"_update_input\00"
@str$189 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$18a = private global [14 x i8] c"_update_input\00"
@str$18b = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$18c = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$18d = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$18e = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$18f = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$190 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$191 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$192 = private global [14 x i8] c"_update_input\00"
@str$193 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$194 = private global [14 x i8] c"_update_input\00"
@str$195 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$196 = private global [14 x i8] c"_update_input\00"
@str$197 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$198 = private global [19 x i8] c"_glfw_key_callback\00"
@str$199 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$19a = private global [19 x i8] c"_glfw_key_callback\00"
@str$19b = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$19c = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$19d = private global [19 x i8] c"_glfw_key_callback\00"
@str$19e = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$19f = private global [19 x i8] c"_glfw_key_callback\00"
@str$1a0 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$1a1 = private global [28 x i8] c"_glfw_mouse_button_callback\00"
@str$1a2 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$1a3 = private global [28 x i8] c"_glfw_mouse_button_callback\00"
@str$1a4 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$1a5 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$1a6 = private global [28 x i8] c"_glfw_mouse_button_callback\00"
@str$1a7 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$1a8 = private global [28 x i8] c"_glfw_mouse_button_callback\00"
@str$1a9 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$1aa = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$1ab = private global [11 x i8] c"\25s.\25s\28\29\3A\25d\00"
@str$1ac = private global [2 x i8] c"\0A\00"
@str$1ad = private global [14 x i8] c"\3C\25s.\25s\28\29\3A\25d\3E\20\00"
@str$1ae = private global [2 x i8] c"\0A\00"
@str$1af = private global [24 x i8] c"GLFW\20Error\3A\20\25d\3A\0A\20\20\20\20\25s\0A\00"
@str$1b0 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$1b1 = private global [24 x i8] c"im_vertex_color_texture\00"
@str$1b2 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$1b3 = private global [24 x i8] c"im_vertex_color_texture\00"
@str$1b4 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$1b5 = private global [17 x i8] c"_update_renderer\00"
@str$1b6 = private global [17 x i8] c"_update_renderer\00"
@str$1b7 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$1b8 = private global [13 x i8] c"render_scene\00"
@str$1b9 = private global [13 x i8] c"render_scene\00"
@str$1ba = private global [13 x i8] c"scene_name\3A\20\00"
@str$1bb = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$1bc = private global [13 x i8] c"render_scene\00"
@str$1bd = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$1be = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$1bf = private global [14 x i8] c"im_draw_flush\00"
@str$1c0 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$1c1 = private global [14 x i8] c"im_draw_flush\00"
@str$1c2 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$1c3 = private global [14 x i8] c"im_draw_flush\00"
@str$1c4 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$1c5 = private global [14 x i8] c"im_draw_flush\00"
@str$1c6 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$1c7 = private global [14 x i8] c"im_draw_flush\00"
@str$1c8 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$1c9 = private global [11 x i8] c"set_shader\00"
@str$1ca = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$1cb = private global [12 x i8] c"set_texture\00"
@str$1cc = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$1cd = private global [18 x i8] c"push_debug_vertex\00"
@str$1ce = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$1cf = private global [17 x i8] c"draw_debug_lines\00"
@str$1d0 = private global [12 x i8] c"create_mesh\00"
@str$1d1 = private global [66 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fthree_d.odin\00"
@str$1d2 = private global [11 x i8] c"load_asset\00"
@str$1d3 = private global [66 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fthree_d.odin\00"
@str$1d4 = private global [11 x i8] c"load_asset\00"
@str$1d5 = private global [66 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fthree_d.odin\00"
@str$1d6 = private global [66 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fthree_d.odin\00"
@str$1d7 = private global [66 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fthree_d.odin\00"
@str$1d8 = private global [11 x i8] c"load_asset\00"
@str$1d9 = private global [66 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fthree_d.odin\00"
@str$1da = private global [11 x i8] c"load_asset\00"
@str$1db = private global [66 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fthree_d.odin\00"
@str$1dc = private global [10 x i8] c"draw_mesh\00"
@str$1dd = private global [13 x i8] c"\5BWB\5D\20FRAME\20\23\00"
@str$1de = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwb.odin\00"
@str$1df = private global [19 x i8] c"make_simple_window\00"
@str$1e0 = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwb.odin\00"
@str$1e1 = private global [19 x i8] c"make_simple_window\00"
@str$1e2 = private global [20 x i8] c"after\20SwapBuffers\28\29\00"
@str$1e3 = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwb.odin\00"
@str$1e4 = private global [12 x i8] c"start_scene\00"
@str$1e5 = private global [15 x i8] c"_update_scenes\00"
@str$1e6 = private global [6 x i8] c"Debug\00"
@str$1e7 = private global [14 x i8] c"wb_debug_data\00"
@str$1e8 = private global [16 x i8] c"Debug\20Rendering\00"
@str$1e9 = private global [9 x i8] c"Debug\20UI\00"
@str$1ea = private global [21 x i8] c"Log\20Frame\20Boundaries\00"
@str$1eb = private global [15 x i8] c"max_draw_calls\00"
@str$1ec = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl.odin\00"
@str$1ed = private global [13 x i8] c"_init_opengl\00"
@str$1ee = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl.odin\00"
@str$1ef = private global [13 x i8] c"_init_opengl\00"
@str$1f0 = private global [460 x i8] c"\0A\23version\20330\20core\0A\0A\2F\2F\20from\20vbo\0Alayout\28location\20\3D\200\29\20in\20vec3\20vbo_vertex_position\3B\0Alayout\28location\20\3D\201\29\20in\20vec2\20vbo_tex_coord\3B\0Alayout\28location\20\3D\202\29\20in\20vec4\20vbo_color\3B\0A\0Auniform\20mat4\20mvp_matrix\3B\0A\0Aout\20vec4\20desired_color\3B\0A\0Avoid\20main\28\29\20\7B\0A\20\20\20\20vec4\20result\20\3D\20mvp_matrix\20\2A\20vec4\28vbo_vertex_position.x\2C\20vbo_vertex_position.y\2C\20vbo_vertex_position.z\2C\201\29\3B\0A\20\20\20\20if\20\28result.w\20\3E\200\29\20\7B\20result\20\2F\3D\20result.w\3B\20\7D\0A\20\20\20\20gl_Position\20\3D\20vec4\28result.xyz\2C\201\29\3B\0A\20\20\20\20desired_color\20\3D\20vbo_color\3B\0A\7D\0A\00"
@str$1f1 = private global [105 x i8] c"\0A\23version\20330\20core\0A\0Ain\20vec4\20desired_color\3B\0A\0Aout\20vec4\20color\3B\0A\0Avoid\20main\28\29\20\7B\0A\20\20\20\20color\20\3D\20desired_color\3B\0A\7D\0A\00"
@str$1f2 = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl.odin\00"
@str$1f3 = private global [13 x i8] c"_init_opengl\00"
@str$1f4 = private global [511 x i8] c"\0A\23version\20330\20core\0A\0A\2F\2F\20from\20vbo\0Alayout\28location\20\3D\200\29\20in\20vec3\20vbo_vertex_position\3B\0Alayout\28location\20\3D\201\29\20in\20vec2\20vbo_tex_coord\3B\0Alayout\28location\20\3D\202\29\20in\20vec4\20vbo_color\3B\0A\0Auniform\20mat4\20mvp_matrix\3B\0A\0Aout\20vec2\20tex_coord\3B\0Aout\20vec4\20desired_color\3B\0A\0Avoid\20main\28\29\20\7B\0A\20\20\20\20vec4\20result\20\3D\20mvp_matrix\20\2A\20vec4\28vbo_vertex_position.x\2C\20vbo_vertex_position.y\2C\20vbo_vertex_position.z\2C\201\29\3B\0A\20\20\20\20if\20\28result.w\20\3E\200\29\20\7B\20result\20\2F\3D\20result.w\3B\20\7D\0A\20\20\20\20gl_Position\20\3D\20vec4\28result.xyz\2C\201\29\3B\0A\20\20\20\20tex_coord\20\3D\20vbo_tex_coord\3B\0A\20\20\20\20desired_color\20\3D\20vbo_color\3B\0A\7D\0A\00"
@str$1f5 = private global [194 x i8] c"\0A\23version\20330\20core\0A\0Ain\20vec2\20tex_coord\3B\0Ain\20vec4\20desired_color\3B\0A\0Auniform\20sampler2D\20atlas_texture\3B\0A\0Aout\20vec4\20color\3B\0A\0Avoid\20main\28\29\20\7B\0A\20\20\20\20color\20\3D\20texture\28atlas_texture\2C\20tex_coord\29\20\2A\20desired_color\3B\0A\7D\0A\00"
@str$1f6 = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl.odin\00"
@str$1f7 = private global [13 x i8] c"_init_opengl\00"
@str$1f8 = private global [511 x i8] c"\0A\23version\20330\20core\0A\0A\2F\2F\20from\20vbo\0Alayout\28location\20\3D\200\29\20in\20vec3\20vbo_vertex_position\3B\0Alayout\28location\20\3D\201\29\20in\20vec2\20vbo_tex_coord\3B\0Alayout\28location\20\3D\202\29\20in\20vec4\20vbo_color\3B\0A\0Auniform\20mat4\20mvp_matrix\3B\0A\0Aout\20vec2\20tex_coord\3B\0Aout\20vec4\20desired_color\3B\0A\0Avoid\20main\28\29\20\7B\0A\20\20\20\20vec4\20result\20\3D\20mvp_matrix\20\2A\20vec4\28vbo_vertex_position.x\2C\20vbo_vertex_position.y\2C\20vbo_vertex_position.z\2C\201\29\3B\0A\20\20\20\20if\20\28result.w\20\3E\200\29\20\7B\20result\20\2F\3D\20result.w\3B\20\7D\0A\20\20\20\20gl_Position\20\3D\20vec4\28result.xyz\2C\201\29\3B\0A\20\20\20\20tex_coord\20\3D\20vbo_tex_coord\3B\0A\20\20\20\20desired_color\20\3D\20vbo_color\3B\0A\7D\0A\00"
@str$1f9 = private global [420 x i8] c"\0A\23version\20330\20core\0A\0Ain\20vec2\20tex_coord\3B\0Ain\20vec4\20desired_color\3B\0A\0Auniform\20sampler2D\20atlas_texture\3B\0A\0Aout\20vec4\20color\3B\0A\0Avoid\20main\28\29\20\7B\0A\09uvec4\20bytes\20\3D\20uvec4\28texture\28atlas_texture\2C\20tex_coord\29\20\2A\20255\29\3B\0A\09uvec4\20desired\20\3D\20uvec4\28desired_color\20\2A\20255\29\3B\0A\0A\09uint\20old_r\20\3D\20bytes.r\3B\0A\0A\09bytes.r\20\3D\20desired.r\3B\0A\09bytes.g\20\3D\20desired.g\3B\0A\09bytes.b\20\3D\20desired.b\3B\0A\09bytes.a\20\26\3D\20old_r\20\26\20desired.a\3B\0A\0A\09color\20\3D\20vec4\28bytes.r\2C\20bytes.g\2C\20bytes.b\2C\20bytes.a\29\20\2F\20255f\3B\0A\7D\0A\00"
@str$1fa = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl.odin\00"
@str$1fb = private global [13 x i8] c"_init_opengl\00"
@str$1fc = private global [489 x i8] c"\0A\23version\20330\20core\0A\0Alayout\28location\20\3D\200\29\20in\20vec3\20vbo_vertex_position\3B\0Alayout\28location\20\3D\201\29\20in\20vec2\20vbo_tex_coord\3B\0Alayout\28location\20\3D\202\29\20in\20vec4\20vbo_color\3B\0Alayout\28location\20\3D\203\29\20in\20vec4\20vbo_normal\3B\0A\0Auniform\20mat4\20mvp_matrix\3B\0A\0Aout\20vec4\20desired_color\3B\0A\0Avoid\20main\28\29\20\7B\0A\20\20\20\20vec4\20result\20\3D\20mvp_matrix\20\2A\20vec4\28vbo_vertex_position.x\2C\20vbo_vertex_position.y\2C\20vbo_vertex_position.z\2C\201\29\3B\0A\20\20\20\20if\20\28result.w\20\3E\200\29\20\7B\20result\20\2F\3D\20result.w\3B\20\7D\0A\20\20\20\20gl_Position\20\3D\20vec4\28result.xyz\2C\201\29\3B\0A\20\20\20\20desired_color\20\3D\20vbo_color\3B\0A\7D\0A\00"
@str$1fd = private global [105 x i8] c"\0A\23version\20330\20core\0A\0Ain\20vec4\20desired_color\3B\0A\0Aout\20vec4\20color\3B\0A\0Avoid\20main\28\29\20\7B\0A\20\20\20\20color\20\3D\20desired_color\3B\0A\7D\0A\00"
@str$1fe = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl.odin\00"
@str$1ff = private global [13 x i8] c"_init_opengl\00"
@str$200 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fbasic.odin\00"
@str$201 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fbasic.odin\00"
@str$202 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fbasic.odin\00"
@str$203 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fbasic.odin\00"
@str$204 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fbasic.odin\00"
@str$205 = private global [8 x i8] c"gen_vao\00"
@str$206 = private global [9 x i8] c"bind_vao\00"
@str$207 = private global [11 x i8] c"delete_vao\00"
@str$208 = private global [11 x i8] c"gen_buffer\00"
@str$209 = private global [16 x i8] c"bind_buffer_vbo\00"
@str$20a = private global [16 x i8] c"bind_buffer_ebo\00"
@str$20b = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$20c = private global [12 x i8] c"check_error\00"
@str$20d = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$20e = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$20f = private global [16 x i8] c"Error\20in\20\25v\3A\0A\25s\00"
@str$210 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$211 = private global [12 x i8] c"check_error\00"
@str$212 = private global [12 x i8] c"use_program\00"
@str$213 = private global [12 x i8] c"gen_texture\00"
@str$214 = private global [15 x i8] c"bind_texture2d\00"
@str$215 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$216 = private global [21 x i8] c"get_uniform_location\00"
@str$217 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$218 = private global [20 x i8] c"get_attrib_location\00"
@str$219 = private global [8 x i8] c"get_int\00"
@str$21a = private global [10 x i8] c"uniform1i\00"
@str$21b = private global [18 x i8] c"uniform_matrix4fv\00"
@str$21c = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$21d = private global [32 x i8] c"\5B\25s\5D\20OpenGL\20Error\20at\20\25s\3A\25d\3A\20\25d\0A\00"
@str$21e = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$21f = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$220 = private global [20 x i8] c"tween_destroy_index\00"
@str$221 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$222 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$223 = private global [14 x i8] c"_update_tween\00"
@str$224 = private global [321 x i8] c"\23version\20330\0A\20\20\20\20\20\20\20\20uniform\20mat4\20ProjMtx\3B\0A\20\20\20\20\20\20\20\20in\20vec2\20Position\3B\0A\20\20\20\20\20\20\20\20in\20vec2\20UV\3B\0A\20\20\20\20\20\20\20\20in\20vec4\20Color\3B\0A\20\20\20\20\20\20\20\20out\20vec2\20Frag_UV\3B\0A\20\20\20\20\20\20\20\20out\20vec4\20Frag_Color\3B\0A\20\20\20\20\20\20\20\20void\20main\28\29\0A\20\20\20\20\20\20\20\20\7B\0A\20\20\20\20\20\20\20\20\20\20\20Frag_UV\20\3D\20UV\3B\0A\20\20\20\20\20\20\20\20\20\20\20Frag_Color\20\3D\20Color\3B\0A\20\20\20\20\20\20\20\20\20\20\20gl_Position\20\3D\20ProjMtx\20\2A\20vec4\28Position.xy\2C0\2C1\29\3B\0A\20\20\20\20\20\20\20\20\7D\00"
@str$225 = private global [236 x i8] c"\23version\20330\0A\20\20\20\20\20\20\20\20uniform\20sampler2D\20Texture\3B\0A\20\20\20\20\20\20\20\20in\20vec2\20Frag_UV\3B\0A\20\20\20\20\20\20\20\20in\20vec4\20Frag_Color\3B\0A\20\20\20\20\20\20\20\20out\20vec4\20Out_Color\3B\0A\20\20\20\20\20\20\20\20void\20main\28\29\0A\20\20\20\20\20\20\20\20\7B\0A\20\20\20\20\20\20\20\20\20\20\20Out_Color\20\3D\20Frag_Color\20\2A\20texture\28\20Texture\2C\20Frag_UV.st\29\3B\0A\20\20\20\20\20\20\20\20\7D\00"
@str$226 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$227 = private global [17 x i8] c"_init_dear_imgui\00"
@str$228 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$229 = private global [17 x i8] c"_init_dear_imgui\00"
@str$22a = private global [8 x i8] c"Texture\00"
@str$22b = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$22c = private global [17 x i8] c"_init_dear_imgui\00"
@str$22d = private global [8 x i8] c"ProjMtx\00"
@str$22e = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$22f = private global [17 x i8] c"_init_dear_imgui\00"
@str$230 = private global [9 x i8] c"Position\00"
@str$231 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$232 = private global [17 x i8] c"_init_dear_imgui\00"
@str$233 = private global [3 x i8] c"UV\00"
@str$234 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$235 = private global [17 x i8] c"_init_dear_imgui\00"
@str$236 = private global [6 x i8] c"Color\00"
@str$237 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$238 = private global [17 x i8] c"_init_dear_imgui\00"
@str$239 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$23a = private global [17 x i8] c"_init_dear_imgui\00"
@str$23b = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$23c = private global [17 x i8] c"_init_dear_imgui\00"
@str$23d = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$23e = private global [17 x i8] c"_init_dear_imgui\00"
@str$23f = private global [27 x i8] c"fonts\2FOpenSans-Regular.ttf\00"
@str$240 = private global [22 x i8] c"fonts\2FInconsolata.ttf\00"
@str$241 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$242 = private global [17 x i8] c"_init_dear_imgui\00"
@str$243 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$244 = private global [17 x i8] c"_init_dear_imgui\00"
@str$245 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$246 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$247 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$248 = private global [13 x i8] c"imgui_render\00"
@str$249 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$24a = private global [13 x i8] c"imgui_render\00"
@str$24b = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$24c = private global [13 x i8] c"imgui_render\00"
@str$24d = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$24e = private global [13 x i8] c"imgui_render\00"
@str$24f = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$250 = private global [13 x i8] c"imgui_render\00"
@str$251 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$252 = private global [13 x i8] c"imgui_render\00"
@str$253 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$254 = private global [13 x i8] c"imgui_render\00"
@str$255 = private global [8 x i8] c"Texture\00"
@str$256 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$257 = private global [13 x i8] c"imgui_render\00"
@str$258 = private global [8 x i8] c"ProjMtx\00"
@str$259 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$25a = private global [13 x i8] c"imgui_render\00"
@str$25b = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$25c = private global [13 x i8] c"imgui_render\00"
@str$25d = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$25e = private global [13 x i8] c"imgui_render\00"
@str$25f = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$260 = private global [13 x i8] c"imgui_render\00"
@str$261 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$262 = private global [13 x i8] c"imgui_render\00"
@str$263 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$264 = private global [13 x i8] c"imgui_render\00"
@str$265 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$266 = private global [13 x i8] c"imgui_render\00"
@str$267 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$268 = private global [13 x i8] c"imgui_render\00"
@str$269 = private global [3 x i8] c"\3A\20\00"
@str$26a = private global [3 x i8] c"\20\7B\00"
@str$26b = private global [7 x i8] c"\20...\20\7D\00"
@str$26c = private global [2 x i8] c"\7D\00"
@str$26d = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$26e = private global [23 x i8] c"_imgui_struct_internal\00"
@str$26f = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$270 = private global [23 x i8] c"_imgui_struct_internal\00"
@str$271 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$272 = private global [23 x i8] c"_imgui_struct_internal\00"
@str$273 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$274 = private global [23 x i8] c"_imgui_struct_internal\00"
@str$275 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$276 = private global [23 x i8] c"_imgui_struct_internal\00"
@str$277 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$278 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$279 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$27a = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$27b = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$27c = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$27d = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$27e = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$27f = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$280 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$281 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fimgui.odin\00"
@str$282 = private global [3 x i8] c"\5B\5D\00"
@str$283 = private global [2 x i8] c"\5B\00"
@str$284 = private global [2 x i8] c"\5D\00"
@str$285 = private global [2 x i8] c"\5B\00"
@str$286 = private global [2 x i8] c"\5D\00"
@str$287 = private global [2 x i8] c"\5B\00"
@str$288 = private global [2 x i8] c"\5D\00"
@str$289 = private global [17 x i8] c"UNHANDLED\20TYPE\3A\20\00"
@str$28a = private global [10 x i8] c"\5Bdynamic\5D\00"
@str$28b = private global [2 x i8] c"\5B\00"
@str$28c = private global [2 x i8] c"\5D\00"
@str$28d = private global [2 x i8] c"\22\00"
@str$28e = private global [2 x i8] c"\22\00"
@str$28f = private global [5 x i8] c"\25.8f\00"
@str$290 = private global [4 x i8] c"nil\00"
@str$291 = private global [4 x i8] c"\20\3D\20\00"
@str$292 = private global [2 x i8] c"\22\00"
@str$293 = private global [2 x i8] c"\22\00"
@str$294 = private global [5 x i8] c"\25.8f\00"
@str$295 = private global [4 x i8] c"nil\00"
@str$296 = private global [4 x i8] c"\20\3D\20\00"
@str$297 = private global [2 x i8] c"\22\00"
@str$298 = private global [2 x i8] c"\22\00"
@str$299 = private global [5 x i8] c"\25.8f\00"
@str$29a = private global [4 x i8] c"nil\00"
@str$29b = private global [4 x i8] c"\20\3D\20\00"
@str$29c = private global [2 x i8] c"\22\00"
@str$29d = private global [2 x i8] c"\22\00"
@str$29e = private global [5 x i8] c"\25.8f\00"
@str$29f = private global [4 x i8] c"nil\00"
@str$2a0 = private global [4 x i8] c"\20\3D\20\00"
@str$2a1 = private global [2 x i8] c"\22\00"
@str$2a2 = private global [2 x i8] c"\22\00"
@str$2a3 = private global [5 x i8] c"\25.8f\00"
@str$2a4 = private global [4 x i8] c"nil\00"
@str$2a5 = private global [4 x i8] c"\20\3D\20\00"
@str$2a6 = private global [2 x i8] c"\22\00"
@str$2a7 = private global [2 x i8] c"\22\00"
@str$2a8 = private global [5 x i8] c"\25.8f\00"
@str$2a9 = private global [4 x i8] c"nil\00"
@str$2aa = private global [4 x i8] c"\20\3D\20\00"
@str$2ab = private global [2 x i8] c"\22\00"
@str$2ac = private global [2 x i8] c"\22\00"
@str$2ad = private global [5 x i8] c"\25.8f\00"
@str$2ae = private global [4 x i8] c"nil\00"
@str$2af = private global [4 x i8] c"\20\3D\20\00"
@str$2b0 = private global [2 x i8] c"\22\00"
@str$2b1 = private global [2 x i8] c"\22\00"
@str$2b2 = private global [5 x i8] c"\25.8f\00"
@str$2b3 = private global [4 x i8] c"nil\00"
@str$2b4 = private global [4 x i8] c"\20\3D\20\00"
@str$2b5 = private global [2 x i8] c"\22\00"
@str$2b6 = private global [2 x i8] c"\22\00"
@str$2b7 = private global [5 x i8] c"\25.8f\00"
@str$2b8 = private global [4 x i8] c"nil\00"
@str$2b9 = private global [4 x i8] c"\20\3D\20\00"
@str$2ba = private global [2 x i8] c"\22\00"
@str$2bb = private global [2 x i8] c"\22\00"
@str$2bc = private global [5 x i8] c"\25.8f\00"
@str$2bd = private global [4 x i8] c"nil\00"
@str$2be = private global [4 x i8] c"\20\3D\20\00"
@str$2bf = private global [2 x i8] c"\22\00"
@str$2c0 = private global [2 x i8] c"\22\00"
@str$2c1 = private global [5 x i8] c"\25.8f\00"
@str$2c2 = private global [4 x i8] c"nil\00"
@str$2c3 = private global [4 x i8] c"\20\3D\20\00"
@str$2c4 = private global [2 x i8] c"\22\00"
@str$2c5 = private global [2 x i8] c"\22\00"
@str$2c6 = private global [5 x i8] c"\25.8f\00"
@str$2c7 = private global [4 x i8] c"nil\00"
@str$2c8 = private global [4 x i8] c"\20\3D\20\00"
@str$2c9 = private global [2 x i8] c"\22\00"
@str$2ca = private global [2 x i8] c"\22\00"
@str$2cb = private global [5 x i8] c"\25.8f\00"
@str$2cc = private global [4 x i8] c"nil\00"
@str$2cd = private global [4 x i8] c"\20\3D\20\00"
@str$2ce = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2cf = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2d0 = private global [11 x i8] c"_update_ui\00"
@str$2d1 = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2d2 = private global [11 x i8] c"_update_ui\00"
@str$2d3 = private global [19 x i8] c"Unsupported\20kind\3A\20\00"
@str$2d4 = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2d5 = private global [19 x i8] c"can_be_hot_or_warm\00"
@str$2d6 = private global [10 x i8] c"UI\20System\00"
@str$2d7 = private global [14 x i8] c"ui_debug_info\00"
@str$2d8 = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2d9 = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2da = private global [16 x i8] c"_late_update_ui\00"
@str$2db = private global [11 x i8] c"ui_element\00"
@str$2dc = private global [7 x i8] c"\25s\23\23\25d\00"
@str$2dd = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2de = private global [16 x i8] c"_late_update_ui\00"
@str$2df = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2e0 = private global [16 x i8] c"_late_update_ui\00"
@str$2e1 = private global [27 x i8] c"get_imgui_id_from_location\00"
@str$2e2 = private global [27 x i8] c"get_imgui_id_from_location\00"
@str$2e3 = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2e4 = private global [27 x i8] c"get_imgui_id_from_location\00"
@str$2e5 = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2e6 = private global [13 x i8] c"ui_push_rect\00"
@str$2e7 = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2e8 = private global [13 x i8] c"ui_push_rect\00"
@str$2e9 = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2ea = private global [13 x i8] c"ui_push_rect\00"
@str$2eb = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2ec = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2ed = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2ee = private global [23 x i8] c"ui_debug_get_file_line\00"
@str$2ef = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2f0 = private global [23 x i8] c"ui_debug_get_file_line\00"
@str$2f1 = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fui.odin\00"
@str$2f2 = private global [23 x i8] c"ui_debug_get_file_line\00"
@str$2f3 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$2f4 = private global [13 x i8] c"generic_ftoa\00"
@str$2f5 = private global [26 x i8] c"strconv\3A\20invalid\20bit_size\00"
@str$2f6 = private global [4 x i8] c"NaN\00"
@str$2f7 = private global [5 x i8] c"-Inf\00"
@str$2f8 = private global [5 x i8] c"\2BInf\00"
@str$2f9 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$2fa = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$2fb = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$2fc = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$2fd = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$2fe = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$2ff = private global [14 x i8] c"format_digits\00"
@str$300 = private global [49 x i8] c"strconv\3A\20e\2FE\20float\20printing\20is\20not\20yet\20supported\00"
@str$301 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$302 = private global [14 x i8] c"format_digits\00"
@str$303 = private global [49 x i8] c"strconv\3A\20g\2FG\20float\20printing\20is\20not\20yet\20supported\00"
@str$304 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$305 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$306 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$307 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$308 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$309 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$30a = private global [20 x i8] c"is_integer_negative\00"
@str$30b = private global [42 x i8] c"is_integer_negative\3A\20Unknown\20integer\20size\00"
@str$30c = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$30d = private global [12 x i8] c"append_bits\00"
@str$30e = private global [44 x i8] c"strconv\3A\20illegal\20base\20passed\20to\20append_bits\00"
@str$30f = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$310 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$311 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$312 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$313 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$314 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$315 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$316 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$317 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$318 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$319 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$31a = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$31b = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$31c = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$31d = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$31e = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fglfw\2Fglfw.odin\00"
@str$31f = private global [2 x i8] c"\00\00"
@str$320 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fodin-imgui\2Fdear_imgui.odin\00"
@str$321 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fodin-imgui\2Fdear_imgui.odin\00"
@str$322 = private global [2 x i8] c"\00\00"
@str$323 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fodin-imgui\2Fdear_imgui.odin\00"
@str$324 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fodin-imgui\2Fdear_imgui.odin\00"
@str$325 = private global [2 x i8] c"\00\00"
@str$326 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fodin-imgui\2Fdear_imgui.odin\00"
@str$327 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fodin-imgui\2Fdear_imgui.odin\00"
@str$328 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fodin-imgui\2Fdear_imgui.odin\00"
@str$329 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrings\2Fstrings.odin\00"
@str$32a = private global [11 x i8] c"new_string\00"
@str$32b = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrings\2Fstrings.odin\00"
@str$32c = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrings\2Fstrings.odin\00"
@str$32d = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrings\2Fstrings.odin\00"
@str$32e = private global [12 x i8] c"new_cstring\00"
@str$32f = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrings\2Fstrings.odin\00"
@str$330 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrings\2Fstrings.odin\00"
@str$331 = private global [61 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmath\2Frand\2Frand.odin\00"
@str$332 = private global [10 x i8] c"int63_max\00"
@str$333 = private global [30 x i8] c"Invalid\20argument\20to\20int63_max\00"
@str$334 = private global [4 x i8] c"0.0\00"
@str$335 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fodin-gl\2Fgl.odin\00"
@str$336 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fodin-gl\2Fgl.odin\00"
@str$337 = private global [11 x i8] c"glCullFace\00"
@str$338 = private global [12 x i8] c"glFrontFace\00"
@str$339 = private global [7 x i8] c"glHint\00"
@str$33a = private global [12 x i8] c"glLineWidth\00"
@str$33b = private global [12 x i8] c"glPointSize\00"
@str$33c = private global [14 x i8] c"glPolygonMode\00"
@str$33d = private global [10 x i8] c"glScissor\00"
@str$33e = private global [16 x i8] c"glTexParameterf\00"
@str$33f = private global [17 x i8] c"glTexParameterfv\00"
@str$340 = private global [16 x i8] c"glTexParameteri\00"
@str$341 = private global [17 x i8] c"glTexParameteriv\00"
@str$342 = private global [13 x i8] c"glTexImage1D\00"
@str$343 = private global [13 x i8] c"glTexImage2D\00"
@str$344 = private global [13 x i8] c"glDrawBuffer\00"
@str$345 = private global [8 x i8] c"glClear\00"
@str$346 = private global [13 x i8] c"glClearColor\00"
@str$347 = private global [15 x i8] c"glClearStencil\00"
@str$348 = private global [13 x i8] c"glClearDepth\00"
@str$349 = private global [14 x i8] c"glStencilMask\00"
@str$34a = private global [12 x i8] c"glColorMask\00"
@str$34b = private global [12 x i8] c"glDepthMask\00"
@str$34c = private global [10 x i8] c"glDisable\00"
@str$34d = private global [9 x i8] c"glEnable\00"
@str$34e = private global [9 x i8] c"glFinish\00"
@str$34f = private global [8 x i8] c"glFlush\00"
@str$350 = private global [12 x i8] c"glBlendFunc\00"
@str$351 = private global [10 x i8] c"glLogicOp\00"
@str$352 = private global [14 x i8] c"glStencilFunc\00"
@str$353 = private global [12 x i8] c"glStencilOp\00"
@str$354 = private global [12 x i8] c"glDepthFunc\00"
@str$355 = private global [14 x i8] c"glPixelStoref\00"
@str$356 = private global [14 x i8] c"glPixelStorei\00"
@str$357 = private global [13 x i8] c"glReadBuffer\00"
@str$358 = private global [13 x i8] c"glReadPixels\00"
@str$359 = private global [14 x i8] c"glGetBooleanv\00"
@str$35a = private global [13 x i8] c"glGetDoublev\00"
@str$35b = private global [11 x i8] c"glGetError\00"
@str$35c = private global [12 x i8] c"glGetFloatv\00"
@str$35d = private global [14 x i8] c"glGetIntegerv\00"
@str$35e = private global [12 x i8] c"glGetString\00"
@str$35f = private global [14 x i8] c"glGetTexImage\00"
@str$360 = private global [20 x i8] c"glGetTexParameterfv\00"
@str$361 = private global [20 x i8] c"glGetTexParameteriv\00"
@str$362 = private global [25 x i8] c"glGetTexLevelParameterfv\00"
@str$363 = private global [25 x i8] c"glGetTexLevelParameteriv\00"
@str$364 = private global [12 x i8] c"glIsEnabled\00"
@str$365 = private global [13 x i8] c"glDepthRange\00"
@str$366 = private global [11 x i8] c"glViewport\00"
@str$367 = private global [13 x i8] c"glDrawArrays\00"
@str$368 = private global [15 x i8] c"glDrawElements\00"
@str$369 = private global [16 x i8] c"glPolygonOffset\00"
@str$36a = private global [17 x i8] c"glCopyTexImage1D\00"
@str$36b = private global [17 x i8] c"glCopyTexImage2D\00"
@str$36c = private global [20 x i8] c"glCopyTexSubImage1D\00"
@str$36d = private global [20 x i8] c"glCopyTexSubImage2D\00"
@str$36e = private global [16 x i8] c"glTexSubImage1D\00"
@str$36f = private global [16 x i8] c"glTexSubImage2D\00"
@str$370 = private global [14 x i8] c"glBindTexture\00"
@str$371 = private global [17 x i8] c"glDeleteTextures\00"
@str$372 = private global [14 x i8] c"glGenTextures\00"
@str$373 = private global [12 x i8] c"glIsTexture\00"
@str$374 = private global [20 x i8] c"glDrawRangeElements\00"
@str$375 = private global [13 x i8] c"glTexImage3D\00"
@str$376 = private global [16 x i8] c"glTexSubImage3D\00"
@str$377 = private global [20 x i8] c"glCopyTexSubImage3D\00"
@str$378 = private global [16 x i8] c"glActiveTexture\00"
@str$379 = private global [17 x i8] c"glSampleCoverage\00"
@str$37a = private global [23 x i8] c"glCompressedTexImage3D\00"
@str$37b = private global [23 x i8] c"glCompressedTexImage2D\00"
@str$37c = private global [23 x i8] c"glCompressedTexImage1D\00"
@str$37d = private global [26 x i8] c"glCompressedTexSubImage3D\00"
@str$37e = private global [26 x i8] c"glCompressedTexSubImage2D\00"
@str$37f = private global [26 x i8] c"glCompressedTexSubImage1D\00"
@str$380 = private global [24 x i8] c"glGetCompressedTexImage\00"
@str$381 = private global [20 x i8] c"glBlendFuncSeparate\00"
@str$382 = private global [18 x i8] c"glMultiDrawArrays\00"
@str$383 = private global [20 x i8] c"glMultiDrawElements\00"
@str$384 = private global [18 x i8] c"glPointParameterf\00"
@str$385 = private global [19 x i8] c"glPointParameterfv\00"
@str$386 = private global [18 x i8] c"glPointParameteri\00"
@str$387 = private global [19 x i8] c"glPointParameteriv\00"
@str$388 = private global [13 x i8] c"glBlendColor\00"
@str$389 = private global [16 x i8] c"glBlendEquation\00"
@str$38a = private global [13 x i8] c"glGenQueries\00"
@str$38b = private global [16 x i8] c"glDeleteQueries\00"
@str$38c = private global [10 x i8] c"glIsQuery\00"
@str$38d = private global [13 x i8] c"glBeginQuery\00"
@str$38e = private global [11 x i8] c"glEndQuery\00"
@str$38f = private global [13 x i8] c"glGetQueryiv\00"
@str$390 = private global [19 x i8] c"glGetQueryObjectiv\00"
@str$391 = private global [20 x i8] c"glGetQueryObjectuiv\00"
@str$392 = private global [13 x i8] c"glBindBuffer\00"
@str$393 = private global [16 x i8] c"glDeleteBuffers\00"
@str$394 = private global [13 x i8] c"glGenBuffers\00"
@str$395 = private global [11 x i8] c"glIsBuffer\00"
@str$396 = private global [13 x i8] c"glBufferData\00"
@str$397 = private global [16 x i8] c"glBufferSubData\00"
@str$398 = private global [19 x i8] c"glGetBufferSubData\00"
@str$399 = private global [12 x i8] c"glMapBuffer\00"
@str$39a = private global [14 x i8] c"glUnmapBuffer\00"
@str$39b = private global [23 x i8] c"glGetBufferParameteriv\00"
@str$39c = private global [20 x i8] c"glGetBufferPointerv\00"
@str$39d = private global [24 x i8] c"glBlendEquationSeparate\00"
@str$39e = private global [14 x i8] c"glDrawBuffers\00"
@str$39f = private global [20 x i8] c"glStencilOpSeparate\00"
@str$3a0 = private global [22 x i8] c"glStencilFuncSeparate\00"
@str$3a1 = private global [22 x i8] c"glStencilMaskSeparate\00"
@str$3a2 = private global [15 x i8] c"glAttachShader\00"
@str$3a3 = private global [21 x i8] c"glBindAttribLocation\00"
@str$3a4 = private global [16 x i8] c"glCompileShader\00"
@str$3a5 = private global [16 x i8] c"glCreateProgram\00"
@str$3a6 = private global [15 x i8] c"glCreateShader\00"
@str$3a7 = private global [16 x i8] c"glDeleteProgram\00"
@str$3a8 = private global [15 x i8] c"glDeleteShader\00"
@str$3a9 = private global [15 x i8] c"glDetachShader\00"
@str$3aa = private global [27 x i8] c"glDisableVertexAttribArray\00"
@str$3ab = private global [26 x i8] c"glEnableVertexAttribArray\00"
@str$3ac = private global [18 x i8] c"glGetActiveAttrib\00"
@str$3ad = private global [19 x i8] c"glGetActiveUniform\00"
@str$3ae = private global [21 x i8] c"glGetAttachedShaders\00"
@str$3af = private global [20 x i8] c"glGetAttribLocation\00"
@str$3b0 = private global [15 x i8] c"glGetProgramiv\00"
@str$3b1 = private global [20 x i8] c"glGetProgramInfoLog\00"
@str$3b2 = private global [14 x i8] c"glGetShaderiv\00"
@str$3b3 = private global [19 x i8] c"glGetShaderInfoLog\00"
@str$3b4 = private global [18 x i8] c"glGetShaderSource\00"
@str$3b5 = private global [21 x i8] c"glGetUniformLocation\00"
@str$3b6 = private global [15 x i8] c"glGetUniformfv\00"
@str$3b7 = private global [15 x i8] c"glGetUniformiv\00"
@str$3b8 = private global [20 x i8] c"glGetVertexAttribdv\00"
@str$3b9 = private global [20 x i8] c"glGetVertexAttribfv\00"
@str$3ba = private global [20 x i8] c"glGetVertexAttribiv\00"
@str$3bb = private global [26 x i8] c"glGetVertexAttribPointerv\00"
@str$3bc = private global [12 x i8] c"glIsProgram\00"
@str$3bd = private global [11 x i8] c"glIsShader\00"
@str$3be = private global [14 x i8] c"glLinkProgram\00"
@str$3bf = private global [15 x i8] c"glShaderSource\00"
@str$3c0 = private global [13 x i8] c"glUseProgram\00"
@str$3c1 = private global [12 x i8] c"glUniform1f\00"
@str$3c2 = private global [12 x i8] c"glUniform2f\00"
@str$3c3 = private global [12 x i8] c"glUniform3f\00"
@str$3c4 = private global [12 x i8] c"glUniform4f\00"
@str$3c5 = private global [12 x i8] c"glUniform1i\00"
@str$3c6 = private global [12 x i8] c"glUniform2i\00"
@str$3c7 = private global [12 x i8] c"glUniform3i\00"
@str$3c8 = private global [12 x i8] c"glUniform4i\00"
@str$3c9 = private global [13 x i8] c"glUniform1fv\00"
@str$3ca = private global [13 x i8] c"glUniform2fv\00"
@str$3cb = private global [13 x i8] c"glUniform3fv\00"
@str$3cc = private global [13 x i8] c"glUniform4fv\00"
@str$3cd = private global [13 x i8] c"glUniform1iv\00"
@str$3ce = private global [13 x i8] c"glUniform2iv\00"
@str$3cf = private global [13 x i8] c"glUniform3iv\00"
@str$3d0 = private global [13 x i8] c"glUniform4iv\00"
@str$3d1 = private global [19 x i8] c"glUniformMatrix2fv\00"
@str$3d2 = private global [19 x i8] c"glUniformMatrix3fv\00"
@str$3d3 = private global [19 x i8] c"glUniformMatrix4fv\00"
@str$3d4 = private global [18 x i8] c"glValidateProgram\00"
@str$3d5 = private global [17 x i8] c"glVertexAttrib1d\00"
@str$3d6 = private global [18 x i8] c"glVertexAttrib1dv\00"
@str$3d7 = private global [17 x i8] c"glVertexAttrib1f\00"
@str$3d8 = private global [18 x i8] c"glVertexAttrib1fv\00"
@str$3d9 = private global [17 x i8] c"glVertexAttrib1s\00"
@str$3da = private global [18 x i8] c"glVertexAttrib1sv\00"
@str$3db = private global [17 x i8] c"glVertexAttrib2d\00"
@str$3dc = private global [18 x i8] c"glVertexAttrib2dv\00"
@str$3dd = private global [17 x i8] c"glVertexAttrib2f\00"
@str$3de = private global [18 x i8] c"glVertexAttrib2fv\00"
@str$3df = private global [17 x i8] c"glVertexAttrib2s\00"
@str$3e0 = private global [18 x i8] c"glVertexAttrib2sv\00"
@str$3e1 = private global [17 x i8] c"glVertexAttrib3d\00"
@str$3e2 = private global [18 x i8] c"glVertexAttrib3dv\00"
@str$3e3 = private global [17 x i8] c"glVertexAttrib3f\00"
@str$3e4 = private global [18 x i8] c"glVertexAttrib3fv\00"
@str$3e5 = private global [17 x i8] c"glVertexAttrib3s\00"
@str$3e6 = private global [18 x i8] c"glVertexAttrib3sv\00"
@str$3e7 = private global [19 x i8] c"glVertexAttrib4Nbv\00"
@str$3e8 = private global [19 x i8] c"glVertexAttrib4Niv\00"
@str$3e9 = private global [19 x i8] c"glVertexAttrib4Nsv\00"
@str$3ea = private global [19 x i8] c"glVertexAttrib4Nub\00"
@str$3eb = private global [20 x i8] c"glVertexAttrib4Nubv\00"
@str$3ec = private global [20 x i8] c"glVertexAttrib4Nuiv\00"
@str$3ed = private global [20 x i8] c"glVertexAttrib4Nusv\00"
@str$3ee = private global [18 x i8] c"glVertexAttrib4bv\00"
@str$3ef = private global [17 x i8] c"glVertexAttrib4d\00"
@str$3f0 = private global [18 x i8] c"glVertexAttrib4dv\00"
@str$3f1 = private global [17 x i8] c"glVertexAttrib4f\00"
@str$3f2 = private global [18 x i8] c"glVertexAttrib4fv\00"
@str$3f3 = private global [18 x i8] c"glVertexAttrib4iv\00"
@str$3f4 = private global [17 x i8] c"glVertexAttrib4s\00"
@str$3f5 = private global [18 x i8] c"glVertexAttrib4sv\00"
@str$3f6 = private global [19 x i8] c"glVertexAttrib4ubv\00"
@str$3f7 = private global [19 x i8] c"glVertexAttrib4uiv\00"
@str$3f8 = private global [19 x i8] c"glVertexAttrib4usv\00"
@str$3f9 = private global [22 x i8] c"glVertexAttribPointer\00"
@str$3fa = private global [21 x i8] c"glUniformMatrix2x3fv\00"
@str$3fb = private global [21 x i8] c"glUniformMatrix3x2fv\00"
@str$3fc = private global [21 x i8] c"glUniformMatrix2x4fv\00"
@str$3fd = private global [21 x i8] c"glUniformMatrix4x2fv\00"
@str$3fe = private global [21 x i8] c"glUniformMatrix3x4fv\00"
@str$3ff = private global [21 x i8] c"glUniformMatrix4x3fv\00"
@str$400 = private global [13 x i8] c"glColorMaski\00"
@str$401 = private global [16 x i8] c"glGetBooleani_v\00"
@str$402 = private global [16 x i8] c"glGetIntegeri_v\00"
@str$403 = private global [10 x i8] c"glEnablei\00"
@str$404 = private global [11 x i8] c"glDisablei\00"
@str$405 = private global [13 x i8] c"glIsEnabledi\00"
@str$406 = private global [25 x i8] c"glBeginTransformFeedback\00"
@str$407 = private global [23 x i8] c"glEndTransformFeedback\00"
@str$408 = private global [18 x i8] c"glBindBufferRange\00"
@str$409 = private global [17 x i8] c"glBindBufferBase\00"
@str$40a = private global [28 x i8] c"glTransformFeedbackVaryings\00"
@str$40b = private global [30 x i8] c"glGetTransformFeedbackVarying\00"
@str$40c = private global [13 x i8] c"glClampColor\00"
@str$40d = private global [25 x i8] c"glBeginConditionalRender\00"
@str$40e = private global [23 x i8] c"glEndConditionalRender\00"
@str$40f = private global [23 x i8] c"glVertexAttribIPointer\00"
@str$410 = private global [21 x i8] c"glGetVertexAttribIiv\00"
@str$411 = private global [22 x i8] c"glGetVertexAttribIuiv\00"
@str$412 = private global [18 x i8] c"glVertexAttribI1i\00"
@str$413 = private global [18 x i8] c"glVertexAttribI2i\00"
@str$414 = private global [18 x i8] c"glVertexAttribI3i\00"
@str$415 = private global [18 x i8] c"glVertexAttribI4i\00"
@str$416 = private global [19 x i8] c"glVertexAttribI1ui\00"
@str$417 = private global [19 x i8] c"glVertexAttribI2ui\00"
@str$418 = private global [19 x i8] c"glVertexAttribI3ui\00"
@str$419 = private global [19 x i8] c"glVertexAttribI4ui\00"
@str$41a = private global [19 x i8] c"glVertexAttribI1iv\00"
@str$41b = private global [19 x i8] c"glVertexAttribI2iv\00"
@str$41c = private global [19 x i8] c"glVertexAttribI3iv\00"
@str$41d = private global [19 x i8] c"glVertexAttribI4iv\00"
@str$41e = private global [20 x i8] c"glVertexAttribI1uiv\00"
@str$41f = private global [20 x i8] c"glVertexAttribI2uiv\00"
@str$420 = private global [20 x i8] c"glVertexAttribI3uiv\00"
@str$421 = private global [20 x i8] c"glVertexAttribI4uiv\00"
@str$422 = private global [19 x i8] c"glVertexAttribI4bv\00"
@str$423 = private global [19 x i8] c"glVertexAttribI4sv\00"
@str$424 = private global [20 x i8] c"glVertexAttribI4ubv\00"
@str$425 = private global [20 x i8] c"glVertexAttribI4usv\00"
@str$426 = private global [16 x i8] c"glGetUniformuiv\00"
@str$427 = private global [23 x i8] c"glBindFragDataLocation\00"
@str$428 = private global [22 x i8] c"glGetFragDataLocation\00"
@str$429 = private global [13 x i8] c"glUniform1ui\00"
@str$42a = private global [13 x i8] c"glUniform2ui\00"
@str$42b = private global [13 x i8] c"glUniform3ui\00"
@str$42c = private global [13 x i8] c"glUniform4ui\00"
@str$42d = private global [14 x i8] c"glUniform1uiv\00"
@str$42e = private global [14 x i8] c"glUniform2uiv\00"
@str$42f = private global [14 x i8] c"glUniform3uiv\00"
@str$430 = private global [14 x i8] c"glUniform4uiv\00"
@str$431 = private global [18 x i8] c"glTexParameterIiv\00"
@str$432 = private global [19 x i8] c"glTexParameterIuiv\00"
@str$433 = private global [21 x i8] c"glGetTexParameterIiv\00"
@str$434 = private global [22 x i8] c"glGetTexParameterIuiv\00"
@str$435 = private global [16 x i8] c"glClearBufferiv\00"
@str$436 = private global [17 x i8] c"glClearBufferuiv\00"
@str$437 = private global [16 x i8] c"glClearBufferfv\00"
@str$438 = private global [16 x i8] c"glClearBufferfi\00"
@str$439 = private global [13 x i8] c"glGetStringi\00"
@str$43a = private global [17 x i8] c"glIsRenderbuffer\00"
@str$43b = private global [19 x i8] c"glBindRenderbuffer\00"
@str$43c = private global [22 x i8] c"glDeleteRenderbuffers\00"
@str$43d = private global [19 x i8] c"glGenRenderbuffers\00"
@str$43e = private global [22 x i8] c"glRenderbufferStorage\00"
@str$43f = private global [29 x i8] c"glGetRenderbufferParameteriv\00"
@str$440 = private global [16 x i8] c"glIsFramebuffer\00"
@str$441 = private global [18 x i8] c"glBindFramebuffer\00"
@str$442 = private global [21 x i8] c"glDeleteFramebuffers\00"
@str$443 = private global [18 x i8] c"glGenFramebuffers\00"
@str$444 = private global [25 x i8] c"glCheckFramebufferStatus\00"
@str$445 = private global [23 x i8] c"glFramebufferTexture1D\00"
@str$446 = private global [23 x i8] c"glFramebufferTexture2D\00"
@str$447 = private global [23 x i8] c"glFramebufferTexture3D\00"
@str$448 = private global [26 x i8] c"glFramebufferRenderbuffer\00"
@str$449 = private global [38 x i8] c"glGetFramebufferAttachmentParameteriv\00"
@str$44a = private global [17 x i8] c"glGenerateMipmap\00"
@str$44b = private global [18 x i8] c"glBlitFramebuffer\00"
@str$44c = private global [33 x i8] c"glRenderbufferStorageMultisample\00"
@str$44d = private global [26 x i8] c"glFramebufferTextureLayer\00"
@str$44e = private global [17 x i8] c"glMapBufferRange\00"
@str$44f = private global [25 x i8] c"glFlushMappedBufferRange\00"
@str$450 = private global [18 x i8] c"glBindVertexArray\00"
@str$451 = private global [21 x i8] c"glDeleteVertexArrays\00"
@str$452 = private global [18 x i8] c"glGenVertexArrays\00"
@str$453 = private global [16 x i8] c"glIsVertexArray\00"
@str$454 = private global [22 x i8] c"glDrawArraysInstanced\00"
@str$455 = private global [24 x i8] c"glDrawElementsInstanced\00"
@str$456 = private global [12 x i8] c"glTexBuffer\00"
@str$457 = private global [24 x i8] c"glPrimitiveRestartIndex\00"
@str$458 = private global [20 x i8] c"glCopyBufferSubData\00"
@str$459 = private global [20 x i8] c"glGetUniformIndices\00"
@str$45a = private global [22 x i8] c"glGetActiveUniformsiv\00"
@str$45b = private global [23 x i8] c"glGetActiveUniformName\00"
@str$45c = private global [23 x i8] c"glGetUniformBlockIndex\00"
@str$45d = private global [26 x i8] c"glGetActiveUniformBlockiv\00"
@str$45e = private global [28 x i8] c"glGetActiveUniformBlockName\00"
@str$45f = private global [22 x i8] c"glUniformBlockBinding\00"
@str$460 = private global [25 x i8] c"glDrawElementsBaseVertex\00"
@str$461 = private global [30 x i8] c"glDrawRangeElementsBaseVertex\00"
@str$462 = private global [34 x i8] c"glDrawElementsInstancedBaseVertex\00"
@str$463 = private global [30 x i8] c"glMultiDrawElementsBaseVertex\00"
@str$464 = private global [18 x i8] c"glProvokingVertex\00"
@str$465 = private global [12 x i8] c"glFenceSync\00"
@str$466 = private global [9 x i8] c"glIsSync\00"
@str$467 = private global [13 x i8] c"glDeleteSync\00"
@str$468 = private global [17 x i8] c"glClientWaitSync\00"
@str$469 = private global [11 x i8] c"glWaitSync\00"
@str$46a = private global [16 x i8] c"glGetInteger64v\00"
@str$46b = private global [12 x i8] c"glGetSynciv\00"
@str$46c = private global [18 x i8] c"glGetInteger64i_v\00"
@str$46d = private global [25 x i8] c"glGetBufferParameteri64v\00"
@str$46e = private global [21 x i8] c"glFramebufferTexture\00"
@str$46f = private global [24 x i8] c"glTexImage2DMultisample\00"
@str$470 = private global [24 x i8] c"glTexImage3DMultisample\00"
@str$471 = private global [19 x i8] c"glGetMultisamplefv\00"
@str$472 = private global [14 x i8] c"glSampleMaski\00"
@str$473 = private global [30 x i8] c"glBindFragDataLocationIndexed\00"
@str$474 = private global [19 x i8] c"glGetFragDataIndex\00"
@str$475 = private global [14 x i8] c"glGenSamplers\00"
@str$476 = private global [17 x i8] c"glDeleteSamplers\00"
@str$477 = private global [12 x i8] c"glIsSampler\00"
@str$478 = private global [14 x i8] c"glBindSampler\00"
@str$479 = private global [20 x i8] c"glSamplerParameteri\00"
@str$47a = private global [21 x i8] c"glSamplerParameteriv\00"
@str$47b = private global [20 x i8] c"glSamplerParameterf\00"
@str$47c = private global [21 x i8] c"glSamplerParameterfv\00"
@str$47d = private global [22 x i8] c"glSamplerParameterIiv\00"
@str$47e = private global [23 x i8] c"glSamplerParameterIuiv\00"
@str$47f = private global [24 x i8] c"glGetSamplerParameteriv\00"
@str$480 = private global [25 x i8] c"glGetSamplerParameterIiv\00"
@str$481 = private global [24 x i8] c"glGetSamplerParameterfv\00"
@str$482 = private global [26 x i8] c"glGetSamplerParameterIuiv\00"
@str$483 = private global [15 x i8] c"glQueryCounter\00"
@str$484 = private global [21 x i8] c"glGetQueryObjecti64v\00"
@str$485 = private global [22 x i8] c"glGetQueryObjectui64v\00"
@str$486 = private global [22 x i8] c"glVertexAttribDivisor\00"
@str$487 = private global [19 x i8] c"glVertexAttribP1ui\00"
@str$488 = private global [20 x i8] c"glVertexAttribP1uiv\00"
@str$489 = private global [19 x i8] c"glVertexAttribP2ui\00"
@str$48a = private global [20 x i8] c"glVertexAttribP2uiv\00"
@str$48b = private global [19 x i8] c"glVertexAttribP3ui\00"
@str$48c = private global [20 x i8] c"glVertexAttribP3uiv\00"
@str$48d = private global [19 x i8] c"glVertexAttribP4ui\00"
@str$48e = private global [20 x i8] c"glVertexAttribP4uiv\00"
@str$48f = private global [13 x i8] c"glVertexP2ui\00"
@str$490 = private global [14 x i8] c"glVertexP2uiv\00"
@str$491 = private global [13 x i8] c"glVertexP3ui\00"
@str$492 = private global [14 x i8] c"glVertexP3uiv\00"
@str$493 = private global [13 x i8] c"glVertexP4ui\00"
@str$494 = private global [14 x i8] c"glVertexP4uiv\00"
@str$495 = private global [15 x i8] c"glTexCoordP1ui\00"
@str$496 = private global [16 x i8] c"glTexCoordP1uiv\00"
@str$497 = private global [15 x i8] c"glTexCoordP2ui\00"
@str$498 = private global [16 x i8] c"glTexCoordP2uiv\00"
@str$499 = private global [15 x i8] c"glTexCoordP3ui\00"
@str$49a = private global [16 x i8] c"glTexCoordP3uiv\00"
@str$49b = private global [15 x i8] c"glTexCoordP4ui\00"
@str$49c = private global [16 x i8] c"glTexCoordP4uiv\00"
@str$49d = private global [20 x i8] c"glMultiTexCoordP1ui\00"
@str$49e = private global [21 x i8] c"glMultiTexCoordP1uiv\00"
@str$49f = private global [20 x i8] c"glMultiTexCoordP2ui\00"
@str$4a0 = private global [21 x i8] c"glMultiTexCoordP2uiv\00"
@str$4a1 = private global [20 x i8] c"glMultiTexCoordP3ui\00"
@str$4a2 = private global [21 x i8] c"glMultiTexCoordP3uiv\00"
@str$4a3 = private global [20 x i8] c"glMultiTexCoordP4ui\00"
@str$4a4 = private global [21 x i8] c"glMultiTexCoordP4uiv\00"
@str$4a5 = private global [13 x i8] c"glNormalP3ui\00"
@str$4a6 = private global [14 x i8] c"glNormalP3uiv\00"
@str$4a7 = private global [12 x i8] c"glColorP3ui\00"
@str$4a8 = private global [13 x i8] c"glColorP3uiv\00"
@str$4a9 = private global [12 x i8] c"glColorP4ui\00"
@str$4aa = private global [13 x i8] c"glColorP4uiv\00"
@str$4ab = private global [21 x i8] c"glSecondaryColorP3ui\00"
@str$4ac = private global [22 x i8] c"glSecondaryColorP3uiv\00"
@str$4ad = private global [19 x i8] c"glMinSampleShading\00"
@str$4ae = private global [17 x i8] c"glBlendEquationi\00"
@str$4af = private global [25 x i8] c"glBlendEquationSeparatei\00"
@str$4b0 = private global [13 x i8] c"glBlendFunci\00"
@str$4b1 = private global [21 x i8] c"glBlendFuncSeparatei\00"
@str$4b2 = private global [21 x i8] c"glDrawArraysIndirect\00"
@str$4b3 = private global [23 x i8] c"glDrawElementsIndirect\00"
@str$4b4 = private global [12 x i8] c"glUniform1d\00"
@str$4b5 = private global [12 x i8] c"glUniform2d\00"
@str$4b6 = private global [12 x i8] c"glUniform3d\00"
@str$4b7 = private global [12 x i8] c"glUniform4d\00"
@str$4b8 = private global [13 x i8] c"glUniform1dv\00"
@str$4b9 = private global [13 x i8] c"glUniform2dv\00"
@str$4ba = private global [13 x i8] c"glUniform3dv\00"
@str$4bb = private global [13 x i8] c"glUniform4dv\00"
@str$4bc = private global [19 x i8] c"glUniformMatrix2dv\00"
@str$4bd = private global [19 x i8] c"glUniformMatrix3dv\00"
@str$4be = private global [19 x i8] c"glUniformMatrix4dv\00"
@str$4bf = private global [21 x i8] c"glUniformMatrix2x3dv\00"
@str$4c0 = private global [21 x i8] c"glUniformMatrix2x4dv\00"
@str$4c1 = private global [21 x i8] c"glUniformMatrix3x2dv\00"
@str$4c2 = private global [21 x i8] c"glUniformMatrix3x4dv\00"
@str$4c3 = private global [21 x i8] c"glUniformMatrix4x2dv\00"
@str$4c4 = private global [21 x i8] c"glUniformMatrix4x3dv\00"
@str$4c5 = private global [15 x i8] c"glGetUniformdv\00"
@str$4c6 = private global [31 x i8] c"glGetSubroutineUniformLocation\00"
@str$4c7 = private global [21 x i8] c"glGetSubroutineIndex\00"
@str$4c8 = private global [31 x i8] c"glGetActiveSubroutineUniformiv\00"
@str$4c9 = private global [33 x i8] c"glGetActiveSubroutineUniformName\00"
@str$4ca = private global [26 x i8] c"glGetActiveSubroutineName\00"
@str$4cb = private global [24 x i8] c"glUniformSubroutinesuiv\00"
@str$4cc = private global [26 x i8] c"glGetUniformSubroutineuiv\00"
@str$4cd = private global [20 x i8] c"glGetProgramStageiv\00"
@str$4ce = private global [18 x i8] c"glPatchParameteri\00"
@str$4cf = private global [19 x i8] c"glPatchParameterfv\00"
@str$4d0 = private global [24 x i8] c"glBindTransformFeedback\00"
@str$4d1 = private global [27 x i8] c"glDeleteTransformFeedbacks\00"
@str$4d2 = private global [24 x i8] c"glGenTransformFeedbacks\00"
@str$4d3 = private global [22 x i8] c"glIsTransformFeedback\00"
@str$4d4 = private global [25 x i8] c"glPauseTransformFeedback\00"
@str$4d5 = private global [26 x i8] c"glResumeTransformFeedback\00"
@str$4d6 = private global [24 x i8] c"glDrawTransformFeedback\00"
@str$4d7 = private global [30 x i8] c"glDrawTransformFeedbackStream\00"
@str$4d8 = private global [20 x i8] c"glBeginQueryIndexed\00"
@str$4d9 = private global [18 x i8] c"glEndQueryIndexed\00"
@str$4da = private global [20 x i8] c"glGetQueryIndexediv\00"
@str$4db = private global [24 x i8] c"glReleaseShaderCompiler\00"
@str$4dc = private global [15 x i8] c"glShaderBinary\00"
@str$4dd = private global [27 x i8] c"glGetShaderPrecisionFormat\00"
@str$4de = private global [14 x i8] c"glDepthRangef\00"
@str$4df = private global [14 x i8] c"glClearDepthf\00"
@str$4e0 = private global [19 x i8] c"glGetProgramBinary\00"
@str$4e1 = private global [16 x i8] c"glProgramBinary\00"
@str$4e2 = private global [20 x i8] c"glProgramParameteri\00"
@str$4e3 = private global [19 x i8] c"glUseProgramStages\00"
@str$4e4 = private global [22 x i8] c"glActiveShaderProgram\00"
@str$4e5 = private global [23 x i8] c"glCreateShaderProgramv\00"
@str$4e6 = private global [22 x i8] c"glBindProgramPipeline\00"
@str$4e7 = private global [25 x i8] c"glDeleteProgramPipelines\00"
@str$4e8 = private global [22 x i8] c"glGenProgramPipelines\00"
@str$4e9 = private global [20 x i8] c"glIsProgramPipeline\00"
@str$4ea = private global [23 x i8] c"glGetProgramPipelineiv\00"
@str$4eb = private global [19 x i8] c"glProgramUniform1i\00"
@str$4ec = private global [20 x i8] c"glProgramUniform1iv\00"
@str$4ed = private global [19 x i8] c"glProgramUniform1f\00"
@str$4ee = private global [20 x i8] c"glProgramUniform1fv\00"
@str$4ef = private global [19 x i8] c"glProgramUniform1d\00"
@str$4f0 = private global [20 x i8] c"glProgramUniform1dv\00"
@str$4f1 = private global [20 x i8] c"glProgramUniform1ui\00"
@str$4f2 = private global [21 x i8] c"glProgramUniform1uiv\00"
@str$4f3 = private global [19 x i8] c"glProgramUniform2i\00"
@str$4f4 = private global [20 x i8] c"glProgramUniform2iv\00"
@str$4f5 = private global [19 x i8] c"glProgramUniform2f\00"
@str$4f6 = private global [20 x i8] c"glProgramUniform2fv\00"
@str$4f7 = private global [19 x i8] c"glProgramUniform2d\00"
@str$4f8 = private global [20 x i8] c"glProgramUniform2dv\00"
@str$4f9 = private global [20 x i8] c"glProgramUniform2ui\00"
@str$4fa = private global [21 x i8] c"glProgramUniform2uiv\00"
@str$4fb = private global [19 x i8] c"glProgramUniform3i\00"
@str$4fc = private global [20 x i8] c"glProgramUniform3iv\00"
@str$4fd = private global [19 x i8] c"glProgramUniform3f\00"
@str$4fe = private global [20 x i8] c"glProgramUniform3fv\00"
@str$4ff = private global [19 x i8] c"glProgramUniform3d\00"
@str$500 = private global [20 x i8] c"glProgramUniform3dv\00"
@str$501 = private global [20 x i8] c"glProgramUniform3ui\00"
@str$502 = private global [21 x i8] c"glProgramUniform3uiv\00"
@str$503 = private global [19 x i8] c"glProgramUniform4i\00"
@str$504 = private global [20 x i8] c"glProgramUniform4iv\00"
@str$505 = private global [19 x i8] c"glProgramUniform4f\00"
@str$506 = private global [20 x i8] c"glProgramUniform4fv\00"
@str$507 = private global [19 x i8] c"glProgramUniform4d\00"
@str$508 = private global [20 x i8] c"glProgramUniform4dv\00"
@str$509 = private global [20 x i8] c"glProgramUniform4ui\00"
@str$50a = private global [21 x i8] c"glProgramUniform4uiv\00"
@str$50b = private global [26 x i8] c"glProgramUniformMatrix2fv\00"
@str$50c = private global [26 x i8] c"glProgramUniformMatrix3fv\00"
@str$50d = private global [26 x i8] c"glProgramUniformMatrix4fv\00"
@str$50e = private global [26 x i8] c"glProgramUniformMatrix2dv\00"
@str$50f = private global [26 x i8] c"glProgramUniformMatrix3dv\00"
@str$510 = private global [26 x i8] c"glProgramUniformMatrix4dv\00"
@str$511 = private global [28 x i8] c"glProgramUniformMatrix2x3fv\00"
@str$512 = private global [28 x i8] c"glProgramUniformMatrix3x2fv\00"
@str$513 = private global [28 x i8] c"glProgramUniformMatrix2x4fv\00"
@str$514 = private global [28 x i8] c"glProgramUniformMatrix4x2fv\00"
@str$515 = private global [28 x i8] c"glProgramUniformMatrix3x4fv\00"
@str$516 = private global [28 x i8] c"glProgramUniformMatrix4x3fv\00"
@str$517 = private global [28 x i8] c"glProgramUniformMatrix2x3dv\00"
@str$518 = private global [28 x i8] c"glProgramUniformMatrix3x2dv\00"
@str$519 = private global [28 x i8] c"glProgramUniformMatrix2x4dv\00"
@str$51a = private global [28 x i8] c"glProgramUniformMatrix4x2dv\00"
@str$51b = private global [28 x i8] c"glProgramUniformMatrix3x4dv\00"
@str$51c = private global [28 x i8] c"glProgramUniformMatrix4x3dv\00"
@str$51d = private global [26 x i8] c"glValidateProgramPipeline\00"
@str$51e = private global [28 x i8] c"glGetProgramPipelineInfoLog\00"
@str$51f = private global [18 x i8] c"glVertexAttribL1d\00"
@str$520 = private global [18 x i8] c"glVertexAttribL2d\00"
@str$521 = private global [18 x i8] c"glVertexAttribL3d\00"
@str$522 = private global [18 x i8] c"glVertexAttribL4d\00"
@str$523 = private global [19 x i8] c"glVertexAttribL1dv\00"
@str$524 = private global [19 x i8] c"glVertexAttribL2dv\00"
@str$525 = private global [19 x i8] c"glVertexAttribL3dv\00"
@str$526 = private global [19 x i8] c"glVertexAttribL4dv\00"
@str$527 = private global [23 x i8] c"glVertexAttribLPointer\00"
@str$528 = private global [21 x i8] c"glGetVertexAttribLdv\00"
@str$529 = private global [17 x i8] c"glViewportArrayv\00"
@str$52a = private global [19 x i8] c"glViewportIndexedf\00"
@str$52b = private global [20 x i8] c"glViewportIndexedfv\00"
@str$52c = private global [16 x i8] c"glScissorArrayv\00"
@str$52d = private global [17 x i8] c"glScissorIndexed\00"
@str$52e = private global [18 x i8] c"glScissorIndexedv\00"
@str$52f = private global [19 x i8] c"glDepthRangeArrayv\00"
@str$530 = private global [20 x i8] c"glDepthRangeIndexed\00"
@str$531 = private global [14 x i8] c"glGetFloati_v\00"
@str$532 = private global [15 x i8] c"glGetDoublei_v\00"
@str$533 = private global [34 x i8] c"glDrawArraysInstancedBaseInstance\00"
@str$534 = private global [36 x i8] c"glDrawElementsInstancedBaseInstance\00"
@str$535 = private global [46 x i8] c"glDrawElementsInstancedBaseVertexBaseInstance\00"
@str$536 = private global [22 x i8] c"glGetInternalformativ\00"
@str$537 = private global [33 x i8] c"glGetActiveAtomicCounterBufferiv\00"
@str$538 = private global [19 x i8] c"glBindImageTexture\00"
@str$539 = private global [16 x i8] c"glMemoryBarrier\00"
@str$53a = private global [15 x i8] c"glTexStorage1D\00"
@str$53b = private global [15 x i8] c"glTexStorage2D\00"
@str$53c = private global [15 x i8] c"glTexStorage3D\00"
@str$53d = private global [33 x i8] c"glDrawTransformFeedbackInstanced\00"
@str$53e = private global [39 x i8] c"glDrawTransformFeedbackStreamInstanced\00"
@str$53f = private global [18 x i8] c"glClearBufferData\00"
@str$540 = private global [21 x i8] c"glClearBufferSubData\00"
@str$541 = private global [18 x i8] c"glDispatchCompute\00"
@str$542 = private global [26 x i8] c"glDispatchComputeIndirect\00"
@str$543 = private global [19 x i8] c"glCopyImageSubData\00"
@str$544 = private global [24 x i8] c"glFramebufferParameteri\00"
@str$545 = private global [28 x i8] c"glGetFramebufferParameteriv\00"
@str$546 = private global [24 x i8] c"glGetInternalformati64v\00"
@str$547 = private global [24 x i8] c"glInvalidateTexSubImage\00"
@str$548 = private global [21 x i8] c"glInvalidateTexImage\00"
@str$549 = private global [26 x i8] c"glInvalidateBufferSubData\00"
@str$54a = private global [23 x i8] c"glInvalidateBufferData\00"
@str$54b = private global [24 x i8] c"glInvalidateFramebuffer\00"
@str$54c = private global [27 x i8] c"glInvalidateSubFramebuffer\00"
@str$54d = private global [26 x i8] c"glMultiDrawArraysIndirect\00"
@str$54e = private global [28 x i8] c"glMultiDrawElementsIndirect\00"
@str$54f = private global [24 x i8] c"glGetProgramInterfaceiv\00"
@str$550 = private global [26 x i8] c"glGetProgramResourceIndex\00"
@str$551 = private global [25 x i8] c"glGetProgramResourceName\00"
@str$552 = private global [23 x i8] c"glGetProgramResourceiv\00"
@str$553 = private global [29 x i8] c"glGetProgramResourceLocation\00"
@str$554 = private global [34 x i8] c"glGetProgramResourceLocationIndex\00"
@str$555 = private global [28 x i8] c"glShaderStorageBlockBinding\00"
@str$556 = private global [17 x i8] c"glTexBufferRange\00"
@str$557 = private global [26 x i8] c"glTexStorage2DMultisample\00"
@str$558 = private global [26 x i8] c"glTexStorage3DMultisample\00"
@str$559 = private global [14 x i8] c"glTextureView\00"
@str$55a = private global [19 x i8] c"glBindVertexBuffer\00"
@str$55b = private global [21 x i8] c"glVertexAttribFormat\00"
@str$55c = private global [22 x i8] c"glVertexAttribIFormat\00"
@str$55d = private global [22 x i8] c"glVertexAttribLFormat\00"
@str$55e = private global [22 x i8] c"glVertexAttribBinding\00"
@str$55f = private global [23 x i8] c"glVertexBindingDivisor\00"
@str$560 = private global [22 x i8] c"glDebugMessageControl\00"
@str$561 = private global [21 x i8] c"glDebugMessageInsert\00"
@str$562 = private global [23 x i8] c"glDebugMessageCallback\00"
@str$563 = private global [21 x i8] c"glGetDebugMessageLog\00"
@str$564 = private global [17 x i8] c"glPushDebugGroup\00"
@str$565 = private global [16 x i8] c"glPopDebugGroup\00"
@str$566 = private global [14 x i8] c"glObjectLabel\00"
@str$567 = private global [17 x i8] c"glGetObjectLabel\00"
@str$568 = private global [17 x i8] c"glObjectPtrLabel\00"
@str$569 = private global [20 x i8] c"glGetObjectPtrLabel\00"
@str$56a = private global [16 x i8] c"glBufferStorage\00"
@str$56b = private global [16 x i8] c"glClearTexImage\00"
@str$56c = private global [19 x i8] c"glClearTexSubImage\00"
@str$56d = private global [18 x i8] c"glBindBuffersBase\00"
@str$56e = private global [19 x i8] c"glBindBuffersRange\00"
@str$56f = private global [15 x i8] c"glBindTextures\00"
@str$570 = private global [15 x i8] c"glBindSamplers\00"
@str$571 = private global [20 x i8] c"glBindImageTextures\00"
@str$572 = private global [20 x i8] c"glBindVertexBuffers\00"
@str$573 = private global [14 x i8] c"glClipControl\00"
@str$574 = private global [27 x i8] c"glCreateTransformFeedbacks\00"
@str$575 = private global [30 x i8] c"glTransformFeedbackBufferBase\00"
@str$576 = private global [31 x i8] c"glTransformFeedbackBufferRange\00"
@str$577 = private global [25 x i8] c"glGetTransformFeedbackiv\00"
@str$578 = private global [26 x i8] c"glGetTransformFeedbacki_v\00"
@str$579 = private global [28 x i8] c"glGetTransformFeedbacki64_v\00"
@str$57a = private global [16 x i8] c"glCreateBuffers\00"
@str$57b = private global [21 x i8] c"glNamedBufferStorage\00"
@str$57c = private global [18 x i8] c"glNamedBufferData\00"
@str$57d = private global [21 x i8] c"glNamedBufferSubData\00"
@str$57e = private global [25 x i8] c"glCopyNamedBufferSubData\00"
@str$57f = private global [23 x i8] c"glClearNamedBufferData\00"
@str$580 = private global [26 x i8] c"glClearNamedBufferSubData\00"
@str$581 = private global [17 x i8] c"glMapNamedBuffer\00"
@str$582 = private global [22 x i8] c"glMapNamedBufferRange\00"
@str$583 = private global [19 x i8] c"glUnmapNamedBuffer\00"
@str$584 = private global [30 x i8] c"glFlushMappedNamedBufferRange\00"
@str$585 = private global [28 x i8] c"glGetNamedBufferParameteriv\00"
@str$586 = private global [30 x i8] c"glGetNamedBufferParameteri64v\00"
@str$587 = private global [25 x i8] c"glGetNamedBufferPointerv\00"
@str$588 = private global [24 x i8] c"glGetNamedBufferSubData\00"
@str$589 = private global [21 x i8] c"glCreateFramebuffers\00"
@str$58a = private global [31 x i8] c"glNamedFramebufferRenderbuffer\00"
@str$58b = private global [29 x i8] c"glNamedFramebufferParameteri\00"
@str$58c = private global [26 x i8] c"glNamedFramebufferTexture\00"
@str$58d = private global [31 x i8] c"glNamedFramebufferTextureLayer\00"
@str$58e = private global [29 x i8] c"glNamedFramebufferDrawBuffer\00"
@str$58f = private global [30 x i8] c"glNamedFramebufferDrawBuffers\00"
@str$590 = private global [29 x i8] c"glNamedFramebufferReadBuffer\00"
@str$591 = private global [33 x i8] c"glInvalidateNamedFramebufferData\00"
@str$592 = private global [36 x i8] c"glInvalidateNamedFramebufferSubData\00"
@str$593 = private global [26 x i8] c"glClearNamedFramebufferiv\00"
@str$594 = private global [27 x i8] c"glClearNamedFramebufferuiv\00"
@str$595 = private global [26 x i8] c"glClearNamedFramebufferfv\00"
@str$596 = private global [26 x i8] c"glClearNamedFramebufferfi\00"
@str$597 = private global [23 x i8] c"glBlitNamedFramebuffer\00"
@str$598 = private global [30 x i8] c"glCheckNamedFramebufferStatus\00"
@str$599 = private global [33 x i8] c"glGetNamedFramebufferParameteriv\00"
@str$59a = private global [43 x i8] c"glGetNamedFramebufferAttachmentParameteriv\00"
@str$59b = private global [22 x i8] c"glCreateRenderbuffers\00"
@str$59c = private global [27 x i8] c"glNamedRenderbufferStorage\00"
@str$59d = private global [38 x i8] c"glNamedRenderbufferStorageMultisample\00"
@str$59e = private global [34 x i8] c"glGetNamedRenderbufferParameteriv\00"
@str$59f = private global [17 x i8] c"glCreateTextures\00"
@str$5a0 = private global [16 x i8] c"glTextureBuffer\00"
@str$5a1 = private global [21 x i8] c"glTextureBufferRange\00"
@str$5a2 = private global [19 x i8] c"glTextureStorage1D\00"
@str$5a3 = private global [19 x i8] c"glTextureStorage2D\00"
@str$5a4 = private global [19 x i8] c"glTextureStorage3D\00"
@str$5a5 = private global [30 x i8] c"glTextureStorage2DMultisample\00"
@str$5a6 = private global [30 x i8] c"glTextureStorage3DMultisample\00"
@str$5a7 = private global [20 x i8] c"glTextureSubImage1D\00"
@str$5a8 = private global [20 x i8] c"glTextureSubImage2D\00"
@str$5a9 = private global [20 x i8] c"glTextureSubImage3D\00"
@str$5aa = private global [30 x i8] c"glCompressedTextureSubImage1D\00"
@str$5ab = private global [30 x i8] c"glCompressedTextureSubImage2D\00"
@str$5ac = private global [30 x i8] c"glCompressedTextureSubImage3D\00"
@str$5ad = private global [24 x i8] c"glCopyTextureSubImage1D\00"
@str$5ae = private global [24 x i8] c"glCopyTextureSubImage2D\00"
@str$5af = private global [24 x i8] c"glCopyTextureSubImage3D\00"
@str$5b0 = private global [20 x i8] c"glTextureParameterf\00"
@str$5b1 = private global [21 x i8] c"glTextureParameterfv\00"
@str$5b2 = private global [20 x i8] c"glTextureParameteri\00"
@str$5b3 = private global [22 x i8] c"glTextureParameterIiv\00"
@str$5b4 = private global [23 x i8] c"glTextureParameterIuiv\00"
@str$5b5 = private global [21 x i8] c"glTextureParameteriv\00"
@str$5b6 = private global [24 x i8] c"glGenerateTextureMipmap\00"
@str$5b7 = private global [18 x i8] c"glBindTextureUnit\00"
@str$5b8 = private global [18 x i8] c"glGetTextureImage\00"
@str$5b9 = private global [28 x i8] c"glGetCompressedTextureImage\00"
@str$5ba = private global [29 x i8] c"glGetTextureLevelParameterfv\00"
@str$5bb = private global [29 x i8] c"glGetTextureLevelParameteriv\00"
@str$5bc = private global [24 x i8] c"glGetTextureParameterfv\00"
@str$5bd = private global [25 x i8] c"glGetTextureParameterIiv\00"
@str$5be = private global [26 x i8] c"glGetTextureParameterIuiv\00"
@str$5bf = private global [24 x i8] c"glGetTextureParameteriv\00"
@str$5c0 = private global [21 x i8] c"glCreateVertexArrays\00"
@str$5c1 = private global [27 x i8] c"glDisableVertexArrayAttrib\00"
@str$5c2 = private global [26 x i8] c"glEnableVertexArrayAttrib\00"
@str$5c3 = private global [27 x i8] c"glVertexArrayElementBuffer\00"
@str$5c4 = private global [26 x i8] c"glVertexArrayVertexBuffer\00"
@str$5c5 = private global [27 x i8] c"glVertexArrayVertexBuffers\00"
@str$5c6 = private global [27 x i8] c"glVertexArrayAttribBinding\00"
@str$5c7 = private global [26 x i8] c"glVertexArrayAttribFormat\00"
@str$5c8 = private global [27 x i8] c"glVertexArrayAttribIFormat\00"
@str$5c9 = private global [27 x i8] c"glVertexArrayAttribLFormat\00"
@str$5ca = private global [28 x i8] c"glVertexArrayBindingDivisor\00"
@str$5cb = private global [19 x i8] c"glGetVertexArrayiv\00"
@str$5cc = private global [26 x i8] c"glGetVertexArrayIndexediv\00"
@str$5cd = private global [28 x i8] c"glGetVertexArrayIndexed64iv\00"
@str$5ce = private global [17 x i8] c"glCreateSamplers\00"
@str$5cf = private global [25 x i8] c"glCreateProgramPipelines\00"
@str$5d0 = private global [16 x i8] c"glCreateQueries\00"
@str$5d1 = private global [27 x i8] c"glGetQueryBufferObjecti64v\00"
@str$5d2 = private global [25 x i8] c"glGetQueryBufferObjectiv\00"
@str$5d3 = private global [28 x i8] c"glGetQueryBufferObjectui64v\00"
@str$5d4 = private global [26 x i8] c"glGetQueryBufferObjectuiv\00"
@str$5d5 = private global [24 x i8] c"glMemoryBarrierByRegion\00"
@str$5d6 = private global [21 x i8] c"glGetTextureSubImage\00"
@str$5d7 = private global [31 x i8] c"glGetCompressedTextureSubImage\00"
@str$5d8 = private global [25 x i8] c"glGetGraphicsResetStatus\00"
@str$5d9 = private global [25 x i8] c"glGetnCompressedTexImage\00"
@str$5da = private global [15 x i8] c"glGetnTexImage\00"
@str$5db = private global [16 x i8] c"glGetnUniformdv\00"
@str$5dc = private global [16 x i8] c"glGetnUniformfv\00"
@str$5dd = private global [16 x i8] c"glGetnUniformiv\00"
@str$5de = private global [17 x i8] c"glGetnUniformuiv\00"
@str$5df = private global [14 x i8] c"glReadnPixels\00"
@str$5e0 = private global [12 x i8] c"glGetnMapdv\00"
@str$5e1 = private global [12 x i8] c"glGetnMapfv\00"
@str$5e2 = private global [12 x i8] c"glGetnMapiv\00"
@str$5e3 = private global [17 x i8] c"glGetnPixelMapfv\00"
@str$5e4 = private global [18 x i8] c"glGetnPixelMapuiv\00"
@str$5e5 = private global [18 x i8] c"glGetnPixelMapusv\00"
@str$5e6 = private global [21 x i8] c"glGetnPolygonStipple\00"
@str$5e7 = private global [17 x i8] c"glGetnColorTable\00"
@str$5e8 = private global [24 x i8] c"glGetnConvolutionFilter\00"
@str$5e9 = private global [22 x i8] c"glGetnSeparableFilter\00"
@str$5ea = private global [16 x i8] c"glGetnHistogram\00"
@str$5eb = private global [13 x i8] c"glGetnMinmax\00"
@str$5ec = private global [17 x i8] c"glTextureBarrier\00"
@str$5ed = private global [19 x i8] c"glSpecializeShader\00"
@str$5ee = private global [31 x i8] c"glMultiDrawArraysIndirectCount\00"
@str$5ef = private global [33 x i8] c"glMultiDrawElementsIndirectCount\00"
@str$5f0 = private global [21 x i8] c"glPolygonOffsetClamp\00"
@str$5f1 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$5f2 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$5f3 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$5f4 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$5f5 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$5f6 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$5f7 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$5f8 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$5f9 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$5fa = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$5fb = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$5fc = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$5fd = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$5fe = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$5ff = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$600 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$601 = private global [66 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fcatalog.odin\00"
@str$602 = private global [66 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fcatalog.odin\00"
@str$603 = private global [16 x i8] c"_update_catalog\00"
@str$604 = private global [66 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fcatalog.odin\00"
@str$605 = private global [16 x i8] c"_update_catalog\00"
@str$606 = private global [66 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fcatalog.odin\00"
@str$607 = private global [18 x i8] c"new\20contents\20for\20\00"
@str$608 = private global [66 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fcatalog.odin\00"
@str$609 = private global [16 x i8] c"_update_catalog\00"
@str$60a = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$60b = private global [15 x i8] c"__slice_resize\00"
@str$60c = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$60d = private global [14 x i8] c"add_component\00"
@str$60e = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$60f = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$610 = private global [14 x i8] c"add_component\00"
@str$611 = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$612 = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$613 = private global [14 x i8] c"add_component\00"
@str$614 = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$615 = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$616 = private global [14 x i8] c"add_component\00"
@str$617 = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$618 = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$619 = private global [28 x i8] c"No\20generated\20code\20for\20type\20\00"
@str$61a = private global [88 x i8] c"\20in\20get_component\28\29.\20Make\20sure\20you\20add\20your\20new\20component\20types\20to\20component_types.wbml\00"
@str$61b = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$61c = private global [14 x i8] c"get_component\00"
@str$61d = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$61e = private global [28 x i8] c"No\20generated\20code\20for\20type\20\00"
@str$61f = private global [88 x i8] c"\20in\20get_component\28\29.\20Make\20sure\20you\20add\20your\20new\20component\20types\20to\20component_types.wbml\00"
@str$620 = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$621 = private global [14 x i8] c"get_component\00"
@str$622 = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$623 = private global [28 x i8] c"No\20generated\20code\20for\20type\20\00"
@str$624 = private global [88 x i8] c"\20in\20get_component\28\29.\20Make\20sure\20you\20add\20your\20new\20component\20types\20to\20component_types.wbml\00"
@str$625 = private global [75 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Ftmp\2Fodinscape_generated_code.odin\00"
@str$626 = private global [14 x i8] c"get_component\00"
@str$627 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$628 = private global [12 x i8] c"append_elem\00"
@str$629 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$62a = private global [13 x i8] c"append_elems\00"
@str$62b = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$62c = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$62d = private global [12 x i8] c"append_elem\00"
@str$62e = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmath\2Fmath.odin\00"
@str$62f = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmath\2Fmath.odin\00"
@str$630 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$631 = private global [12 x i8] c"append_elem\00"
@str$632 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fbasic.odin\00"
@str$633 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fbasic.odin\00"
@str$634 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fmath.odin\00"
@str$635 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fmath.odin\00"
@str$636 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$637 = private global [12 x i8] c"append_elem\00"
@str$638 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fsort\2Fsort.odin\00"
@str$639 = private global [16 x i8] c"quick_sort_proc\00"
@str$63a = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fsort\2Fsort.odin\00"
@str$63b = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fsort\2Fsort.odin\00"
@str$63c = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fsort\2Fsort.odin\00"
@str$63d = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fsort\2Fsort.odin\00"
@str$63e = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fsort\2Fsort.odin\00"
@str$63f = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fsort\2Fsort.odin\00"
@str$640 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fsort\2Fsort.odin\00"
@str$641 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fsort\2Fsort.odin\00"
@str$642 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fsort\2Fsort.odin\00"
@str$643 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$644 = private global [17 x i8] c"draw_vertex_list\00"
@str$645 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$646 = private global [17 x i8] c"draw_vertex_list\00"
@str$647 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$648 = private global [17 x i8] c"draw_vertex_list\00"
@str$649 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$64a = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$64b = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$64c = private global [17 x i8] c"draw_vertex_list\00"
@str$64d = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$64e = private global [17 x i8] c"draw_vertex_list\00"
@str$64f = private global [14 x i8] c"atlas_texture\00"
@str$650 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$651 = private global [17 x i8] c"draw_vertex_list\00"
@str$652 = private global [11 x i8] c"mvp_matrix\00"
@str$653 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$654 = private global [12 x i8] c"append_elem\00"
@str$655 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Fmem.odin\00"
@str$656 = private global [10 x i8] c"slice_ptr\00"
@str$657 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Fmem.odin\00"
@str$658 = private global [10 x i8] c"slice_ptr\00"
@str$659 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$65a = private global [12 x i8] c"append_elem\00"
@str$65b = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$65c = private global [12 x i8] c"append_elem\00"
@str$65d = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$65e = private global [17 x i8] c"draw_vertex_list\00"
@str$65f = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$660 = private global [17 x i8] c"draw_vertex_list\00"
@str$661 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$662 = private global [17 x i8] c"draw_vertex_list\00"
@str$663 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$664 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$665 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$666 = private global [17 x i8] c"draw_vertex_list\00"
@str$667 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$668 = private global [17 x i8] c"draw_vertex_list\00"
@str$669 = private global [14 x i8] c"atlas_texture\00"
@str$66a = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fdraw.odin\00"
@str$66b = private global [17 x i8] c"draw_vertex_list\00"
@str$66c = private global [11 x i8] c"mvp_matrix\00"
@str$66d = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Fmem.odin\00"
@str$66e = private global [10 x i8] c"slice_ptr\00"
@str$66f = private global [74 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Frolling_average.odin\00"
@str$670 = private global [28 x i8] c"rolling_average_push_sample\00"
@str$671 = private global [74 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Frolling_average.odin\00"
@str$672 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$673 = private global [12 x i8] c"append_elem\00"
@str$674 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fbasic.odin\00"
@str$675 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fbasic.odin\00"
@str$676 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$677 = private global [20 x i8] c"_update_one_tweener\00"
@str$678 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$679 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$67a = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$67b = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$67c = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$67d = private global [20 x i8] c"_update_one_tweener\00"
@str$67e = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$67f = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$680 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$681 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$682 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$683 = private global [20 x i8] c"_update_one_tweener\00"
@str$684 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$685 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$686 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$687 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$688 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$689 = private global [20 x i8] c"_update_one_tweener\00"
@str$68a = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$68b = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$68c = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$68d = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Ftween.odin\00"
@str$68e = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Fmem.odin\00"
@str$68f = private global [10 x i8] c"slice_ptr\00"
@str$690 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$691 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$692 = private global [12 x i8] c"append_elem\00"
@str$693 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fbasic.odin\00"
@str$694 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$695 = private global [12 x i8] c"append_elem\00"
@str$696 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$697 = private global [4 x i8] c"pop\00"
@str$698 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$699 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$69a = private global [12 x i8] c"append_elem\00"
@str$69b = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$69c = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$69d = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Fmem.odin\00"
@str$69e = private global [10 x i8] c"slice_ptr\00"
@str$69f = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6a0 = private global [12 x i8] c"append_elem\00"
@str$6a1 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6a2 = private global [12 x i8] c"append_elem\00"
@str$6a3 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6a4 = private global [12 x i8] c"append_elem\00"
@str$6a5 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6a6 = private global [12 x i8] c"append_elem\00"
@str$6a7 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6a8 = private global [22 x i8] c"reserve_dynamic_array\00"
@str$6a9 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6aa = private global [22 x i8] c"reserve_dynamic_array\00"
@str$6ab = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6ac = private global [22 x i8] c"reserve_dynamic_array\00"
@str$6ad = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6ae = private global [4 x i8] c"pop\00"
@str$6af = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6b0 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6b1 = private global [22 x i8] c"reserve_dynamic_array\00"
@str$6b2 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$6b3 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$6b4 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$6b5 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$6b6 = private global [44 x i8] c"UNSUPPORTED\20TYPE\20IN\20VERTEX\20FORMAT\20-\20\25s\3A\20\25s\0A\00"
@str$6b7 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$6b8 = private global [18 x i8] c"set_vertex_format\00"
@str$6b9 = private global [18 x i8] c"set_vertex_format\00"
@str$6ba = private global [18 x i8] c"set_vertex_format\00"
@str$6bb = private global [18 x i8] c"set_vertex_format\00"
@str$6bc = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6bd = private global [22 x i8] c"reserve_dynamic_array\00"
@str$6be = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6bf = private global [22 x i8] c"reserve_dynamic_array\00"
@str$6c0 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6c1 = private global [22 x i8] c"reserve_dynamic_array\00"
@str$6c2 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$6c3 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$6c4 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$6c5 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$6c6 = private global [44 x i8] c"UNSUPPORTED\20TYPE\20IN\20VERTEX\20FORMAT\20-\20\25s\3A\20\25s\0A\00"
@str$6c7 = private global [70 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fgl_wrappers.odin\00"
@str$6c8 = private global [18 x i8] c"set_vertex_format\00"
@str$6c9 = private global [18 x i8] c"set_vertex_format\00"
@str$6ca = private global [18 x i8] c"set_vertex_format\00"
@str$6cb = private global [18 x i8] c"set_vertex_format\00"
@str$6cc = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6cd = private global [22 x i8] c"reserve_dynamic_array\00"
@str$6ce = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6cf = private global [14 x i8] c"__get_map_key\00"
@str$6d0 = private global [23 x i8] c"Unhandled\20integer\20size\00"
@str$6d1 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6d2 = private global [14 x i8] c"__get_map_key\00"
@str$6d3 = private global [21 x i8] c"Unhandled\20float\20size\00"
@str$6d4 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6d5 = private global [14 x i8] c"__get_map_key\00"
@str$6d6 = private global [23 x i8] c"Unhandled\20map\20key\20type\00"
@str$6d7 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6d8 = private global [4 x i8] c"pop\00"
@str$6d9 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6da = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6db = private global [22 x i8] c"reserve_dynamic_array\00"
@str$6dc = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6dd = private global [22 x i8] c"reserve_dynamic_array\00"
@str$6de = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6df = private global [22 x i8] c"reserve_dynamic_array\00"
@str$6e0 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6e1 = private global [22 x i8] c"reserve_dynamic_array\00"
@str$6e2 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6e3 = private global [22 x i8] c"reserve_dynamic_array\00"
@str$6e4 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6e5 = private global [22 x i8] c"reserve_dynamic_array\00"
@str$6e6 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$6e7 = private global [22 x i8] c"reserve_dynamic_array\00"
@str$6e8 = private global [16 x i8] c"IMGUI_Rect_Kind\00"
@str$6e9 = private global [10 x i8] c"Push_Rect\00"
@str$6ea = private global [18 x i8] c"Draw_Colored_Quad\00"
@str$6eb = private global [12 x i8] c"Draw_Sprite\00"
@str$6ec = private global [7 x i8] c"Button\00"
@str$6ed = private global [14 x i8] c"Fit_To_Aspect\00"
@str$6ee = private global [12 x i8] c"Scroll_View\00"
@str$6ef = private global [5 x i8] c"Text\00"
@str$6f0 = private global [6 x i8] c"Color\00"
@str$6f1 = private global [5 x i8] c"Text\00"
@str$6f2 = private global [13 x i8] c"TextDisabled\00"
@str$6f3 = private global [9 x i8] c"WindowBg\00"
@str$6f4 = private global [8 x i8] c"ChildBg\00"
@str$6f5 = private global [8 x i8] c"PopupBg\00"
@str$6f6 = private global [7 x i8] c"Border\00"
@str$6f7 = private global [13 x i8] c"BorderShadow\00"
@str$6f8 = private global [8 x i8] c"FrameBg\00"
@str$6f9 = private global [15 x i8] c"FrameBgHovered\00"
@str$6fa = private global [14 x i8] c"FrameBgActive\00"
@str$6fb = private global [8 x i8] c"TitleBg\00"
@str$6fc = private global [14 x i8] c"TitleBgActive\00"
@str$6fd = private global [17 x i8] c"TitleBgCollapsed\00"
@str$6fe = private global [10 x i8] c"MenuBarBg\00"
@str$6ff = private global [12 x i8] c"ScrollbarBg\00"
@str$700 = private global [14 x i8] c"ScrollbarGrab\00"
@str$701 = private global [21 x i8] c"ScrollbarGrabHovered\00"
@str$702 = private global [20 x i8] c"ScrollbarGrabActive\00"
@str$703 = private global [10 x i8] c"CheckMark\00"
@str$704 = private global [11 x i8] c"SliderGrab\00"
@str$705 = private global [17 x i8] c"SliderGrabActive\00"
@str$706 = private global [7 x i8] c"Button\00"
@str$707 = private global [14 x i8] c"ButtonHovered\00"
@str$708 = private global [13 x i8] c"ButtonActive\00"
@str$709 = private global [7 x i8] c"Header\00"
@str$70a = private global [14 x i8] c"HeaderHovered\00"
@str$70b = private global [13 x i8] c"HeaderActive\00"
@str$70c = private global [10 x i8] c"Separator\00"
@str$70d = private global [17 x i8] c"SeparatorHovered\00"
@str$70e = private global [16 x i8] c"SeparatorActive\00"
@str$70f = private global [11 x i8] c"ResizeGrip\00"
@str$710 = private global [18 x i8] c"ResizeGripHovered\00"
@str$711 = private global [17 x i8] c"ResizeGripActive\00"
@str$712 = private global [12 x i8] c"CloseButton\00"
@str$713 = private global [19 x i8] c"CloseButtonHovered\00"
@str$714 = private global [18 x i8] c"CloseButtonActive\00"
@str$715 = private global [10 x i8] c"PlotLines\00"
@str$716 = private global [17 x i8] c"PlotLinesHovered\00"
@str$717 = private global [14 x i8] c"PlotHistogram\00"
@str$718 = private global [21 x i8] c"PlotHistogramHovered\00"
@str$719 = private global [15 x i8] c"TextSelectedBg\00"
@str$71a = private global [21 x i8] c"ModalWindowDarkening\00"
@str$71b = private global [15 x i8] c"DragDropTarget\00"
@str$71c = private global [6 x i8] c"COUNT\00"
@str$71d = private global [14 x i8] c"ChildWindowBg\00"
@str$71e = private global [7 x i8] c"Column\00"
@str$71f = private global [14 x i8] c"ColumnHovered\00"
@str$720 = private global [13 x i8] c"ColumnActive\00"
@str$721 = private global [4 x i8] c"Key\00"
@str$722 = private global [4 x i8] c"Tab\00"
@str$723 = private global [10 x i8] c"LeftArrow\00"
@str$724 = private global [11 x i8] c"RightArrow\00"
@str$725 = private global [8 x i8] c"UpArrow\00"
@str$726 = private global [10 x i8] c"DownArrow\00"
@str$727 = private global [7 x i8] c"PageUp\00"
@str$728 = private global [9 x i8] c"PageDown\00"
@str$729 = private global [5 x i8] c"Home\00"
@str$72a = private global [4 x i8] c"End\00"
@str$72b = private global [7 x i8] c"Delete\00"
@str$72c = private global [10 x i8] c"Backspace\00"
@str$72d = private global [6 x i8] c"Enter\00"
@str$72e = private global [7 x i8] c"Escape\00"
@str$72f = private global [2 x i8] c"A\00"
@str$730 = private global [2 x i8] c"C\00"
@str$731 = private global [2 x i8] c"V\00"
@str$732 = private global [2 x i8] c"X\00"
@str$733 = private global [2 x i8] c"Y\00"
@str$734 = private global [2 x i8] c"Z\00"
@str$735 = private global [6 x i8] c"COUNT\00"
@str$736 = private global [10 x i8] c"Type_Info\00"
@str$737 = private global [5 x i8] c"size\00"
@str$738 = private global [6 x i8] c"align\00"
@str$739 = private global [3 x i8] c"id\00"
@str$73a = private global [8 x i8] c"variant\00"
@str$73b = private global [16 x i8] c"Type_Info_Named\00"
@str$73c = private global [5 x i8] c"name\00"
@str$73d = private global [5 x i8] c"base\00"
@str$73e = private global [18 x i8] c"Type_Info_Integer\00"
@str$73f = private global [7 x i8] c"signed\00"
@str$740 = private global [15 x i8] c"Type_Info_Rune\00"
@str$741 = private global [16 x i8] c"Type_Info_Float\00"
@str$742 = private global [18 x i8] c"Type_Info_Complex\00"
@str$743 = private global [17 x i8] c"Type_Info_String\00"
@str$744 = private global [11 x i8] c"is_cstring\00"
@str$745 = private global [18 x i8] c"Type_Info_Boolean\00"
@str$746 = private global [14 x i8] c"Type_Info_Any\00"
@str$747 = private global [18 x i8] c"Type_Info_Type_Id\00"
@str$748 = private global [18 x i8] c"Type_Info_Pointer\00"
@str$749 = private global [5 x i8] c"elem\00"
@str$74a = private global [20 x i8] c"Type_Info_Procedure\00"
@str$74b = private global [7 x i8] c"params\00"
@str$74c = private global [8 x i8] c"results\00"
@str$74d = private global [9 x i8] c"variadic\00"
@str$74e = private global [11 x i8] c"convention\00"
@str$74f = private global [19 x i8] c"Calling_Convention\00"
@str$750 = private global [8 x i8] c"Invalid\00"
@str$751 = private global [5 x i8] c"Odin\00"
@str$752 = private global [12 x i8] c"Contextless\00"
@str$753 = private global [2 x i8] c"C\00"
@str$754 = private global [4 x i8] c"Std\00"
@str$755 = private global [5 x i8] c"Fast\00"
@str$756 = private global [16 x i8] c"Type_Info_Array\00"
@str$757 = private global [5 x i8] c"elem\00"
@str$758 = private global [10 x i8] c"elem_size\00"
@str$759 = private global [6 x i8] c"count\00"
@str$75a = private global [24 x i8] c"Type_Info_Dynamic_Array\00"
@str$75b = private global [5 x i8] c"elem\00"
@str$75c = private global [10 x i8] c"elem_size\00"
@str$75d = private global [16 x i8] c"Type_Info_Slice\00"
@str$75e = private global [16 x i8] c"Type_Info_Tuple\00"
@str$75f = private global [6 x i8] c"types\00"
@str$760 = private global [6 x i8] c"names\00"
@str$761 = private global [17 x i8] c"Type_Info_Struct\00"
@str$762 = private global [6 x i8] c"types\00"
@str$763 = private global [6 x i8] c"names\00"
@str$764 = private global [8 x i8] c"offsets\00"
@str$765 = private global [7 x i8] c"usings\00"
@str$766 = private global [10 x i8] c"is_packed\00"
@str$767 = private global [13 x i8] c"is_raw_union\00"
@str$768 = private global [13 x i8] c"custom_align\00"
@str$769 = private global [16 x i8] c"Type_Info_Union\00"
@str$76a = private global [9 x i8] c"variants\00"
@str$76b = private global [11 x i8] c"tag_offset\00"
@str$76c = private global [9 x i8] c"tag_type\00"
@str$76d = private global [13 x i8] c"custom_align\00"
@str$76e = private global [15 x i8] c"Type_Info_Enum\00"
@str$76f = private global [5 x i8] c"base\00"
@str$770 = private global [6 x i8] c"names\00"
@str$771 = private global [7 x i8] c"values\00"
@str$772 = private global [21 x i8] c"Type_Info_Enum_Value\00"
@str$773 = private global [14 x i8] c"Type_Info_Map\00"
@str$774 = private global [4 x i8] c"key\00"
@str$775 = private global [6 x i8] c"value\00"
@str$776 = private global [17 x i8] c"generated_struct\00"
@str$777 = private global [20 x i8] c"Type_Info_Bit_Field\00"
@str$778 = private global [6 x i8] c"names\00"
@str$779 = private global [5 x i8] c"bits\00"
@str$77a = private global [8 x i8] c"offsets\00"
@str$77b = private global [18 x i8] c"Type_Info_Bit_Set\00"
@str$77c = private global [5 x i8] c"elem\00"
@str$77d = private global [11 x i8] c"underlying\00"
@str$77e = private global [6 x i8] c"lower\00"
@str$77f = private global [6 x i8] c"upper\00"
@str$780 = private global [15 x i8] c"Allocator_Mode\00"
@str$781 = private global [6 x i8] c"Alloc\00"
@str$782 = private global [5 x i8] c"Free\00"
@str$783 = private global [9 x i8] c"Free_All\00"
@str$784 = private global [7 x i8] c"Resize\00"
@str$785 = private global [4 x i8] c"Key\00"
@str$786 = private global [8 x i8] c"Unknown\00"
@str$787 = private global [6 x i8] c"Space\00"
@str$788 = private global [11 x i8] c"Apostrophe\00"
@str$789 = private global [6 x i8] c"Comma\00"
@str$78a = private global [6 x i8] c"Minus\00"
@str$78b = private global [7 x i8] c"Period\00"
@str$78c = private global [6 x i8] c"Slash\00"
@str$78d = private global [10 x i8] c"Semicolon\00"
@str$78e = private global [6 x i8] c"Equal\00"
@str$78f = private global [13 x i8] c"Left_Bracket\00"
@str$790 = private global [10 x i8] c"BACKSLASH\00"
@str$791 = private global [14 x i8] c"Right_Bracket\00"
@str$792 = private global [13 x i8] c"Grave_Accent\00"
@str$793 = private global [8 x i8] c"World_1\00"
@str$794 = private global [8 x i8] c"World_2\00"
@str$795 = private global [5 x i8] c"NR_0\00"
@str$796 = private global [5 x i8] c"NR_1\00"
@str$797 = private global [5 x i8] c"NR_2\00"
@str$798 = private global [5 x i8] c"NR_3\00"
@str$799 = private global [5 x i8] c"NR_4\00"
@str$79a = private global [5 x i8] c"NR_5\00"
@str$79b = private global [5 x i8] c"NR_6\00"
@str$79c = private global [5 x i8] c"NR_7\00"
@str$79d = private global [5 x i8] c"NR_8\00"
@str$79e = private global [5 x i8] c"NR_9\00"
@str$79f = private global [2 x i8] c"A\00"
@str$7a0 = private global [2 x i8] c"B\00"
@str$7a1 = private global [2 x i8] c"C\00"
@str$7a2 = private global [2 x i8] c"D\00"
@str$7a3 = private global [2 x i8] c"E\00"
@str$7a4 = private global [2 x i8] c"F\00"
@str$7a5 = private global [2 x i8] c"G\00"
@str$7a6 = private global [2 x i8] c"H\00"
@str$7a7 = private global [2 x i8] c"I\00"
@str$7a8 = private global [2 x i8] c"J\00"
@str$7a9 = private global [2 x i8] c"K\00"
@str$7aa = private global [2 x i8] c"L\00"
@str$7ab = private global [2 x i8] c"M\00"
@str$7ac = private global [2 x i8] c"N\00"
@str$7ad = private global [2 x i8] c"O\00"
@str$7ae = private global [2 x i8] c"P\00"
@str$7af = private global [2 x i8] c"Q\00"
@str$7b0 = private global [2 x i8] c"R\00"
@str$7b1 = private global [2 x i8] c"S\00"
@str$7b2 = private global [2 x i8] c"T\00"
@str$7b3 = private global [2 x i8] c"U\00"
@str$7b4 = private global [2 x i8] c"V\00"
@str$7b5 = private global [2 x i8] c"W\00"
@str$7b6 = private global [2 x i8] c"X\00"
@str$7b7 = private global [2 x i8] c"Y\00"
@str$7b8 = private global [2 x i8] c"Z\00"
@str$7b9 = private global [7 x i8] c"Escape\00"
@str$7ba = private global [6 x i8] c"Enter\00"
@str$7bb = private global [4 x i8] c"Tab\00"
@str$7bc = private global [10 x i8] c"Backspace\00"
@str$7bd = private global [7 x i8] c"Insert\00"
@str$7be = private global [7 x i8] c"Delete\00"
@str$7bf = private global [6 x i8] c"Right\00"
@str$7c0 = private global [5 x i8] c"Left\00"
@str$7c1 = private global [5 x i8] c"Down\00"
@str$7c2 = private global [3 x i8] c"Up\00"
@str$7c3 = private global [8 x i8] c"Page_Up\00"
@str$7c4 = private global [10 x i8] c"Page_Down\00"
@str$7c5 = private global [5 x i8] c"Home\00"
@str$7c6 = private global [4 x i8] c"End\00"
@str$7c7 = private global [10 x i8] c"Caps_Lock\00"
@str$7c8 = private global [12 x i8] c"Scroll_Lock\00"
@str$7c9 = private global [9 x i8] c"Num_Lock\00"
@str$7ca = private global [13 x i8] c"Print_Screen\00"
@str$7cb = private global [6 x i8] c"Pause\00"
@str$7cc = private global [3 x i8] c"F1\00"
@str$7cd = private global [3 x i8] c"F2\00"
@str$7ce = private global [3 x i8] c"F3\00"
@str$7cf = private global [3 x i8] c"F4\00"
@str$7d0 = private global [3 x i8] c"F5\00"
@str$7d1 = private global [3 x i8] c"F6\00"
@str$7d2 = private global [3 x i8] c"F7\00"
@str$7d3 = private global [3 x i8] c"F8\00"
@str$7d4 = private global [3 x i8] c"F9\00"
@str$7d5 = private global [4 x i8] c"F10\00"
@str$7d6 = private global [4 x i8] c"F11\00"
@str$7d7 = private global [4 x i8] c"F12\00"
@str$7d8 = private global [4 x i8] c"F13\00"
@str$7d9 = private global [4 x i8] c"F14\00"
@str$7da = private global [4 x i8] c"F15\00"
@str$7db = private global [4 x i8] c"F16\00"
@str$7dc = private global [4 x i8] c"F17\00"
@str$7dd = private global [4 x i8] c"F18\00"
@str$7de = private global [4 x i8] c"F19\00"
@str$7df = private global [4 x i8] c"F20\00"
@str$7e0 = private global [4 x i8] c"F21\00"
@str$7e1 = private global [4 x i8] c"F22\00"
@str$7e2 = private global [4 x i8] c"F23\00"
@str$7e3 = private global [4 x i8] c"F24\00"
@str$7e4 = private global [4 x i8] c"F25\00"
@str$7e5 = private global [5 x i8] c"KP_0\00"
@str$7e6 = private global [5 x i8] c"KP_1\00"
@str$7e7 = private global [5 x i8] c"KP_2\00"
@str$7e8 = private global [5 x i8] c"KP_3\00"
@str$7e9 = private global [5 x i8] c"KP_4\00"
@str$7ea = private global [5 x i8] c"KP_5\00"
@str$7eb = private global [5 x i8] c"KP_6\00"
@str$7ec = private global [5 x i8] c"KP_7\00"
@str$7ed = private global [5 x i8] c"KP_8\00"
@str$7ee = private global [5 x i8] c"KP_9\00"
@str$7ef = private global [11 x i8] c"KP_Decimal\00"
@str$7f0 = private global [10 x i8] c"KP_Divide\00"
@str$7f1 = private global [12 x i8] c"KP_Multiply\00"
@str$7f2 = private global [12 x i8] c"KP_Subtract\00"
@str$7f3 = private global [7 x i8] c"KP_Add\00"
@str$7f4 = private global [9 x i8] c"KP_Enter\00"
@str$7f5 = private global [9 x i8] c"KP_Equal\00"
@str$7f6 = private global [11 x i8] c"Left_Shift\00"
@str$7f7 = private global [13 x i8] c"Left_Control\00"
@str$7f8 = private global [9 x i8] c"Left_Alt\00"
@str$7f9 = private global [11 x i8] c"Left_Super\00"
@str$7fa = private global [12 x i8] c"Right_Shift\00"
@str$7fb = private global [14 x i8] c"Right_Control\00"
@str$7fc = private global [10 x i8] c"Right_Alt\00"
@str$7fd = private global [12 x i8] c"Right_Super\00"
@str$7fe = private global [9 x i8] c"Key_Menu\00"
@str$7ff = private global [5 x i8] c"Last\00"
@str$800 = private global [7 x i8] c"Action\00"
@str$801 = private global [8 x i8] c"Release\00"
@str$802 = private global [6 x i8] c"Press\00"
@str$803 = private global [7 x i8] c"Repeat\00"
@str$804 = private global [6 x i8] c"Mouse\00"
@str$805 = private global [9 x i8] c"Button_1\00"
@str$806 = private global [9 x i8] c"Button_2\00"
@str$807 = private global [9 x i8] c"Button_3\00"
@str$808 = private global [9 x i8] c"Button_4\00"
@str$809 = private global [9 x i8] c"Button_5\00"
@str$80a = private global [9 x i8] c"Button_6\00"
@str$80b = private global [9 x i8] c"Button_7\00"
@str$80c = private global [9 x i8] c"Button_8\00"
@str$80d = private global [5 x i8] c"Last\00"
@str$80e = private global [5 x i8] c"Left\00"
@str$80f = private global [6 x i8] c"Right\00"
@str$810 = private global [7 x i8] c"Middle\00"
@str$811 = private global [21 x i8] c"Source_Code_Location\00"
@str$812 = private global [10 x i8] c"file_path\00"
@str$813 = private global [5 x i8] c"line\00"
@str$814 = private global [7 x i8] c"column\00"
@str$815 = private global [10 x i8] c"procedure\00"
@str$816 = private global [19 x i8] c"aiPostProcessSteps\00"
@str$817 = private global [17 x i8] c"CalcTangentSpace\00"
@str$818 = private global [22 x i8] c"JoinIdenticalVertices\00"
@str$819 = private global [15 x i8] c"MakeLeftHanded\00"
@str$81a = private global [12 x i8] c"Triangulate\00"
@str$81b = private global [16 x i8] c"RemoveComponent\00"
@str$81c = private global [11 x i8] c"GenNormals\00"
@str$81d = private global [17 x i8] c"GenSmoothNormals\00"
@str$81e = private global [17 x i8] c"SplitLargeMeshes\00"
@str$81f = private global [21 x i8] c"PreTransformVertices\00"
@str$820 = private global [17 x i8] c"LimitBoneWeights\00"
@str$821 = private global [22 x i8] c"ValidateDataStructure\00"
@str$822 = private global [21 x i8] c"ImproveCacheLocality\00"
@str$823 = private global [25 x i8] c"RemoveRedundantMaterials\00"
@str$824 = private global [19 x i8] c"FixInfacingNormals\00"
@str$825 = private global [12 x i8] c"SortByPType\00"
@str$826 = private global [16 x i8] c"FindDegenerates\00"
@str$827 = private global [16 x i8] c"FindInvalidData\00"
@str$828 = private global [12 x i8] c"GenUVCoords\00"
@str$829 = private global [18 x i8] c"TransformUVCoords\00"
@str$82a = private global [14 x i8] c"FindInstances\00"
@str$82b = private global [15 x i8] c"OptimizeMeshes\00"
@str$82c = private global [14 x i8] c"OptimizeGraph\00"
@str$82d = private global [8 x i8] c"FlipUVs\00"
@str$82e = private global [17 x i8] c"FlipWindingOrder\00"
@str$82f = private global [12 x i8] c"Shader_Type\00"
@str$830 = private global [16 x i8] c"FRAGMENT_SHADER\00"
@str$831 = private global [14 x i8] c"VERTEX_SHADER\00"
@str$832 = private global [16 x i8] c"GEOMETRY_SHADER\00"
@str$833 = private global [15 x i8] c"COMPUTE_SHADER\00"
@str$834 = private global [23 x i8] c"TESS_EVALUATION_SHADER\00"
@str$835 = private global [20 x i8] c"TESS_CONTROL_SHADER\00"
@str$836 = private global [12 x i8] c"SHADER_LINK\00"
@str$837 = private global [5 x i8] c"Vec2\00"
@str$838 = private global [5 x i8] c"Vec3\00"
@str$839 = private global [5 x i8] c"Vec4\00"
@str$83a = private global [9 x i8] c"Int_Flag\00"
@str$83b = private global [7 x i8] c"Prefix\00"
@str$83c = private global [5 x i8] c"Plus\00"
@str$83d = private global [6 x i8] c"Space\00"
@str$83e = private global [10 x i8] c"Transform\00"
@str$83f = private global [7 x i8] c"entity\00"
@str$840 = private global [9 x i8] c"position\00"
@str$841 = private global [14 x i8] c"Mesh_Renderer\00"
@str$842 = private global [7 x i8] c"entity\00"
@str$843 = private global [9 x i8] c"mesh_ids\00"
@str$844 = private global [10 x i8] c"Allocator\00"
@str$845 = private global [10 x i8] c"procedure\00"
@str$846 = private global [5 x i8] c"data\00"
@str$847 = private global [15 x i8] c"Allocator_Proc\00"
@str$848 = private global [15 x i8] c"allocator_data\00"
@str$849 = private global [5 x i8] c"mode\00"
@str$84a = private global [5 x i8] c"size\00"
@str$84b = private global [10 x i8] c"alignment\00"
@str$84c = private global [11 x i8] c"old_memory\00"
@str$84d = private global [9 x i8] c"old_size\00"
@str$84e = private global [6 x i8] c"flags\00"
@str$84f = private global [9 x i8] c"location\00"
@str$850 = private global [16 x i8] c"Sprite_Renderer\00"
@str$851 = private global [7 x i8] c"entity\00"
@str$852 = private global [6 x i8] c"color\00"
@str$853 = private global [7 x i8] c"Colorf\00"
@str$854 = private global [2 x i8] c"r\00"
@str$855 = private global [2 x i8] c"g\00"
@str$856 = private global [2 x i8] c"b\00"
@str$857 = private global [2 x i8] c"a\00"
@str$858 = private global [18 x i8] c"Spinner_Component\00"
@str$859 = private global [7 x i8] c"entity\00"
@str$85a = private global [6 x i8] c"speed\00"
@str$85b = private global [7 x i8] c"radius\00"
@str$85c = private global [14 x i8] c"WB_Debug_Data\00"
@str$85d = private global [16 x i8] c"camera_position\00"
@str$85e = private global [22 x i8] c"precise_delta_time_ms\00"
@str$85f = private global [25 x i8] c"client_target_delta_time\00"
@str$860 = private global [24 x i8] c"client_target_framerate\00"
@str$861 = private global [11 x i8] c"draw_calls\00"
@str$862 = private global [14 x i8] c"UI_Debug_Info\00"
@str$863 = private global [13 x i8] c"pushed_rects\00"
@str$864 = private global [11 x i8] c"IMGUI_Rect\00"
@str$865 = private global [9 x i8] c"imgui_id\00"
@str$866 = private global [5 x i8] c"kind\00"
@str$867 = private global [10 x i8] c"code_line\00"
@str$868 = private global [9 x i8] c"location\00"
@str$869 = private global [10 x i8] c"unit_rect\00"
@str$86a = private global [11 x i8] c"pixel_rect\00"
@str$86b = private global [14 x i8] c"unit_param_x1\00"
@str$86c = private global [14 x i8] c"unit_param_y1\00"
@str$86d = private global [14 x i8] c"unit_param_x2\00"
@str$86e = private global [14 x i8] c"unit_param_y2\00"
@str$86f = private global [16 x i8] c"pixel_param_top\00"
@str$870 = private global [18 x i8] c"pixel_param_right\00"
@str$871 = private global [19 x i8] c"pixel_param_bottom\00"
@str$872 = private global [17 x i8] c"pixel_param_left\00"
@str$873 = private global [10 x i8] c"Rect\28f32\29\00"
@str$874 = private global [3 x i8] c"x1\00"
@str$875 = private global [3 x i8] c"y1\00"
@str$876 = private global [3 x i8] c"x2\00"
@str$877 = private global [3 x i8] c"y2\00"
@str$878 = private global [10 x i8] c"Rect\28int\29\00"
@str$879 = private global [3 x i8] c"x1\00"
@str$87a = private global [3 x i8] c"y1\00"
@str$87b = private global [3 x i8] c"x2\00"
@str$87c = private global [3 x i8] c"y2\00"
@str$87d = private global [9 x i8] c"Vertex2D\00"
@str$87e = private global [9 x i8] c"position\00"
@str$87f = private global [10 x i8] c"tex_coord\00"
@str$880 = private global [6 x i8] c"color\00"
@str$881 = private global [7 x i8] c"Colori\00"
@str$882 = private global [2 x i8] c"r\00"
@str$883 = private global [2 x i8] c"g\00"
@str$884 = private global [2 x i8] c"b\00"
@str$885 = private global [2 x i8] c"a\00"
@str$886 = private global [9 x i8] c"Vertex3D\00"
@str$887 = private global [9 x i8] c"position\00"
@str$888 = private global [10 x i8] c"tex_coord\00"
@str$889 = private global [6 x i8] c"color\00"
@str$88a = private global [7 x i8] c"normal\00"
@str$88b = private global [9 x i8] c"Scene_ID\00"
@str$88c = private global [18 x i8] c"0123456789abcdefx\00"
@str$88d = private global [18 x i8] c"0123456789ABCDEFX\00"
@str$88e = private global [37 x i8] c"0123456789abcdefghijklmnopqrstuvwxyz\00"
@str$88f = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$890 = private global [19 x i8] c"__$startup_runtime\00"
@str$891 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$892 = private global [19 x i8] c"__$startup_runtime\00"
@str$893 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$894 = private global [19 x i8] c"__$startup_runtime\00"
@str$895 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$896 = private global [19 x i8] c"__$startup_runtime\00"
@str$897 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$898 = private global [19 x i8] c"__$startup_runtime\00"
@str$899 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Finput.odin\00"
@str$89a = private global [19 x i8] c"__$startup_runtime\00"
@str$89b = private global [18 x i8] c"0123456789abcdefx\00"
@str$89c = private global [18 x i8] c"0123456789ABCDEFX\00"
@str$89d = private global [37 x i8] c"0123456789abcdefghijklmnopqrstuvwxyz\00"
attributes #0 = {nounwind uwtable}
attributes #1 = {nounwind alwaysinline uwtable}
attributes #2 = {nounwind noinline optnone uwtable}
attributes #3 = {nounwind readnone}
