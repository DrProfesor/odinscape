target triple = "x86_64-apple-macosx10.8"

%..opaque = type {};
%..string = type {i8*, i64} ; Basic_string
%..rawptr = type i8* ; Basic_rawptr
%..complex32 = type {half, half} ; Basic_complex32
%..complex64 = type {float, float} ; Basic_complex64
%..complex128 = type {double, double} ; Basic_complex128
%..typeid = type i64 ; Basic_typeid
%..any = type {%..rawptr, %..typeid} ; Basic_any
declare void @llvm.dbg.declare(metadata, metadata, metadata) #3 

%runtime.Calling_Convention = type i64
%runtime.Type_Info_Enum_Value = type {[0 x <8 x i8>], [8 x i8], i8}
%runtime.Type_Info_Named = type {%..string, %runtime.Type_Info*}
%runtime.Type_Info_Integer = type {i8}
%runtime.Type_Info_Rune = type {}
%runtime.Type_Info_Float = type {}
%runtime.Type_Info_Complex = type {}
%runtime.Type_Info_String = type {i8}
%runtime.Type_Info_Boolean = type {}
%runtime.Type_Info_Any = type {}
%runtime.Type_Info_Type_Id = type {}
%runtime.Type_Info_Pointer = type {%runtime.Type_Info*}
%runtime.Type_Info_Procedure = type {%runtime.Type_Info*, %runtime.Type_Info*, i8, i64}
%runtime.Type_Info_Array = type {%runtime.Type_Info*, i64, i64}
%runtime.Type_Info_Dynamic_Array = type {%runtime.Type_Info*, i64}
%runtime.Type_Info_Slice = type {%runtime.Type_Info*, i64}
%runtime.Type_Info_Tuple = type {{%runtime.Type_Info**, i64}, {%..string*, i64}}
%runtime.Type_Info_Struct = type {{%runtime.Type_Info**, i64}, {%..string*, i64}, {i64*, i64}, {i8*, i64}, i8, i8, i8}
%runtime.Type_Info_Union = type {{%runtime.Type_Info**, i64}, i64, %runtime.Type_Info*, i8}
%runtime.Type_Info_Enum = type {%runtime.Type_Info*, {%..string*, i64}, {%runtime.Type_Info_Enum_Value*, i64}}
%runtime.Type_Info_Map = type {%runtime.Type_Info*, %runtime.Type_Info*, %runtime.Type_Info*}
%runtime.Type_Info_Bit_Field = type {{%..string*, i64}, {i32*, i64}, {i32*, i64}}
%runtime.Type_Info_Bit_Set = type {%runtime.Type_Info*, %runtime.Type_Info*, i64, i64}
%runtime.Type_Info = type {i64, i64, %..typeid, {[0 x <8 x i8>], [72 x i8], i8}}
%runtime.Typeid_Bit_Field = type {[0 x <8 x i8>], [8 x i8]}
%runtime.Source_Code_Location = type {%..string, i64, i64, %..string}
%runtime.Assertion_Failure_Proc = type void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*
%runtime.Context = type {%mem.Allocator, %mem.Allocator, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, %log.Logger, i64, %..any, i64, %..any}
%runtime.Map_Key = type {i64, %..string}
%runtime.Map_Entry_Header = type {%runtime.Map_Key, i64}
%mem.Raw_String = type {i8*, i64}
%mem.Raw_Slice = type {%..rawptr, i64}
%mem.Raw_Dynamic_Array = type {%..rawptr, i64, i64, %mem.Allocator}
%mem.Raw_Map = type {{i64*, i64}, %mem.Raw_Dynamic_Array}
%mem.Allocator_Mode = type i8
%mem.Allocator_Proc = type %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*
%mem.Allocator = type {%..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr}
%mem.Scratch_Allocator = type {{i8*, i64}, i64, i64, %mem.Allocator, {%..rawptr*, i64, i64, %mem.Allocator}}
%os.Handle = type i32
%os.Errno = type i64
%utf8.Accept_Range = type {i8, i8}
%log.Level = type i64
%log.Option = type i64
%log.Options = type i8
%log.Logger_Proc = type void (%..rawptr, i64, %..string, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)*
%log.Logger = type {void (%..rawptr, i64, %..string, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr}
%fmt.String_Buffer = type {i8*, i64, i64, %mem.Allocator}
%fmt.Fmt_Info = type {i8, i8, i8, i8, i8, i8, i8, i64, i64, i64, i8, i8, {i8*, i64, i64, %mem.Allocator}*, %..any}
%strconv.Int_Flag = type i64
%strconv.Int_Flags = type i8
%strconv.DecimalSlice = type {{i8*, i64}, i64, i64, i8}
%strconv.FloatInfo = type {i64, i64, i64}
%decimal.Decimal = type {[384 x i8], i64, i64, i8, i8}
%lexer.Lexer = type {%..string, i64, i64, i64, %..any}
%lexer.Token_Identifier = type {%..string}
%lexer.Token_Number = type {i64, i64, double, i8}
%lexer.Token_String = type {%..string}
%lexer.Token_Symbol = type {i32}
%lexer.Token = type {%..string, {[0 x <8 x i8>], [32 x i8], i8}}
%prebuild.Parameter = type {%..string, %..string}
%strconv.format_digits.Buffer-249 = type {{i8*, i64}, i64}
%prebuild.main.Component_Definition-250 = type {%..string, %..string, %..string, %..string, %..string, %..string}

declare ccc void @llvm.debugtrap() #0 
declare ccc i32 @open(i8*, i64) #0 
declare ccc void @close(i32) #0 
declare ccc i64 @read(i32, %..rawptr, i64) #0 
declare ccc i64 @write(i32, %..rawptr, i64) #0 
declare ccc i64 @lseek(i32, i64, i64) #0 
declare ccc %..rawptr @calloc(i64, i64) #0 
declare ccc void @free(%..rawptr) #0 
declare ccc %..rawptr @realloc(%..rawptr, i64) #0 

define void @runtime.print_u64(i32 %fd, i64 %u, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i64, align 16
	%2 = alloca %..string, align 16
	%3 = alloca [129 x i8], align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca {i8*, i64}, align 16
	%7 = alloca {i8*, i64}, align 16
	store i32 %fd, i32* %0
	store i64 %u, i64* %1
	; digits
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$0, i64 0, i32 0), i64 10}, %..string* %2
	; a
	%8 = bitcast [129 x i8]* %3 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 129) noinline
	store [129 x i8] zeroinitializer, [129 x i8]* %3
	; i
	store i64 129, i64* %4
	; b
	store i64 10, i64* %5
	; ForStmt
	br label %for.loop-1

for.loop-1:
	%10 = load i64, i64* %1, align 8
	%11 = load i64, i64* %5, align 8
	%12 = icmp uge i64 %10, %11
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %for.body-2, label %for.done-3

for.body-2:
	; AssignStmt
	%15 = load i64, i64* %4, align 8
	%16 = sub i64 %15, 1
	store i64 %16, i64* %4
	; AssignStmt
	; IndexExpr
	%17 = load i64, i64* %4, align 8
	%18 = trunc i64 %17 to i32
	%19 = getelementptr inbounds [129 x i8], [129 x i8]* %3, i64 0, i32 %18
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1, i64 0, i32 0), i64 62}, i64 15, i64 13, i64 %17, i64 129)
	; IndexExpr
	%20 = load %..string, %..string* %2, align 8
	%21 = extractvalue %..string %20, 0
	%22 = extractvalue %..string %20, 1
	%23 = load i64, i64* %1, align 8
	%24 = load i64, i64* %5, align 8
	%25 = urem i64 %23, %24
	%26 = bitcast i64 %25 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$2, i64 0, i32 0), i64 62}, i64 15, i64 25, i64 %26, i64 %22)
	%27 = getelementptr inbounds i8, i8* %21, i64 %26
	%28 = load i8, i8* %27, align 1
	store i8 %28, i8* %19
	; AssignStmt
	%29 = load i64, i64* %5, align 8
	%30 = load i64, i64* %1, align 8
	%31 = udiv i64 %30, %29
	store i64 %31, i64* %1
	br label %for.loop-1

for.done-3:
	; AssignStmt
	%32 = load i64, i64* %4, align 8
	%33 = sub i64 %32, 1
	store i64 %33, i64* %4
	; AssignStmt
	; IndexExpr
	%34 = load i64, i64* %4, align 8
	%35 = trunc i64 %34 to i32
	%36 = getelementptr inbounds [129 x i8], [129 x i8]* %3, i64 0, i32 %35
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$3, i64 0, i32 0), i64 62}, i64 18, i64 12, i64 %34, i64 129)
	; IndexExpr
	%37 = load %..string, %..string* %2, align 8
	%38 = extractvalue %..string %37, 0
	%39 = extractvalue %..string %37, 1
	%40 = load i64, i64* %1, align 8
	%41 = load i64, i64* %5, align 8
	%42 = urem i64 %40, %41
	%43 = bitcast i64 %42 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$4, i64 0, i32 0), i64 62}, i64 18, i64 24, i64 %43, i64 %39)
	%44 = getelementptr inbounds i8, i8* %38, i64 %43
	%45 = load i8, i8* %44, align 1
	store i8 %45, i8* %36
	; SelectorExpr
	%46 = load i32, i32* %0, align 4
	; SliceExpr
	%47 = load i64, i64* %4, align 8
	%48 = load [129 x i8], [129 x i8]* %3, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$5, i64 0, i32 0), i64 62}, i64 20, i64 16, i64 %47, i64 129, i64 129)
	%49 = getelementptr inbounds [129 x i8], [129 x i8]* %3, i64 0, i32 0
	%50 = getelementptr inbounds i8, i8* %49, i64 %47
	%51 = sub i64 129, %47
	%52 = bitcast {i8*, i64}* %6 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	%54 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %6, i64 0, i32 0
	store i8* %50, i8** %54
	%55 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %6, i64 0, i32 1
	store i64 %51, i64* %55
	%56 = load {i8*, i64}, {i8*, i64}* %6, align 8
	%57 = bitcast {i8*, i64}* %7 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %7
	store {i8*, i64} %56, {i8*, i64}* %7
	%59 = call {i64, i64} @os.write(i32 %46, {i8*, i64}* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @runtime.print_i64(i32 %fd, i64 %u, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i64, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	%4 = alloca [129 x i8], align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca {i8*, i64}, align 16
	%8 = alloca {i8*, i64}, align 16
	store i32 %fd, i32* %0
	store i64 %u, i64* %1
	; digits
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$6, i64 0, i32 0), i64 10}, %..string* %2
	; neg
	%9 = load i64, i64* %1, align 8
	%10 = icmp slt i64 %9, 0
	%11 = zext i1 %10 to i8
	store i8 %11, i8* %3
	; AssignStmt
	%12 = load i64, i64* %1, align 8
	; abs
	%13 = icmp slt i64 %12, 0
	%14 = sub i64 0, %12
	%15 = select i1 %13, i64 %14, i64 %12
	store i64 %15, i64* %1
	; a
	%16 = bitcast [129 x i8]* %4 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 129) noinline
	store [129 x i8] zeroinitializer, [129 x i8]* %4
	; i
	store i64 129, i64* %5
	; b
	store i64 10, i64* %6
	; ForStmt
	br label %for.loop-1

for.loop-1:
	%18 = load i64, i64* %1, align 8
	%19 = load i64, i64* %6, align 8
	%20 = icmp sge i64 %18, %19
	%21 = zext i1 %20 to i8
	%22 = trunc i8 %21 to i1
	br i1 %22, label %for.body-2, label %for.done-3

for.body-2:
	; AssignStmt
	%23 = load i64, i64* %5, align 8
	%24 = sub i64 %23, 1
	store i64 %24, i64* %5
	; AssignStmt
	; IndexExpr
	%25 = load i64, i64* %5, align 8
	%26 = trunc i64 %25 to i32
	%27 = getelementptr inbounds [129 x i8], [129 x i8]* %4, i64 0, i32 %26
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$7, i64 0, i32 0), i64 62}, i64 33, i64 13, i64 %25, i64 129)
	; IndexExpr
	%28 = load %..string, %..string* %2, align 8
	%29 = extractvalue %..string %28, 0
	%30 = extractvalue %..string %28, 1
	%31 = load i64, i64* %1, align 8
	%32 = load i64, i64* %6, align 8
	%33 = srem i64 %31, %32
	%34 = bitcast i64 %33 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$8, i64 0, i32 0), i64 62}, i64 33, i64 25, i64 %34, i64 %30)
	%35 = getelementptr inbounds i8, i8* %29, i64 %34
	%36 = load i8, i8* %35, align 1
	store i8 %36, i8* %27
	; AssignStmt
	%37 = load i64, i64* %6, align 8
	%38 = load i64, i64* %1, align 8
	%39 = sdiv i64 %38, %37
	store i64 %39, i64* %1
	br label %for.loop-1

for.done-3:
	; AssignStmt
	%40 = load i64, i64* %5, align 8
	%41 = sub i64 %40, 1
	store i64 %41, i64* %5
	; AssignStmt
	; IndexExpr
	%42 = load i64, i64* %5, align 8
	%43 = trunc i64 %42 to i32
	%44 = getelementptr inbounds [129 x i8], [129 x i8]* %4, i64 0, i32 %43
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$9, i64 0, i32 0), i64 62}, i64 36, i64 12, i64 %42, i64 129)
	; IndexExpr
	%45 = load %..string, %..string* %2, align 8
	%46 = extractvalue %..string %45, 0
	%47 = extractvalue %..string %45, 1
	%48 = load i64, i64* %1, align 8
	%49 = load i64, i64* %6, align 8
	%50 = srem i64 %48, %49
	%51 = bitcast i64 %50 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$a, i64 0, i32 0), i64 62}, i64 36, i64 24, i64 %51, i64 %47)
	%52 = getelementptr inbounds i8, i8* %46, i64 %51
	%53 = load i8, i8* %52, align 1
	store i8 %53, i8* %44
	; IfStmt
	%54 = load i8, i8* %3, align 1
	%55 = trunc i8 %54 to i1
	br i1 %55, label %if.then-4, label %if.done-5

if.then-4:
	; AssignStmt
	%56 = load i64, i64* %5, align 8
	%57 = sub i64 %56, 1
	store i64 %57, i64* %5
	; AssignStmt
	; IndexExpr
	%58 = load i64, i64* %5, align 8
	%59 = trunc i64 %58 to i32
	%60 = getelementptr inbounds [129 x i8], [129 x i8]* %4, i64 0, i32 %59
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$b, i64 0, i32 0), i64 62}, i64 38, i64 13, i64 %58, i64 129)
	store i8 45, i8* %60
	br label %if.done-5

if.done-5:
	; SelectorExpr
	%61 = load i32, i32* %0, align 4
	; SliceExpr
	%62 = load i64, i64* %5, align 8
	%63 = load [129 x i8], [129 x i8]* %4, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$c, i64 0, i32 0), i64 62}, i64 41, i64 16, i64 %62, i64 129, i64 129)
	%64 = getelementptr inbounds [129 x i8], [129 x i8]* %4, i64 0, i32 0
	%65 = getelementptr inbounds i8, i8* %64, i64 %62
	%66 = sub i64 129, %62
	%67 = bitcast {i8*, i64}* %7 to %..rawptr
	%68 = call %..rawptr @mem.zero(%..rawptr %67, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %7
	%69 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i64 0, i32 0
	store i8* %65, i8** %69
	%70 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i64 0, i32 1
	store i64 %66, i64* %70
	%71 = load {i8*, i64}, {i8*, i64}* %7, align 8
	%72 = bitcast {i8*, i64}* %8 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %8
	store {i8*, i64} %71, {i8*, i64}* %8
	%74 = call {i64, i64} @os.write(i32 %61, {i8*, i64}* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @runtime.print_caller_location(i32 %fd, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	store i32 %fd, i32* %0
	%1 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%2 = load i32, i32* %0, align 4
	%3 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, i64 0, i32 0
	%4 = load %..string, %..string* %3, align 8
	%5 = call {i64, i64} @os.write_string(i32 %2, %..string %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%6 = load i32, i32* %0, align 4
	%7 = call {i64, i64} @os.write_byte(i32 %6, i8 40, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%8 = load i32, i32* %0, align 4
	%9 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, i64 0, i32 1
	%10 = load i64, i64* %9, align 8
	%11 = bitcast i64 %10 to i64
	call void @runtime.print_u64(i32 %8, i64 %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%12 = load i32, i32* %0, align 4
	%13 = call {i64, i64} @os.write_byte(i32 %12, i8 58, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%14 = load i32, i32* %0, align 4
	%15 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, i64 0, i32 2
	%16 = load i64, i64* %15, align 8
	%17 = bitcast i64 %16 to i64
	call void @runtime.print_u64(i32 %14, i64 %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%18 = load i32, i32* %0, align 4
	%19 = call {i64, i64} @os.write_byte(i32 %18, i8 41, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @runtime.print_typeid(i32 %fd, %..typeid %id, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %..typeid, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	store i32 %fd, i32* %0
	store %..typeid %id, %..typeid* %1
	; ti
	%3 = load %..typeid, %..typeid* %1, align 8
	%4 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %3)
	store %runtime.Type_Info* %4, %runtime.Type_Info** %2
	%5 = load i32, i32* %0, align 4
	%6 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	call void @runtime.print_type(i32 %5, %runtime.Type_Info* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @runtime.print_type(i32 %fd, %runtime.Type_Info* %ti, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	%2 = alloca %runtime.Type_Info_Named, align 16
	%3 = alloca %runtime.Type_Info_Integer, align 16
	%4 = alloca %runtime.Type_Info_Rune, align 16
	%5 = alloca %runtime.Type_Info_Float, align 16
	%6 = alloca %runtime.Type_Info_Complex, align 16
	%7 = alloca %runtime.Type_Info_String, align 16
	%8 = alloca %runtime.Type_Info_Boolean, align 16
	%9 = alloca %runtime.Type_Info_Any, align 16
	%10 = alloca %runtime.Type_Info_Type_Id, align 16
	%11 = alloca %runtime.Type_Info_Pointer, align 16
	%12 = alloca %runtime.Type_Info_Procedure, align 16
	%13 = alloca %runtime.Type_Info_Tuple, align 16
	%14 = alloca {%runtime.Type_Info_Tuple, i8}, align 16
	%15 = alloca %runtime.Type_Info*, align 16
	%16 = alloca i64, align 16
	%17 = alloca i64, align 16
	%18 = alloca i64, align 16
	%19 = alloca %runtime.Type_Info_Tuple, align 16
	%20 = alloca i64, align 16
	%21 = alloca %..string, align 16
	%22 = alloca i64, align 16
	%23 = alloca i64, align 16
	%24 = alloca i64, align 16
	%25 = alloca %runtime.Type_Info*, align 16
	%26 = alloca %runtime.Type_Info_Array, align 16
	%27 = alloca %runtime.Type_Info_Dynamic_Array, align 16
	%28 = alloca %runtime.Type_Info_Slice, align 16
	%29 = alloca %runtime.Type_Info_Map, align 16
	%30 = alloca %runtime.Type_Info_Struct, align 16
	%31 = alloca %..string, align 16
	%32 = alloca i64, align 16
	%33 = alloca i64, align 16
	%34 = alloca i64, align 16
	%35 = alloca %runtime.Type_Info_Union, align 16
	%36 = alloca %runtime.Type_Info*, align 16
	%37 = alloca i64, align 16
	%38 = alloca i64, align 16
	%39 = alloca i64, align 16
	%40 = alloca %runtime.Type_Info_Enum, align 16
	%41 = alloca %..string, align 16
	%42 = alloca i64, align 16
	%43 = alloca i64, align 16
	%44 = alloca i64, align 16
	%45 = alloca %runtime.Type_Info_Bit_Field, align 16
	%46 = alloca %..string, align 16
	%47 = alloca i64, align 16
	%48 = alloca i64, align 16
	%49 = alloca i64, align 16
	%50 = alloca %runtime.Type_Info_Bit_Set, align 16
	%51 = alloca %runtime.Type_Info*, align 16
	%52 = alloca %runtime.Type_Info_Enum, align 16
	%53 = alloca %runtime.Type_Info_Rune, align 16
	%54 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	store i32 %fd, i32* %0
	store %runtime.Type_Info* %ti, %runtime.Type_Info** %1
	; IfStmt
	%55 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%56 = icmp eq %runtime.Type_Info* %55, zeroinitializer
	%57 = zext i1 %56 to i8
	%58 = trunc i8 %57 to i1
	br i1 %58, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	%59 = load i32, i32* %0, align 4
	%60 = call {i64, i64} @os.write_string(i32 %59, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$d, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-2:
	; TypeSwitchStmt
	; SelectorExpr
	%61 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%62 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %61, i64 0
	%63 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %62, i64 0, i32 3
	%64 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %63, align 8
	; get union's tag
	%65 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %63, i64 0, i32 2 ; UnionTagPtr
	%66 = load i8, i8* %65, align 1
	%67 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %63 to %..rawptr
	%68 = icmp eq i8 %66, 1
	br i1 %68, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.next-3:
	%69 = icmp eq i8 %66, 2
	br i1 %69, label %typeswitch.body-6, label %typeswitch.next-5

typeswitch.body-4:
	%70 = bitcast %..rawptr %67 to %runtime.Type_Info_Named*
	%71 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %70, align 8
	store %runtime.Type_Info_Named %71, %runtime.Type_Info_Named* %2
	; SelectorExpr
	%72 = load i32, i32* %0, align 4
	; SelectorExpr
	%73 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2, i64 0, i32 0
	%74 = load %..string, %..string* %73, align 8
	%75 = call {i64, i64} @os.write_string(i32 %72, %..string %74, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-5:
	%76 = icmp eq i8 %66, 3
	br i1 %76, label %typeswitch.body-18, label %typeswitch.next-17

typeswitch.body-6:
	%77 = bitcast %..rawptr %67 to %runtime.Type_Info_Integer*
	%78 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %77, align 1
	store %runtime.Type_Info_Integer %78, %runtime.Type_Info_Integer* %3
	; SwitchStmt
	; SelectorExpr
	%79 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%80 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %79, i64 0
	%81 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %80, i64 0, i32 2
	%82 = load %..typeid, %..typeid* %81, align 8
	%83 = icmp eq %..typeid %82, 4683743612465315846
	br i1 %83, label %switch.case.body-8, label %switch.case.next-7

switch.case.next-7:
	%84 = icmp eq %..typeid %82, 72057594037928001
	br i1 %84, label %switch.fall.body-10, label %switch.case.next-9

switch.case.body-8:
	; SelectorExpr
	%85 = load i32, i32* %0, align 4
	%86 = call {i64, i64} @os.write_string(i32 %85, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$e, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

switch.case.next-9:
	%87 = icmp eq %..typeid %82, 72057594037927982
	br i1 %87, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	; SelectorExpr
	%88 = load i32, i32* %0, align 4
	%89 = call {i64, i64} @os.write_string(i32 %88, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$f, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

switch.case.next-11:
	; SelectorExpr
	%90 = load i32, i32* %0, align 4
	; TernaryExpr
	; SelectorExpr
	%91 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %3, i64 0, i32 0
	%92 = load i8, i8* %91, align 1
	%93 = trunc i8 %92 to i1
	br i1 %93, label %if.then-13, label %if.else-14

switch.fall.body-12:
	; SelectorExpr
	%94 = load i32, i32* %0, align 4
	%95 = call {i64, i64} @os.write_string(i32 %94, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$10, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

if.then-13:
	br label %if.done-15

if.else-14:
	br label %if.done-15

if.done-15:
	%96 = phi i32 [ 105, %if.then-13 ], [ 117, %if.else-14 ]
	%97 = trunc i32 %96 to i8
	%98 = call {i64, i64} @os.write_byte(i32 %90, i8 %97, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%99 = load i32, i32* %0, align 4
	; SelectorExpr
	%100 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%101 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %100, i64 0
	%102 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %101, i64 0, i32 0
	%103 = load i64, i64* %102, align 8
	%104 = mul i64 8, %103
	%105 = bitcast i64 %104 to i64
	call void @runtime.print_u64(i32 %99, i64 %105, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

switch.done-16:
	br label %typeswitch.done-119

typeswitch.next-17:
	%106 = icmp eq i8 %66, 4
	br i1 %106, label %typeswitch.body-20, label %typeswitch.next-19

typeswitch.body-18:
	%107 = bitcast %..rawptr %67 to %runtime.Type_Info_Rune*
	%108 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %107, align 1
	store %runtime.Type_Info_Rune %108, %runtime.Type_Info_Rune* %4
	; SelectorExpr
	%109 = load i32, i32* %0, align 4
	%110 = call {i64, i64} @os.write_string(i32 %109, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$11, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-19:
	%111 = icmp eq i8 %66, 5
	br i1 %111, label %typeswitch.body-22, label %typeswitch.next-21

typeswitch.body-20:
	%112 = bitcast %..rawptr %67 to %runtime.Type_Info_Float*
	%113 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %112, align 1
	store %runtime.Type_Info_Float %113, %runtime.Type_Info_Float* %5
	; SelectorExpr
	%114 = load i32, i32* %0, align 4
	%115 = call {i64, i64} @os.write_byte(i32 %114, i8 102, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%116 = load i32, i32* %0, align 4
	; SelectorExpr
	%117 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%118 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %117, i64 0
	%119 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %118, i64 0, i32 0
	%120 = load i64, i64* %119, align 8
	%121 = mul i64 8, %120
	%122 = bitcast i64 %121 to i64
	call void @runtime.print_u64(i32 %116, i64 %122, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-21:
	%123 = icmp eq i8 %66, 6
	br i1 %123, label %typeswitch.body-24, label %typeswitch.next-23

typeswitch.body-22:
	%124 = bitcast %..rawptr %67 to %runtime.Type_Info_Complex*
	%125 = load %runtime.Type_Info_Complex, %runtime.Type_Info_Complex* %124, align 1
	store %runtime.Type_Info_Complex %125, %runtime.Type_Info_Complex* %6
	; SelectorExpr
	%126 = load i32, i32* %0, align 4
	%127 = call {i64, i64} @os.write_string(i32 %126, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$12, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%128 = load i32, i32* %0, align 4
	; SelectorExpr
	%129 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%130 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %129, i64 0
	%131 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %130, i64 0, i32 0
	%132 = load i64, i64* %131, align 8
	%133 = mul i64 8, %132
	%134 = bitcast i64 %133 to i64
	call void @runtime.print_u64(i32 %128, i64 %134, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-23:
	%135 = icmp eq i8 %66, 7
	br i1 %135, label %typeswitch.body-26, label %typeswitch.next-25

typeswitch.body-24:
	%136 = bitcast %..rawptr %67 to %runtime.Type_Info_String*
	%137 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %136, align 1
	store %runtime.Type_Info_String %137, %runtime.Type_Info_String* %7
	; SelectorExpr
	%138 = load i32, i32* %0, align 4
	%139 = call {i64, i64} @os.write_string(i32 %138, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$13, i64 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-25:
	%140 = icmp eq i8 %66, 8
	br i1 %140, label %typeswitch.body-31, label %typeswitch.next-30

typeswitch.body-26:
	%141 = bitcast %..rawptr %67 to %runtime.Type_Info_Boolean*
	%142 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %141, align 1
	store %runtime.Type_Info_Boolean %142, %runtime.Type_Info_Boolean* %8
	; SwitchStmt
	; SelectorExpr
	%143 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%144 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %143, i64 0
	%145 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %144, i64 0, i32 2
	%146 = load %..typeid, %..typeid* %145, align 8
	%147 = icmp eq %..typeid %146, 432345564227567632
	br i1 %147, label %switch.case.body-28, label %switch.case.next-27

switch.case.next-27:
	; SelectorExpr
	%148 = load i32, i32* %0, align 4
	%149 = call {i64, i64} @os.write_byte(i32 %148, i8 98, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%150 = load i32, i32* %0, align 4
	; SelectorExpr
	%151 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%152 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %151, i64 0
	%153 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %152, i64 0, i32 0
	%154 = load i64, i64* %153, align 8
	%155 = mul i64 8, %154
	%156 = bitcast i64 %155 to i64
	call void @runtime.print_u64(i32 %150, i64 %156, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-29

switch.case.body-28:
	; SelectorExpr
	%157 = load i32, i32* %0, align 4
	%158 = call {i64, i64} @os.write_string(i32 %157, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$14, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-29

switch.done-29:
	br label %typeswitch.done-119

typeswitch.next-30:
	%159 = icmp eq i8 %66, 9
	br i1 %159, label %typeswitch.body-33, label %typeswitch.next-32

typeswitch.body-31:
	%160 = bitcast %..rawptr %67 to %runtime.Type_Info_Any*
	%161 = load %runtime.Type_Info_Any, %runtime.Type_Info_Any* %160, align 1
	store %runtime.Type_Info_Any %161, %runtime.Type_Info_Any* %9
	; SelectorExpr
	%162 = load i32, i32* %0, align 4
	%163 = call {i64, i64} @os.write_string(i32 %162, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$15, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-32:
	%164 = icmp eq i8 %66, 10
	br i1 %164, label %typeswitch.body-35, label %typeswitch.next-34

typeswitch.body-33:
	%165 = bitcast %..rawptr %67 to %runtime.Type_Info_Type_Id*
	%166 = load %runtime.Type_Info_Type_Id, %runtime.Type_Info_Type_Id* %165, align 1
	store %runtime.Type_Info_Type_Id %166, %runtime.Type_Info_Type_Id* %10
	; SelectorExpr
	%167 = load i32, i32* %0, align 4
	%168 = call {i64, i64} @os.write_string(i32 %167, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$16, i64 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-34:
	%169 = icmp eq i8 %66, 11
	br i1 %169, label %typeswitch.body-40, label %typeswitch.next-39

typeswitch.body-35:
	%170 = bitcast %..rawptr %67 to %runtime.Type_Info_Pointer*
	%171 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %170, align 8
	store %runtime.Type_Info_Pointer %171, %runtime.Type_Info_Pointer* %11
	; IfStmt
	; SelectorExpr
	%172 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %11, i64 0, i32 0
	%173 = load %runtime.Type_Info*, %runtime.Type_Info** %172, align 8
	%174 = icmp eq %runtime.Type_Info* %173, zeroinitializer
	%175 = zext i1 %174 to i8
	%176 = trunc i8 %175 to i1
	br i1 %176, label %if.then-36, label %if.else-37

if.then-36:
	; SelectorExpr
	%177 = load i32, i32* %0, align 4
	%178 = call {i64, i64} @os.write_string(i32 %177, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$17, i64 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-38

if.else-37:
	; SelectorExpr
	%179 = load i32, i32* %0, align 4
	%180 = call {i64, i64} @os.write_string(i32 %179, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$18, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%181 = load i32, i32* %0, align 4
	; SelectorExpr
	%182 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %11, i64 0, i32 0
	%183 = load %runtime.Type_Info*, %runtime.Type_Info** %182, align 8
	call void @runtime.print_type(i32 %181, %runtime.Type_Info* %183, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-38

if.done-38:
	br label %typeswitch.done-119

typeswitch.next-39:
	%184 = icmp eq i8 %66, 15
	br i1 %184, label %typeswitch.body-54, label %typeswitch.next-53

typeswitch.body-40:
	%185 = bitcast %..rawptr %67 to %runtime.Type_Info_Procedure*
	%186 = load %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %185, align 8
	store %runtime.Type_Info_Procedure %186, %runtime.Type_Info_Procedure* %12
	; SelectorExpr
	%187 = load i32, i32* %0, align 4
	%188 = call {i64, i64} @os.write_string(i32 %187, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$19, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%189 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 0
	%190 = load %runtime.Type_Info*, %runtime.Type_Info** %189, align 8
	%191 = icmp eq %runtime.Type_Info* %190, zeroinitializer
	%192 = zext i1 %191 to i8
	%193 = trunc i8 %192 to i1
	br i1 %193, label %if.then-41, label %if.else-42

if.then-41:
	; SelectorExpr
	%194 = load i32, i32* %0, align 4
	%195 = call {i64, i64} @os.write_string(i32 %194, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1a, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-50

if.else-42:
	; t
	; SelectorExpr
	; SelectorExpr
	%196 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 0
	%197 = load %runtime.Type_Info*, %runtime.Type_Info** %196, align 8
	%198 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %197, i64 0
	%199 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %198, i64 0, i32 3
	%200 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %199, align 8
	; cast - union_cast
	%201 = bitcast {%runtime.Type_Info_Tuple, i8}* %14 to %..rawptr
	%202 = call %..rawptr @mem.zero(%..rawptr %201, i64 40) noinline
	store {%runtime.Type_Info_Tuple, i8} zeroinitializer, {%runtime.Type_Info_Tuple, i8}* %14
	%203 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %199, i64 0, i32 2 ; UnionTagPtr
	%204 = load i8, i8* %203, align 1
	%205 = icmp eq i8 %204, 15
	br i1 %205, label %union_cast.ok-43, label %union_cast.end-44

union_cast.ok-43:
	%206 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 0
	%207 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 1
	%208 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %199 to %runtime.Type_Info_Tuple*
	%209 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %208, align 8
	store %runtime.Type_Info_Tuple %209, %runtime.Type_Info_Tuple* %206
	store i8 1, i8* %207
	br label %union_cast.end-44

union_cast.end-44:
	%210 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 1
	%211 = load i8, i8* %210, align 1
	%212 = trunc i8 %211 to i1
	call void @runtime.type_assertion_check(i1 %212, %..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1b, i64 0, i32 0), i64 62}, i64 108, i64 21, %..typeid 1152921504606846984, %..typeid 3386706919782613029)
	%213 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 0
	%214 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %213, align 8
	store %runtime.Type_Info_Tuple %214, %runtime.Type_Info_Tuple* %13
	; SelectorExpr
	%215 = load i32, i32* %0, align 4
	%216 = call {i64, i64} @os.write_string(i32 %215, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$1c, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; t
	%217 = bitcast %runtime.Type_Info** %15 to %..rawptr
	%218 = call %..rawptr @mem.zero(%..rawptr %217, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %15
	; i
	%219 = bitcast i64* %16 to %..rawptr
	%220 = call %..rawptr @mem.zero(%..rawptr %219, i64 8) noinline
	store i64 zeroinitializer, i64* %16
	; SelectorExpr
	%221 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %13, i64 0, i32 0
	%222 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %221, align 8
	%223 = bitcast i64* %17 to %..rawptr
	%224 = call %..rawptr @mem.zero(%..rawptr %223, i64 8) noinline
	store i64 zeroinitializer, i64* %17
	%225 = extractvalue {%runtime.Type_Info**, i64} %222, 1
	store i64 %225, i64* %17
	%226 = bitcast i64* %18 to %..rawptr
	%227 = call %..rawptr @mem.zero(%..rawptr %226, i64 8) noinline
	store i64 zeroinitializer, i64* %18
	store i64 -1, i64* %18
	br label %for.index.loop-45

for.index.loop-45:
	%228 = load i64, i64* %18, align 8
	%229 = add i64 %228, 1
	store i64 %229, i64* %18
	%230 = load i64, i64* %17, align 8
	%231 = icmp slt i64 %229, %230
	br i1 %231, label %for.index.body-46, label %for.index.done-49

for.index.body-46:
	%232 = load i64, i64* %18, align 8
	%233 = extractvalue {%runtime.Type_Info**, i64} %222, 0
	%234 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %233, i64 %232
	%235 = load %runtime.Type_Info*, %runtime.Type_Info** %234, align 8
	store %runtime.Type_Info* %235, %runtime.Type_Info** %15
	store i64 %232, i64* %16
	; IfStmt
	%236 = load i64, i64* %16, align 8
	%237 = icmp sgt i64 %236, 0
	%238 = zext i1 %237 to i8
	%239 = trunc i8 %238 to i1
	br i1 %239, label %if.then-47, label %if.done-48

if.then-47:
	; SelectorExpr
	%240 = load i32, i32* %0, align 4
	%241 = call {i64, i64} @os.write_string(i32 %240, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1d, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-48

if.done-48:
	%242 = load i32, i32* %0, align 4
	%243 = load %runtime.Type_Info*, %runtime.Type_Info** %15, align 8
	call void @runtime.print_type(i32 %242, %runtime.Type_Info* %243, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-45

for.index.done-49:
	; SelectorExpr
	%244 = load i32, i32* %0, align 4
	%245 = call {i64, i64} @os.write_string(i32 %244, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$1e, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-50

if.done-50:
	; IfStmt
	; SelectorExpr
	%246 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 1
	%247 = load %runtime.Type_Info*, %runtime.Type_Info** %246, align 8
	%248 = icmp ne %runtime.Type_Info* %247, zeroinitializer
	%249 = zext i1 %248 to i8
	%250 = trunc i8 %249 to i1
	br i1 %250, label %if.then-51, label %if.done-52

if.then-51:
	; SelectorExpr
	%251 = load i32, i32* %0, align 4
	%252 = call {i64, i64} @os.write_string(i32 %251, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$1f, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%253 = load i32, i32* %0, align 4
	; SelectorExpr
	%254 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 1
	%255 = load %runtime.Type_Info*, %runtime.Type_Info** %254, align 8
	call void @runtime.print_type(i32 %253, %runtime.Type_Info* %255, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-52

if.done-52:
	br label %typeswitch.done-119

typeswitch.next-53:
	%256 = icmp eq i8 %66, 12
	br i1 %256, label %typeswitch.body-67, label %typeswitch.next-66

typeswitch.body-54:
	%257 = bitcast %..rawptr %67 to %runtime.Type_Info_Tuple*
	%258 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %257, align 8
	store %runtime.Type_Info_Tuple %258, %runtime.Type_Info_Tuple* %19
	; count
	; SelectorExpr
	%259 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %19, i64 0, i32 1
	%260 = load {%..string*, i64}, {%..string*, i64}* %259, align 8
	%261 = extractvalue {%..string*, i64} %260, 1
	store i64 %261, i64* %20
	; IfStmt
	%262 = load i64, i64* %20, align 8
	%263 = icmp ne i64 %262, 1
	%264 = zext i1 %263 to i8
	%265 = trunc i8 %264 to i1
	br i1 %265, label %if.then-55, label %if.done-56

if.then-55:
	; SelectorExpr
	%266 = load i32, i32* %0, align 4
	%267 = call {i64, i64} @os.write_string(i32 %266, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$20, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-56

if.done-56:
	; RangeStmt
	; name
	%268 = bitcast %..string* %21 to %..rawptr
	%269 = call %..rawptr @mem.zero(%..rawptr %268, i64 16) noinline
	store %..string zeroinitializer, %..string* %21
	; i
	%270 = bitcast i64* %22 to %..rawptr
	%271 = call %..rawptr @mem.zero(%..rawptr %270, i64 8) noinline
	store i64 zeroinitializer, i64* %22
	; SelectorExpr
	%272 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %19, i64 0, i32 1
	%273 = load {%..string*, i64}, {%..string*, i64}* %272, align 8
	%274 = bitcast i64* %23 to %..rawptr
	%275 = call %..rawptr @mem.zero(%..rawptr %274, i64 8) noinline
	store i64 zeroinitializer, i64* %23
	%276 = extractvalue {%..string*, i64} %273, 1
	store i64 %276, i64* %23
	%277 = bitcast i64* %24 to %..rawptr
	%278 = call %..rawptr @mem.zero(%..rawptr %277, i64 8) noinline
	store i64 zeroinitializer, i64* %24
	store i64 -1, i64* %24
	br label %for.index.loop-57

for.index.loop-57:
	%279 = load i64, i64* %24, align 8
	%280 = add i64 %279, 1
	store i64 %280, i64* %24
	%281 = load i64, i64* %23, align 8
	%282 = icmp slt i64 %280, %281
	br i1 %282, label %for.index.body-58, label %for.index.done-63

for.index.body-58:
	%283 = load i64, i64* %24, align 8
	%284 = extractvalue {%..string*, i64} %273, 0
	%285 = getelementptr inbounds %..string, %..string* %284, i64 %283
	%286 = load %..string, %..string* %285, align 8
	store %..string %286, %..string* %21
	store i64 %283, i64* %22
	; IfStmt
	%287 = load i64, i64* %22, align 8
	%288 = icmp sgt i64 %287, 0
	%289 = zext i1 %288 to i8
	%290 = trunc i8 %289 to i1
	br i1 %290, label %if.then-59, label %if.done-60

if.then-59:
	; SelectorExpr
	%291 = load i32, i32* %0, align 4
	%292 = call {i64, i64} @os.write_string(i32 %291, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$21, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-60

if.done-60:
	; t
	; IndexExpr
	; SelectorExpr
	%293 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %19, i64 0, i32 0
	%294 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %293, align 8
	%295 = extractvalue {%runtime.Type_Info**, i64} %294, 0
	%296 = load i64, i64* %22, align 8
	%297 = extractvalue {%runtime.Type_Info**, i64} %294, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$22, i64 0, i32 0), i64 62}, i64 126, i64 20, i64 %296, i64 %297)
	%298 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %295, i64 %296
	%299 = load %runtime.Type_Info*, %runtime.Type_Info** %298, align 8
	store %runtime.Type_Info* %299, %runtime.Type_Info** %25
	; IfStmt
	%300 = load %..string, %..string* %21, align 8
	%301 = extractvalue %..string %300, 1
	%302 = icmp sgt i64 %301, 0
	%303 = zext i1 %302 to i8
	%304 = trunc i8 %303 to i1
	br i1 %304, label %if.then-61, label %if.done-62

if.then-61:
	; SelectorExpr
	%305 = load i32, i32* %0, align 4
	%306 = load %..string, %..string* %21, align 8
	%307 = call {i64, i64} @os.write_string(i32 %305, %..string %306, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%308 = load i32, i32* %0, align 4
	%309 = call {i64, i64} @os.write_string(i32 %308, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$23, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-62

if.done-62:
	%310 = load i32, i32* %0, align 4
	%311 = load %runtime.Type_Info*, %runtime.Type_Info** %25, align 8
	call void @runtime.print_type(i32 %310, %runtime.Type_Info* %311, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-57

for.index.done-63:
	; IfStmt
	%312 = load i64, i64* %20, align 8
	%313 = icmp ne i64 %312, 1
	%314 = zext i1 %313 to i8
	%315 = trunc i8 %314 to i1
	br i1 %315, label %if.then-64, label %if.done-65

if.then-64:
	; SelectorExpr
	%316 = load i32, i32* %0, align 4
	%317 = call {i64, i64} @os.write_string(i32 %316, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$24, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-65

if.done-65:
	br label %typeswitch.done-119

typeswitch.next-66:
	%318 = icmp eq i8 %66, 13
	br i1 %318, label %typeswitch.body-69, label %typeswitch.next-68

typeswitch.body-67:
	%319 = bitcast %..rawptr %67 to %runtime.Type_Info_Array*
	%320 = load %runtime.Type_Info_Array, %runtime.Type_Info_Array* %319, align 8
	store %runtime.Type_Info_Array %320, %runtime.Type_Info_Array* %26
	; SelectorExpr
	%321 = load i32, i32* %0, align 4
	%322 = call {i64, i64} @os.write_string(i32 %321, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$25, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%323 = load i32, i32* %0, align 4
	; SelectorExpr
	%324 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %26, i64 0, i32 2
	%325 = load i64, i64* %324, align 8
	%326 = bitcast i64 %325 to i64
	call void @runtime.print_u64(i32 %323, i64 %326, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%327 = load i32, i32* %0, align 4
	%328 = call {i64, i64} @os.write_string(i32 %327, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$26, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%329 = load i32, i32* %0, align 4
	; SelectorExpr
	%330 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %26, i64 0, i32 0
	%331 = load %runtime.Type_Info*, %runtime.Type_Info** %330, align 8
	call void @runtime.print_type(i32 %329, %runtime.Type_Info* %331, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-68:
	%332 = icmp eq i8 %66, 14
	br i1 %332, label %typeswitch.body-71, label %typeswitch.next-70

typeswitch.body-69:
	%333 = bitcast %..rawptr %67 to %runtime.Type_Info_Dynamic_Array*
	%334 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %333, align 8
	store %runtime.Type_Info_Dynamic_Array %334, %runtime.Type_Info_Dynamic_Array* %27
	; SelectorExpr
	%335 = load i32, i32* %0, align 4
	%336 = call {i64, i64} @os.write_string(i32 %335, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$27, i64 0, i32 0), i64 9}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%337 = load i32, i32* %0, align 4
	; SelectorExpr
	%338 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %27, i64 0, i32 0
	%339 = load %runtime.Type_Info*, %runtime.Type_Info** %338, align 8
	call void @runtime.print_type(i32 %337, %runtime.Type_Info* %339, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-70:
	%340 = icmp eq i8 %66, 19
	br i1 %340, label %typeswitch.body-73, label %typeswitch.next-72

typeswitch.body-71:
	%341 = bitcast %..rawptr %67 to %runtime.Type_Info_Slice*
	%342 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %341, align 8
	store %runtime.Type_Info_Slice %342, %runtime.Type_Info_Slice* %28
	; SelectorExpr
	%343 = load i32, i32* %0, align 4
	%344 = call {i64, i64} @os.write_string(i32 %343, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$28, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%345 = load i32, i32* %0, align 4
	; SelectorExpr
	%346 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %28, i64 0, i32 0
	%347 = load %runtime.Type_Info*, %runtime.Type_Info** %346, align 8
	call void @runtime.print_type(i32 %345, %runtime.Type_Info* %347, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-72:
	%348 = icmp eq i8 %66, 16
	br i1 %348, label %typeswitch.body-75, label %typeswitch.next-74

typeswitch.body-73:
	%349 = bitcast %..rawptr %67 to %runtime.Type_Info_Map*
	%350 = load %runtime.Type_Info_Map, %runtime.Type_Info_Map* %349, align 8
	store %runtime.Type_Info_Map %350, %runtime.Type_Info_Map* %29
	; SelectorExpr
	%351 = load i32, i32* %0, align 4
	%352 = call {i64, i64} @os.write_string(i32 %351, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$29, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%353 = load i32, i32* %0, align 4
	; SelectorExpr
	%354 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %29, i64 0, i32 0
	%355 = load %runtime.Type_Info*, %runtime.Type_Info** %354, align 8
	call void @runtime.print_type(i32 %353, %runtime.Type_Info* %355, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%356 = load i32, i32* %0, align 4
	%357 = call {i64, i64} @os.write_byte(i32 %356, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%358 = load i32, i32* %0, align 4
	; SelectorExpr
	%359 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %29, i64 0, i32 1
	%360 = load %runtime.Type_Info*, %runtime.Type_Info** %359, align 8
	call void @runtime.print_type(i32 %358, %runtime.Type_Info* %360, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-74:
	%361 = icmp eq i8 %66, 17
	br i1 %361, label %typeswitch.body-88, label %typeswitch.next-87

typeswitch.body-75:
	%362 = bitcast %..rawptr %67 to %runtime.Type_Info_Struct*
	%363 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %362, align 8
	store %runtime.Type_Info_Struct %363, %runtime.Type_Info_Struct* %30
	; SelectorExpr
	%364 = load i32, i32* %0, align 4
	%365 = call {i64, i64} @os.write_string(i32 %364, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$2a, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%366 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 4
	%367 = load i8, i8* %366, align 1
	%368 = trunc i8 %367 to i1
	br i1 %368, label %if.then-76, label %if.done-77

if.then-76:
	; SelectorExpr
	%369 = load i32, i32* %0, align 4
	%370 = call {i64, i64} @os.write_string(i32 %369, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$2b, i64 0, i32 0), i64 8}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-77

if.done-77:
	; IfStmt
	; SelectorExpr
	%371 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 5
	%372 = load i8, i8* %371, align 1
	%373 = trunc i8 %372 to i1
	br i1 %373, label %if.then-78, label %if.done-79

if.then-78:
	; SelectorExpr
	%374 = load i32, i32* %0, align 4
	%375 = call {i64, i64} @os.write_string(i32 %374, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$2c, i64 0, i32 0), i64 11}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-79

if.done-79:
	; IfStmt
	; SelectorExpr
	%376 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 6
	%377 = load i8, i8* %376, align 1
	%378 = trunc i8 %377 to i1
	br i1 %378, label %if.then-80, label %if.done-81

if.then-80:
	; SelectorExpr
	%379 = load i32, i32* %0, align 4
	%380 = call {i64, i64} @os.write_string(i32 %379, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$2d, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%381 = load i32, i32* %0, align 4
	; SelectorExpr
	%382 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%383 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %382, i64 0
	%384 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %383, i64 0, i32 1
	%385 = load i64, i64* %384, align 8
	%386 = bitcast i64 %385 to i64
	call void @runtime.print_u64(i32 %381, i64 %386, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%387 = load i32, i32* %0, align 4
	%388 = call {i64, i64} @os.write_byte(i32 %387, i8 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-81

if.done-81:
	; SelectorExpr
	%389 = load i32, i32* %0, align 4
	%390 = call {i64, i64} @os.write_byte(i32 %389, i8 123, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; name
	%391 = bitcast %..string* %31 to %..rawptr
	%392 = call %..rawptr @mem.zero(%..rawptr %391, i64 16) noinline
	store %..string zeroinitializer, %..string* %31
	; i
	%393 = bitcast i64* %32 to %..rawptr
	%394 = call %..rawptr @mem.zero(%..rawptr %393, i64 8) noinline
	store i64 zeroinitializer, i64* %32
	; SelectorExpr
	%395 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 1
	%396 = load {%..string*, i64}, {%..string*, i64}* %395, align 8
	%397 = bitcast i64* %33 to %..rawptr
	%398 = call %..rawptr @mem.zero(%..rawptr %397, i64 8) noinline
	store i64 zeroinitializer, i64* %33
	%399 = extractvalue {%..string*, i64} %396, 1
	store i64 %399, i64* %33
	%400 = bitcast i64* %34 to %..rawptr
	%401 = call %..rawptr @mem.zero(%..rawptr %400, i64 8) noinline
	store i64 zeroinitializer, i64* %34
	store i64 -1, i64* %34
	br label %for.index.loop-82

for.index.loop-82:
	%402 = load i64, i64* %34, align 8
	%403 = add i64 %402, 1
	store i64 %403, i64* %34
	%404 = load i64, i64* %33, align 8
	%405 = icmp slt i64 %403, %404
	br i1 %405, label %for.index.body-83, label %for.index.done-86

for.index.body-83:
	%406 = load i64, i64* %34, align 8
	%407 = extractvalue {%..string*, i64} %396, 0
	%408 = getelementptr inbounds %..string, %..string* %407, i64 %406
	%409 = load %..string, %..string* %408, align 8
	store %..string %409, %..string* %31
	store i64 %406, i64* %32
	; IfStmt
	%410 = load i64, i64* %32, align 8
	%411 = icmp sgt i64 %410, 0
	%412 = zext i1 %411 to i8
	%413 = trunc i8 %412 to i1
	br i1 %413, label %if.then-84, label %if.done-85

if.then-84:
	; SelectorExpr
	%414 = load i32, i32* %0, align 4
	%415 = call {i64, i64} @os.write_string(i32 %414, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$2e, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-85

if.done-85:
	; SelectorExpr
	%416 = load i32, i32* %0, align 4
	%417 = load %..string, %..string* %31, align 8
	%418 = call {i64, i64} @os.write_string(i32 %416, %..string %417, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%419 = load i32, i32* %0, align 4
	%420 = call {i64, i64} @os.write_string(i32 %419, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$2f, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%421 = load i32, i32* %0, align 4
	; IndexExpr
	; SelectorExpr
	%422 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 0
	%423 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %422, align 8
	%424 = extractvalue {%runtime.Type_Info**, i64} %423, 0
	%425 = load i64, i64* %32, align 8
	%426 = extractvalue {%runtime.Type_Info**, i64} %423, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$30, i64 0, i32 0), i64 62}, i64 168, i64 30, i64 %425, i64 %426)
	%427 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %424, i64 %425
	%428 = load %runtime.Type_Info*, %runtime.Type_Info** %427, align 8
	call void @runtime.print_type(i32 %421, %runtime.Type_Info* %428, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-82

for.index.done-86:
	; SelectorExpr
	%429 = load i32, i32* %0, align 4
	%430 = call {i64, i64} @os.write_byte(i32 %429, i8 125, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-87:
	%431 = icmp eq i8 %66, 18
	br i1 %431, label %typeswitch.body-95, label %typeswitch.next-94

typeswitch.body-88:
	%432 = bitcast %..rawptr %67 to %runtime.Type_Info_Union*
	%433 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %432, align 8
	store %runtime.Type_Info_Union %433, %runtime.Type_Info_Union* %35
	; SelectorExpr
	%434 = load i32, i32* %0, align 4
	%435 = call {i64, i64} @os.write_string(i32 %434, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$31, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; variant
	%436 = bitcast %runtime.Type_Info** %36 to %..rawptr
	%437 = call %..rawptr @mem.zero(%..rawptr %436, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %36
	; i
	%438 = bitcast i64* %37 to %..rawptr
	%439 = call %..rawptr @mem.zero(%..rawptr %438, i64 8) noinline
	store i64 zeroinitializer, i64* %37
	; SelectorExpr
	%440 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %35, i64 0, i32 0
	%441 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %440, align 8
	%442 = bitcast i64* %38 to %..rawptr
	%443 = call %..rawptr @mem.zero(%..rawptr %442, i64 8) noinline
	store i64 zeroinitializer, i64* %38
	%444 = extractvalue {%runtime.Type_Info**, i64} %441, 1
	store i64 %444, i64* %38
	%445 = bitcast i64* %39 to %..rawptr
	%446 = call %..rawptr @mem.zero(%..rawptr %445, i64 8) noinline
	store i64 zeroinitializer, i64* %39
	store i64 -1, i64* %39
	br label %for.index.loop-89

for.index.loop-89:
	%447 = load i64, i64* %39, align 8
	%448 = add i64 %447, 1
	store i64 %448, i64* %39
	%449 = load i64, i64* %38, align 8
	%450 = icmp slt i64 %448, %449
	br i1 %450, label %for.index.body-90, label %for.index.done-93

for.index.body-90:
	%451 = load i64, i64* %39, align 8
	%452 = extractvalue {%runtime.Type_Info**, i64} %441, 0
	%453 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %452, i64 %451
	%454 = load %runtime.Type_Info*, %runtime.Type_Info** %453, align 8
	store %runtime.Type_Info* %454, %runtime.Type_Info** %36
	store i64 %451, i64* %37
	; IfStmt
	%455 = load i64, i64* %37, align 8
	%456 = icmp sgt i64 %455, 0
	%457 = zext i1 %456 to i8
	%458 = trunc i8 %457 to i1
	br i1 %458, label %if.then-91, label %if.done-92

if.then-91:
	; SelectorExpr
	%459 = load i32, i32* %0, align 4
	%460 = call {i64, i64} @os.write_string(i32 %459, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$32, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-92

if.done-92:
	%461 = load i32, i32* %0, align 4
	%462 = load %runtime.Type_Info*, %runtime.Type_Info** %36, align 8
	call void @runtime.print_type(i32 %461, %runtime.Type_Info* %462, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-89

for.index.done-93:
	; SelectorExpr
	%463 = load i32, i32* %0, align 4
	%464 = call {i64, i64} @os.write_string(i32 %463, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$33, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-94:
	%465 = icmp eq i8 %66, 20
	br i1 %465, label %typeswitch.body-102, label %typeswitch.next-101

typeswitch.body-95:
	%466 = bitcast %..rawptr %67 to %runtime.Type_Info_Enum*
	%467 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %466, align 8
	store %runtime.Type_Info_Enum %467, %runtime.Type_Info_Enum* %40
	; SelectorExpr
	%468 = load i32, i32* %0, align 4
	%469 = call {i64, i64} @os.write_string(i32 %468, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$34, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%470 = load i32, i32* %0, align 4
	; SelectorExpr
	%471 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %40, i64 0, i32 0
	%472 = load %runtime.Type_Info*, %runtime.Type_Info** %471, align 8
	call void @runtime.print_type(i32 %470, %runtime.Type_Info* %472, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%473 = load i32, i32* %0, align 4
	%474 = call {i64, i64} @os.write_string(i32 %473, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$35, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; name
	%475 = bitcast %..string* %41 to %..rawptr
	%476 = call %..rawptr @mem.zero(%..rawptr %475, i64 16) noinline
	store %..string zeroinitializer, %..string* %41
	; i
	%477 = bitcast i64* %42 to %..rawptr
	%478 = call %..rawptr @mem.zero(%..rawptr %477, i64 8) noinline
	store i64 zeroinitializer, i64* %42
	; SelectorExpr
	%479 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %40, i64 0, i32 1
	%480 = load {%..string*, i64}, {%..string*, i64}* %479, align 8
	%481 = bitcast i64* %43 to %..rawptr
	%482 = call %..rawptr @mem.zero(%..rawptr %481, i64 8) noinline
	store i64 zeroinitializer, i64* %43
	%483 = extractvalue {%..string*, i64} %480, 1
	store i64 %483, i64* %43
	%484 = bitcast i64* %44 to %..rawptr
	%485 = call %..rawptr @mem.zero(%..rawptr %484, i64 8) noinline
	store i64 zeroinitializer, i64* %44
	store i64 -1, i64* %44
	br label %for.index.loop-96

for.index.loop-96:
	%486 = load i64, i64* %44, align 8
	%487 = add i64 %486, 1
	store i64 %487, i64* %44
	%488 = load i64, i64* %43, align 8
	%489 = icmp slt i64 %487, %488
	br i1 %489, label %for.index.body-97, label %for.index.done-100

for.index.body-97:
	%490 = load i64, i64* %44, align 8
	%491 = extractvalue {%..string*, i64} %480, 0
	%492 = getelementptr inbounds %..string, %..string* %491, i64 %490
	%493 = load %..string, %..string* %492, align 8
	store %..string %493, %..string* %41
	store i64 %490, i64* %42
	; IfStmt
	%494 = load i64, i64* %42, align 8
	%495 = icmp sgt i64 %494, 0
	%496 = zext i1 %495 to i8
	%497 = trunc i8 %496 to i1
	br i1 %497, label %if.then-98, label %if.done-99

if.then-98:
	; SelectorExpr
	%498 = load i32, i32* %0, align 4
	%499 = call {i64, i64} @os.write_string(i32 %498, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$36, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-99

if.done-99:
	; SelectorExpr
	%500 = load i32, i32* %0, align 4
	%501 = load %..string, %..string* %41, align 8
	%502 = call {i64, i64} @os.write_string(i32 %500, %..string %501, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-96

for.index.done-100:
	; SelectorExpr
	%503 = load i32, i32* %0, align 4
	%504 = call {i64, i64} @os.write_string(i32 %503, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$37, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-101:
	%505 = icmp eq i8 %66, 21
	br i1 %505, label %typeswitch.body-111, label %typeswitch.next-110

typeswitch.body-102:
	%506 = bitcast %..rawptr %67 to %runtime.Type_Info_Bit_Field*
	%507 = load %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %506, align 8
	store %runtime.Type_Info_Bit_Field %507, %runtime.Type_Info_Bit_Field* %45
	; SelectorExpr
	%508 = load i32, i32* %0, align 4
	%509 = call {i64, i64} @os.write_string(i32 %508, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$38, i64 0, i32 0), i64 10}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%510 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%511 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %510, i64 0
	%512 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %511, i64 0, i32 1
	%513 = load i64, i64* %512, align 8
	%514 = icmp ne i64 %513, 1
	%515 = zext i1 %514 to i8
	%516 = trunc i8 %515 to i1
	br i1 %516, label %if.then-103, label %if.done-104

if.then-103:
	; SelectorExpr
	%517 = load i32, i32* %0, align 4
	%518 = call {i64, i64} @os.write_string(i32 %517, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$39, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%519 = load i32, i32* %0, align 4
	; SelectorExpr
	%520 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%521 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %520, i64 0
	%522 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %521, i64 0, i32 1
	%523 = load i64, i64* %522, align 8
	%524 = bitcast i64 %523 to i64
	call void @runtime.print_u64(i32 %519, i64 %524, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%525 = load i32, i32* %0, align 4
	%526 = call {i64, i64} @os.write_byte(i32 %525, i8 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-104

if.done-104:
	; SelectorExpr
	%527 = load i32, i32* %0, align 4
	%528 = call {i64, i64} @os.write_string(i32 %527, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$3a, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; name
	%529 = bitcast %..string* %46 to %..rawptr
	%530 = call %..rawptr @mem.zero(%..rawptr %529, i64 16) noinline
	store %..string zeroinitializer, %..string* %46
	; i
	%531 = bitcast i64* %47 to %..rawptr
	%532 = call %..rawptr @mem.zero(%..rawptr %531, i64 8) noinline
	store i64 zeroinitializer, i64* %47
	; SelectorExpr
	%533 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %45, i64 0, i32 0
	%534 = load {%..string*, i64}, {%..string*, i64}* %533, align 8
	%535 = bitcast i64* %48 to %..rawptr
	%536 = call %..rawptr @mem.zero(%..rawptr %535, i64 8) noinline
	store i64 zeroinitializer, i64* %48
	%537 = extractvalue {%..string*, i64} %534, 1
	store i64 %537, i64* %48
	%538 = bitcast i64* %49 to %..rawptr
	%539 = call %..rawptr @mem.zero(%..rawptr %538, i64 8) noinline
	store i64 zeroinitializer, i64* %49
	store i64 -1, i64* %49
	br label %for.index.loop-105

for.index.loop-105:
	%540 = load i64, i64* %49, align 8
	%541 = add i64 %540, 1
	store i64 %541, i64* %49
	%542 = load i64, i64* %48, align 8
	%543 = icmp slt i64 %541, %542
	br i1 %543, label %for.index.body-106, label %for.index.done-109

for.index.body-106:
	%544 = load i64, i64* %49, align 8
	%545 = extractvalue {%..string*, i64} %534, 0
	%546 = getelementptr inbounds %..string, %..string* %545, i64 %544
	%547 = load %..string, %..string* %546, align 8
	store %..string %547, %..string* %46
	store i64 %544, i64* %47
	; IfStmt
	%548 = load i64, i64* %47, align 8
	%549 = icmp sgt i64 %548, 0
	%550 = zext i1 %549 to i8
	%551 = trunc i8 %550 to i1
	br i1 %551, label %if.then-107, label %if.done-108

if.then-107:
	; SelectorExpr
	%552 = load i32, i32* %0, align 4
	%553 = call {i64, i64} @os.write_string(i32 %552, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$3b, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-108

if.done-108:
	; SelectorExpr
	%554 = load i32, i32* %0, align 4
	%555 = load %..string, %..string* %46, align 8
	%556 = call {i64, i64} @os.write_string(i32 %554, %..string %555, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%557 = load i32, i32* %0, align 4
	%558 = call {i64, i64} @os.write_string(i32 %557, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$3c, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%559 = load i32, i32* %0, align 4
	; IndexExpr
	; SelectorExpr
	%560 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %45, i64 0, i32 1
	%561 = load {i32*, i64}, {i32*, i64}* %560, align 8
	%562 = extractvalue {i32*, i64} %561, 0
	%563 = load i64, i64* %47, align 8
	%564 = extractvalue {i32*, i64} %561, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$3d, i64 0, i32 0), i64 62}, i64 202, i64 32, i64 %563, i64 %564)
	%565 = getelementptr inbounds i32, i32* %562, i64 %563
	%566 = load i32, i32* %565, align 4
	%567 = sext i32 %566 to i64
	call void @runtime.print_u64(i32 %559, i64 %567, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-105

for.index.done-109:
	; SelectorExpr
	%568 = load i32, i32* %0, align 4
	%569 = call {i64, i64} @os.write_string(i32 %568, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$3e, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.next-110:
	br label %typeswitch.done-119

typeswitch.body-111:
	%570 = bitcast %..rawptr %67 to %runtime.Type_Info_Bit_Set*
	%571 = load %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %570, align 8
	store %runtime.Type_Info_Bit_Set %571, %runtime.Type_Info_Bit_Set* %50
	; SelectorExpr
	%572 = load i32, i32* %0, align 4
	%573 = call {i64, i64} @os.write_string(i32 %572, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$3f, i64 0, i32 0), i64 8}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; TypeSwitchStmt
	; SelectorExpr
	; SelectorExpr
	%574 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 0
	%575 = load %runtime.Type_Info*, %runtime.Type_Info** %574, align 8
	%576 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %575)
	%577 = bitcast %runtime.Type_Info** %51 to %..rawptr
	%578 = call %..rawptr @mem.zero(%..rawptr %577, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %51
	store %runtime.Type_Info* %576, %runtime.Type_Info** %51
	%579 = load %runtime.Type_Info*, %runtime.Type_Info** %51, align 8
	%580 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %579, i64 0
	%581 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %580, i64 0, i32 3
	%582 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %581, align 8
	; get union's tag
	%583 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %581, i64 0, i32 2 ; UnionTagPtr
	%584 = load i8, i8* %583, align 1
	%585 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %581 to %..rawptr
	%586 = icmp eq i8 %584, 18
	br i1 %586, label %typeswitch.body-113, label %typeswitch.next-112

typeswitch.next-112:
	%587 = icmp eq i8 %584, 3
	br i1 %587, label %typeswitch.body-115, label %typeswitch.next-114

typeswitch.body-113:
	%588 = bitcast %..rawptr %585 to %runtime.Type_Info_Enum*
	%589 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %588, align 8
	store %runtime.Type_Info_Enum %589, %runtime.Type_Info_Enum* %52
	%590 = load i32, i32* %0, align 4
	; SelectorExpr
	%591 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 0
	%592 = load %runtime.Type_Info*, %runtime.Type_Info** %591, align 8
	call void @runtime.print_type(i32 %590, %runtime.Type_Info* %592, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-116

typeswitch.next-114:
	store {[0 x <8 x i8>], [72 x i8], i8} %582, {[0 x <8 x i8>], [72 x i8], i8}* %54
	%593 = load i32, i32* %0, align 4
	; SelectorExpr
	%594 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 2
	%595 = load i64, i64* %594, align 8
	call void @runtime.print_i64(i32 %593, i64 %595, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%596 = load i32, i32* %0, align 4
	%597 = call {i64, i64} @os.write_string(i32 %596, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$40, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%598 = load i32, i32* %0, align 4
	; SelectorExpr
	%599 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 3
	%600 = load i64, i64* %599, align 8
	call void @runtime.print_i64(i32 %598, i64 %600, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-116

typeswitch.body-115:
	%601 = bitcast %..rawptr %585 to %runtime.Type_Info_Rune*
	%602 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %601, align 1
	store %runtime.Type_Info_Rune %602, %runtime.Type_Info_Rune* %53
	; SelectorExpr
	%603 = load i32, i32* %0, align 4
	; SelectorExpr
	%604 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 2
	%605 = load i64, i64* %604, align 8
	%606 = trunc i64 %605 to i32
	call void @os.write_encoded_rune(i32 %603, i32 %606, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%607 = load i32, i32* %0, align 4
	%608 = call {i64, i64} @os.write_string(i32 %607, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$41, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%609 = load i32, i32* %0, align 4
	; SelectorExpr
	%610 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 3
	%611 = load i64, i64* %610, align 8
	%612 = trunc i64 %611 to i32
	call void @os.write_encoded_rune(i32 %609, i32 %612, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-116

typeswitch.done-116:
	; IfStmt
	; SelectorExpr
	%613 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 1
	%614 = load %runtime.Type_Info*, %runtime.Type_Info** %613, align 8
	%615 = icmp ne %runtime.Type_Info* %614, zeroinitializer
	%616 = zext i1 %615 to i8
	%617 = trunc i8 %616 to i1
	br i1 %617, label %if.then-117, label %if.done-118

if.then-117:
	; SelectorExpr
	%618 = load i32, i32* %0, align 4
	%619 = call {i64, i64} @os.write_string(i32 %618, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$42, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%620 = load i32, i32* %0, align 4
	; SelectorExpr
	%621 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 1
	%622 = load %runtime.Type_Info*, %runtime.Type_Info** %621, align 8
	call void @runtime.print_type(i32 %620, %runtime.Type_Info* %622, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-118

if.done-118:
	; SelectorExpr
	%623 = load i32, i32* %0, align 4
	%624 = call {i64, i64} @os.write_byte(i32 %623, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-119

typeswitch.done-119:
	ret void
}

define i8 @runtime.string_eq(%..string %a, %..string %b) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	store %..string %a, %..string* %0
	store %..string %b, %..string* %1
	; SwitchStmt
	%2 = load %..string, %..string* %0, align 8
	%3 = extractvalue %..string %2, 1
	%4 = load %..string, %..string* %1, align 8
	%5 = extractvalue %..string %4, 1
	%6 = icmp ne i64 %3, %5
	%7 = zext i1 %6 to i8
	%8 = icmp eq i8 1, %7
	br i1 %8, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%9 = load %..string, %..string* %0, align 8
	%10 = extractvalue %..string %9, 1
	%11 = icmp eq i64 %10, 0
	%12 = zext i1 %11 to i8
	%13 = icmp eq i8 1, %12
	br i1 %13, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	; ReturnStmt
	ret i8 0

switch.case.next-3:
	; IndexExpr
	%14 = load %..string, %..string* %0, align 8
	%15 = extractvalue %..string %14, 0
	%16 = extractvalue %..string %14, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$43, i64 0, i32 0), i64 62}, i64 233, i64 10, i64 0, i64 %16)
	%17 = getelementptr inbounds i8, i8* %15, i64 0
	; IndexExpr
	%18 = load %..string, %..string* %1, align 8
	%19 = extractvalue %..string %18, 0
	%20 = extractvalue %..string %18, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$44, i64 0, i32 0), i64 62}, i64 233, i64 19, i64 0, i64 %20)
	%21 = getelementptr inbounds i8, i8* %19, i64 0
	%22 = icmp eq i8* %17, %21
	%23 = zext i1 %22 to i8
	%24 = icmp eq i8 1, %23
	br i1 %24, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	; ReturnStmt
	ret i8 1

switch.case.next-5:
	; ReturnStmt
	%25 = load %..string, %..string* %0, align 8
	%26 = load %..string, %..string* %1, align 8
	%27 = call i64 @runtime.string_cmp(%..string %25, %..string %26)
	%28 = icmp eq i64 %27, 0
	%29 = zext i1 %28 to i8
	ret i8 %29

switch.fall.body-6:
	; ReturnStmt
	ret i8 1
}

define i64 @runtime.string_cmp(%..string %a, %..string %b) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	store %..string %a, %..string* %0
	store %..string %b, %..string* %1
	; ReturnStmt
	; SelectorExpr
	; IndexExpr
	%2 = load %..string, %..string* %0, align 8
	%3 = extractvalue %..string %2, 0
	%4 = extractvalue %..string %2, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$45, i64 0, i32 0), i64 62}, i64 239, i64 34, i64 0, i64 %4)
	%5 = getelementptr inbounds i8, i8* %3, i64 0
	; IndexExpr
	%6 = load %..string, %..string* %1, align 8
	%7 = extractvalue %..string %6, 0
	%8 = extractvalue %..string %6, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$46, i64 0, i32 0), i64 62}, i64 239, i64 41, i64 0, i64 %8)
	%9 = getelementptr inbounds i8, i8* %7, i64 0
	; min
	%10 = load %..string, %..string* %0, align 8
	%11 = extractvalue %..string %10, 1
	%12 = load %..string, %..string* %1, align 8
	%13 = extractvalue %..string %12, 1
	%14 = icmp slt i64 %11, %13
	%15 = select i1 %14, i64 %11, i64 %13
	%16 = call i64 @mem.compare_byte_ptrs(i8* %5, i8* %9, i64 %15)
	ret i64 %16
}

define i8 @runtime.string_ne(%..string %a, %..string %b) alwaysinline #1 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	store %..string %a, %..string* %0
	store %..string %b, %..string* %1
	; ReturnStmt
	%2 = load %..string, %..string* %0, align 8
	%3 = load %..string, %..string* %1, align 8
	%4 = call i8 @runtime.string_eq(%..string %2, %..string %3) alwaysinline
	%5 = icmp eq i8 %4, 0
	%6 = zext i1 %5 to i8
	ret i8 %6
}

define i64 @runtime.cstring_len(i8* %s) #0 {
decls-0:
	%0 = alloca i8*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8*, align 16
	store i8* %s, i8** %0
	; n
	store i64 0, i64* %1
	; ForStmt
	; p
	%3 = load i8*, i8** %0, align 8
	%4 = bitcast i8* %3 to i8*
	store i8* %4, i8** %2
	br label %for.loop-1

for.loop-1:
	%5 = load i8*, i8** %2, align 8
	%6 = icmp ne i8* %5, zeroinitializer
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	br i1 %8, label %cmp.and-2, label %for.done-4

cmp.and-2:
	%9 = load i8*, i8** %2, align 8
	%10 = getelementptr inbounds i8, i8* %9, i64 0
	%11 = load i8, i8* %10, align 1
	%12 = icmp ne i8 %11, 0
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %for.body-3, label %for.done-4

for.body-3:
	; AssignStmt
	%15 = load i64, i64* %1, align 8
	%16 = add i64 %15, 1
	store i64 %16, i64* %1
	; AssignStmt
	; SelectorExpr
	%17 = load i8*, i8** %2, align 8
	%18 = call i8* @mem.ptr_offset-13939(i8* %17, i64 1)
	store i8* %18, i8** %2
	br label %for.loop-1

for.done-4:
	; ReturnStmt
	%19 = load i64, i64* %1, align 8
	ret i64 %19
}

define %..string @runtime.cstring_to_string(i8* %s) #0 {
decls-0:
	%0 = alloca i8*, align 16
	%1 = alloca i8*, align 16
	%2 = alloca i64, align 16
	%3 = alloca %mem.Raw_String, align 16
	store i8* %s, i8** %0
	; IfStmt
	%4 = load i8*, i8** %0, align 8
	%5 = bitcast i8* %4 to i8*
	%6 = bitcast %..rawptr null to i8*
	%7 = icmp eq i8* %5, %6
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	br i1 %9, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %..string zeroinitializer

if.done-2:
	; ptr
	%10 = load i8*, i8** %0, align 8
	%11 = bitcast i8* %10 to i8*
	store i8* %11, i8** %1
	; n
	%12 = load i8*, i8** %0, align 8
	%13 = call i64 @runtime.cstring_len(i8* %12)
	store i64 %13, i64* %2
	; ReturnStmt
	; CompoundLit
	%14 = bitcast %mem.Raw_String* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 16) noinline
	store %mem.Raw_String zeroinitializer, %mem.Raw_String* %3
	store %mem.Raw_String {i8* zeroinitializer, i64 zeroinitializer}, %mem.Raw_String* %3
	%16 = load i8*, i8** %1, align 8
	%17 = getelementptr inbounds %mem.Raw_String, %mem.Raw_String* %3, i64 0, i32 0
	store i8* %16, i8** %17
	%18 = load i64, i64* %2, align 8
	%19 = getelementptr inbounds %mem.Raw_String, %mem.Raw_String* %3, i64 0, i32 1
	store i64 %18, i64* %19
	%20 = load %mem.Raw_String, %mem.Raw_String* %3, align 8
	%21 = bitcast %mem.Raw_String* %3 to %..string*
	%22 = load %..string, %..string* %21, align 8
	ret %..string %22
}

define void @runtime.bounds_check_error(%..string %file, i64 %line, i64 %column, i64 %index, i64 %count) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i32, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca %runtime.Context, align 16
	%8 = bitcast %runtime.Context* %7 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %7
	%10 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %10, %runtime.Context* %7
	call void @runtime.__init_context(%runtime.Context* %7)
	%11 = alloca %runtime.Source_Code_Location, align 16
	store %..string %file, %..string* %0
	store i64 %line, i64* %1
	store i64 %column, i64* %2
	store i64 %index, i64* %3
	store i64 %count, i64* %4
	; IfStmt
	%12 = load i64, i64* %3, align 8
	%13 = icmp sle i64 0, %12
	%14 = zext i1 %13 to i8
	%15 = trunc i8 %14 to i1
	br i1 %15, label %cmp.and-1, label %if.done-3

cmp.and-1:
	%16 = load i64, i64* %3, align 8
	%17 = load i64, i64* %4, align 8
	%18 = icmp slt i64 %16, %17
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	; fd
	; SelectorExpr
	%21 = load i32, i32* @os.stderr, align 4
	store i32 %21, i32* %5
	%22 = load i32, i32* %5, align 4
	; CompoundLit
	%23 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %..string zeroinitializer}, %runtime.Source_Code_Location* %6
	%25 = load %..string, %..string* %0, align 8
	%26 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %6, i64 0, i32 0
	store %..string %25, %..string* %26
	%27 = load i64, i64* %1, align 8
	%28 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %6, i64 0, i32 1
	store i64 %27, i64* %28
	%29 = load i64, i64* %2, align 8
	%30 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %6, i64 0, i32 2
	store i64 %29, i64* %30
	%31 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %6, align 8
	%32 = bitcast %runtime.Source_Code_Location* %11 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %11
	store %runtime.Source_Code_Location %31, %runtime.Source_Code_Location* %11
	call void @runtime.print_caller_location(i32 %22, %runtime.Source_Code_Location* %11, %runtime.Context* noalias nonnull nocapture inreg %7)
	; SelectorExpr
	%34 = load i32, i32* %5, align 4
	%35 = call {i64, i64} @os.write_string(i32 %34, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$47, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %7)
	%36 = load i32, i32* %5, align 4
	%37 = load i64, i64* %3, align 8
	%38 = bitcast i64 %37 to i64
	call void @runtime.print_i64(i32 %36, i64 %38, %runtime.Context* noalias nonnull nocapture inreg %7)
	; SelectorExpr
	%39 = load i32, i32* %5, align 4
	%40 = call {i64, i64} @os.write_string(i32 %39, %..string {i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$48, i64 0, i32 0), i64 26}, %runtime.Context* noalias nonnull nocapture inreg %7)
	%41 = load i32, i32* %5, align 4
	%42 = load i64, i64* %4, align 8
	%43 = bitcast i64 %42 to i64
	call void @runtime.print_i64(i32 %41, i64 %43, %runtime.Context* noalias nonnull nocapture inreg %7)
	; SelectorExpr
	%44 = load i32, i32* %5, align 4
	%45 = call {i64, i64} @os.write_byte(i32 %44, i8 10, %runtime.Context* noalias nonnull nocapture inreg %7)
	call ccc void @llvm.debugtrap()
	ret void
}

define void @runtime.slice_expr_error(%..string %file, i64 %line, i64 %column, i64 %lo, i64 %hi, i64 %len) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i32, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca %runtime.Context, align 16
	%9 = bitcast %runtime.Context* %8 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %8
	%11 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %11, %runtime.Context* %8
	call void @runtime.__init_context(%runtime.Context* %8)
	%12 = alloca %runtime.Source_Code_Location, align 16
	store %..string %file, %..string* %0
	store i64 %line, i64* %1
	store i64 %column, i64* %2
	store i64 %lo, i64* %3
	store i64 %hi, i64* %4
	store i64 %len, i64* %5
	; IfStmt
	%13 = load i64, i64* %3, align 8
	%14 = icmp sle i64 0, %13
	%15 = zext i1 %14 to i8
	%16 = trunc i8 %15 to i1
	br i1 %16, label %cmp.and-1, label %if.done-4

cmp.and-1:
	%17 = load i64, i64* %3, align 8
	%18 = load i64, i64* %4, align 8
	%19 = icmp sle i64 %17, %18
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %cmp.and-2, label %if.done-4

cmp.and-2:
	%22 = load i64, i64* %4, align 8
	%23 = load i64, i64* %5, align 8
	%24 = icmp sle i64 %22, %23
	%25 = zext i1 %24 to i8
	%26 = trunc i8 %25 to i1
	br i1 %26, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret void

if.done-4:
	; fd
	; SelectorExpr
	%27 = load i32, i32* @os.stderr, align 4
	store i32 %27, i32* %6
	%28 = load i32, i32* %6, align 4
	; CompoundLit
	%29 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %..string zeroinitializer}, %runtime.Source_Code_Location* %7
	%31 = load %..string, %..string* %0, align 8
	%32 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 0
	store %..string %31, %..string* %32
	%33 = load i64, i64* %1, align 8
	%34 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 1
	store i64 %33, i64* %34
	%35 = load i64, i64* %2, align 8
	%36 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 2
	store i64 %35, i64* %36
	%37 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, align 8
	%38 = bitcast %runtime.Source_Code_Location* %12 to %..rawptr
	%39 = call %..rawptr @mem.zero(%..rawptr %38, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %12
	store %runtime.Source_Code_Location %37, %runtime.Source_Code_Location* %12
	call void @runtime.print_caller_location(i32 %28, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%40 = load i32, i32* %6, align 4
	%41 = call {i64, i64} @os.write_string(i32 %40, %..string {i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$49, i64 0, i32 0), i64 24}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%42 = load i32, i32* %6, align 4
	%43 = load i64, i64* %3, align 8
	%44 = bitcast i64 %43 to i64
	call void @runtime.print_i64(i32 %42, i64 %44, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%45 = load i32, i32* %6, align 4
	%46 = call {i64, i64} @os.write_string(i32 %45, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$4a, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%47 = load i32, i32* %6, align 4
	%48 = load i64, i64* %4, align 8
	%49 = bitcast i64 %48 to i64
	call void @runtime.print_i64(i32 %47, i64 %49, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%50 = load i32, i32* %6, align 4
	%51 = call {i64, i64} @os.write_string(i32 %50, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$4b, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%52 = load i32, i32* %6, align 4
	%53 = load i64, i64* %5, align 8
	%54 = bitcast i64 %53 to i64
	call void @runtime.print_i64(i32 %52, i64 %54, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%55 = load i32, i32* %6, align 4
	%56 = call {i64, i64} @os.write_byte(i32 %55, i8 10, %runtime.Context* noalias nonnull nocapture inreg %8)
	call ccc void @llvm.debugtrap()
	ret void
}

define void @runtime.dynamic_array_expr_error(%..string %file, i64 %line, i64 %column, i64 %low, i64 %high, i64 %max) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i32, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca %runtime.Context, align 16
	%9 = bitcast %runtime.Context* %8 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %8
	%11 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %11, %runtime.Context* %8
	call void @runtime.__init_context(%runtime.Context* %8)
	%12 = alloca %runtime.Source_Code_Location, align 16
	store %..string %file, %..string* %0
	store i64 %line, i64* %1
	store i64 %column, i64* %2
	store i64 %low, i64* %3
	store i64 %high, i64* %4
	store i64 %max, i64* %5
	; IfStmt
	%13 = load i64, i64* %3, align 8
	%14 = icmp sle i64 0, %13
	%15 = zext i1 %14 to i8
	%16 = trunc i8 %15 to i1
	br i1 %16, label %cmp.and-1, label %if.done-4

cmp.and-1:
	%17 = load i64, i64* %3, align 8
	%18 = load i64, i64* %4, align 8
	%19 = icmp sle i64 %17, %18
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %cmp.and-2, label %if.done-4

cmp.and-2:
	%22 = load i64, i64* %4, align 8
	%23 = load i64, i64* %5, align 8
	%24 = icmp sle i64 %22, %23
	%25 = zext i1 %24 to i8
	%26 = trunc i8 %25 to i1
	br i1 %26, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret void

if.done-4:
	; fd
	; SelectorExpr
	%27 = load i32, i32* @os.stderr, align 4
	store i32 %27, i32* %6
	%28 = load i32, i32* %6, align 4
	; CompoundLit
	%29 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %..string zeroinitializer}, %runtime.Source_Code_Location* %7
	%31 = load %..string, %..string* %0, align 8
	%32 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 0
	store %..string %31, %..string* %32
	%33 = load i64, i64* %1, align 8
	%34 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 1
	store i64 %33, i64* %34
	%35 = load i64, i64* %2, align 8
	%36 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 2
	store i64 %35, i64* %36
	%37 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, align 8
	%38 = bitcast %runtime.Source_Code_Location* %12 to %..rawptr
	%39 = call %..rawptr @mem.zero(%..rawptr %38, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %12
	store %runtime.Source_Code_Location %37, %runtime.Source_Code_Location* %12
	call void @runtime.print_caller_location(i32 %28, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%40 = load i32, i32* %6, align 4
	%41 = call {i64, i64} @os.write_string(i32 %40, %..string {i8* getelementptr inbounds ([32 x i8], [32 x i8]* @str$4c, i64 0, i32 0), i64 31}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%42 = load i32, i32* %6, align 4
	%43 = load i64, i64* %3, align 8
	%44 = bitcast i64 %43 to i64
	call void @runtime.print_i64(i32 %42, i64 %44, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%45 = load i32, i32* %6, align 4
	%46 = call {i64, i64} @os.write_string(i32 %45, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$4d, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%47 = load i32, i32* %6, align 4
	%48 = load i64, i64* %4, align 8
	%49 = bitcast i64 %48 to i64
	call void @runtime.print_i64(i32 %47, i64 %49, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%50 = load i32, i32* %6, align 4
	%51 = call {i64, i64} @os.write_string(i32 %50, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$4e, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%52 = load i32, i32* %6, align 4
	%53 = load i64, i64* %5, align 8
	%54 = bitcast i64 %53 to i64
	call void @runtime.print_i64(i32 %52, i64 %54, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%55 = load i32, i32* %6, align 4
	%56 = call {i64, i64} @os.write_byte(i32 %55, i8 10, %runtime.Context* noalias nonnull nocapture inreg %8)
	call ccc void @llvm.debugtrap()
	ret void
}

define void @runtime.type_assertion_check(i1 %ok, %..string %file, i64 %line, i64 %column, %..typeid %from, %..typeid %to) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..typeid, align 16
	%5 = alloca %..typeid, align 16
	%6 = alloca i32, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca %runtime.Context, align 16
	%9 = bitcast %runtime.Context* %8 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %8
	%11 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %11, %runtime.Context* %8
	call void @runtime.__init_context(%runtime.Context* %8)
	%12 = alloca %runtime.Source_Code_Location, align 16
	%13 = zext i1 %ok to i8
	store i8 %13, i8* %0
	store %..string %file, %..string* %1
	store i64 %line, i64* %2
	store i64 %column, i64* %3
	store %..typeid %from, %..typeid* %4
	store %..typeid %to, %..typeid* %5
	; IfStmt
	%14 = load i8, i8* %0, align 1
	%15 = trunc i8 %14 to i1
	br i1 %15, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; fd
	; SelectorExpr
	%16 = load i32, i32* @os.stderr, align 4
	store i32 %16, i32* %6
	%17 = load i32, i32* %6, align 4
	; CompoundLit
	%18 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %..string zeroinitializer}, %runtime.Source_Code_Location* %7
	%20 = load %..string, %..string* %1, align 8
	%21 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 0
	store %..string %20, %..string* %21
	%22 = load i64, i64* %2, align 8
	%23 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 1
	store i64 %22, i64* %23
	%24 = load i64, i64* %3, align 8
	%25 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i64 0, i32 2
	store i64 %24, i64* %25
	%26 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, align 8
	%27 = bitcast %runtime.Source_Code_Location* %12 to %..rawptr
	%28 = call %..rawptr @mem.zero(%..rawptr %27, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %12
	store %runtime.Source_Code_Location %26, %runtime.Source_Code_Location* %12
	call void @runtime.print_caller_location(i32 %17, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%29 = load i32, i32* %6, align 4
	%30 = call {i64, i64} @os.write_string(i32 %29, %..string {i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$4f, i64 0, i32 0), i64 29}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%31 = load i32, i32* %6, align 4
	%32 = load %..typeid, %..typeid* %4, align 8
	call void @runtime.print_typeid(i32 %31, %..typeid %32, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%33 = load i32, i32* %6, align 4
	%34 = call {i64, i64} @os.write_string(i32 %33, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$50, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %8)
	%35 = load i32, i32* %6, align 4
	%36 = load %..typeid, %..typeid* %5, align 8
	call void @runtime.print_typeid(i32 %35, %..typeid %36, %runtime.Context* noalias nonnull nocapture inreg %8)
	; SelectorExpr
	%37 = load i32, i32* %6, align 4
	%38 = call {i64, i64} @os.write_byte(i32 %37, i8 10, %runtime.Context* noalias nonnull nocapture inreg %8)
	call ccc void @llvm.debugtrap()
	ret void
}

define {i32, i64} @runtime.string_decode_rune(%..string %s) alwaysinline #1 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %runtime.Context, align 16
	%2 = bitcast %runtime.Context* %1 to %..rawptr
	%3 = call %..rawptr @mem.zero(%..rawptr %2, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %1
	%4 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %4, %runtime.Context* %1
	call void @runtime.__init_context(%runtime.Context* %1) alwaysinline
	%5 = alloca {i32, i64}, align 16
	store %..string %s, %..string* %0
	; ReturnStmt
	; SelectorExpr
	%6 = load %..string, %..string* %0, align 8
	%7 = call {i32, i64} @utf8.decode_rune_from_string(%..string %6, %runtime.Context* noalias nonnull nocapture inreg %1) alwaysinline
	%8 = extractvalue {i32, i64} %7, 0
	%9 = extractvalue {i32, i64} %7, 1
	%10 = bitcast {i32, i64}* %5 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %5
	%12 = getelementptr inbounds {i32, i64}, {i32, i64}* %5, i64 0, i32 0
	store i32 %8, i32* %12
	%13 = getelementptr inbounds {i32, i64}, {i32, i64}* %5, i64 0, i32 1
	store i64 %9, i64* %13
	%14 = load {i32, i64}, {i32, i64}* %5, align 8
	ret {i32, i64} %14
}

define void @runtime.make_slice_error_loc(%runtime.Source_Code_Location* %loc, i64 %len) alwaysinline #1 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i32, align 16
	%2 = alloca %runtime.Context, align 16
	%3 = bitcast %runtime.Context* %2 to %..rawptr
	%4 = call %..rawptr @mem.zero(%..rawptr %3, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %2
	%5 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %5, %runtime.Context* %2
	call void @runtime.__init_context(%runtime.Context* %2) alwaysinline
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	store i64 %len, i64* %0
	; IfStmt
	%8 = load i64, i64* %0, align 8
	%9 = icmp sle i64 0, %8
	%10 = zext i1 %9 to i8
	%11 = trunc i8 %10 to i1
	br i1 %11, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; fd
	; SelectorExpr
	%12 = load i32, i32* @os.stderr, align 4
	store i32 %12, i32* %1
	%13 = load i32, i32* %1, align 4
	%14 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%15 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location %14, %runtime.Source_Code_Location* %6
	call void @runtime.print_caller_location(i32 %13, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture inreg %2) alwaysinline
	; SelectorExpr
	%17 = load i32, i32* %1, align 4
	%18 = call {i64, i64} @os.write_string(i32 %17, %..string {i8* getelementptr inbounds ([33 x i8], [33 x i8]* @str$51, i64 0, i32 0), i64 32}, %runtime.Context* noalias nonnull nocapture inreg %2) alwaysinline
	%19 = load i32, i32* %1, align 4
	%20 = load i64, i64* %0, align 8
	%21 = bitcast i64 %20 to i64
	call void @runtime.print_i64(i32 %19, i64 %21, %runtime.Context* noalias nonnull nocapture inreg %2) alwaysinline
	; SelectorExpr
	%22 = load i32, i32* %1, align 4
	%23 = call {i64, i64} @os.write_byte(i32 %22, i8 10, %runtime.Context* noalias nonnull nocapture inreg %2) alwaysinline
	call ccc void @llvm.debugtrap() alwaysinline
	ret void
}

define void @runtime.make_dynamic_array_error_loc(%runtime.Source_Code_Location* %loc, i64 %len, i64 %cap) alwaysinline #1 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca i32, align 16
	%3 = alloca %runtime.Context, align 16
	%4 = bitcast %runtime.Context* %3 to %..rawptr
	%5 = call %..rawptr @mem.zero(%..rawptr %4, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %3
	%6 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %6, %runtime.Context* %3
	call void @runtime.__init_context(%runtime.Context* %3) alwaysinline
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	store i64 %len, i64* %0
	store i64 %cap, i64* %1
	; IfStmt
	%9 = load i64, i64* %0, align 8
	%10 = icmp sle i64 0, %9
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %cmp.and-1, label %if.done-3

cmp.and-1:
	%13 = load i64, i64* %0, align 8
	%14 = load i64, i64* %1, align 8
	%15 = icmp sle i64 %13, %14
	%16 = zext i1 %15 to i8
	%17 = trunc i8 %16 to i1
	br i1 %17, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	; fd
	; SelectorExpr
	%18 = load i32, i32* @os.stderr, align 4
	store i32 %18, i32* %2
	%19 = load i32, i32* %2, align 4
	%20 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%21 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location %20, %runtime.Source_Code_Location* %7
	call void @runtime.print_caller_location(i32 %19, %runtime.Source_Code_Location* %7, %runtime.Context* noalias nonnull nocapture inreg %3) alwaysinline
	; SelectorExpr
	%23 = load i32, i32* %2, align 4
	%24 = call {i64, i64} @os.write_string(i32 %23, %..string {i8* getelementptr inbounds ([45 x i8], [45 x i8]* @str$52, i64 0, i32 0), i64 44}, %runtime.Context* noalias nonnull nocapture inreg %3) alwaysinline
	%25 = load i32, i32* %2, align 4
	%26 = load i64, i64* %0, align 8
	%27 = bitcast i64 %26 to i64
	call void @runtime.print_i64(i32 %25, i64 %27, %runtime.Context* noalias nonnull nocapture inreg %3) alwaysinline
	; SelectorExpr
	%28 = load i32, i32* %2, align 4
	%29 = call {i64, i64} @os.write_byte(i32 %28, i8 58, %runtime.Context* noalias nonnull nocapture inreg %3) alwaysinline
	%30 = load i32, i32* %2, align 4
	%31 = load i64, i64* %1, align 8
	%32 = bitcast i64 %31 to i64
	call void @runtime.print_i64(i32 %30, i64 %32, %runtime.Context* noalias nonnull nocapture inreg %3) alwaysinline
	; SelectorExpr
	%33 = load i32, i32* %2, align 4
	%34 = call {i64, i64} @os.write_byte(i32 %33, i8 10, %runtime.Context* noalias nonnull nocapture inreg %3) alwaysinline
	call ccc void @llvm.debugtrap() alwaysinline
	ret void
}

define float @runtime.abs_f32(float %x) alwaysinline #1 {
decls-0:
	%0 = alloca float, align 16
	store float %x, float* %0
	; ReturnStmt
	%1 = load float, float* %0, align 4
	%2 = call ccc float @llvm.fabs.f32(float %1) alwaysinline
	ret float %2
}
declare ccc float @llvm.fabs.f32(float) #0 

define double @runtime.abs_f64(double %x) alwaysinline #1 {
decls-0:
	%0 = alloca double, align 16
	store double %x, double* %0
	; ReturnStmt
	%1 = load double, double* %0, align 8
	%2 = call ccc double @llvm.fabs.f64(double %1) alwaysinline
	ret double %2
}
declare ccc double @llvm.fabs.f64(double) #0 

define %..complex64 @runtime.quo_complex64(%..complex64 %n, %..complex64 %m, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..complex64, align 16
	%1 = alloca %..complex64, align 16
	%2 = alloca float, align 16
	%3 = alloca float, align 16
	%4 = alloca float, align 16
	%5 = alloca float, align 16
	%6 = alloca float, align 16
	%7 = alloca float, align 16
	%8 = alloca %..complex64, align 16
	store %..complex64 %n, %..complex64* %0
	store %..complex64 %m, %..complex64* %1
	; e
	%9 = bitcast float* %2 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 4) noinline
	store float zeroinitializer, float* %2
	; f
	%11 = bitcast float* %3 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 4) noinline
	store float zeroinitializer, float* %3
	; IfStmt
	; real
	%13 = load %..complex64, %..complex64* %1, align 4
	%14 = extractvalue %..complex64 %13, 0
	; abs
	%15 = call float @runtime.abs_f32(float %14)
	; imag
	%16 = load %..complex64, %..complex64* %1, align 4
	%17 = extractvalue %..complex64 %16, 1
	; abs
	%18 = call float @runtime.abs_f32(float %17)
	%19 = fcmp oge float %15, %18
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %if.then-1, label %if.else-2

if.then-1:
	; ratio
	; imag
	%22 = load %..complex64, %..complex64* %1, align 4
	%23 = extractvalue %..complex64 %22, 1
	; real
	%24 = load %..complex64, %..complex64* %1, align 4
	%25 = extractvalue %..complex64 %24, 0
	%26 = fdiv float %23, %25
	store float %26, float* %4
	; denom
	; real
	%27 = load %..complex64, %..complex64* %1, align 4
	%28 = extractvalue %..complex64 %27, 0
	%29 = load float, float* %4, align 4
	; imag
	%30 = load %..complex64, %..complex64* %1, align 4
	%31 = extractvalue %..complex64 %30, 1
	%32 = fmul float %29, %31
	%33 = fadd float %28, %32
	store float %33, float* %5
	; AssignStmt
	; real
	%34 = load %..complex64, %..complex64* %0, align 4
	%35 = extractvalue %..complex64 %34, 0
	; imag
	%36 = load %..complex64, %..complex64* %0, align 4
	%37 = extractvalue %..complex64 %36, 1
	%38 = load float, float* %4, align 4
	%39 = fmul float %37, %38
	%40 = fadd float %35, %39
	%41 = load float, float* %5, align 4
	%42 = fdiv float %40, %41
	store float %42, float* %2
	; AssignStmt
	; imag
	%43 = load %..complex64, %..complex64* %0, align 4
	%44 = extractvalue %..complex64 %43, 1
	; real
	%45 = load %..complex64, %..complex64* %0, align 4
	%46 = extractvalue %..complex64 %45, 0
	%47 = load float, float* %4, align 4
	%48 = fmul float %46, %47
	%49 = fsub float %44, %48
	%50 = load float, float* %5, align 4
	%51 = fdiv float %49, %50
	store float %51, float* %3
	br label %if.done-3

if.else-2:
	; ratio
	; real
	%52 = load %..complex64, %..complex64* %1, align 4
	%53 = extractvalue %..complex64 %52, 0
	; imag
	%54 = load %..complex64, %..complex64* %1, align 4
	%55 = extractvalue %..complex64 %54, 1
	%56 = fdiv float %53, %55
	store float %56, float* %6
	; denom
	; imag
	%57 = load %..complex64, %..complex64* %1, align 4
	%58 = extractvalue %..complex64 %57, 1
	%59 = load float, float* %6, align 4
	; real
	%60 = load %..complex64, %..complex64* %1, align 4
	%61 = extractvalue %..complex64 %60, 0
	%62 = fmul float %59, %61
	%63 = fadd float %58, %62
	store float %63, float* %7
	; AssignStmt
	; real
	%64 = load %..complex64, %..complex64* %0, align 4
	%65 = extractvalue %..complex64 %64, 0
	%66 = load float, float* %6, align 4
	%67 = fmul float %65, %66
	; imag
	%68 = load %..complex64, %..complex64* %0, align 4
	%69 = extractvalue %..complex64 %68, 1
	%70 = fadd float %67, %69
	%71 = load float, float* %7, align 4
	%72 = fdiv float %70, %71
	store float %72, float* %2
	; AssignStmt
	; imag
	%73 = load %..complex64, %..complex64* %0, align 4
	%74 = extractvalue %..complex64 %73, 1
	%75 = load float, float* %6, align 4
	%76 = fmul float %74, %75
	; real
	%77 = load %..complex64, %..complex64* %0, align 4
	%78 = extractvalue %..complex64 %77, 0
	%79 = fsub float %76, %78
	%80 = load float, float* %7, align 4
	%81 = fdiv float %79, %80
	store float %81, float* %3
	br label %if.done-3

if.done-3:
	; ReturnStmt
	; complex
	%82 = load float, float* %2, align 4
	%83 = load float, float* %3, align 4
	%84 = bitcast %..complex64* %8 to %..rawptr
	%85 = call %..rawptr @mem.zero(%..rawptr %84, i64 8) noinline
	store %..complex64 zeroinitializer, %..complex64* %8
	%86 = getelementptr inbounds %..complex64, %..complex64* %8, i64 0, i32 0
	store float %82, float* %86
	%87 = getelementptr inbounds %..complex64, %..complex64* %8, i64 0, i32 1
	store float %83, float* %87
	%88 = load %..complex64, %..complex64* %8, align 4
	ret %..complex64 %88
}

define %..complex128 @runtime.quo_complex128(%..complex128* %n, %..complex128* %m, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca double, align 16
	%1 = alloca double, align 16
	%2 = alloca double, align 16
	%3 = alloca double, align 16
	%4 = alloca double, align 16
	%5 = alloca double, align 16
	%6 = alloca %..complex128, align 16
	%7 = load %..complex128, %..complex128* %n, align 8
	%8 = load %..complex128, %..complex128* %m, align 8
	; e
	%9 = bitcast double* %0 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 8) noinline
	store double zeroinitializer, double* %0
	; f
	%11 = bitcast double* %1 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 8) noinline
	store double zeroinitializer, double* %1
	; IfStmt
	; real
	%13 = load %..complex128, %..complex128* %m, align 8
	%14 = extractvalue %..complex128 %13, 0
	; abs
	%15 = call double @runtime.abs_f64(double %14)
	; imag
	%16 = load %..complex128, %..complex128* %m, align 8
	%17 = extractvalue %..complex128 %16, 1
	; abs
	%18 = call double @runtime.abs_f64(double %17)
	%19 = fcmp oge double %15, %18
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %if.then-1, label %if.else-2

if.then-1:
	; ratio
	; imag
	%22 = load %..complex128, %..complex128* %m, align 8
	%23 = extractvalue %..complex128 %22, 1
	; real
	%24 = load %..complex128, %..complex128* %m, align 8
	%25 = extractvalue %..complex128 %24, 0
	%26 = fdiv double %23, %25
	store double %26, double* %2
	; denom
	; real
	%27 = load %..complex128, %..complex128* %m, align 8
	%28 = extractvalue %..complex128 %27, 0
	%29 = load double, double* %2, align 8
	; imag
	%30 = load %..complex128, %..complex128* %m, align 8
	%31 = extractvalue %..complex128 %30, 1
	%32 = fmul double %29, %31
	%33 = fadd double %28, %32
	store double %33, double* %3
	; AssignStmt
	; real
	%34 = load %..complex128, %..complex128* %n, align 8
	%35 = extractvalue %..complex128 %34, 0
	; imag
	%36 = load %..complex128, %..complex128* %n, align 8
	%37 = extractvalue %..complex128 %36, 1
	%38 = load double, double* %2, align 8
	%39 = fmul double %37, %38
	%40 = fadd double %35, %39
	%41 = load double, double* %3, align 8
	%42 = fdiv double %40, %41
	store double %42, double* %0
	; AssignStmt
	; imag
	%43 = load %..complex128, %..complex128* %n, align 8
	%44 = extractvalue %..complex128 %43, 1
	; real
	%45 = load %..complex128, %..complex128* %n, align 8
	%46 = extractvalue %..complex128 %45, 0
	%47 = load double, double* %2, align 8
	%48 = fmul double %46, %47
	%49 = fsub double %44, %48
	%50 = load double, double* %3, align 8
	%51 = fdiv double %49, %50
	store double %51, double* %1
	br label %if.done-3

if.else-2:
	; ratio
	; real
	%52 = load %..complex128, %..complex128* %m, align 8
	%53 = extractvalue %..complex128 %52, 0
	; imag
	%54 = load %..complex128, %..complex128* %m, align 8
	%55 = extractvalue %..complex128 %54, 1
	%56 = fdiv double %53, %55
	store double %56, double* %4
	; denom
	; imag
	%57 = load %..complex128, %..complex128* %m, align 8
	%58 = extractvalue %..complex128 %57, 1
	%59 = load double, double* %4, align 8
	; real
	%60 = load %..complex128, %..complex128* %m, align 8
	%61 = extractvalue %..complex128 %60, 0
	%62 = fmul double %59, %61
	%63 = fadd double %58, %62
	store double %63, double* %5
	; AssignStmt
	; real
	%64 = load %..complex128, %..complex128* %n, align 8
	%65 = extractvalue %..complex128 %64, 0
	%66 = load double, double* %4, align 8
	%67 = fmul double %65, %66
	; imag
	%68 = load %..complex128, %..complex128* %n, align 8
	%69 = extractvalue %..complex128 %68, 1
	%70 = fadd double %67, %69
	%71 = load double, double* %5, align 8
	%72 = fdiv double %70, %71
	store double %72, double* %0
	; AssignStmt
	; imag
	%73 = load %..complex128, %..complex128* %n, align 8
	%74 = extractvalue %..complex128 %73, 1
	%75 = load double, double* %4, align 8
	%76 = fmul double %74, %75
	; real
	%77 = load %..complex128, %..complex128* %n, align 8
	%78 = extractvalue %..complex128 %77, 0
	%79 = fsub double %76, %78
	%80 = load double, double* %5, align 8
	%81 = fdiv double %79, %80
	store double %81, double* %1
	br label %if.done-3

if.done-3:
	; ReturnStmt
	; complex
	%82 = load double, double* %0, align 8
	%83 = load double, double* %1, align 8
	%84 = bitcast %..complex128* %6 to %..rawptr
	%85 = call %..rawptr @mem.zero(%..rawptr %84, i64 16) noinline
	store %..complex128 zeroinitializer, %..complex128* %6
	%86 = getelementptr inbounds %..complex128, %..complex128* %6, i64 0, i32 0
	store double %82, double* %86
	%87 = getelementptr inbounds %..complex128, %..complex128* %6, i64 0, i32 1
	store double %83, double* %87
	%88 = load %..complex128, %..complex128* %6, align 8
	ret %..complex128 %88
}

define %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %info) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	%2 = alloca %runtime.Type_Info_Named, align 16
	%3 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	store %runtime.Type_Info* %info, %runtime.Type_Info** %0
	; IfStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%5 = icmp eq %runtime.Type_Info* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %runtime.Type_Info* zeroinitializer

if.done-2:
	; base
	%8 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	store %runtime.Type_Info* %8, %runtime.Type_Info** %1
	; ForStmt
	br label %for.body-3

for.body-3:
	; TypeSwitchStmt
	; SelectorExpr
	%9 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%10 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %9, i64 0
	%11 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %10, i64 0, i32 3
	%12 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %11, align 8
	; get union's tag
	%13 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %11, i64 0, i32 2 ; UnionTagPtr
	%14 = load i8, i8* %13, align 1
	%15 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %11 to %..rawptr
	%16 = icmp eq i8 %14, 1
	br i1 %16, label %typeswitch.body-5, label %typeswitch.next-4

typeswitch.next-4:
	store {[0 x <8 x i8>], [72 x i8], i8} %12, {[0 x <8 x i8>], [72 x i8], i8}* %3
	; break
	; ReturnStmt
	%17 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	ret %runtime.Type_Info* %17

typeswitch.body-5:
	%18 = bitcast %..rawptr %15 to %runtime.Type_Info_Named*
	%19 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %18, align 8
	store %runtime.Type_Info_Named %19, %runtime.Type_Info_Named* %2
	; AssignStmt
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2, i64 0, i32 1
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	store %runtime.Type_Info* %21, %runtime.Type_Info** %1
	br label %for.body-3
}

define %runtime.Type_Info* @runtime.__type_info_of(%..typeid %id) #0 {
decls-0:
	%0 = alloca %..typeid, align 16
	%1 = alloca {[0 x <8 x i8>], [8 x i8]}, align 16
	%2 = alloca i64, align 16
	store %..typeid %id, %..typeid* %0
	; data
	%3 = load %..typeid, %..typeid* %0, align 8
	%4 = bitcast %..typeid* %0 to {[0 x <8 x i8>], [8 x i8]}*
	%5 = load {[0 x <8 x i8>], [8 x i8]}, {[0 x <8 x i8>], [8 x i8]}* %4, align 8
	store {[0 x <8 x i8>], [8 x i8]} %5, {[0 x <8 x i8>], [8 x i8]}* %1
	; n
	; SelectorExpr
	%6 = bitcast {[0 x <8 x i8>], [8 x i8]}* %1 to i8*
	%7 = getelementptr inbounds i8, i8* %6, i64 0
	%8 = bitcast i8* %7 to i64*
	%9 = load i64, i64* %8, align 8
	%10 = shl i64 %9, 8
	%11 = lshr i64 %10, 8
	%12 = bitcast i64 %11 to i64
	store i64 %12, i64* %2
	; IfStmt
	%13 = load i64, i64* %2, align 8
	%14 = icmp slt i64 %13, 0
	%15 = zext i1 %14 to i8
	%16 = trunc i8 %15 to i1
	br i1 %16, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%17 = load i64, i64* %2, align 8
	%18 = load {%runtime.Type_Info*, i64}, {%runtime.Type_Info*, i64}* @runtime.type_table, align 8
	%19 = extractvalue {%runtime.Type_Info*, i64} %18, 1
	%20 = icmp sge i64 %17, %19
	%21 = zext i1 %20 to i8
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-2, label %if.done-3

if.then-2:
	; AssignStmt
	store i64 0, i64* %2
	br label %if.done-3

if.done-3:
	; ReturnStmt
	; IndexExpr
	%23 = load {%runtime.Type_Info*, i64}, {%runtime.Type_Info*, i64}* @runtime.type_table, align 8
	%24 = extractvalue {%runtime.Type_Info*, i64} %23, 0
	%25 = load i64, i64* %2, align 8
	%26 = extractvalue {%runtime.Type_Info*, i64} %23, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$53, i64 0, i32 0), i64 58}, i64 279, i64 21, i64 %25, i64 %26)
	%27 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %24, i64 %25
	ret %runtime.Type_Info* %27
}

define %..typeid @runtime.typeid_base(%..typeid %id) #0 {
decls-0:
	%0 = alloca %..typeid, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	store %..typeid %id, %..typeid* %0
	; ti
	%2 = load %..typeid, %..typeid* %0, align 8
	%3 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %2)
	store %runtime.Type_Info* %3, %runtime.Type_Info** %1
	; AssignStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%5 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %4)
	store %runtime.Type_Info* %5, %runtime.Type_Info** %1
	; ReturnStmt
	; SelectorExpr
	%6 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%7 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %6, i64 0
	%8 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %7, i64 0, i32 2
	%9 = load %..typeid, %..typeid* %8, align 8
	ret %..typeid %9
}

define void @runtime.__init_context(%runtime.Context* %c) #0 {
decls-0:
	%0 = alloca %runtime.Context*, align 16
	store %runtime.Context* %c, %runtime.Context** %0
	; IfStmt
	%1 = load %runtime.Context*, %runtime.Context** %0, align 8
	%2 = icmp eq %runtime.Context* %1, zeroinitializer
	%3 = zext i1 %2 to i8
	%4 = trunc i8 %3 to i1
	br i1 %4, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%5 = load %runtime.Context*, %runtime.Context** %0, align 8
	%6 = getelementptr inbounds %runtime.Context, %runtime.Context* %5, i64 0
	%7 = getelementptr inbounds %runtime.Context, %runtime.Context* %6, i64 0, i32 0
	%8 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %7, i64 0, i32 0
	; SelectorExpr
	%9 = bitcast %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* @os.heap_allocator_proc to %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*
	store %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %9, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %8
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%10 = load %runtime.Context*, %runtime.Context** %0, align 8
	%11 = getelementptr inbounds %runtime.Context, %runtime.Context* %10, i64 0
	%12 = getelementptr inbounds %runtime.Context, %runtime.Context* %11, i64 0, i32 0
	%13 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %12, i64 0, i32 1
	store %..rawptr zeroinitializer, %..rawptr* %13
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%14 = load %runtime.Context*, %runtime.Context** %0, align 8
	%15 = getelementptr inbounds %runtime.Context, %runtime.Context* %14, i64 0
	%16 = getelementptr inbounds %runtime.Context, %runtime.Context* %15, i64 0, i32 1
	%17 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %16, i64 0, i32 0
	; SelectorExpr
	%18 = bitcast %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* @mem.scratch_allocator_proc to %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*
	store %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %18, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %17
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%19 = load %runtime.Context*, %runtime.Context** %0, align 8
	%20 = getelementptr inbounds %runtime.Context, %runtime.Context* %19, i64 0
	%21 = getelementptr inbounds %runtime.Context, %runtime.Context* %20, i64 0, i32 1
	%22 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %21, i64 0, i32 1
	%23 = bitcast %mem.Scratch_Allocator* @runtime.global_scratch_allocator_data to %..rawptr
	store %..rawptr %23, %..rawptr* %22
	; AssignStmt
	; SelectorExpr
	%24 = load %runtime.Context*, %runtime.Context** %0, align 8
	%25 = getelementptr inbounds %runtime.Context, %runtime.Context* %24, i64 0
	%26 = getelementptr inbounds %runtime.Context, %runtime.Context* %25, i64 0, i32 4
	; SelectorExpr
	%27 = call i64 @os.current_thread_id()
	store i64 %27, i64* %26
	; AssignStmt
	; SelectorExpr
	%28 = load %runtime.Context*, %runtime.Context** %0, align 8
	%29 = getelementptr inbounds %runtime.Context, %runtime.Context* %28, i64 0
	%30 = getelementptr inbounds %runtime.Context, %runtime.Context* %29, i64 0, i32 2
	%31 = bitcast void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* @runtime.default_assertion_failure_proc to void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*
	store void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %31, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %30
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%32 = load %runtime.Context*, %runtime.Context** %0, align 8
	%33 = getelementptr inbounds %runtime.Context, %runtime.Context* %32, i64 0
	%34 = getelementptr inbounds %runtime.Context, %runtime.Context* %33, i64 0, i32 3
	%35 = getelementptr inbounds %log.Logger, %log.Logger* %34, i64 0, i32 0
	; SelectorExpr
	%36 = bitcast void (%..rawptr, i64, %..string, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)* @log.nil_logger_proc to void (%..rawptr, i64, %..string, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)*
	store void (%..rawptr, i64, %..string, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)* %36, void (%..rawptr, i64, %..string, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)** %35
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%37 = load %runtime.Context*, %runtime.Context** %0, align 8
	%38 = getelementptr inbounds %runtime.Context, %runtime.Context* %37, i64 0
	%39 = getelementptr inbounds %runtime.Context, %runtime.Context* %38, i64 0, i32 3
	%40 = getelementptr inbounds %log.Logger, %log.Logger* %39, i64 0, i32 1
	store %..rawptr zeroinitializer, %..rawptr* %40
	ret void
}

define void @runtime.default_assertion_failure_proc(%..string %prefix, %..string %message, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i32, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	store %..string %prefix, %..string* %0
	store %..string %message, %..string* %1
	%4 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; fd
	; SelectorExpr
	%5 = load i32, i32* @os.stderr, align 4
	store i32 %5, i32* %2
	%6 = load i32, i32* %2, align 4
	%7 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%8 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %7, %runtime.Source_Code_Location* %3
	call void @runtime.print_caller_location(i32 %6, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%10 = load i32, i32* %2, align 4
	%11 = call {i64, i64} @os.write_string(i32 %10, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$54, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%12 = load i32, i32* %2, align 4
	%13 = load %..string, %..string* %0, align 8
	%14 = call {i64, i64} @os.write_string(i32 %12, %..string %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	%15 = load %..string, %..string* %1, align 8
	%16 = extractvalue %..string %15, 1
	%17 = icmp sgt i64 %16, 0
	%18 = zext i1 %17 to i8
	%19 = trunc i8 %18 to i1
	br i1 %19, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	%20 = load i32, i32* %2, align 4
	%21 = call {i64, i64} @os.write_string(i32 %20, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$55, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%22 = load i32, i32* %2, align 4
	%23 = load %..string, %..string* %1, align 8
	%24 = call {i64, i64} @os.write_string(i32 %22, %..string %23, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-2

if.done-2:
	; SelectorExpr
	%25 = load i32, i32* %2, align 4
	%26 = call {i64, i64} @os.write_byte(i32 %25, i8 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	call ccc void @llvm.debugtrap()
	ret void
}

define i8 @runtime.assert(i1 %condition, %..string %message, %runtime.Source_Code_Location* %loc) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca %..string, align 16
	%2 = alloca void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, align 16
	%3 = alloca %runtime.Context, align 16
	%4 = bitcast %runtime.Context* %3 to %..rawptr
	%5 = call %..rawptr @mem.zero(%..rawptr %4, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %3
	%6 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %6, %runtime.Context* %3
	call void @runtime.__init_context(%runtime.Context* %3)
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = zext i1 %condition to i8
	store i8 %8, i8* %0
	store %..string %message, %..string* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load i8, i8* %0, align 1
	%11 = trunc i8 %10 to i1
	br i1 %11, label %if.done-4, label %if.then-1

if.then-1:
	; p
	; SelectorExpr
	%12 = getelementptr inbounds %runtime.Context, %runtime.Context* %3, i64 0, i32 2
	%13 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %12, align 8
	store void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %13, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %2
	; IfStmt
	%14 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %2, align 8
	%15 = icmp eq void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %14, zeroinitializer
	%16 = zext i1 %15 to i8
	%17 = trunc i8 %16 to i1
	br i1 %17, label %if.then-2, label %if.done-3

if.then-2:
	; AssignStmt
	%18 = bitcast void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* @runtime.default_assertion_failure_proc to void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*
	store void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %18, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %2
	br label %if.done-3

if.done-3:
	%19 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %2, align 8
	%20 = load %..string, %..string* %1, align 8
	%21 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%22 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location %21, %runtime.Source_Code_Location* %7
	call void %19(%..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$56, i64 0, i32 0), i64 17}, %..string %20, %runtime.Source_Code_Location* %7, %runtime.Context* noalias nonnull nocapture inreg %3)
	br label %if.done-4

if.done-4:
	; ReturnStmt
	%24 = load i8, i8* %0, align 1
	ret i8 %24
}

define void @runtime.panic(%..string %message, %runtime.Source_Code_Location* %loc) #0 noreturn {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, align 16
	%2 = alloca %runtime.Context, align 16
	%3 = bitcast %runtime.Context* %2 to %..rawptr
	%4 = call %..rawptr @mem.zero(%..rawptr %3, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %2
	%5 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %5, %runtime.Context* %2
	call void @runtime.__init_context(%runtime.Context* %2)
	%6 = alloca %runtime.Source_Code_Location, align 16
	store %..string %message, %..string* %0
	%7 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; p
	; SelectorExpr
	%8 = getelementptr inbounds %runtime.Context, %runtime.Context* %2, i64 0, i32 2
	%9 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %8, align 8
	store void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %9, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1
	; IfStmt
	%10 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1, align 8
	%11 = icmp eq void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	%14 = bitcast void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* @runtime.default_assertion_failure_proc to void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*
	store void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %14, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1
	br label %if.done-2

if.done-2:
	%15 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1, align 8
	%16 = load %..string, %..string* %0, align 8
	%17 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%18 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location %17, %runtime.Source_Code_Location* %6
	call void %15(%..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$57, i64 0, i32 0), i64 5}, %..string %16, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture inreg %2)
	ret void
}

define %..rawptr @mem.set(%..rawptr %data, i8 %value, i64 %len) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	store %..rawptr %data, %..rawptr* %0
	store i8 %value, i8* %1
	store i64 %len, i64* %2
	; IfStmt
	%3 = load %..rawptr, %..rawptr* %0, align 8
	%4 = icmp eq %..rawptr %3, zeroinitializer
	%5 = zext i1 %4 to i8
	%6 = trunc i8 %5 to i1
	br i1 %6, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %..rawptr zeroinitializer

if.done-2:
	; IfStmt
	%7 = load i64, i64* %2, align 8
	%8 = icmp slt i64 %7, 0
	%9 = zext i1 %8 to i8
	%10 = trunc i8 %9 to i1
	br i1 %10, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	%11 = load %..rawptr, %..rawptr* %0, align 8
	ret %..rawptr %11

if.done-4:
	%12 = load %..rawptr, %..rawptr* %0, align 8
	%13 = load i8, i8* %1, align 1
	%14 = load i64, i64* %2, align 8
	call ccc void @llvm.memset.p0i8.i64(%..rawptr %12, i8 %13, i64 %14, i32 1, i1 false)
	; ReturnStmt
	%15 = load %..rawptr, %..rawptr* %0, align 8
	ret %..rawptr %15
}
declare ccc void @llvm.memset.p0i8.i64(%..rawptr, i8, i64, i32, i1) #0 

define %..rawptr @mem.zero(%..rawptr %data, i64 %len) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i64, align 16
	store %..rawptr %data, %..rawptr* %0
	store i64 %len, i64* %1
	; ReturnStmt
	%2 = load %..rawptr, %..rawptr* %0, align 8
	%3 = load i64, i64* %1, align 8
	%4 = call %..rawptr @mem.set(%..rawptr %2, i8 0, i64 %3)
	ret %..rawptr %4
}

define %..rawptr @mem.copy(%..rawptr %dst, %..rawptr %src, i64 %len) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca i64, align 16
	store %..rawptr %dst, %..rawptr* %0
	store %..rawptr %src, %..rawptr* %1
	store i64 %len, i64* %2
	; IfStmt
	%3 = load %..rawptr, %..rawptr* %1, align 8
	%4 = icmp eq %..rawptr %3, zeroinitializer
	%5 = zext i1 %4 to i8
	%6 = trunc i8 %5 to i1
	br i1 %6, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%7 = load %..rawptr, %..rawptr* %0, align 8
	ret %..rawptr %7

if.done-2:
	%8 = load %..rawptr, %..rawptr* %0, align 8
	%9 = load %..rawptr, %..rawptr* %1, align 8
	%10 = load i64, i64* %2, align 8
	call ccc void @llvm.memmove.p0i8.p0i8.i64(%..rawptr %8, %..rawptr %9, i64 %10, i32 1, i1 false)
	; ReturnStmt
	%11 = load %..rawptr, %..rawptr* %0, align 8
	ret %..rawptr %11
}
declare ccc void @llvm.memmove.p0i8.p0i8.i64(%..rawptr, %..rawptr, i64, i32, i1) #0 

define i64 @mem.compare_byte_ptrs(i8* %a, i8* %b, i64 %n) #0 {
decls-0:
	%0 = alloca i8*, align 16
	%1 = alloca i8*, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	store i8* %a, i8** %0
	store i8* %b, i8** %1
	store i64 %n, i64* %2
	; RangeStmt
	; i
	%6 = bitcast i64* %3 to %..rawptr
	store i64 zeroinitializer, i64* %3
	%7 = bitcast i64* %4 to %..rawptr
	store i64 zeroinitializer, i64* %4
	store i64 0, i64* %4
	%8 = bitcast i64* %5 to %..rawptr
	store i64 zeroinitializer, i64* %5
	store i64 0, i64* %5
	br label %for.interval.loop-1

for.interval.loop-1:
	%9 = load i64, i64* %2, align 8
	%10 = sub i64 %9, 1
	%11 = load i64, i64* %4, align 8
	%12 = icmp sle i64 %11, %10
	br i1 %12, label %for.interval.body-2, label %for.interval.done-7

for.interval.body-2:
	%13 = load i64, i64* %4, align 8
	%14 = load i64, i64* %5, align 8
	%15 = load i64, i64* %4, align 8
	%16 = add i64 %15, 1
	store i64 %16, i64* %4
	%17 = load i64, i64* %5, align 8
	%18 = add i64 %17, 1
	store i64 %18, i64* %5
	store i64 %13, i64* %3
	; SwitchStmt
	%19 = load i8*, i8** %0, align 8
	%20 = load i64, i64* %3, align 8
	%21 = call i8* @mem.ptr_offset-13939(i8* %19, i64 %20)
	%22 = getelementptr inbounds i8, i8* %21, i64 0
	%23 = load i8, i8* %22, align 1
	%24 = load i8*, i8** %1, align 8
	%25 = load i64, i64* %3, align 8
	%26 = call i8* @mem.ptr_offset-13939(i8* %24, i64 %25)
	%27 = getelementptr inbounds i8, i8* %26, i64 0
	%28 = load i8, i8* %27, align 1
	%29 = icmp ult i8 %23, %28
	%30 = zext i1 %29 to i8
	%31 = icmp eq i8 1, %30
	br i1 %31, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%32 = load i8*, i8** %0, align 8
	%33 = load i64, i64* %3, align 8
	%34 = call i8* @mem.ptr_offset-13939(i8* %32, i64 %33)
	%35 = getelementptr inbounds i8, i8* %34, i64 0
	%36 = load i8, i8* %35, align 1
	%37 = load i8*, i8** %1, align 8
	%38 = load i64, i64* %3, align 8
	%39 = call i8* @mem.ptr_offset-13939(i8* %37, i64 %38)
	%40 = getelementptr inbounds i8, i8* %39, i64 0
	%41 = load i8, i8* %40, align 1
	%42 = icmp ugt i8 %36, %41
	%43 = zext i1 %42 to i8
	%44 = icmp eq i8 1, %43
	br i1 %44, label %switch.fall.body-6, label %switch.case.next-5

switch.case.body-4:
	; ReturnStmt
	ret i64 -1

switch.case.next-5:
	br label %for.interval.loop-1

switch.fall.body-6:
	; ReturnStmt
	ret i64 1

for.interval.done-7:
	; ReturnStmt
	ret i64 0
}

define i8 @mem.is_power_of_two(i64 %x, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	store i64 %x, i64* %0
	; IfStmt
	%1 = load i64, i64* %0, align 8
	%2 = icmp ule i64 %1, 0
	%3 = zext i1 %2 to i8
	%4 = trunc i8 %3 to i1
	br i1 %4, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ReturnStmt
	%5 = load i64, i64* %0, align 8
	%6 = load i64, i64* %0, align 8
	%7 = sub i64 %6, 1
	%8 = and i64 %5, %7
	%9 = icmp eq i64 %8, 0
	%10 = zext i1 %9 to i8
	ret i8 %10
}

define i64 @mem.align_forward_uintptr(i64 %ptr, i64 %align, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	store i64 %ptr, i64* %0
	store i64 %align, i64* %1
	%6 = load i64, i64* %1, align 8
	%7 = call i8 @mem.is_power_of_two(i64 %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%8 = trunc i8 %7 to i1
	%9 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$58, i64 0, i32 0), i64 53}, i64 149, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$59, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %2
	%10 = call i8 @runtime.assert(i1 %8, %..string zeroinitializer, %runtime.Source_Code_Location* %2)
	; a
	%11 = load i64, i64* %1, align 8
	store i64 %11, i64* %3
	; p
	%12 = load i64, i64* %0, align 8
	store i64 %12, i64* %4
	; modulo
	%13 = load i64, i64* %4, align 8
	%14 = load i64, i64* %3, align 8
	%15 = sub i64 %14, 1
	%16 = and i64 %13, %15
	store i64 %16, i64* %5
	; IfStmt
	%17 = load i64, i64* %5, align 8
	%18 = icmp ne i64 %17, 0
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	%21 = load i64, i64* %3, align 8
	%22 = load i64, i64* %5, align 8
	%23 = sub i64 %21, %22
	%24 = load i64, i64* %4, align 8
	%25 = add i64 %24, %23
	store i64 %25, i64* %4
	br label %if.done-2

if.done-2:
	; ReturnStmt
	%26 = load i64, i64* %4, align 8
	ret i64 %26
}

define %..rawptr @mem.alloc(i64 %size, i64 %alignment, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	store i64 %size, i64* %0
	store i64 %alignment, i64* %1
	%3 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%4 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%5 = load i64, i64* %0, align 8
	%6 = icmp eq i64 %5, 0
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	br i1 %8, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %..rawptr zeroinitializer

if.done-2:
	; IfStmt
	; SelectorExpr
	%9 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 0
	%10 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %9, align 8
	%11 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret %..rawptr zeroinitializer

if.done-4:
	; ReturnStmt
	; SelectorExpr
	%14 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 0
	%15 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %14, align 8
	; SelectorExpr
	%16 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 1
	%17 = load %..rawptr, %..rawptr* %16, align 8
	%18 = load i64, i64* %0, align 8
	%19 = load i64, i64* %1, align 8
	%20 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%21 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %20, %runtime.Source_Code_Location* %2
	%22 = call %..rawptr %15(%..rawptr %17, i8 0, i64 %18, i64 %19, %..rawptr zeroinitializer, i64 0, i64 0, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret %..rawptr %22
}

define void @mem.free(%..rawptr %ptr, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	store %..rawptr %ptr, %..rawptr* %0
	%2 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%3 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%4 = load %..rawptr, %..rawptr* %0, align 8
	%5 = icmp eq %..rawptr %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; IfStmt
	; SelectorExpr
	%8 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 0
	%9 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %8, align 8
	%10 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret void

if.done-4:
	; SelectorExpr
	%13 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 0
	%14 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %13, align 8
	; SelectorExpr
	%15 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %allocator, i64 0, i32 1
	%16 = load %..rawptr, %..rawptr* %15, align 8
	%17 = load %..rawptr, %..rawptr* %0, align 8
	%18 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%19 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %18, %runtime.Source_Code_Location* %1
	%20 = call %..rawptr %14(%..rawptr %16, i8 1, i64 0, i64 0, %..rawptr %17, i64 0, i64 0, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret void
}

define void @mem.delete_cstring(i8* %str, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i8*, align 16
	%1 = alloca %mem.Allocator, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	store i8* %str, i8** %0
	%3 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%4 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%5 = load i8*, i8** %0, align 8
	%6 = bitcast i8* %5 to i8*
	%7 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%9 = bitcast i8* %6 to %..rawptr
	%10 = bitcast %mem.Allocator* %1 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %1
	store %mem.Allocator %7, %mem.Allocator* %1
	%11 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %8, %runtime.Source_Code_Location* %2
	call void @mem.free(%..rawptr %9, %mem.Allocator* %1, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define %..rawptr @mem.nil_allocator_proc(%..rawptr %allocator_data, i8 %mode, i64 %size, i64 %alignment, %..rawptr %old_memory, i64 %old_size, i64 %flags, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..rawptr, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	store %..rawptr %allocator_data, %..rawptr* %0
	store i8 %mode, i8* %1
	store i64 %size, i64* %2
	store i64 %alignment, i64* %3
	store %..rawptr %old_memory, %..rawptr* %4
	store i64 %old_size, i64* %5
	store i64 %flags, i64* %6
	%7 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; ReturnStmt
	ret %..rawptr zeroinitializer
}

define %mem.Allocator @mem.nil_allocator(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Allocator, align 16
	; ReturnStmt
	; CompoundLit
	%1 = bitcast %mem.Allocator* %0 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %0
	store %mem.Allocator {%..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* zeroinitializer, %..rawptr zeroinitializer}, %mem.Allocator* %0
	%2 = bitcast %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* @mem.nil_allocator_proc to %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*
	%3 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %0, i64 0, i32 0
	store %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %2, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %3
	%4 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %0, i64 0, i32 1
	store %..rawptr zeroinitializer, %..rawptr* %4
	%5 = load %mem.Allocator, %mem.Allocator* %0, align 8
	ret %mem.Allocator %5
}

define void @mem.scratch_allocator_init(%mem.Scratch_Allocator* %scratch, {i8*, i64}* %data, %mem.Allocator* %backup_allocator, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Scratch_Allocator*, align 16
	store %mem.Scratch_Allocator* %scratch, %mem.Scratch_Allocator** %0
	%1 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%2 = load %mem.Allocator, %mem.Allocator* %backup_allocator, align 8
	; AssignStmt
	; SelectorExpr
	%3 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %0, align 8
	%4 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %3, i64 0
	%5 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %4, i64 0, i32 0
	%6 = load {i8*, i64}, {i8*, i64}* %data, align 8
	store {i8*, i64} %6, {i8*, i64}* %5
	; AssignStmt
	; SelectorExpr
	%7 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %0, align 8
	%8 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %7, i64 0
	%9 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %8, i64 0, i32 1
	store i64 0, i64* %9
	; AssignStmt
	; SelectorExpr
	%10 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %0, align 8
	%11 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %10, i64 0
	%12 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %11, i64 0, i32 2
	store i64 0, i64* %12
	; AssignStmt
	; SelectorExpr
	%13 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %0, align 8
	%14 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %13, i64 0
	%15 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %14, i64 0, i32 3
	%16 = load %mem.Allocator, %mem.Allocator* %backup_allocator, align 8
	store %mem.Allocator %16, %mem.Allocator* %15
	ret void
}

define %..rawptr @mem.scratch_allocator_proc(%..rawptr %allocator_data, i8 %mode, i64 %size, i64 %alignment, %..rawptr %old_memory, i64 %old_size, i64 %flags, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..rawptr, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca %mem.Scratch_Allocator*, align 16
	%8 = alloca %mem.Allocator, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca {i8*, i64}, align 16
	%11 = alloca %mem.Allocator, align 16
	%12 = alloca i64, align 16
	%13 = alloca i8*, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8*, align 16
	%16 = alloca %mem.Allocator, align 16
	%17 = alloca %..rawptr, align 16
	%18 = alloca %mem.Allocator, align 16
	%19 = alloca %runtime.Source_Code_Location, align 16
	%20 = alloca %mem.Allocator, align 16
	%21 = alloca %runtime.Source_Code_Location, align 16
	%22 = alloca %runtime.Source_Code_Location, align 16
	%23 = alloca %..rawptr, align 16
	%24 = alloca i64, align 16
	%25 = alloca %..rawptr, align 16
	%26 = alloca i64, align 16
	%27 = alloca %mem.Allocator, align 16
	%28 = alloca %runtime.Source_Code_Location, align 16
	%29 = alloca %..rawptr, align 16
	%30 = alloca %runtime.Source_Code_Location, align 16
	store %..rawptr %allocator_data, %..rawptr* %0
	store i8 %mode, i8* %1
	store i64 %size, i64* %2
	store i64 %alignment, i64* %3
	store %..rawptr %old_memory, %..rawptr* %4
	store i64 %old_size, i64* %5
	store i64 %flags, i64* %6
	%31 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; scratch
	%32 = load %..rawptr, %..rawptr* %0, align 8
	%33 = bitcast %..rawptr %32 to %mem.Scratch_Allocator*
	store %mem.Scratch_Allocator* %33, %mem.Scratch_Allocator** %7
	; IfStmt
	; SelectorExpr
	%34 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%35 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %34, i64 0
	%36 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %35, i64 0, i32 0
	%37 = load {i8*, i64}, {i8*, i64}* %36, align 8
	%38 = extractvalue {i8*, i64} %37, 0
	%39 = extractvalue {i8*, i64} %37, 1
	%40 = bitcast %..rawptr null to i8*
	%41 = icmp eq i8* %38, %40
	%42 = icmp eq i64 %39, 0
	%43 = zext i1 %41 to i8
	%44 = zext i1 %42 to i8
	%45 = or i8 %43, %44
	%46 = trunc i8 %45 to i1
	br i1 %46, label %if.then-1, label %if.done-2

if.then-1:
	%47 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	; SelectorExpr
	%48 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%49 = load %mem.Allocator, %mem.Allocator* %48, align 8
	%50 = bitcast %mem.Allocator* %8 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %8
	store %mem.Allocator %49, %mem.Allocator* %8
	%51 = bitcast %runtime.Source_Code_Location* %9 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %9
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$5a, i64 0, i32 0), i64 55}, i64 190, i64 35, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$5b, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %9
	%52 = call {i8*, i64} @mem.make_slice-14294(i64 4194304, %mem.Allocator* %8, %runtime.Source_Code_Location* %9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%53 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%54 = load %mem.Allocator, %mem.Allocator* %53, align 8
	%55 = bitcast {i8*, i64}* %10 to %..rawptr
	store {i8*, i64} zeroinitializer, {i8*, i64}* %10
	store {i8*, i64} %52, {i8*, i64}* %10
	%56 = bitcast %mem.Allocator* %11 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %11
	store %mem.Allocator %54, %mem.Allocator* %11
	call void @mem.scratch_allocator_init(%mem.Scratch_Allocator* %47, {i8*, i64}* %10, %mem.Allocator* %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-2

if.done-2:
	; SwitchStmt
	%57 = load i8, i8* %1, align 1
	%58 = icmp eq i8 %57, 0
	br i1 %58, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%59 = icmp eq i8 %57, 1
	br i1 %59, label %switch.fall.body-14, label %switch.case.next-13

switch.case.body-4:
	; SwitchStmt
	; SelectorExpr
	%60 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%61 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %60, i64 0
	%62 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %61, i64 0, i32 1
	%63 = load i64, i64* %62, align 8
	%64 = load i64, i64* %2, align 8
	%65 = add i64 %63, %64
	; SelectorExpr
	%66 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%67 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %66, i64 0
	%68 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %67, i64 0, i32 0
	%69 = load {i8*, i64}, {i8*, i64}* %68, align 8
	%70 = extractvalue {i8*, i64} %69, 1
	%71 = icmp sle i64 %65, %70
	%72 = zext i1 %71 to i8
	%73 = icmp eq i8 1, %72
	br i1 %73, label %switch.case.body-6, label %switch.case.next-5

switch.case.next-5:
	%74 = load i64, i64* %2, align 8
	; SelectorExpr
	%75 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%76 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %75, i64 0
	%77 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %76, i64 0, i32 0
	%78 = load {i8*, i64}, {i8*, i64}* %77, align 8
	%79 = extractvalue {i8*, i64} %78, 1
	%80 = icmp sle i64 %74, %79
	%81 = zext i1 %80 to i8
	%82 = icmp eq i8 1, %81
	br i1 %82, label %switch.fall.body-8, label %switch.case.next-7

switch.case.body-6:
	; offset
	; SelectorExpr
	%83 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%84 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %83, i64 0
	%85 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %84, i64 0, i32 1
	%86 = load i64, i64* %85, align 8
	%87 = bitcast i64 %86 to i64
	%88 = load i64, i64* %3, align 8
	%89 = bitcast i64 %88 to i64
	%90 = call i64 @mem.align_forward_uintptr(i64 %87, i64 %89, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %90, i64* %12
	; ptr
	; IndexExpr
	; SelectorExpr
	%91 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%92 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %91, i64 0
	%93 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %92, i64 0, i32 0
	%94 = load {i8*, i64}, {i8*, i64}* %93, align 8
	%95 = extractvalue {i8*, i64} %94, 0
	%96 = load i64, i64* %12, align 8
	%97 = bitcast i64 %96 to i64
	%98 = extractvalue {i8*, i64} %94, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$5c, i64 0, i32 0), i64 55}, i64 198, i64 25, i64 %97, i64 %98)
	%99 = getelementptr inbounds i8, i8* %95, i64 %97
	store i8* %99, i8** %13
	%100 = load i8*, i8** %13, align 8
	%101 = load i64, i64* %2, align 8
	%102 = bitcast i8* %100 to %..rawptr
	%103 = call %..rawptr @mem.zero(%..rawptr %102, i64 %101)
	; AssignStmt
	; SelectorExpr
	%104 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%105 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %104, i64 0
	%106 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %105, i64 0, i32 2
	%107 = load i64, i64* %12, align 8
	%108 = bitcast i64 %107 to i64
	store i64 %108, i64* %106
	; AssignStmt
	; SelectorExpr
	%109 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%110 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %109, i64 0
	%111 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %110, i64 0, i32 1
	%112 = load i64, i64* %12, align 8
	%113 = bitcast i64 %112 to i64
	%114 = load i64, i64* %2, align 8
	%115 = add i64 %113, %114
	store i64 %115, i64* %111
	; ReturnStmt
	%116 = load i8*, i8** %13, align 8
	%117 = bitcast i8* %116 to %..rawptr
	ret %..rawptr %117

switch.case.next-7:
	; a
	; SelectorExpr
	%118 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%119 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %118, i64 0
	%120 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %119, i64 0, i32 3
	%121 = load %mem.Allocator, %mem.Allocator* %120, align 8
	store %mem.Allocator %121, %mem.Allocator* %16
	; IfStmt
	; SelectorExpr
	%122 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %16, i64 0, i32 0
	%123 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %122, align 8
	%124 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %123, zeroinitializer
	%125 = zext i1 %124 to i8
	%126 = trunc i8 %125 to i1
	br i1 %126, label %if.then-9, label %if.done-10

switch.fall.body-8:
	; offset
	%127 = load i64, i64* %3, align 8
	%128 = bitcast i64 %127 to i64
	%129 = call i64 @mem.align_forward_uintptr(i64 0, i64 %128, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %129, i64* %14
	; ptr
	; IndexExpr
	; SelectorExpr
	%130 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%131 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %130, i64 0
	%132 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %131, i64 0, i32 0
	%133 = load {i8*, i64}, {i8*, i64}* %132, align 8
	%134 = extractvalue {i8*, i64} %133, 0
	%135 = load i64, i64* %14, align 8
	%136 = bitcast i64 %135 to i64
	%137 = extractvalue {i8*, i64} %133, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$5d, i64 0, i32 0), i64 55}, i64 205, i64 25, i64 %136, i64 %137)
	%138 = getelementptr inbounds i8, i8* %134, i64 %136
	store i8* %138, i8** %15
	%139 = load i8*, i8** %15, align 8
	%140 = load i64, i64* %2, align 8
	%141 = bitcast i8* %139 to %..rawptr
	%142 = call %..rawptr @mem.zero(%..rawptr %141, i64 %140)
	; AssignStmt
	; SelectorExpr
	%143 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%144 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %143, i64 0
	%145 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %144, i64 0, i32 2
	%146 = load i64, i64* %14, align 8
	%147 = bitcast i64 %146 to i64
	store i64 %147, i64* %145
	; AssignStmt
	; SelectorExpr
	%148 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%149 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %148, i64 0
	%150 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %149, i64 0, i32 1
	%151 = load i64, i64* %14, align 8
	%152 = bitcast i64 %151 to i64
	%153 = load i64, i64* %2, align 8
	%154 = add i64 %152, %153
	store i64 %154, i64* %150
	; ReturnStmt
	%155 = load i8*, i8** %15, align 8
	%156 = bitcast i8* %155 to %..rawptr
	ret %..rawptr %156

if.then-9:
	; AssignStmt
	; SelectorExpr
	%157 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%158 = load %mem.Allocator, %mem.Allocator* %157, align 8
	store %mem.Allocator %158, %mem.Allocator* %16
	; AssignStmt
	; SelectorExpr
	%159 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%160 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %159, i64 0
	%161 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %160, i64 0, i32 3
	%162 = load %mem.Allocator, %mem.Allocator* %16, align 8
	store %mem.Allocator %162, %mem.Allocator* %161
	br label %if.done-10

if.done-10:
	; ptr
	%163 = load i64, i64* %2, align 8
	%164 = load i64, i64* %3, align 8
	%165 = load %mem.Allocator, %mem.Allocator* %16, align 8
	%166 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%167 = bitcast %mem.Allocator* %18 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %18
	store %mem.Allocator %165, %mem.Allocator* %18
	%168 = bitcast %runtime.Source_Code_Location* %19 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %19
	store %runtime.Source_Code_Location %166, %runtime.Source_Code_Location* %19
	%169 = call %..rawptr @mem.alloc(i64 %163, i64 %164, %mem.Allocator* %18, %runtime.Source_Code_Location* %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %169, %..rawptr* %17
	; IfStmt
	; SelectorExpr
	%170 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%171 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %170, i64 0
	%172 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %171, i64 0, i32 4
	%173 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %172, align 8
	%174 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %173, 0
	%175 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %173, 2
	%176 = bitcast %..rawptr null to %..rawptr*
	%177 = icmp eq %..rawptr* %174, %176
	%178 = icmp eq i64 %175, 0
	%179 = zext i1 %177 to i8
	%180 = zext i1 %178 to i8
	%181 = or i8 %179, %180
	%182 = trunc i8 %181 to i1
	br i1 %182, label %if.then-11, label %if.done-12

if.then-11:
	; AssignStmt
	; SelectorExpr
	%183 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%184 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %183, i64 0
	%185 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %184, i64 0, i32 4
	%186 = load %mem.Allocator, %mem.Allocator* %16, align 8
	%187 = bitcast %mem.Allocator* %20 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %20
	store %mem.Allocator %186, %mem.Allocator* %20
	%188 = bitcast %runtime.Source_Code_Location* %21 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %21
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$5e, i64 0, i32 0), i64 55}, i64 220, i64 33, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$5f, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %21
	%189 = call {%..rawptr*, i64, i64, %mem.Allocator} @mem.make_dynamic_array-14399(%mem.Allocator* %20, %runtime.Source_Code_Location* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {%..rawptr*, i64, i64, %mem.Allocator} %189, {%..rawptr*, i64, i64, %mem.Allocator}* %185
	br label %if.done-12

if.done-12:
	; SelectorExpr
	%190 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%191 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %190, i64 0
	%192 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %191, i64 0, i32 4
	%193 = load %..rawptr, %..rawptr* %17, align 8
	%194 = bitcast %runtime.Source_Code_Location* %22 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %22
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$60, i64 0, i32 0), i64 55}, i64 222, i64 3, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$61, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %22
	%195 = call i64 @runtime.append_elem-14444({%..rawptr*, i64, i64, %mem.Allocator}* %192, %..rawptr %193, %runtime.Source_Code_Location* %22, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%196 = load %..rawptr, %..rawptr* %17, align 8
	ret %..rawptr %196

switch.case.next-13:
	%197 = icmp eq i8 %57, 2
	br i1 %197, label %switch.fall.body-18, label %switch.case.next-17

switch.fall.body-14:
	; last_ptr
	; IndexExpr
	; SelectorExpr
	%198 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%199 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %198, i64 0
	%200 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %199, i64 0, i32 0
	%201 = load {i8*, i64}, {i8*, i64}* %200, align 8
	%202 = extractvalue {i8*, i64} %201, 0
	; SelectorExpr
	%203 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%204 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %203, i64 0
	%205 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %204, i64 0, i32 2
	%206 = load i64, i64* %205, align 8
	%207 = extractvalue {i8*, i64} %201, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$62, i64 0, i32 0), i64 55}, i64 227, i64 44, i64 %206, i64 %207)
	%208 = getelementptr inbounds i8, i8* %202, i64 %206
	%209 = bitcast i8* %208 to %..rawptr
	store %..rawptr %209, %..rawptr* %23
	; IfStmt
	%210 = load %..rawptr, %..rawptr* %4, align 8
	%211 = load %..rawptr, %..rawptr* %23, align 8
	%212 = icmp eq %..rawptr %210, %211
	%213 = zext i1 %212 to i8
	%214 = trunc i8 %213 to i1
	br i1 %214, label %if.then-15, label %if.done-16

if.then-15:
	; size
	; SelectorExpr
	%215 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%216 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %215, i64 0
	%217 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %216, i64 0, i32 1
	%218 = load i64, i64* %217, align 8
	; SelectorExpr
	%219 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%220 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %219, i64 0
	%221 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %220, i64 0, i32 2
	%222 = load i64, i64* %221, align 8
	%223 = sub i64 %218, %222
	store i64 %223, i64* %24
	; AssignStmt
	; SelectorExpr
	%224 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%225 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %224, i64 0
	%226 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %225, i64 0, i32 1
	; SelectorExpr
	%227 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%228 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %227, i64 0
	%229 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %228, i64 0, i32 2
	%230 = load i64, i64* %229, align 8
	store i64 %230, i64* %226
	%231 = load %..rawptr, %..rawptr* %23, align 8
	%232 = load i64, i64* %24, align 8
	%233 = call %..rawptr @mem.zero(%..rawptr %231, i64 %232)
	; ReturnStmt
	ret %..rawptr zeroinitializer

if.done-16:
	br label %switch.done-27

switch.case.next-17:
	%234 = icmp eq i8 %57, 3
	br i1 %234, label %switch.fall.body-23, label %switch.case.next-22

switch.fall.body-18:
	; AssignStmt
	; SelectorExpr
	%235 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%236 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %235, i64 0
	%237 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %236, i64 0, i32 1
	store i64 0, i64* %237
	; AssignStmt
	; SelectorExpr
	%238 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%239 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %238, i64 0
	%240 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %239, i64 0, i32 2
	store i64 0, i64* %240
	; RangeStmt
	; ptr
	%241 = bitcast %..rawptr* %25 to %..rawptr
	store %..rawptr zeroinitializer, %..rawptr* %25
	; SelectorExpr
	%242 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%243 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %242, i64 0
	%244 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %243, i64 0, i32 4
	%245 = getelementptr inbounds {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %244, i64 0, i32 1
	%246 = bitcast i64* %26 to %..rawptr
	store i64 zeroinitializer, i64* %26
	store i64 -1, i64* %26
	br label %for.index.loop-19

for.index.loop-19:
	%247 = load i64, i64* %26, align 8
	%248 = add i64 %247, 1
	store i64 %248, i64* %26
	%249 = load i64, i64* %245, align 8
	%250 = icmp slt i64 %248, %249
	br i1 %250, label %for.index.body-20, label %for.index.done-21

for.index.body-20:
	%251 = load i64, i64* %26, align 8
	%252 = getelementptr inbounds {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %244, i64 0, i32 0
	%253 = load %..rawptr*, %..rawptr** %252, align 8
	%254 = getelementptr inbounds %..rawptr, %..rawptr* %253, i64 %251
	%255 = load %..rawptr, %..rawptr* %254, align 8
	store %..rawptr %255, %..rawptr* %25
	%256 = load %..rawptr, %..rawptr* %25, align 8
	; SelectorExpr
	%257 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%258 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %257, i64 0
	%259 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %258, i64 0, i32 3
	%260 = load %mem.Allocator, %mem.Allocator* %259, align 8
	%261 = bitcast %mem.Allocator* %27 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %27
	store %mem.Allocator %260, %mem.Allocator* %27
	%262 = bitcast %runtime.Source_Code_Location* %28 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %28
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$63, i64 0, i32 0), i64 55}, i64 240, i64 4, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$64, i64 0, i32 0), i64 22}}, %runtime.Source_Code_Location* %28
	call void @mem.free(%..rawptr %256, %mem.Allocator* %27, %runtime.Source_Code_Location* %28, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-19

for.index.done-21:
	; SelectorExpr
	%263 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%264 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %263, i64 0
	%265 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %264, i64 0, i32 4
	call void @runtime.clear_dynamic_array-14473({%..rawptr*, i64, i64, %mem.Allocator}* %265)
	br label %switch.done-27

switch.case.next-22:
	br label %switch.done-27

switch.fall.body-23:
	; last_ptr
	; IndexExpr
	; SelectorExpr
	%266 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%267 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %266, i64 0
	%268 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %267, i64 0, i32 0
	%269 = load {i8*, i64}, {i8*, i64}* %268, align 8
	%270 = extractvalue {i8*, i64} %269, 0
	; SelectorExpr
	%271 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%272 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %271, i64 0
	%273 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %272, i64 0, i32 2
	%274 = load i64, i64* %273, align 8
	%275 = extractvalue {i8*, i64} %269, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$65, i64 0, i32 0), i64 55}, i64 245, i64 44, i64 %274, i64 %275)
	%276 = getelementptr inbounds i8, i8* %270, i64 %274
	%277 = bitcast i8* %276 to %..rawptr
	store %..rawptr %277, %..rawptr* %29
	; IfStmt
	%278 = load %..rawptr, %..rawptr* %4, align 8
	%279 = load %..rawptr, %..rawptr* %29, align 8
	%280 = icmp eq %..rawptr %278, %279
	%281 = zext i1 %280 to i8
	%282 = trunc i8 %281 to i1
	br i1 %282, label %cmp.and-24, label %if.done-26

cmp.and-24:
	; SelectorExpr
	%283 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%284 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %283, i64 0
	%285 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %284, i64 0, i32 0
	%286 = load {i8*, i64}, {i8*, i64}* %285, align 8
	%287 = extractvalue {i8*, i64} %286, 1
	; SelectorExpr
	%288 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%289 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %288, i64 0
	%290 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %289, i64 0, i32 2
	%291 = load i64, i64* %290, align 8
	%292 = sub i64 %287, %291
	%293 = load i64, i64* %2, align 8
	%294 = icmp sge i64 %292, %293
	%295 = zext i1 %294 to i8
	%296 = trunc i8 %295 to i1
	br i1 %296, label %if.then-25, label %if.done-26

if.then-25:
	; AssignStmt
	; SelectorExpr
	%297 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%298 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %297, i64 0
	%299 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %298, i64 0, i32 1
	; SelectorExpr
	%300 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%301 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %300, i64 0
	%302 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %301, i64 0, i32 2
	%303 = load i64, i64* %302, align 8
	%304 = load i64, i64* %2, align 8
	%305 = add i64 %303, %304
	store i64 %305, i64* %299
	; ReturnStmt
	%306 = load %..rawptr, %..rawptr* %4, align 8
	ret %..rawptr %306

if.done-26:
	; ReturnStmt
	%307 = load %..rawptr, %..rawptr* %0, align 8
	%308 = load i64, i64* %2, align 8
	%309 = load i64, i64* %3, align 8
	%310 = load %..rawptr, %..rawptr* %4, align 8
	%311 = load i64, i64* %5, align 8
	%312 = load i64, i64* %6, align 8
	%313 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%314 = bitcast %runtime.Source_Code_Location* %30 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %30
	store %runtime.Source_Code_Location %313, %runtime.Source_Code_Location* %30
	%315 = call %..rawptr @mem.scratch_allocator_proc(%..rawptr %307, i8 0, i64 %308, i64 %309, %..rawptr %310, i64 %311, i64 %312, %runtime.Source_Code_Location* %30, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret %..rawptr %315

switch.done-27:
	; ReturnStmt
	ret %..rawptr zeroinitializer
}

define {i64, i64} @os.write_string(i32 %fd, %..string %str, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i8*, align 16
	%3 = alloca {i8*, i64}, align 16
	%4 = alloca {i8*, i64}, align 16
	%5 = alloca {i64, i64}, align 16
	store i32 %fd, i32* %0
	store %..string %str, %..string* %1
	; ReturnStmt
	%6 = load i32, i32* %0, align 4
	%7 = load %..string, %..string* %1, align 8
	%8 = extractvalue %..string %7, 0
	%9 = bitcast i8** %2 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 8) noinline
	store i8* zeroinitializer, i8** %2
	store i8* %8, i8** %2
	%11 = extractvalue %..string %7, 1
	%12 = sub i64 %11, 0
	%13 = load i8*, i8** %2, align 8
	%14 = getelementptr inbounds i8, i8* %13, i64 0
	%15 = bitcast {i8*, i64}* %3 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %3
	%17 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3, i64 0, i32 0
	store i8* %14, i8** %17
	%18 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3, i64 0, i32 1
	store i64 %12, i64* %18
	%19 = load {i8*, i64}, {i8*, i64}* %3, align 8
	%20 = bitcast {i8*, i64}* %4 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %4
	store {i8*, i64} %19, {i8*, i64}* %4
	%22 = call {i64, i64} @os.write(i32 %6, {i8*, i64}* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = extractvalue {i64, i64} %22, 0
	%24 = extractvalue {i64, i64} %22, 1
	%25 = bitcast {i64, i64}* %5 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %5
	%27 = getelementptr inbounds {i64, i64}, {i64, i64}* %5, i64 0, i32 0
	store i64 %23, i64* %27
	%28 = getelementptr inbounds {i64, i64}, {i64, i64}* %5, i64 0, i32 1
	store i64 %24, i64* %28
	%29 = load {i64, i64}, {i64, i64}* %5, align 8
	ret {i64, i64} %29
}

define {i64, i64} @os.write_byte(i32 %fd, i8 %b, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i8, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca {i8*, i64}, align 16
	%4 = alloca {i64, i64}, align 16
	store i32 %fd, i32* %0
	store i8 %b, i8* %1
	; ReturnStmt
	%5 = load i32, i32* %0, align 4
	; CompoundLit
	%6 = bitcast {i8*, i64}* %2 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %2
	%8 = getelementptr inbounds [1 x i8], [1 x i8]* @csba$0, i64 0, i32 0
	%9 = load i8, i8* %1, align 1
	%10 = getelementptr inbounds i8, i8* %8, i64 0
	store i8 %9, i8* %10
	%11 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 0
	store i8* %8, i8** %11
	%12 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 1
	store i64 1, i64* %12
	%13 = load {i8*, i64}, {i8*, i64}* %2, align 8
	%14 = bitcast {i8*, i64}* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %3
	store {i8*, i64} %13, {i8*, i64}* %3
	%16 = call {i64, i64} @os.write(i32 %5, {i8*, i64}* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = extractvalue {i64, i64} %16, 0
	%18 = extractvalue {i64, i64} %16, 1
	%19 = bitcast {i64, i64}* %4 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %4
	%21 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 0
	store i64 %17, i64* %21
	%22 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 1
	store i64 %18, i64* %22
	%23 = load {i64, i64}, {i64, i64}* %4, align 8
	ret {i64, i64} %23
}

define {i64, i64} @os.write_rune(i32 %fd, i32 %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i32, align 16
	%2 = alloca {i64, i64}, align 16
	%3 = alloca [4 x i8], align 16
	%4 = alloca i64, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca {i8*, i64}, align 16
	%7 = alloca {i64, i64}, align 16
	store i32 %fd, i32* %0
	store i32 %r, i32* %1
	; IfStmt
	%8 = load i32, i32* %1, align 4
	%9 = icmp slt i32 %8, 128
	%10 = zext i1 %9 to i8
	%11 = trunc i8 %10 to i1
	br i1 %11, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%12 = load i32, i32* %0, align 4
	%13 = load i32, i32* %1, align 4
	%14 = trunc i32 %13 to i8
	%15 = call {i64, i64} @os.write_byte(i32 %12, i8 %14, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%16 = extractvalue {i64, i64} %15, 0
	%17 = extractvalue {i64, i64} %15, 1
	%18 = bitcast {i64, i64}* %2 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %2
	%20 = getelementptr inbounds {i64, i64}, {i64, i64}* %2, i64 0, i32 0
	store i64 %16, i64* %20
	%21 = getelementptr inbounds {i64, i64}, {i64, i64}* %2, i64 0, i32 1
	store i64 %17, i64* %21
	%22 = load {i64, i64}, {i64, i64}* %2, align 8
	ret {i64, i64} %22

if.done-2:
	; b
	; n
	; SelectorExpr
	%23 = load i32, i32* %1, align 4
	%24 = call {[4 x i8], i64} @utf8.encode_rune(i32 %23, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%25 = extractvalue {[4 x i8], i64} %24, 0
	%26 = extractvalue {[4 x i8], i64} %24, 1
	store [4 x i8] %25, [4 x i8]* %3
	store i64 %26, i64* %4
	; ReturnStmt
	%27 = load i32, i32* %0, align 4
	; SliceExpr
	%28 = load i64, i64* %4, align 8
	%29 = load [4 x i8], [4 x i8]* %3, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([52 x i8], [52 x i8]* @str$66, i64 0, i32 0), i64 51}, i64 21, i64 20, i64 0, i64 %28, i64 4)
	%30 = getelementptr inbounds [4 x i8], [4 x i8]* %3, i64 0, i32 0
	%31 = getelementptr inbounds i8, i8* %30, i64 0
	%32 = sub i64 %28, 0
	%33 = bitcast {i8*, i64}* %5 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	%35 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 0
	store i8* %31, i8** %35
	%36 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 1
	store i64 %32, i64* %36
	%37 = load {i8*, i64}, {i8*, i64}* %5, align 8
	%38 = bitcast {i8*, i64}* %6 to %..rawptr
	%39 = call %..rawptr @mem.zero(%..rawptr %38, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	store {i8*, i64} %37, {i8*, i64}* %6
	%40 = call {i64, i64} @os.write(i32 %27, {i8*, i64}* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%41 = extractvalue {i64, i64} %40, 0
	%42 = extractvalue {i64, i64} %40, 1
	%43 = bitcast {i64, i64}* %7 to %..rawptr
	%44 = call %..rawptr @mem.zero(%..rawptr %43, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %7
	%45 = getelementptr inbounds {i64, i64}, {i64, i64}* %7, i64 0, i32 0
	store i64 %41, i64* %45
	%46 = getelementptr inbounds {i64, i64}, {i64, i64}* %7, i64 0, i32 1
	store i64 %42, i64* %46
	%47 = load {i64, i64}, {i64, i64}* %7, align 8
	ret {i64, i64} %47
}

define void @os.write_encoded_rune(i32 %fd, i32 %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i32, align 16
	%2 = alloca [2 x i8], align 16
	%3 = alloca %..string, align 16
	%4 = alloca {i8*, i64}, align 16
	%5 = alloca {i8*, i64}, align 16
	store i32 %fd, i32* %0
	store i32 %r, i32* %1
	%6 = load i32, i32* %0, align 4
	%7 = call {i64, i64} @os.write_byte(i32 %6, i8 39, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SwitchStmt
	%8 = load i32, i32* %1, align 4
	%9 = icmp eq i32 %8, 7
	br i1 %9, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%10 = icmp eq i32 %8, 8
	br i1 %10, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	%11 = load i32, i32* %0, align 4
	%12 = call {i64, i64} @os.write_string(i32 %11, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$67, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-3:
	%13 = icmp eq i32 %8, 27
	br i1 %13, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	%14 = load i32, i32* %0, align 4
	%15 = call {i64, i64} @os.write_string(i32 %14, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$68, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-5:
	%16 = icmp eq i32 %8, 12
	br i1 %16, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	%17 = load i32, i32* %0, align 4
	%18 = call {i64, i64} @os.write_string(i32 %17, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$69, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-7:
	%19 = icmp eq i32 %8, 10
	br i1 %19, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	%20 = load i32, i32* %0, align 4
	%21 = call {i64, i64} @os.write_string(i32 %20, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$6a, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-9:
	%22 = icmp eq i32 %8, 13
	br i1 %22, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	%23 = load i32, i32* %0, align 4
	%24 = call {i64, i64} @os.write_string(i32 %23, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$6b, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-11:
	%25 = icmp eq i32 %8, 9
	br i1 %25, label %switch.fall.body-14, label %switch.case.next-13

switch.fall.body-12:
	%26 = load i32, i32* %0, align 4
	%27 = call {i64, i64} @os.write_string(i32 %26, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$6c, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-13:
	%28 = icmp eq i32 %8, 11
	br i1 %28, label %switch.fall.body-16, label %switch.case.next-15

switch.fall.body-14:
	%29 = load i32, i32* %0, align 4
	%30 = call {i64, i64} @os.write_string(i32 %29, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$6d, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-15:
	; IfStmt
	%31 = load i32, i32* %1, align 4
	%32 = icmp slt i32 %31, 32
	%33 = zext i1 %32 to i8
	%34 = trunc i8 %33 to i1
	br i1 %34, label %if.then-17, label %if.else-25

switch.fall.body-16:
	%35 = load i32, i32* %0, align 4
	%36 = call {i64, i64} @os.write_string(i32 %35, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$6e, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

if.then-17:
	%37 = load i32, i32* %0, align 4
	%38 = call {i64, i64} @os.write_string(i32 %37, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$6f, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; b
	%39 = bitcast [2 x i8]* %2 to %..rawptr
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 2) noinline
	store [2 x i8] zeroinitializer, [2 x i8]* %2
	; s
	; SelectorExpr
	; SliceExpr
	%41 = load [2 x i8], [2 x i8]* %2, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([52 x i8], [52 x i8]* @str$70, i64 0, i32 0), i64 51}, i64 40, i64 30, i64 0, i64 2, i64 2)
	%42 = getelementptr inbounds [2 x i8], [2 x i8]* %2, i64 0, i32 0
	%43 = getelementptr inbounds i8, i8* %42, i64 0
	%44 = sub i64 2, 0
	%45 = bitcast {i8*, i64}* %4 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %4
	%47 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4, i64 0, i32 0
	store i8* %43, i8** %47
	%48 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4, i64 0, i32 1
	store i64 %44, i64* %48
	%49 = load {i8*, i64}, {i8*, i64}* %4, align 8
	%50 = load i32, i32* %1, align 4
	%51 = sext i32 %50 to i64
	; SelectorExpr
	%52 = load %..string, %..string* @strconv.digits, align 8
	%53 = bitcast {i8*, i64}* %5 to %..rawptr
	%54 = call %..rawptr @mem.zero(%..rawptr %53, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	store {i8*, i64} %49, {i8*, i64}* %5
	%55 = call %..string @strconv.append_bits({i8*, i64}* %5, i64 %51, i64 16, i1 true, i64 64, %..string %52, i8 zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %55, %..string* %3
	; SwitchStmt
	%56 = load %..string, %..string* %3, align 8
	%57 = extractvalue %..string %56, 1
	%58 = icmp eq i64 %57, 0
	br i1 %58, label %switch.case.body-19, label %switch.case.next-18

switch.case.next-18:
	%59 = icmp eq i64 %57, 1
	br i1 %59, label %switch.fall.body-21, label %switch.case.next-20

switch.case.body-19:
	%60 = load i32, i32* %0, align 4
	%61 = call {i64, i64} @os.write_string(i32 %60, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$71, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-20:
	%62 = icmp eq i64 %57, 2
	br i1 %62, label %switch.fall.body-23, label %switch.case.next-22

switch.fall.body-21:
	%63 = load i32, i32* %0, align 4
	%64 = call {i64, i64} @os.write_rune(i32 %63, i32 48, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-22:
	br label %switch.done-24

switch.fall.body-23:
	%65 = load i32, i32* %0, align 4
	%66 = load %..string, %..string* %3, align 8
	%67 = call {i64, i64} @os.write_string(i32 %65, %..string %66, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.done-24:
	br label %if.done-26

if.else-25:
	%68 = load i32, i32* %0, align 4
	%69 = load i32, i32* %1, align 4
	%70 = call {i64, i64} @os.write_rune(i32 %68, i32 %69, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-26

if.done-26:
	br label %switch.done-27

switch.done-27:
	%71 = load i32, i32* %0, align 4
	%72 = call {i64, i64} @os.write_byte(i32 %71, i8 39, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define {{i8*, i64}, i8} @os.read_entire_file(%..string %name, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca {i8*, i64}, align 16
	%2 = alloca i8, align 16
	%3 = alloca i32, align 16
	%4 = alloca i64, align 16
	%5 = alloca {{i8*, i64}, i8}, align 16
	%6 = alloca i64, align 16
	%7 = alloca {{i8*, i64}, i8}, align 16
	%8 = alloca {{i8*, i64}, i8}, align 16
	%9 = alloca %mem.Allocator, align 16
	%10 = alloca %runtime.Source_Code_Location, align 16
	%11 = alloca {{i8*, i64}, i8}, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca {i8*, i64}, align 16
	%15 = alloca {i8*, i64}, align 16
	%16 = alloca %mem.Allocator, align 16
	%17 = alloca %runtime.Source_Code_Location, align 16
	%18 = alloca {{i8*, i64}, i8}, align 16
	%19 = alloca {i8*, i64}, align 16
	%20 = alloca {{i8*, i64}, i8}, align 16
	store %..string %name, %..string* %0
	%21 = bitcast {i8*, i64}* %1 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %1
	%23 = bitcast i8* %2 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 1) noinline
	store i8 zeroinitializer, i8* %2
	; fd
	; err
	%25 = load %..string, %..string* %0, align 8
	%26 = call {i32, i64} @os.open(%..string %25, i64 0, i32 0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%27 = extractvalue {i32, i64} %26, 0
	%28 = extractvalue {i32, i64} %26, 1
	store i32 %27, i32* %3
	store i64 %28, i64* %4
	; IfStmt
	%29 = load i64, i64* %4, align 8
	%30 = icmp ne i64 %29, 0
	%31 = zext i1 %30 to i8
	%32 = trunc i8 %31 to i1
	br i1 %32, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%33 = bitcast {{i8*, i64}, i8}* %5 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 24) noinline
	store {{i8*, i64}, i8} zeroinitializer, {{i8*, i64}, i8}* %5
	%35 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %5, i64 0, i32 0
	store {i8*, i64} zeroinitializer, {i8*, i64}* %35
	%36 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %5, i64 0, i32 1
	store i8 0, i8* %36
	%37 = load {{i8*, i64}, i8}, {{i8*, i64}, i8}* %5, align 8
	ret {{i8*, i64}, i8} %37

if.done-2:
	; DeferStmt
	; length
	%38 = bitcast i64* %6 to %..rawptr
	%39 = call %..rawptr @mem.zero(%..rawptr %38, i64 8) noinline
	store i64 zeroinitializer, i64* %6
	; IfStmt
	; AssignStmt
	%40 = load i32, i32* %3, align 4
	%41 = call {i64, i64} @os.file_size(i32 %40, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%42 = extractvalue {i64, i64} %41, 0
	%43 = extractvalue {i64, i64} %41, 1
	store i64 %42, i64* %6
	store i64 %43, i64* %4
	%44 = load i64, i64* %4, align 8
	%45 = icmp ne i64 %44, 0
	%46 = zext i1 %45 to i8
	%47 = trunc i8 %46 to i1
	br i1 %47, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	%48 = bitcast {{i8*, i64}, i8}* %7 to %..rawptr
	%49 = call %..rawptr @mem.zero(%..rawptr %48, i64 24) noinline
	store {{i8*, i64}, i8} zeroinitializer, {{i8*, i64}, i8}* %7
	%50 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %7, i64 0, i32 0
	store {i8*, i64} zeroinitializer, {i8*, i64}* %50
	%51 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %7, i64 0, i32 1
	store i8 0, i8* %51
	%52 = load {{i8*, i64}, i8}, {{i8*, i64}, i8}* %7, align 8
	; defer
	%53 = load i32, i32* %3, align 4
	call void @os.close(i32 %53, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {{i8*, i64}, i8} %52

if.done-4:
	; IfStmt
	%54 = load i64, i64* %6, align 8
	%55 = icmp sle i64 %54, 0
	%56 = zext i1 %55 to i8
	%57 = trunc i8 %56 to i1
	br i1 %57, label %if.then-5, label %if.done-6

if.then-5:
	; ReturnStmt
	%58 = bitcast {{i8*, i64}, i8}* %8 to %..rawptr
	%59 = call %..rawptr @mem.zero(%..rawptr %58, i64 24) noinline
	store {{i8*, i64}, i8} zeroinitializer, {{i8*, i64}, i8}* %8
	%60 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %8, i64 0, i32 0
	store {i8*, i64} zeroinitializer, {i8*, i64}* %60
	%61 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %8, i64 0, i32 1
	store i8 1, i8* %61
	%62 = load {{i8*, i64}, i8}, {{i8*, i64}, i8}* %8, align 8
	; defer
	%63 = load i32, i32* %3, align 4
	call void @os.close(i32 %63, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {{i8*, i64}, i8} %62

if.done-6:
	; AssignStmt
	%64 = load i64, i64* %6, align 8
	%65 = bitcast i64 %64 to i64
	; SelectorExpr
	%66 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%67 = load %mem.Allocator, %mem.Allocator* %66, align 8
	%68 = bitcast %mem.Allocator* %9 to %..rawptr
	%69 = call %..rawptr @mem.zero(%..rawptr %68, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %9
	store %mem.Allocator %67, %mem.Allocator* %9
	%70 = bitcast %runtime.Source_Code_Location* %10 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %10
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([52 x i8], [52 x i8]* @str$72, i64 0, i32 0), i64 51}, i64 70, i64 9, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$73, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %10
	%72 = call {i8*, i64} @mem.make_slice-14294(i64 %65, %mem.Allocator* %9, %runtime.Source_Code_Location* %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64} %72, {i8*, i64}* %1
	; IfStmt
	%73 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%74 = extractvalue {i8*, i64} %73, 0
	%75 = extractvalue {i8*, i64} %73, 1
	%76 = bitcast %..rawptr null to i8*
	%77 = icmp eq i8* %74, %76
	%78 = icmp eq i64 %75, 0
	%79 = zext i1 %77 to i8
	%80 = zext i1 %78 to i8
	%81 = or i8 %79, %80
	%82 = trunc i8 %81 to i1
	br i1 %82, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	%83 = bitcast {{i8*, i64}, i8}* %11 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 24) noinline
	store {{i8*, i64}, i8} zeroinitializer, {{i8*, i64}, i8}* %11
	%85 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %11, i64 0, i32 0
	store {i8*, i64} zeroinitializer, {i8*, i64}* %85
	%86 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %11, i64 0, i32 1
	store i8 0, i8* %86
	%87 = load {{i8*, i64}, i8}, {{i8*, i64}, i8}* %11, align 8
	; defer
	%88 = load i32, i32* %3, align 4
	call void @os.close(i32 %88, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {{i8*, i64}, i8} %87

if.done-8:
	; bytes_read
	; read_err
	%89 = load i32, i32* %3, align 4
	%90 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%91 = bitcast {i8*, i64}* %14 to %..rawptr
	%92 = call %..rawptr @mem.zero(%..rawptr %91, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %14
	store {i8*, i64} %90, {i8*, i64}* %14
	%93 = call {i64, i64} @os.read(i32 %89, {i8*, i64}* %14, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%94 = extractvalue {i64, i64} %93, 0
	%95 = extractvalue {i64, i64} %93, 1
	store i64 %94, i64* %12
	store i64 %95, i64* %13
	; IfStmt
	%96 = load i64, i64* %13, align 8
	%97 = icmp ne i64 %96, 0
	%98 = zext i1 %97 to i8
	%99 = trunc i8 %98 to i1
	br i1 %99, label %if.then-9, label %if.done-10

if.then-9:
	%100 = load {i8*, i64}, {i8*, i64}* %1, align 8
	; SelectorExpr
	%101 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%102 = load %mem.Allocator, %mem.Allocator* %101, align 8
	%103 = bitcast {i8*, i64}* %15 to %..rawptr
	%104 = call %..rawptr @mem.zero(%..rawptr %103, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %15
	store {i8*, i64} %100, {i8*, i64}* %15
	%105 = bitcast %mem.Allocator* %16 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %16
	store %mem.Allocator %102, %mem.Allocator* %16
	%107 = bitcast %runtime.Source_Code_Location* %17 to %..rawptr
	%108 = call %..rawptr @mem.zero(%..rawptr %107, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %17
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([52 x i8], [52 x i8]* @str$74, i64 0, i32 0), i64 51}, i64 77, i64 3, %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$75, i64 0, i32 0), i64 16}}, %runtime.Source_Code_Location* %17
	call void @mem.delete_slice-14814({i8*, i64}* %15, %mem.Allocator* %16, %runtime.Source_Code_Location* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%109 = bitcast {{i8*, i64}, i8}* %18 to %..rawptr
	%110 = call %..rawptr @mem.zero(%..rawptr %109, i64 24) noinline
	store {{i8*, i64}, i8} zeroinitializer, {{i8*, i64}, i8}* %18
	%111 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %18, i64 0, i32 0
	store {i8*, i64} zeroinitializer, {i8*, i64}* %111
	%112 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %18, i64 0, i32 1
	store i8 0, i8* %112
	%113 = load {{i8*, i64}, i8}, {{i8*, i64}, i8}* %18, align 8
	; defer
	%114 = load i32, i32* %3, align 4
	call void @os.close(i32 %114, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {{i8*, i64}, i8} %113

if.done-10:
	; ReturnStmt
	; SliceExpr
	%115 = load i64, i64* %12, align 8
	%116 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%117 = extractvalue {i8*, i64} %116, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([52 x i8], [52 x i8]* @str$76, i64 0, i32 0), i64 51}, i64 80, i64 13, i64 0, i64 %115, i64 %117)
	%118 = extractvalue {i8*, i64} %116, 0
	%119 = getelementptr inbounds i8, i8* %118, i64 0
	%120 = sub i64 %115, 0
	%121 = bitcast {i8*, i64}* %19 to %..rawptr
	%122 = call %..rawptr @mem.zero(%..rawptr %121, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %19
	%123 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %19, i64 0, i32 0
	store i8* %119, i8** %123
	%124 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %19, i64 0, i32 1
	store i64 %120, i64* %124
	%125 = load {i8*, i64}, {i8*, i64}* %19, align 8
	%126 = bitcast {{i8*, i64}, i8}* %20 to %..rawptr
	%127 = call %..rawptr @mem.zero(%..rawptr %126, i64 24) noinline
	store {{i8*, i64}, i8} zeroinitializer, {{i8*, i64}, i8}* %20
	%128 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %20, i64 0, i32 0
	store {i8*, i64} %125, {i8*, i64}* %128
	%129 = getelementptr inbounds {{i8*, i64}, i8}, {{i8*, i64}, i8}* %20, i64 0, i32 1
	store i8 1, i8* %129
	%130 = load {{i8*, i64}, i8}, {{i8*, i64}, i8}* %20, align 8
	; defer
	%131 = load i32, i32* %3, align 4
	call void @os.close(i32 %131, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {{i8*, i64}, i8} %130
}

define i8 @os.write_entire_file(%..string %name, {i8*, i64}* %data, i1 %truncate, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i8, align 16
	%2 = alloca i8, align 16
	%3 = alloca i64, align 16
	%4 = alloca i32, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca {i8*, i64}, align 16
	store %..string %name, %..string* %0
	%8 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%9 = zext i1 %truncate to i8
	store i8 %9, i8* %1
	%10 = bitcast i8* %2 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 1) noinline
	store i8 zeroinitializer, i8* %2
	; flags
	store i64 65, i64* %3
	; IfStmt
	%12 = load i8, i8* %1, align 1
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	%14 = load i64, i64* %3, align 8
	%15 = or i64 %14, 512
	store i64 %15, i64* %3
	br label %if.done-2

if.done-2:
	; fd
	; err
	%16 = load %..string, %..string* %0, align 8
	%17 = load i64, i64* %3, align 8
	%18 = call {i32, i64} @os.open(%..string %16, i64 %17, i32 0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = extractvalue {i32, i64} %18, 0
	%20 = extractvalue {i32, i64} %18, 1
	store i32 %19, i32* %4
	store i64 %20, i64* %5
	; IfStmt
	%21 = load i64, i64* %5, align 8
	%22 = icmp ne i64 %21, 0
	%23 = zext i1 %22 to i8
	%24 = trunc i8 %23 to i1
	br i1 %24, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 0

if.done-4:
	; DeferStmt
	; write_err
	%25 = load i32, i32* %4, align 4
	%26 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%27 = bitcast {i8*, i64}* %7 to %..rawptr
	%28 = call %..rawptr @mem.zero(%..rawptr %27, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %7
	store {i8*, i64} %26, {i8*, i64}* %7
	%29 = call {i64, i64} @os.write(i32 %25, {i8*, i64}* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%30 = extractvalue {i64, i64} %29, 0
	%31 = extractvalue {i64, i64} %29, 1
	store i64 %31, i64* %6
	; ReturnStmt
	%32 = load i64, i64* %6, align 8
	%33 = icmp eq i64 %32, 0
	%34 = zext i1 %33 to i8
	; defer
	%35 = load i32, i32* %4, align 4
	call void @os.close(i32 %35, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret i8 %34
}

define %..rawptr @os.heap_allocator_proc(%..rawptr %allocator_data, i8 %mode, i64 %size, i64 %alignment, %..rawptr %old_memory, i64 %old_size, i64 %flags, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..rawptr, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store %..rawptr %allocator_data, %..rawptr* %0
	store i8 %mode, i8* %1
	store i64 %size, i64* %2
	store i64 %alignment, i64* %3
	store %..rawptr %old_memory, %..rawptr* %4
	store i64 %old_size, i64* %5
	store i64 %flags, i64* %6
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SwitchStmt
	%10 = load i8, i8* %1, align 1
	%11 = icmp eq i8 %10, 0
	br i1 %11, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%12 = icmp eq i8 %10, 1
	br i1 %12, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	; ReturnStmt
	%13 = load i64, i64* %2, align 8
	%14 = call %..rawptr @os.heap_alloc(i64 %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret %..rawptr %14

switch.case.next-3:
	%15 = icmp eq i8 %10, 2
	br i1 %15, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	%16 = load %..rawptr, %..rawptr* %4, align 8
	call void @os.heap_free(%..rawptr %16, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret %..rawptr zeroinitializer

switch.case.next-5:
	%17 = icmp eq i8 %10, 3
	br i1 %17, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	br label %switch.done-11

switch.case.next-7:
	br label %switch.done-11

switch.fall.body-8:
	; IfStmt
	%18 = load %..rawptr, %..rawptr* %4, align 8
	%19 = icmp eq %..rawptr %18, zeroinitializer
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %if.then-9, label %if.done-10

if.then-9:
	; ReturnStmt
	%22 = load i64, i64* %2, align 8
	%23 = call %..rawptr @os.heap_alloc(i64 %22, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret %..rawptr %23

if.done-10:
	; ptr
	%24 = load %..rawptr, %..rawptr* %4, align 8
	%25 = load i64, i64* %2, align 8
	%26 = call %..rawptr @os.heap_resize(%..rawptr %24, i64 %25, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %26, %..rawptr* %7
	%27 = load %..rawptr, %..rawptr* %7, align 8
	%28 = icmp ne %..rawptr %27, zeroinitializer
	%29 = zext i1 %28 to i8
	%30 = trunc i8 %29 to i1
	%31 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%32 = call %..rawptr @mem.zero(%..rawptr %31, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([52 x i8], [52 x i8]* @str$77, i64 0, i32 0), i64 51}, i64 130, i64 3, %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$78, i64 0, i32 0), i64 19}}, %runtime.Source_Code_Location* %8
	%33 = call i8 @runtime.assert(i1 %30, %..string zeroinitializer, %runtime.Source_Code_Location* %8)
	; ReturnStmt
	%34 = load %..rawptr, %..rawptr* %7, align 8
	ret %..rawptr %34

switch.done-11:
	; ReturnStmt
	ret %..rawptr zeroinitializer
}

define %mem.Allocator @os.heap_allocator(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Allocator, align 16
	; ReturnStmt
	; CompoundLit
	%1 = bitcast %mem.Allocator* %0 to %..rawptr
	%2 = call %..rawptr @mem.zero(%..rawptr %1, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %0
	store %mem.Allocator {%..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* zeroinitializer, %..rawptr zeroinitializer}, %mem.Allocator* %0
	%3 = bitcast %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* @os.heap_allocator_proc to %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*
	%4 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %0, i64 0, i32 0
	store %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %3, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %4
	%5 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %0, i64 0, i32 1
	store %..rawptr zeroinitializer, %..rawptr* %5
	%6 = load %mem.Allocator, %mem.Allocator* %0, align 8
	ret %mem.Allocator %6
}

define {i32, i64} @os.open_simple(%..string %path, i64 %mode, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8*, align 16
	%3 = alloca i32, align 16
	%4 = alloca {i32, i64}, align 16
	%5 = alloca %mem.Allocator, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca {i32, i64}, align 16
	%8 = alloca %mem.Allocator, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca %mem.Allocator, align 16
	%11 = alloca %runtime.Source_Code_Location, align 16
	store %..string %path, %..string* %0
	store i64 %mode, i64* %1
	; cstr
	; SelectorExpr
	%12 = load %..string, %..string* %0, align 8
	%13 = call i8* @strings.new_cstring(%..string %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i8* %13, i8** %2
	; DeferStmt
	; handle
	%14 = load i8*, i8** %2, align 8
	%15 = load i64, i64* %1, align 8
	%16 = call ccc i32 @open(i8* %14, i64 %15)
	store i32 %16, i32* %3
	; IfStmt
	%17 = load i32, i32* %3, align 4
	%18 = icmp eq i32 %17, -1
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%21 = bitcast {i32, i64}* %4 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %4
	%23 = getelementptr inbounds {i32, i64}, {i32, i64}* %4, i64 0, i32 0
	store i32 0, i32* %23
	%24 = getelementptr inbounds {i32, i64}, {i32, i64}* %4, i64 0, i32 1
	store i64 1, i64* %24
	%25 = load {i32, i64}, {i32, i64}* %4, align 8
	; defer
	%26 = load i8*, i8** %2, align 8
	; SelectorExpr
	%27 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%28 = load %mem.Allocator, %mem.Allocator* %27, align 8
	%29 = bitcast %mem.Allocator* %5 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %5
	store %mem.Allocator %28, %mem.Allocator* %5
	%31 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%32 = call %..rawptr @mem.zero(%..rawptr %31, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$79, i64 0, i32 0), i64 55}, i64 157, i64 8, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$7a, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	call void @mem.delete_cstring(i8* %26, %mem.Allocator* %5, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i32, i64} %25

if.done-2:
	; ReturnStmt
	%33 = load i32, i32* %3, align 4
	%34 = bitcast {i32, i64}* %7 to %..rawptr
	%35 = call %..rawptr @mem.zero(%..rawptr %34, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %7
	%36 = getelementptr inbounds {i32, i64}, {i32, i64}* %7, i64 0, i32 0
	store i32 %33, i32* %36
	%37 = getelementptr inbounds {i32, i64}, {i32, i64}* %7, i64 0, i32 1
	store i64 0, i64* %37
	%38 = load {i32, i64}, {i32, i64}* %7, align 8
	; defer
	%39 = load i8*, i8** %2, align 8
	; SelectorExpr
	%40 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%41 = load %mem.Allocator, %mem.Allocator* %40, align 8
	%42 = bitcast %mem.Allocator* %8 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %8
	store %mem.Allocator %41, %mem.Allocator* %8
	%44 = bitcast %runtime.Source_Code_Location* %9 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %9
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$7b, i64 0, i32 0), i64 55}, i64 157, i64 8, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$7c, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %9
	call void @mem.delete_cstring(i8* %39, %mem.Allocator* %8, %runtime.Source_Code_Location* %9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i32, i64} %38
}

define {i32, i64} @os.open(%..string %path, i64 %mode, i32 %perm, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i32, align 16
	%3 = alloca {i32, i64}, align 16
	store %..string %path, %..string* %0
	store i64 %mode, i64* %1
	store i32 %perm, i32* %2
	; ReturnStmt
	%4 = load %..string, %..string* %0, align 8
	%5 = load i64, i64* %1, align 8
	%6 = call {i32, i64} @os.open_simple(%..string %4, i64 %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = extractvalue {i32, i64} %6, 0
	%8 = extractvalue {i32, i64} %6, 1
	%9 = bitcast {i32, i64}* %3 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %3
	%11 = getelementptr inbounds {i32, i64}, {i32, i64}* %3, i64 0, i32 0
	store i32 %7, i32* %11
	%12 = getelementptr inbounds {i32, i64}, {i32, i64}* %3, i64 0, i32 1
	store i64 %8, i64* %12
	%13 = load {i32, i64}, {i32, i64}* %3, align 8
	ret {i32, i64} %13
}

define void @os.close(i32 %fd, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	store i32 %fd, i32* %0
	%1 = load i32, i32* %0, align 4
	call ccc void @close(i32 %1)
	ret void
}

define {i64, i64} @os.write(i32 %fd, {i8*, i64}* %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = alloca i64, align 16
	%3 = alloca {i64, i64}, align 16
	%4 = alloca {i64, i64}, align 16
	store i32 %fd, i32* %0
	%5 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%6 = load i32, i32* %0, align 4
	%7 = icmp ne i32 %6, -1
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	%10 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$7d, i64 0, i32 0), i64 55}, i64 175, i64 2, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$7e, i64 0, i32 0), i64 5}}, %runtime.Source_Code_Location* %1
	%12 = call i8 @runtime.assert(i1 %9, %..string zeroinitializer, %runtime.Source_Code_Location* %1)
	; bytes_written
	%13 = load i32, i32* %0, align 4
	; IndexExpr
	%14 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%15 = extractvalue {i8*, i64} %14, 0
	%16 = extractvalue {i8*, i64} %14, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$7f, i64 0, i32 0), i64 55}, i64 177, i64 41, i64 0, i64 %16)
	%17 = getelementptr inbounds i8, i8* %15, i64 0
	%18 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%19 = extractvalue {i8*, i64} %18, 1
	%20 = bitcast i8* %17 to %..rawptr
	%21 = call ccc i64 @write(i32 %13, %..rawptr %20, i64 %19)
	store i64 %21, i64* %2
	; IfStmt
	%22 = load i64, i64* %2, align 8
	%23 = icmp eq i64 %22, -1
	%24 = zext i1 %23 to i8
	%25 = trunc i8 %24 to i1
	br i1 %25, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%26 = bitcast {i64, i64}* %3 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %3
	%28 = getelementptr inbounds {i64, i64}, {i64, i64}* %3, i64 0, i32 0
	store i64 0, i64* %28
	%29 = getelementptr inbounds {i64, i64}, {i64, i64}* %3, i64 0, i32 1
	store i64 1, i64* %29
	%30 = load {i64, i64}, {i64, i64}* %3, align 8
	ret {i64, i64} %30

if.done-2:
	; ReturnStmt
	%31 = load i64, i64* %2, align 8
	%32 = bitcast {i64, i64}* %4 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %4
	%34 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 0
	store i64 %31, i64* %34
	%35 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 1
	store i64 0, i64* %35
	%36 = load {i64, i64}, {i64, i64}* %4, align 8
	ret {i64, i64} %36
}

define {i64, i64} @os.read(i32 %fd, {i8*, i64}* %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = alloca i64, align 16
	%3 = alloca {i64, i64}, align 16
	%4 = alloca {i64, i64}, align 16
	store i32 %fd, i32* %0
	%5 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%6 = load i32, i32* %0, align 4
	%7 = icmp ne i32 %6, -1
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	%10 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$80, i64 0, i32 0), i64 55}, i64 185, i64 2, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$81, i64 0, i32 0), i64 4}}, %runtime.Source_Code_Location* %1
	%12 = call i8 @runtime.assert(i1 %9, %..string zeroinitializer, %runtime.Source_Code_Location* %1)
	; bytes_read
	%13 = load i32, i32* %0, align 4
	; IndexExpr
	%14 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%15 = extractvalue {i8*, i64} %14, 0
	%16 = extractvalue {i8*, i64} %14, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$82, i64 0, i32 0), i64 55}, i64 187, i64 37, i64 0, i64 %16)
	%17 = getelementptr inbounds i8, i8* %15, i64 0
	%18 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%19 = extractvalue {i8*, i64} %18, 1
	%20 = bitcast i8* %17 to %..rawptr
	%21 = call ccc i64 @read(i32 %13, %..rawptr %20, i64 %19)
	store i64 %21, i64* %2
	; IfStmt
	%22 = load i64, i64* %2, align 8
	%23 = icmp eq i64 %22, -1
	%24 = zext i1 %23 to i8
	%25 = trunc i8 %24 to i1
	br i1 %25, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%26 = bitcast {i64, i64}* %3 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %3
	%28 = getelementptr inbounds {i64, i64}, {i64, i64}* %3, i64 0, i32 0
	store i64 0, i64* %28
	%29 = getelementptr inbounds {i64, i64}, {i64, i64}* %3, i64 0, i32 1
	store i64 1, i64* %29
	%30 = load {i64, i64}, {i64, i64}* %3, align 8
	ret {i64, i64} %30

if.done-2:
	; ReturnStmt
	%31 = load i64, i64* %2, align 8
	%32 = bitcast {i64, i64}* %4 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %4
	%34 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 0
	store i64 %31, i64* %34
	%35 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 1
	store i64 0, i64* %35
	%36 = load {i64, i64}, {i64, i64}* %4, align 8
	ret {i64, i64} %36
}

define {i64, i64} @os.seek(i32 %fd, i64 %offset, i64 %whence, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca {i64, i64}, align 16
	%6 = alloca {i64, i64}, align 16
	store i32 %fd, i32* %0
	store i64 %offset, i64* %1
	store i64 %whence, i64* %2
	%7 = load i32, i32* %0, align 4
	%8 = icmp ne i32 %7, -1
	%9 = zext i1 %8 to i8
	%10 = trunc i8 %9 to i1
	%11 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$83, i64 0, i32 0), i64 55}, i64 195, i64 2, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$84, i64 0, i32 0), i64 4}}, %runtime.Source_Code_Location* %3
	%13 = call i8 @runtime.assert(i1 %10, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; final_offset
	%14 = load i32, i32* %0, align 4
	%15 = load i64, i64* %1, align 8
	%16 = bitcast i64 %15 to i64
	%17 = load i64, i64* %2, align 8
	%18 = call ccc i64 @lseek(i32 %14, i64 %16, i64 %17)
	%19 = bitcast i64 %18 to i64
	store i64 %19, i64* %4
	; IfStmt
	%20 = load i64, i64* %4, align 8
	%21 = icmp eq i64 %20, -1
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%24 = bitcast {i64, i64}* %5 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %5
	%26 = getelementptr inbounds {i64, i64}, {i64, i64}* %5, i64 0, i32 0
	store i64 0, i64* %26
	%27 = getelementptr inbounds {i64, i64}, {i64, i64}* %5, i64 0, i32 1
	store i64 1, i64* %27
	%28 = load {i64, i64}, {i64, i64}* %5, align 8
	ret {i64, i64} %28

if.done-2:
	; ReturnStmt
	%29 = load i64, i64* %4, align 8
	%30 = bitcast {i64, i64}* %6 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %6
	%32 = getelementptr inbounds {i64, i64}, {i64, i64}* %6, i64 0, i32 0
	store i64 %29, i64* %32
	%33 = getelementptr inbounds {i64, i64}, {i64, i64}* %6, i64 0, i32 1
	store i64 0, i64* %33
	%34 = load {i64, i64}, {i64, i64}* %6, align 8
	ret {i64, i64} %34
}

define {i64, i64} @os.file_size(i32 %fd, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca {i64, i64}, align 16
	store i32 %fd, i32* %0
	; prev
	%5 = load i32, i32* %0, align 4
	%6 = call {i64, i64} @os.seek(i32 %5, i64 0, i64 1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = extractvalue {i64, i64} %6, 0
	%8 = extractvalue {i64, i64} %6, 1
	store i64 %7, i64* %1
	; size
	; err
	%9 = load i32, i32* %0, align 4
	%10 = call {i64, i64} @os.seek(i32 %9, i64 0, i64 2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = extractvalue {i64, i64} %10, 0
	%12 = extractvalue {i64, i64} %10, 1
	store i64 %11, i64* %2
	store i64 %12, i64* %3
	%13 = load i32, i32* %0, align 4
	%14 = load i64, i64* %1, align 8
	%15 = call {i64, i64} @os.seek(i32 %13, i64 %14, i64 0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%16 = load i64, i64* %2, align 8
	%17 = load i64, i64* %3, align 8
	%18 = bitcast {i64, i64}* %4 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 16) noinline
	store {i64, i64} zeroinitializer, {i64, i64}* %4
	%20 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 0
	store i64 %16, i64* %20
	%21 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i64 0, i32 1
	store i64 %17, i64* %21
	%22 = load {i64, i64}, {i64, i64}* %4, align 8
	ret {i64, i64} %22
}

define %..rawptr @os.heap_alloc(i64 %size, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	store i64 %size, i64* %0
	%2 = load i64, i64* %0, align 8
	%3 = icmp sgt i64 %2, 0
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	%6 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$85, i64 0, i32 0), i64 55}, i64 238, i64 2, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$86, i64 0, i32 0), i64 10}}, %runtime.Source_Code_Location* %1
	%8 = call i8 @runtime.assert(i1 %5, %..string zeroinitializer, %runtime.Source_Code_Location* %1) alwaysinline
	; ReturnStmt
	%9 = load i64, i64* %0, align 8
	%10 = call ccc %..rawptr @calloc(i64 1, i64 %9) alwaysinline
	ret %..rawptr %10
}

define %..rawptr @os.heap_resize(%..rawptr %ptr, i64 %new_size, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i64, align 16
	store %..rawptr %ptr, %..rawptr* %0
	store i64 %new_size, i64* %1
	; ReturnStmt
	%2 = load %..rawptr, %..rawptr* %0, align 8
	%3 = load i64, i64* %1, align 8
	%4 = call ccc %..rawptr @realloc(%..rawptr %2, i64 %3) alwaysinline
	ret %..rawptr %4
}

define void @os.heap_free(%..rawptr %ptr, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..rawptr, align 16
	store %..rawptr %ptr, %..rawptr* %0
	%1 = load %..rawptr, %..rawptr* %0, align 8
	call ccc void @free(%..rawptr %1) alwaysinline
	ret void
}

define i64 @os.current_thread_id() #0 {
decls-0:
	; ReturnStmt
	ret i64 0
}

define {[4 x i8], i64} @utf8.encode_rune(i32 %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca [4 x i8], align 16
	%2 = alloca i32, align 16
	%3 = alloca {[4 x i8], i64}, align 16
	%4 = alloca {[4 x i8], i64}, align 16
	%5 = alloca {[4 x i8], i64}, align 16
	%6 = alloca {[4 x i8], i64}, align 16
	store i32 %r, i32* %0
	; buf
	%7 = bitcast [4 x i8]* %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 4) noinline
	store [4 x i8] zeroinitializer, [4 x i8]* %1
	; i
	%9 = load i32, i32* %0, align 4
	%10 = bitcast i32 %9 to i32
	store i32 %10, i32* %2
	; IfStmt
	%11 = load i32, i32* %2, align 4
	%12 = icmp ule i32 %11, 127
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; IndexExpr
	%15 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 0
	%16 = load i32, i32* %0, align 4
	%17 = trunc i32 %16 to i8
	store i8 %17, i8* %15
	; ReturnStmt
	%18 = load [4 x i8], [4 x i8]* %1, align 1
	%19 = bitcast {[4 x i8], i64}* %3 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 16) noinline
	store {[4 x i8], i64} zeroinitializer, {[4 x i8], i64}* %3
	%21 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %3, i64 0, i32 0
	store [4 x i8] %18, [4 x i8]* %21
	%22 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %3, i64 0, i32 1
	store i64 1, i64* %22
	%23 = load {[4 x i8], i64}, {[4 x i8], i64}* %3, align 8
	ret {[4 x i8], i64} %23

if.done-2:
	; IfStmt
	%24 = load i32, i32* %2, align 4
	%25 = icmp ule i32 %24, 2047
	%26 = zext i1 %25 to i8
	%27 = trunc i8 %26 to i1
	br i1 %27, label %if.then-3, label %if.done-4

if.then-3:
	; AssignStmt
	; IndexExpr
	%28 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 0
	%29 = load i32, i32* %0, align 4
	%30 = ashr i32 %29, 6
	%31 = trunc i32 %30 to i8
	%32 = or i8 192, %31
	store i8 %32, i8* %28
	; AssignStmt
	; IndexExpr
	%33 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 1
	%34 = load i32, i32* %0, align 4
	%35 = trunc i32 %34 to i8
	%36 = and i8 %35, 63
	%37 = or i8 128, %36
	store i8 %37, i8* %33
	; ReturnStmt
	%38 = load [4 x i8], [4 x i8]* %1, align 1
	%39 = bitcast {[4 x i8], i64}* %4 to %..rawptr
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 16) noinline
	store {[4 x i8], i64} zeroinitializer, {[4 x i8], i64}* %4
	%41 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %4, i64 0, i32 0
	store [4 x i8] %38, [4 x i8]* %41
	%42 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %4, i64 0, i32 1
	store i64 2, i64* %42
	%43 = load {[4 x i8], i64}, {[4 x i8], i64}* %4, align 8
	ret {[4 x i8], i64} %43

if.done-4:
	; IfStmt
	%44 = load i32, i32* %2, align 4
	%45 = icmp ugt i32 %44, 1114111
	%46 = zext i1 %45 to i8
	%47 = trunc i8 %46 to i1
	br i1 %47, label %if.then-7, label %cmp.or-5

cmp.or-5:
	%48 = load i32, i32* %2, align 4
	%49 = icmp ule i32 55296, %48
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%52 = load i32, i32* %2, align 4
	%53 = icmp ule i32 %52, 57343
	%54 = zext i1 %53 to i8
	%55 = trunc i8 %54 to i1
	br i1 %55, label %if.then-7, label %if.done-8

if.then-7:
	; AssignStmt
	store i32 65533, i32* %0
	br label %if.done-8

if.done-8:
	; IfStmt
	%56 = load i32, i32* %2, align 4
	%57 = icmp ule i32 %56, 65535
	%58 = zext i1 %57 to i8
	%59 = trunc i8 %58 to i1
	br i1 %59, label %if.then-9, label %if.done-10

if.then-9:
	; AssignStmt
	; IndexExpr
	%60 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 0
	%61 = load i32, i32* %0, align 4
	%62 = ashr i32 %61, 12
	%63 = trunc i32 %62 to i8
	%64 = or i8 224, %63
	store i8 %64, i8* %60
	; AssignStmt
	; IndexExpr
	%65 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 1
	%66 = load i32, i32* %0, align 4
	%67 = ashr i32 %66, 6
	%68 = trunc i32 %67 to i8
	%69 = and i8 %68, 63
	%70 = or i8 128, %69
	store i8 %70, i8* %65
	; AssignStmt
	; IndexExpr
	%71 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 2
	%72 = load i32, i32* %0, align 4
	%73 = trunc i32 %72 to i8
	%74 = and i8 %73, 63
	%75 = or i8 128, %74
	store i8 %75, i8* %71
	; ReturnStmt
	%76 = load [4 x i8], [4 x i8]* %1, align 1
	%77 = bitcast {[4 x i8], i64}* %5 to %..rawptr
	%78 = call %..rawptr @mem.zero(%..rawptr %77, i64 16) noinline
	store {[4 x i8], i64} zeroinitializer, {[4 x i8], i64}* %5
	%79 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %5, i64 0, i32 0
	store [4 x i8] %76, [4 x i8]* %79
	%80 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %5, i64 0, i32 1
	store i64 3, i64* %80
	%81 = load {[4 x i8], i64}, {[4 x i8], i64}* %5, align 8
	ret {[4 x i8], i64} %81

if.done-10:
	; AssignStmt
	; IndexExpr
	%82 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 0
	%83 = load i32, i32* %0, align 4
	%84 = ashr i32 %83, 18
	%85 = trunc i32 %84 to i8
	%86 = or i8 240, %85
	store i8 %86, i8* %82
	; AssignStmt
	; IndexExpr
	%87 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 1
	%88 = load i32, i32* %0, align 4
	%89 = ashr i32 %88, 12
	%90 = trunc i32 %89 to i8
	%91 = and i8 %90, 63
	%92 = or i8 128, %91
	store i8 %92, i8* %87
	; AssignStmt
	; IndexExpr
	%93 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 2
	%94 = load i32, i32* %0, align 4
	%95 = ashr i32 %94, 6
	%96 = trunc i32 %95 to i8
	%97 = and i8 %96, 63
	%98 = or i8 128, %97
	store i8 %98, i8* %93
	; AssignStmt
	; IndexExpr
	%99 = getelementptr inbounds [4 x i8], [4 x i8]* %1, i64 0, i32 3
	%100 = load i32, i32* %0, align 4
	%101 = trunc i32 %100 to i8
	%102 = and i8 %101, 63
	%103 = or i8 128, %102
	store i8 %103, i8* %99
	; ReturnStmt
	%104 = load [4 x i8], [4 x i8]* %1, align 1
	%105 = bitcast {[4 x i8], i64}* %6 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store {[4 x i8], i64} zeroinitializer, {[4 x i8], i64}* %6
	%107 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %6, i64 0, i32 0
	store [4 x i8] %104, [4 x i8]* %107
	%108 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %6, i64 0, i32 1
	store i64 4, i64* %108
	%109 = load {[4 x i8], i64}, {[4 x i8], i64}* %6, align 8
	ret {[4 x i8], i64} %109
}

define {i32, i64} @utf8.decode_rune_from_string(%..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i8*, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca {i8*, i64}, align 16
	%4 = alloca {i32, i64}, align 16
	store %..string %s, %..string* %0
	; ReturnStmt
	%5 = load %..string, %..string* %0, align 8
	%6 = extractvalue %..string %5, 0
	%7 = bitcast i8** %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 8) noinline
	store i8* zeroinitializer, i8** %1
	store i8* %6, i8** %1
	%9 = extractvalue %..string %5, 1
	%10 = sub i64 %9, 0
	%11 = load i8*, i8** %1, align 8
	%12 = getelementptr inbounds i8, i8* %11, i64 0
	%13 = bitcast {i8*, i64}* %2 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %2
	%15 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 0
	store i8* %12, i8** %15
	%16 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 1
	store i64 %10, i64* %16
	%17 = load {i8*, i64}, {i8*, i64}* %2, align 8
	%18 = bitcast {i8*, i64}* %3 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %3
	store {i8*, i64} %17, {i8*, i64}* %3
	%20 = call {i32, i64} @utf8.decode_rune({i8*, i64}* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	%21 = extractvalue {i32, i64} %20, 0
	%22 = extractvalue {i32, i64} %20, 1
	%23 = bitcast {i32, i64}* %4 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %4
	%25 = getelementptr inbounds {i32, i64}, {i32, i64}* %4, i64 0, i32 0
	store i32 %21, i32* %25
	%26 = getelementptr inbounds {i32, i64}, {i32, i64}* %4, i64 0, i32 1
	store i64 %22, i64* %26
	%27 = load {i32, i64}, {i32, i64}* %4, align 8
	ret {i32, i64} %27
}

define {i32, i64} @utf8.decode_rune({i8*, i64}* %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca {i32, i64}, align 16
	%2 = alloca i8, align 16
	%3 = alloca i8, align 16
	%4 = alloca i32, align 16
	%5 = alloca {i32, i64}, align 16
	%6 = alloca i8, align 16
	%7 = alloca %utf8.Accept_Range, align 16
	%8 = alloca {i32, i64}, align 16
	%9 = alloca i8, align 16
	%10 = alloca {i32, i64}, align 16
	%11 = alloca {i32, i64}, align 16
	%12 = alloca i8, align 16
	%13 = alloca {i32, i64}, align 16
	%14 = alloca {i32, i64}, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i32, i64}, align 16
	%17 = alloca {i32, i64}, align 16
	%18 = load {i8*, i64}, {i8*, i64}* %s, align 8
	; n
	%19 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%20 = extractvalue {i8*, i64} %19, 1
	store i64 %20, i64* %0
	; IfStmt
	%21 = load i64, i64* %0, align 8
	%22 = icmp slt i64 %21, 1
	%23 = zext i1 %22 to i8
	%24 = trunc i8 %23 to i1
	br i1 %24, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%25 = bitcast {i32, i64}* %1 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %1
	%27 = getelementptr inbounds {i32, i64}, {i32, i64}* %1, i64 0, i32 0
	store i32 65533, i32* %27
	%28 = getelementptr inbounds {i32, i64}, {i32, i64}* %1, i64 0, i32 1
	store i64 0, i64* %28
	%29 = load {i32, i64}, {i32, i64}* %1, align 8
	ret {i32, i64} %29

if.done-2:
	; s0
	; IndexExpr
	%30 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%31 = extractvalue {i8*, i64} %30, 0
	%32 = extractvalue {i8*, i64} %30, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$87, i64 0, i32 0), i64 63}, i64 103, i64 10, i64 0, i64 %32)
	%33 = getelementptr inbounds i8, i8* %31, i64 0
	%34 = load i8, i8* %33, align 1
	store i8 %34, i8* %2
	; x
	; IndexExpr
	%35 = load i8, i8* %2, align 1
	%36 = zext i8 %35 to i64
	%37 = trunc i64 %36 to i32
	%38 = getelementptr inbounds [256 x i8], [256 x i8]* @utf8.accept_sizes, i64 0, i32 %37
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$88, i64 0, i32 0), i64 63}, i64 104, i64 20, i64 %36, i64 256)
	%39 = load i8, i8* %38, align 1
	store i8 %39, i8* %3
	; IfStmt
	%40 = load i8, i8* %3, align 1
	%41 = icmp uge i8 %40, 240
	%42 = zext i1 %41 to i8
	%43 = trunc i8 %42 to i1
	br i1 %43, label %if.then-3, label %if.done-4

if.then-3:
	; mask
	%44 = load i8, i8* %3, align 1
	%45 = zext i8 %44 to i32
	%46 = shl i32 %45, 31
	%47 = ashr i32 %46, 31
	store i32 %47, i32* %4
	; ReturnStmt
	; IndexExpr
	%48 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%49 = extractvalue {i8*, i64} %48, 0
	%50 = extractvalue {i8*, i64} %48, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$89, i64 0, i32 0), i64 63}, i64 107, i64 17, i64 0, i64 %50)
	%51 = getelementptr inbounds i8, i8* %49, i64 0
	%52 = load i8, i8* %51, align 1
	%53 = zext i8 %52 to i32
	%54 = load i32, i32* %4, align 4
	%55 = xor i32 %54, -1
	%56 = and i32 %53, %55
	%57 = load i32, i32* %4, align 4
	%58 = and i32 65533, %57
	%59 = or i32 %56, %58
	%60 = bitcast {i32, i64}* %5 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %5
	%62 = getelementptr inbounds {i32, i64}, {i32, i64}* %5, i64 0, i32 0
	store i32 %59, i32* %62
	%63 = getelementptr inbounds {i32, i64}, {i32, i64}* %5, i64 0, i32 1
	store i64 1, i64* %63
	%64 = load {i32, i64}, {i32, i64}* %5, align 8
	ret {i32, i64} %64

if.done-4:
	; sz
	%65 = load i8, i8* %3, align 1
	%66 = and i8 %65, 7
	store i8 %66, i8* %6
	; accept
	; IndexExpr
	%67 = load i8, i8* %3, align 1
	%68 = lshr i8 %67, 4
	%69 = zext i8 %68 to i64
	%70 = trunc i64 %69 to i32
	%71 = getelementptr inbounds [5 x %utf8.Accept_Range], [5 x %utf8.Accept_Range]* @utf8.accept_ranges, i64 0, i32 %70
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$8a, i64 0, i32 0), i64 63}, i64 110, i64 26, i64 %69, i64 5)
	%72 = load %utf8.Accept_Range, %utf8.Accept_Range* %71, align 1
	store %utf8.Accept_Range %72, %utf8.Accept_Range* %7
	; IfStmt
	%73 = load i64, i64* %0, align 8
	%74 = load i8, i8* %6, align 1
	%75 = zext i8 %74 to i64
	%76 = icmp slt i64 %73, %75
	%77 = zext i1 %76 to i8
	%78 = trunc i8 %77 to i1
	br i1 %78, label %if.then-5, label %if.done-6

if.then-5:
	; ReturnStmt
	%79 = bitcast {i32, i64}* %8 to %..rawptr
	%80 = call %..rawptr @mem.zero(%..rawptr %79, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %8
	%81 = getelementptr inbounds {i32, i64}, {i32, i64}* %8, i64 0, i32 0
	store i32 65533, i32* %81
	%82 = getelementptr inbounds {i32, i64}, {i32, i64}* %8, i64 0, i32 1
	store i64 1, i64* %82
	%83 = load {i32, i64}, {i32, i64}* %8, align 8
	ret {i32, i64} %83

if.done-6:
	; b1
	; IndexExpr
	%84 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%85 = extractvalue {i8*, i64} %84, 0
	%86 = extractvalue {i8*, i64} %84, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$8b, i64 0, i32 0), i64 63}, i64 114, i64 10, i64 1, i64 %86)
	%87 = getelementptr inbounds i8, i8* %85, i64 1
	%88 = load i8, i8* %87, align 1
	store i8 %88, i8* %9
	; IfStmt
	%89 = load i8, i8* %9, align 1
	; SelectorExpr
	%90 = getelementptr inbounds %utf8.Accept_Range, %utf8.Accept_Range* %7, i64 0, i32 0
	%91 = load i8, i8* %90, align 1
	%92 = icmp ult i8 %89, %91
	%93 = zext i1 %92 to i8
	%94 = trunc i8 %93 to i1
	br i1 %94, label %if.then-8, label %cmp.or-7

cmp.or-7:
	; SelectorExpr
	%95 = getelementptr inbounds %utf8.Accept_Range, %utf8.Accept_Range* %7, i64 0, i32 1
	%96 = load i8, i8* %95, align 1
	%97 = load i8, i8* %9, align 1
	%98 = icmp ult i8 %96, %97
	%99 = zext i1 %98 to i8
	%100 = trunc i8 %99 to i1
	br i1 %100, label %if.then-8, label %if.done-9

if.then-8:
	; ReturnStmt
	%101 = bitcast {i32, i64}* %10 to %..rawptr
	%102 = call %..rawptr @mem.zero(%..rawptr %101, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %10
	%103 = getelementptr inbounds {i32, i64}, {i32, i64}* %10, i64 0, i32 0
	store i32 65533, i32* %103
	%104 = getelementptr inbounds {i32, i64}, {i32, i64}* %10, i64 0, i32 1
	store i64 1, i64* %104
	%105 = load {i32, i64}, {i32, i64}* %10, align 8
	ret {i32, i64} %105

if.done-9:
	; IfStmt
	%106 = load i8, i8* %6, align 1
	%107 = icmp eq i8 %106, 2
	%108 = zext i1 %107 to i8
	%109 = trunc i8 %108 to i1
	br i1 %109, label %if.then-10, label %if.done-11

if.then-10:
	; ReturnStmt
	%110 = load i8, i8* %2, align 1
	%111 = and i8 %110, 31
	%112 = zext i8 %111 to i32
	%113 = shl i32 %112, 6
	%114 = load i8, i8* %9, align 1
	%115 = and i8 %114, 63
	%116 = zext i8 %115 to i32
	%117 = or i32 %113, %116
	%118 = bitcast {i32, i64}* %11 to %..rawptr
	%119 = call %..rawptr @mem.zero(%..rawptr %118, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %11
	%120 = getelementptr inbounds {i32, i64}, {i32, i64}* %11, i64 0, i32 0
	store i32 %117, i32* %120
	%121 = getelementptr inbounds {i32, i64}, {i32, i64}* %11, i64 0, i32 1
	store i64 2, i64* %121
	%122 = load {i32, i64}, {i32, i64}* %11, align 8
	ret {i32, i64} %122

if.done-11:
	; b2
	; IndexExpr
	%123 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%124 = extractvalue {i8*, i64} %123, 0
	%125 = extractvalue {i8*, i64} %123, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$8c, i64 0, i32 0), i64 63}, i64 121, i64 10, i64 2, i64 %125)
	%126 = getelementptr inbounds i8, i8* %124, i64 2
	%127 = load i8, i8* %126, align 1
	store i8 %127, i8* %12
	; IfStmt
	%128 = load i8, i8* %12, align 1
	%129 = icmp ult i8 %128, 128
	%130 = zext i1 %129 to i8
	%131 = trunc i8 %130 to i1
	br i1 %131, label %if.then-13, label %cmp.or-12

cmp.or-12:
	%132 = load i8, i8* %12, align 1
	%133 = icmp ult i8 191, %132
	%134 = zext i1 %133 to i8
	%135 = trunc i8 %134 to i1
	br i1 %135, label %if.then-13, label %if.done-14

if.then-13:
	; ReturnStmt
	%136 = bitcast {i32, i64}* %13 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %13
	%138 = getelementptr inbounds {i32, i64}, {i32, i64}* %13, i64 0, i32 0
	store i32 65533, i32* %138
	%139 = getelementptr inbounds {i32, i64}, {i32, i64}* %13, i64 0, i32 1
	store i64 1, i64* %139
	%140 = load {i32, i64}, {i32, i64}* %13, align 8
	ret {i32, i64} %140

if.done-14:
	; IfStmt
	%141 = load i8, i8* %6, align 1
	%142 = icmp eq i8 %141, 3
	%143 = zext i1 %142 to i8
	%144 = trunc i8 %143 to i1
	br i1 %144, label %if.then-15, label %if.done-16

if.then-15:
	; ReturnStmt
	%145 = load i8, i8* %2, align 1
	%146 = and i8 %145, 15
	%147 = zext i8 %146 to i32
	%148 = shl i32 %147, 12
	%149 = load i8, i8* %9, align 1
	%150 = and i8 %149, 63
	%151 = zext i8 %150 to i32
	%152 = shl i32 %151, 6
	%153 = or i32 %148, %152
	%154 = load i8, i8* %12, align 1
	%155 = and i8 %154, 63
	%156 = zext i8 %155 to i32
	%157 = or i32 %153, %156
	%158 = bitcast {i32, i64}* %14 to %..rawptr
	%159 = call %..rawptr @mem.zero(%..rawptr %158, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %14
	%160 = getelementptr inbounds {i32, i64}, {i32, i64}* %14, i64 0, i32 0
	store i32 %157, i32* %160
	%161 = getelementptr inbounds {i32, i64}, {i32, i64}* %14, i64 0, i32 1
	store i64 3, i64* %161
	%162 = load {i32, i64}, {i32, i64}* %14, align 8
	ret {i32, i64} %162

if.done-16:
	; b3
	; IndexExpr
	%163 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%164 = extractvalue {i8*, i64} %163, 0
	%165 = extractvalue {i8*, i64} %163, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$8d, i64 0, i32 0), i64 63}, i64 128, i64 10, i64 3, i64 %165)
	%166 = getelementptr inbounds i8, i8* %164, i64 3
	%167 = load i8, i8* %166, align 1
	store i8 %167, i8* %15
	; IfStmt
	%168 = load i8, i8* %15, align 1
	%169 = icmp ult i8 %168, 128
	%170 = zext i1 %169 to i8
	%171 = trunc i8 %170 to i1
	br i1 %171, label %if.then-18, label %cmp.or-17

cmp.or-17:
	%172 = load i8, i8* %15, align 1
	%173 = icmp ult i8 191, %172
	%174 = zext i1 %173 to i8
	%175 = trunc i8 %174 to i1
	br i1 %175, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	%176 = bitcast {i32, i64}* %16 to %..rawptr
	%177 = call %..rawptr @mem.zero(%..rawptr %176, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %16
	%178 = getelementptr inbounds {i32, i64}, {i32, i64}* %16, i64 0, i32 0
	store i32 65533, i32* %178
	%179 = getelementptr inbounds {i32, i64}, {i32, i64}* %16, i64 0, i32 1
	store i64 1, i64* %179
	%180 = load {i32, i64}, {i32, i64}* %16, align 8
	ret {i32, i64} %180

if.done-19:
	; ReturnStmt
	%181 = load i8, i8* %2, align 1
	%182 = and i8 %181, 7
	%183 = zext i8 %182 to i32
	%184 = shl i32 %183, 18
	%185 = load i8, i8* %9, align 1
	%186 = and i8 %185, 63
	%187 = zext i8 %186 to i32
	%188 = shl i32 %187, 12
	%189 = or i32 %184, %188
	%190 = load i8, i8* %12, align 1
	%191 = and i8 %190, 63
	%192 = zext i8 %191 to i32
	%193 = shl i32 %192, 6
	%194 = or i32 %189, %193
	%195 = load i8, i8* %15, align 1
	%196 = and i8 %195, 63
	%197 = zext i8 %196 to i32
	%198 = or i32 %194, %197
	%199 = bitcast {i32, i64}* %17 to %..rawptr
	%200 = call %..rawptr @mem.zero(%..rawptr %199, i64 16) noinline
	store {i32, i64} zeroinitializer, {i32, i64}* %17
	%201 = getelementptr inbounds {i32, i64}, {i32, i64}* %17, i64 0, i32 0
	store i32 %198, i32* %201
	%202 = getelementptr inbounds {i32, i64}, {i32, i64}* %17, i64 0, i32 1
	store i64 4, i64* %202
	%203 = load {i32, i64}, {i32, i64}* %17, align 8
	ret {i32, i64} %203
}

define i64 @utf8.rune_count_from_string(%..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i8*, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca {i8*, i64}, align 16
	store %..string %s, %..string* %0
	; ReturnStmt
	%4 = load %..string, %..string* %0, align 8
	%5 = extractvalue %..string %4, 0
	%6 = bitcast i8** %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 8) noinline
	store i8* zeroinitializer, i8** %1
	store i8* %5, i8** %1
	%8 = extractvalue %..string %4, 1
	%9 = sub i64 %8, 0
	%10 = load i8*, i8** %1, align 8
	%11 = getelementptr inbounds i8, i8* %10, i64 0
	%12 = bitcast {i8*, i64}* %2 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %2
	%14 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 0
	store i8* %11, i8** %14
	%15 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i64 0, i32 1
	store i64 %9, i64* %15
	%16 = load {i8*, i64}, {i8*, i64}* %2, align 8
	%17 = bitcast {i8*, i64}* %3 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %3
	store {i8*, i64} %16, {i8*, i64}* %3
	%19 = call i64 @utf8.rune_count({i8*, i64}* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline
	ret i64 %19
}

define i64 @utf8.rune_count({i8*, i64}* %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i8, align 16
	%4 = alloca i8, align 16
	%5 = alloca i64, align 16
	%6 = alloca %utf8.Accept_Range, align 16
	%7 = alloca i8, align 16
	%8 = alloca i8, align 16
	%9 = alloca i8, align 16
	%10 = load {i8*, i64}, {i8*, i64}* %s, align 8
	; count
	store i64 0, i64* %0
	; n
	%11 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%12 = extractvalue {i8*, i64} %11, 1
	store i64 %12, i64* %1
	; ForStmt
	; i
	store i64 0, i64* %2
	br label %for.loop-1

for.loop-1:
	%13 = load i64, i64* %2, align 8
	%14 = load i64, i64* %1, align 8
	%15 = icmp slt i64 %13, %14
	%16 = zext i1 %15 to i8
	%17 = trunc i8 %16 to i1
	br i1 %17, label %for.body-2, label %for.done-26

for.body-2:
	; DeferStmt
	; si
	; IndexExpr
	%18 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%19 = extractvalue {i8*, i64} %18, 0
	%20 = load i64, i64* %2, align 8
	%21 = extractvalue {i8*, i64} %18, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$8e, i64 0, i32 0), i64 63}, i64 225, i64 11, i64 %20, i64 %21)
	%22 = getelementptr inbounds i8, i8* %19, i64 %20
	%23 = load i8, i8* %22, align 1
	store i8 %23, i8* %3
	; IfStmt
	%24 = load i8, i8* %3, align 1
	%25 = icmp ult i8 %24, 128
	%26 = zext i1 %25 to i8
	%27 = trunc i8 %26 to i1
	br i1 %27, label %if.then-3, label %if.done-4

if.then-3:
	; AssignStmt
	%28 = load i64, i64* %2, align 8
	%29 = add i64 %28, 1
	store i64 %29, i64* %2
	; defer
	; AssignStmt
	%30 = load i64, i64* %0, align 8
	%31 = add i64 %30, 1
	store i64 %31, i64* %0
	; continue
	br label %for.loop-1

if.done-4:
	; x
	; IndexExpr
	%32 = load i8, i8* %3, align 1
	%33 = zext i8 %32 to i64
	%34 = trunc i64 %33 to i32
	%35 = getelementptr inbounds [256 x i8], [256 x i8]* @utf8.accept_sizes, i64 0, i32 %34
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$8f, i64 0, i32 0), i64 63}, i64 230, i64 21, i64 %33, i64 256)
	%36 = load i8, i8* %35, align 1
	store i8 %36, i8* %4
	; IfStmt
	%37 = load i8, i8* %4, align 1
	%38 = icmp eq i8 %37, 241
	%39 = zext i1 %38 to i8
	%40 = trunc i8 %39 to i1
	br i1 %40, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	%41 = load i64, i64* %2, align 8
	%42 = add i64 %41, 1
	store i64 %42, i64* %2
	; defer
	; AssignStmt
	%43 = load i64, i64* %0, align 8
	%44 = add i64 %43, 1
	store i64 %44, i64* %0
	; continue
	br label %for.loop-1

if.done-6:
	; size
	%45 = load i8, i8* %4, align 1
	%46 = and i8 %45, 7
	%47 = zext i8 %46 to i64
	store i64 %47, i64* %5
	; IfStmt
	%48 = load i64, i64* %2, align 8
	%49 = load i64, i64* %5, align 8
	%50 = add i64 %48, %49
	%51 = load i64, i64* %1, align 8
	%52 = icmp sgt i64 %50, %51
	%53 = zext i1 %52 to i8
	%54 = trunc i8 %53 to i1
	br i1 %54, label %if.then-7, label %if.done-8

if.then-7:
	; AssignStmt
	%55 = load i64, i64* %2, align 8
	%56 = add i64 %55, 1
	store i64 %56, i64* %2
	; defer
	; AssignStmt
	%57 = load i64, i64* %0, align 8
	%58 = add i64 %57, 1
	store i64 %58, i64* %0
	; continue
	br label %for.loop-1

if.done-8:
	; ar
	; IndexExpr
	%59 = load i8, i8* %4, align 1
	%60 = lshr i8 %59, 4
	%61 = zext i8 %60 to i64
	%62 = trunc i64 %61 to i32
	%63 = getelementptr inbounds [5 x %utf8.Accept_Range], [5 x %utf8.Accept_Range]* @utf8.accept_ranges, i64 0, i32 %62
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$90, i64 0, i32 0), i64 63}, i64 240, i64 23, i64 %61, i64 5)
	%64 = load %utf8.Accept_Range, %utf8.Accept_Range* %63, align 1
	store %utf8.Accept_Range %64, %utf8.Accept_Range* %6
	; IfStmt
	; b
	; IndexExpr
	%65 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%66 = extractvalue {i8*, i64} %65, 0
	%67 = load i64, i64* %2, align 8
	%68 = add i64 %67, 1
	%69 = extractvalue {i8*, i64} %65, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$91, i64 0, i32 0), i64 63}, i64 241, i64 13, i64 %68, i64 %69)
	%70 = getelementptr inbounds i8, i8* %66, i64 %68
	%71 = load i8, i8* %70, align 1
	store i8 %71, i8* %7
	%72 = load i8, i8* %7, align 1
	; SelectorExpr
	%73 = getelementptr inbounds %utf8.Accept_Range, %utf8.Accept_Range* %6, i64 0, i32 0
	%74 = load i8, i8* %73, align 1
	%75 = icmp ult i8 %72, %74
	%76 = zext i1 %75 to i8
	%77 = trunc i8 %76 to i1
	br i1 %77, label %if.then-10, label %cmp.or-9

cmp.or-9:
	; SelectorExpr
	%78 = getelementptr inbounds %utf8.Accept_Range, %utf8.Accept_Range* %6, i64 0, i32 1
	%79 = load i8, i8* %78, align 1
	%80 = load i8, i8* %7, align 1
	%81 = icmp ult i8 %79, %80
	%82 = zext i1 %81 to i8
	%83 = trunc i8 %82 to i1
	br i1 %83, label %if.then-10, label %if.else-11

if.then-10:
	; AssignStmt
	store i64 1, i64* %5
	br label %if.done-25

if.else-11:
	; IfStmt
	%84 = load i64, i64* %5, align 8
	%85 = icmp eq i64 %84, 2
	%86 = zext i1 %85 to i8
	%87 = trunc i8 %86 to i1
	br i1 %87, label %if.then-12, label %if.else-13

if.then-12:
	br label %if.done-24

if.else-13:
	; IfStmt
	; b
	; IndexExpr
	%88 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%89 = extractvalue {i8*, i64} %88, 0
	%90 = load i64, i64* %2, align 8
	%91 = add i64 %90, 2
	%92 = extractvalue {i8*, i64} %88, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$92, i64 0, i32 0), i64 63}, i64 245, i64 20, i64 %91, i64 %92)
	%93 = getelementptr inbounds i8, i8* %89, i64 %91
	%94 = load i8, i8* %93, align 1
	store i8 %94, i8* %8
	%95 = load i8, i8* %8, align 1
	%96 = icmp ult i8 %95, 128
	%97 = zext i1 %96 to i8
	%98 = trunc i8 %97 to i1
	br i1 %98, label %if.then-15, label %cmp.or-14

cmp.or-14:
	%99 = load i8, i8* %8, align 1
	%100 = icmp ult i8 191, %99
	%101 = zext i1 %100 to i8
	%102 = trunc i8 %101 to i1
	br i1 %102, label %if.then-15, label %if.else-16

if.then-15:
	; AssignStmt
	store i64 1, i64* %5
	br label %if.done-23

if.else-16:
	; IfStmt
	%103 = load i64, i64* %5, align 8
	%104 = icmp eq i64 %103, 3
	%105 = zext i1 %104 to i8
	%106 = trunc i8 %105 to i1
	br i1 %106, label %if.then-17, label %if.else-18

if.then-17:
	br label %if.done-22

if.else-18:
	; IfStmt
	; b
	; IndexExpr
	%107 = load {i8*, i64}, {i8*, i64}* %s, align 8
	%108 = extractvalue {i8*, i64} %107, 0
	%109 = load i64, i64* %2, align 8
	%110 = add i64 %109, 3
	%111 = extractvalue {i8*, i64} %107, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$93, i64 0, i32 0), i64 63}, i64 249, i64 20, i64 %110, i64 %111)
	%112 = getelementptr inbounds i8, i8* %108, i64 %110
	%113 = load i8, i8* %112, align 1
	store i8 %113, i8* %9
	%114 = load i8, i8* %9, align 1
	%115 = icmp ult i8 %114, 128
	%116 = zext i1 %115 to i8
	%117 = trunc i8 %116 to i1
	br i1 %117, label %if.then-20, label %cmp.or-19

cmp.or-19:
	%118 = load i8, i8* %9, align 1
	%119 = icmp ult i8 191, %118
	%120 = zext i1 %119 to i8
	%121 = trunc i8 %120 to i1
	br i1 %121, label %if.then-20, label %if.done-21

if.then-20:
	; AssignStmt
	store i64 1, i64* %5
	br label %if.done-21

if.done-21:
	br label %if.done-22

if.done-22:
	br label %if.done-23

if.done-23:
	br label %if.done-24

if.done-24:
	br label %if.done-25

if.done-25:
	; AssignStmt
	%122 = load i64, i64* %5, align 8
	%123 = load i64, i64* %2, align 8
	%124 = add i64 %123, %122
	store i64 %124, i64* %2
	; defer
	; AssignStmt
	%125 = load i64, i64* %0, align 8
	%126 = add i64 %125, 1
	store i64 %126, i64* %0
	br label %for.loop-1

for.done-26:
	; ReturnStmt
	%127 = load i64, i64* %0, align 8
	ret i64 %127
}

define void @log.nil_logger_proc(%..rawptr %data, i64 %level, %..string %ident, %..string %text, i8 %options, %runtime.Source_Code_Location* %location, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i64, align 16
	%2 = alloca %..string, align 16
	%3 = alloca %..string, align 16
	%4 = alloca i8, align 16
	store %..rawptr %data, %..rawptr* %0
	store i64 %level, i64* %1
	store %..string %ident, %..string* %2
	store %..string %text, %..string* %3
	store i8 %options, i8* %4
	%5 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %location, align 8
	ret void
}

define {i8*, i64, i64, %mem.Allocator} @fmt.string_buffer_from_slice({i8*, i64}* %backing, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Raw_Slice, align 16
	%1 = alloca %mem.Raw_Dynamic_Array, align 16
	%2 = alloca %mem.Raw_Dynamic_Array, align 16
	%3 = load {i8*, i64}, {i8*, i64}* %backing, align 8
	; s
	%4 = load {i8*, i64}, {i8*, i64}* %backing, align 8
	%5 = bitcast {i8*, i64}* %backing to %mem.Raw_Slice*
	%6 = load %mem.Raw_Slice, %mem.Raw_Slice* %5, align 8
	store %mem.Raw_Slice %6, %mem.Raw_Slice* %0
	; d
	; CompoundLit
	%7 = bitcast %mem.Raw_Dynamic_Array* %2 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 40) noinline
	store %mem.Raw_Dynamic_Array zeroinitializer, %mem.Raw_Dynamic_Array* %2
	store %mem.Raw_Dynamic_Array {%..rawptr zeroinitializer, i64 0, i64 zeroinitializer, %mem.Allocator zeroinitializer}, %mem.Raw_Dynamic_Array* %2
	; SelectorExpr
	%9 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %0, i64 0, i32 0
	%10 = load %..rawptr, %..rawptr* %9, align 8
	%11 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %2, i64 0, i32 0
	store %..rawptr %10, %..rawptr* %11
	; SelectorExpr
	%12 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %0, i64 0, i32 1
	%13 = load i64, i64* %12, align 8
	%14 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %2, i64 0, i32 2
	store i64 %13, i64* %14
	; SelectorExpr
	%15 = call %mem.Allocator @mem.nil_allocator(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%16 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %2, i64 0, i32 3
	store %mem.Allocator %15, %mem.Allocator* %16
	%17 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %2, align 8
	store %mem.Raw_Dynamic_Array %17, %mem.Raw_Dynamic_Array* %1
	; ReturnStmt
	%18 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %1, align 8
	%19 = bitcast %mem.Raw_Dynamic_Array* %1 to {i8*, i64, i64, %mem.Allocator}*
	%20 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %19, align 8
	ret {i8*, i64, i64, %mem.Allocator} %20
}

define %..string @fmt.to_string({i8*, i64, i64, %mem.Allocator}* %buf, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64}, align 16
	%1 = alloca %..string, align 16
	%2 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %buf, align 8
	; ReturnStmt
	; SliceExpr
	%3 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %buf, align 8
	%4 = extractvalue {i8*, i64, i64, %mem.Allocator} %3, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$94, i64 0, i32 0), i64 53}, i64 49, i64 19, i64 0, i64 %4, i64 %4)
	%5 = extractvalue {i8*, i64, i64, %mem.Allocator} %3, 0
	%6 = getelementptr inbounds i8, i8* %5, i64 0
	%7 = sub i64 %4, 0
	%8 = bitcast {i8*, i64}* %0 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %0
	%10 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %0, i64 0, i32 0
	store i8* %6, i8** %10
	%11 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %0, i64 0, i32 1
	store i64 %7, i64* %11
	%12 = load {i8*, i64}, {i8*, i64}* %0, align 8
	%13 = extractvalue {i8*, i64} %12, 0
	%14 = extractvalue {i8*, i64} %12, 1
	%15 = bitcast %..string* %1 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 16) noinline
	store %..string zeroinitializer, %..string* %1
	%17 = getelementptr inbounds %..string, %..string* %1, i64 0, i32 0
	store i8* %13, i8** %17
	%18 = getelementptr inbounds %..string, %..string* %1, i64 0, i32 1
	store i64 %14, i64* %18
	%19 = load %..string, %..string* %1, align 8
	ret %..string %19
}

define void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %buf, %..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %..string, align 16
	%2 = alloca {%..string*, i64}, align 16
	%3 = alloca [1 x %..string], align 16
	%4 = alloca {%..string*, i64}, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store %..string %s, %..string* %1
	%6 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%7 = load %..string, %..string* %1, align 8
	; variadic call argument generation
	%8 = bitcast {%..string*, i64}* %2 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 16) noinline
	store {%..string*, i64} zeroinitializer, {%..string*, i64}* %2
	%10 = bitcast [1 x %..string]* %3 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 16) noinline
	store [1 x %..string] zeroinitializer, [1 x %..string]* %3
	%12 = getelementptr inbounds [1 x %..string], [1 x %..string]* %3, i64 0, i32 0
	store %..string %7, %..string* %12
	%13 = getelementptr inbounds [1 x %..string], [1 x %..string]* %3, i64 0, i32 0
	%14 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2, i64 0, i32 0
	store %..string* %13, %..string** %14
	%15 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2, i64 0, i32 1
	store i64 1, i64* %15
	%16 = load {%..string*, i64}, {%..string*, i64}* %2, align 8
	%17 = bitcast {%..string*, i64}* %4 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 16) noinline
	store {%..string*, i64} zeroinitializer, {%..string*, i64}* %4
	store {%..string*, i64} %16, {%..string*, i64}* %4
	%19 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$95, i64 0, i32 0), i64 53}, i64 54, i64 2, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$96, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %5
	%21 = call i64 @runtime.append_string-17996({i8*, i64, i64, %mem.Allocator}* %6, {%..string*, i64}* %4, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.write_bytes({i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64}* %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca {i8*, i64}, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	%3 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%4 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%5 = load {i8*, i64}, {i8*, i64}* %data, align 8
	%6 = bitcast {i8*, i64}* %1 to %..rawptr
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %1
	store {i8*, i64} %5, {i8*, i64}* %1
	%8 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$97, i64 0, i32 0), i64 53}, i64 57, i64 2, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$98, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %2
	%10 = call i64 @runtime.append_elems-18009({i8*, i64, i64, %mem.Allocator}* %4, {i8*, i64}* %1, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %buf, i8 %data, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store i8 %data, i8* %1
	%3 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%4 = load i8, i8* %1, align 1
	%5 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%6 = call %..rawptr @mem.zero(%..rawptr %5, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$99, i64 0, i32 0), i64 53}, i64 60, i64 2, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$9a, i64 0, i32 0), i64 10}}, %runtime.Source_Code_Location* %2
	%7 = call i64 @runtime.append_elem-18028({i8*, i64, i64, %mem.Allocator}* %3, i8 %4, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %buf, i32 %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i32, align 16
	%2 = alloca [4 x i8], align 16
	%3 = alloca i64, align 16
	%4 = alloca {i8*, i64}, align 16
	%5 = alloca {i8*, i64}, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store i32 %r, i32* %1
	; IfStmt
	%6 = load i32, i32* %1, align 4
	%7 = icmp slt i32 %6, 128
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	br i1 %9, label %if.then-1, label %if.done-2

if.then-1:
	%10 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = load i32, i32* %1, align 4
	%12 = trunc i32 %11 to i8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %10, i8 %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-2:
	; b
	; n
	; SelectorExpr
	%13 = load i32, i32* %1, align 4
	%14 = call {[4 x i8], i64} @utf8.encode_rune(i32 %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = extractvalue {[4 x i8], i64} %14, 0
	%16 = extractvalue {[4 x i8], i64} %14, 1
	store [4 x i8] %15, [4 x i8]* %2
	store i64 %16, i64* %3
	%17 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SliceExpr
	%18 = load i64, i64* %3, align 8
	%19 = load [4 x i8], [4 x i8]* %2, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$9b, i64 0, i32 0), i64 53}, i64 69, i64 20, i64 0, i64 %18, i64 4)
	%20 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i64 0, i32 0
	%21 = getelementptr inbounds i8, i8* %20, i64 0
	%22 = sub i64 %18, 0
	%23 = bitcast {i8*, i64}* %4 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %4
	%25 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4, i64 0, i32 0
	store i8* %21, i8** %25
	%26 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4, i64 0, i32 1
	store i64 %22, i64* %26
	%27 = load {i8*, i64}, {i8*, i64}* %4, align 8
	%28 = bitcast {i8*, i64}* %5 to %..rawptr
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	store {i8*, i64} %27, {i8*, i64}* %5
	call void @fmt.write_bytes({i8*, i64, i64, %mem.Allocator}* %17, {i8*, i64}* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.write_encoded_rune({i8*, i64, i64, %mem.Allocator}* %buf, i32 %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i32, align 16
	%2 = alloca [2 x i8], align 16
	%3 = alloca %..string, align 16
	%4 = alloca {i8*, i64}, align 16
	%5 = alloca {i8*, i64}, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store i32 %r, i32* %1
	%6 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %6, i8 39, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SwitchStmt
	%7 = load i32, i32* %1, align 4
	%8 = icmp eq i32 %7, 7
	br i1 %8, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%9 = icmp eq i32 %7, 8
	br i1 %9, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	%10 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %10, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$9c, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-3:
	%11 = icmp eq i32 %7, 27
	br i1 %11, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	%12 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %12, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$9d, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-5:
	%13 = icmp eq i32 %7, 12
	br i1 %13, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	%14 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %14, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$9e, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-7:
	%15 = icmp eq i32 %7, 10
	br i1 %15, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	%16 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %16, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$9f, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-9:
	%17 = icmp eq i32 %7, 13
	br i1 %17, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	%18 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %18, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$a0, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-11:
	%19 = icmp eq i32 %7, 9
	br i1 %19, label %switch.fall.body-14, label %switch.case.next-13

switch.fall.body-12:
	%20 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %20, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$a1, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-13:
	%21 = icmp eq i32 %7, 11
	br i1 %21, label %switch.fall.body-16, label %switch.case.next-15

switch.fall.body-14:
	%22 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %22, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$a2, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

switch.case.next-15:
	; IfStmt
	%23 = load i32, i32* %1, align 4
	%24 = icmp slt i32 %23, 32
	%25 = zext i1 %24 to i8
	%26 = trunc i8 %25 to i1
	br i1 %26, label %if.then-17, label %if.else-25

switch.fall.body-16:
	%27 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %27, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$a3, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-27

if.then-17:
	%28 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %28, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$a4, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; b
	%29 = bitcast [2 x i8]* %2 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 2) noinline
	store [2 x i8] zeroinitializer, [2 x i8]* %2
	; s
	; SelectorExpr
	; SliceExpr
	%31 = load [2 x i8], [2 x i8]* %2, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$a5, i64 0, i32 0), i64 53}, i64 86, i64 30, i64 0, i64 2, i64 2)
	%32 = getelementptr inbounds [2 x i8], [2 x i8]* %2, i64 0, i32 0
	%33 = getelementptr inbounds i8, i8* %32, i64 0
	%34 = sub i64 2, 0
	%35 = bitcast {i8*, i64}* %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %4
	%37 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4, i64 0, i32 0
	store i8* %33, i8** %37
	%38 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %4, i64 0, i32 1
	store i64 %34, i64* %38
	%39 = load {i8*, i64}, {i8*, i64}* %4, align 8
	%40 = load i32, i32* %1, align 4
	%41 = sext i32 %40 to i64
	; SelectorExpr
	%42 = load %..string, %..string* @strconv.digits, align 8
	%43 = bitcast {i8*, i64}* %5 to %..rawptr
	%44 = call %..rawptr @mem.zero(%..rawptr %43, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	store {i8*, i64} %39, {i8*, i64}* %5
	%45 = call %..string @strconv.append_bits({i8*, i64}* %5, i64 %41, i64 16, i1 true, i64 64, %..string %42, i8 zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %45, %..string* %3
	; SwitchStmt
	%46 = load %..string, %..string* %3, align 8
	%47 = extractvalue %..string %46, 1
	%48 = icmp eq i64 %47, 0
	br i1 %48, label %switch.case.body-19, label %switch.case.next-18

switch.case.next-18:
	%49 = icmp eq i64 %47, 1
	br i1 %49, label %switch.fall.body-21, label %switch.case.next-20

switch.case.body-19:
	%50 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %50, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$a6, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-20:
	%51 = icmp eq i64 %47, 2
	br i1 %51, label %switch.fall.body-23, label %switch.case.next-22

switch.fall.body-21:
	%52 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %52, i32 48, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-22:
	br label %switch.done-24

switch.fall.body-23:
	%53 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%54 = load %..string, %..string* %3, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %53, %..string %54, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.done-24:
	br label %if.done-26

if.else-25:
	%55 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%56 = load i32, i32* %1, align 4
	call void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %55, i32 %56, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-26

if.done-26:
	br label %switch.done-27

switch.done-27:
	%57 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %57, i8 39, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.write_u64({i8*, i64, i64, %mem.Allocator}* %buf, i64 %i, i64 %base, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca [129 x i8], align 16
	%4 = alloca %..string, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca {i8*, i64}, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store i64 %i, i64* %1
	store i64 %base, i64* %2
	; b
	%7 = bitcast [129 x i8]* %3 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 129) noinline
	store [129 x i8] zeroinitializer, [129 x i8]* %3
	; s
	; SelectorExpr
	; SliceExpr
	%9 = load [129 x i8], [129 x i8]* %3, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$a7, i64 0, i32 0), i64 53}, i64 102, i64 28, i64 0, i64 129, i64 129)
	%10 = getelementptr inbounds [129 x i8], [129 x i8]* %3, i64 0, i32 0
	%11 = getelementptr inbounds i8, i8* %10, i64 0
	%12 = sub i64 129, 0
	%13 = bitcast {i8*, i64}* %5 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	%15 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 0
	store i8* %11, i8** %15
	%16 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 1
	store i64 %12, i64* %16
	%17 = load {i8*, i64}, {i8*, i64}* %5, align 8
	%18 = load i64, i64* %1, align 8
	%19 = load i64, i64* %2, align 8
	; SelectorExpr
	%20 = load %..string, %..string* @strconv.digits, align 8
	%21 = bitcast {i8*, i64}* %6 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	store {i8*, i64} %17, {i8*, i64}* %6
	%23 = call %..string @strconv.append_bits({i8*, i64}* %6, i64 %18, i64 %19, i1 false, i64 64, %..string %20, i8 zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %23, %..string* %4
	%24 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load %..string, %..string* %4, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %24, %..string %25, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %buf, i64 %i, i64 %base, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca [129 x i8], align 16
	%4 = alloca %..string, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca {i8*, i64}, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store i64 %i, i64* %1
	store i64 %base, i64* %2
	; b
	%7 = bitcast [129 x i8]* %3 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 129) noinline
	store [129 x i8] zeroinitializer, [129 x i8]* %3
	; s
	; SelectorExpr
	; SliceExpr
	%9 = load [129 x i8], [129 x i8]* %3, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$a8, i64 0, i32 0), i64 53}, i64 107, i64 28, i64 0, i64 129, i64 129)
	%10 = getelementptr inbounds [129 x i8], [129 x i8]* %3, i64 0, i32 0
	%11 = getelementptr inbounds i8, i8* %10, i64 0
	%12 = sub i64 129, 0
	%13 = bitcast {i8*, i64}* %5 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	%15 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 0
	store i8* %11, i8** %15
	%16 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 1
	store i64 %12, i64* %16
	%17 = load {i8*, i64}, {i8*, i64}* %5, align 8
	%18 = load i64, i64* %1, align 8
	%19 = bitcast i64 %18 to i64
	%20 = load i64, i64* %2, align 8
	; SelectorExpr
	%21 = load %..string, %..string* @strconv.digits, align 8
	%22 = bitcast {i8*, i64}* %6 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	store {i8*, i64} %17, {i8*, i64}* %6
	%24 = call %..string @strconv.append_bits({i8*, i64}* %6, i64 %19, i64 %20, i1 true, i64 64, %..string %21, i8 zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %24, %..string* %4
	%25 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%26 = load %..string, %..string* %4, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %25, %..string %26, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define i64 @fmt.fprintln(i32 %fd, {%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca [4096 x i8], align 16
	%2 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%3 = alloca {i8*, i64}, align 16
	%4 = alloca {i8*, i64}, align 16
	%5 = alloca %..string, align 16
	%6 = alloca {%..any*, i64}, align 16
	store i32 %fd, i32* %0
	%7 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; data
	%8 = bitcast [4096 x i8]* %1 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 4096) noinline
	store [4096 x i8] zeroinitializer, [4096 x i8]* %1
	; buf
	; SliceExpr
	%10 = load [4096 x i8], [4096 x i8]* %1, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$a9, i64 0, i32 0), i64 53}, i64 121, i64 38, i64 0, i64 4096, i64 4096)
	%11 = getelementptr inbounds [4096 x i8], [4096 x i8]* %1, i64 0, i32 0
	%12 = getelementptr inbounds i8, i8* %11, i64 0
	%13 = sub i64 4096, 0
	%14 = bitcast {i8*, i64}* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %3
	%16 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3, i64 0, i32 0
	store i8* %12, i8** %16
	%17 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3, i64 0, i32 1
	store i64 %13, i64* %17
	%18 = load {i8*, i64}, {i8*, i64}* %3, align 8
	%19 = bitcast {i8*, i64}* %4 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %4
	store {i8*, i64} %18, {i8*, i64}* %4
	%21 = call {i8*, i64, i64, %mem.Allocator} @fmt.string_buffer_from_slice({i8*, i64}* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64, i64, %mem.Allocator} %21, {i8*, i64, i64, %mem.Allocator}* %2
	; res
	%22 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%23 = bitcast {%..any*, i64}* %6 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %6
	store {%..any*, i64} %22, {%..any*, i64}* %6
	%25 = call %..string @fmt.sbprintln({i8*, i64, i64, %mem.Allocator}* %2, {%..any*, i64}* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %25, %..string* %5
	; SelectorExpr
	%26 = load i32, i32* %0, align 4
	%27 = load %..string, %..string* %5, align 8
	%28 = call {i64, i64} @os.write_string(i32 %26, %..string %27, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%29 = load %..string, %..string* %5, align 8
	%30 = extractvalue %..string %29, 1
	ret i64 %30
}

define i64 @fmt.println({%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%..any*, i64}, align 16
	%1 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; ReturnStmt
	; SelectorExpr
	%2 = load i32, i32* @os.stdout, align 4
	%3 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%4 = bitcast {%..any*, i64}* %0 to %..rawptr
	%5 = call %..rawptr @mem.zero(%..rawptr %4, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %0
	store {%..any*, i64} %3, {%..any*, i64}* %0
	%6 = call i64 @fmt.fprintln(i32 %2, {%..any*, i64}* %0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret i64 %6
}

define %..string @fmt.tprint({%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%1 = alloca %mem.Allocator, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%4 = alloca {%..any*, i64}, align 16
	%5 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%6 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; buf
	; SelectorExpr
	%7 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 1
	%8 = load %mem.Allocator, %mem.Allocator* %7, align 8
	%9 = bitcast %mem.Allocator* %1 to %..rawptr
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %1
	store %mem.Allocator %8, %mem.Allocator* %1
	%11 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$aa, i64 0, i32 0), i64 53}, i64 165, i64 23, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$ab, i64 0, i32 0), i64 6}}, %runtime.Source_Code_Location* %2
	%13 = call {i8*, i64, i64, %mem.Allocator} @mem.make_dynamic_array-18075(%mem.Allocator* %1, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%14 = bitcast {i8*, i64, i64, %mem.Allocator}* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 40) noinline
	store {i8*, i64, i64, %mem.Allocator} zeroinitializer, {i8*, i64, i64, %mem.Allocator}* %3
	store {i8*, i64, i64, %mem.Allocator} %13, {i8*, i64, i64, %mem.Allocator}* %3
	%16 = bitcast {i8*, i64, i64, %mem.Allocator}* %3 to {i8*, i64, i64, %mem.Allocator}*
	%17 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %16, align 8
	store {i8*, i64, i64, %mem.Allocator} %17, {i8*, i64, i64, %mem.Allocator}* %0
	%18 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%19 = bitcast {%..any*, i64}* %4 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %4
	store {%..any*, i64} %18, {%..any*, i64}* %4
	%21 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* %0, {%..any*, i64}* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%22 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %0, align 8
	%23 = bitcast {i8*, i64, i64, %mem.Allocator}* %5 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 40) noinline
	store {i8*, i64, i64, %mem.Allocator} zeroinitializer, {i8*, i64, i64, %mem.Allocator}* %5
	store {i8*, i64, i64, %mem.Allocator} %22, {i8*, i64, i64, %mem.Allocator}* %5
	%25 = call %..string @fmt.to_string({i8*, i64, i64, %mem.Allocator}* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret %..string %25
}

define void @fmt.write_typeid({i8*, i64, i64, %mem.Allocator}* %buf, %..typeid %id, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %..typeid, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store %..typeid %id, %..typeid* %1
	%2 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%3 = load %..typeid, %..typeid* %1, align 8
	%4 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %3)
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %2, %runtime.Type_Info* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %buf, %runtime.Type_Info* %ti, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	%2 = alloca %runtime.Type_Info_Named, align 16
	%3 = alloca %runtime.Type_Info_Integer, align 16
	%4 = alloca %runtime.Type_Info_Rune, align 16
	%5 = alloca %runtime.Type_Info_Float, align 16
	%6 = alloca %runtime.Type_Info_Complex, align 16
	%7 = alloca %runtime.Type_Info_String, align 16
	%8 = alloca %runtime.Type_Info_Boolean, align 16
	%9 = alloca %runtime.Type_Info_Any, align 16
	%10 = alloca %runtime.Type_Info_Type_Id, align 16
	%11 = alloca %runtime.Type_Info_Pointer, align 16
	%12 = alloca %runtime.Type_Info_Procedure, align 16
	%13 = alloca %runtime.Type_Info_Tuple, align 16
	%14 = alloca {%runtime.Type_Info_Tuple, i8}, align 16
	%15 = alloca %runtime.Type_Info*, align 16
	%16 = alloca i64, align 16
	%17 = alloca i64, align 16
	%18 = alloca i64, align 16
	%19 = alloca %runtime.Type_Info_Tuple, align 16
	%20 = alloca i64, align 16
	%21 = alloca %..string, align 16
	%22 = alloca i64, align 16
	%23 = alloca i64, align 16
	%24 = alloca i64, align 16
	%25 = alloca %runtime.Type_Info*, align 16
	%26 = alloca %runtime.Type_Info_Array, align 16
	%27 = alloca %runtime.Type_Info_Dynamic_Array, align 16
	%28 = alloca %runtime.Type_Info_Slice, align 16
	%29 = alloca %runtime.Type_Info_Map, align 16
	%30 = alloca %runtime.Type_Info_Struct, align 16
	%31 = alloca %..string, align 16
	%32 = alloca i64, align 16
	%33 = alloca i64, align 16
	%34 = alloca i64, align 16
	%35 = alloca %runtime.Type_Info_Union, align 16
	%36 = alloca %runtime.Type_Info*, align 16
	%37 = alloca i64, align 16
	%38 = alloca i64, align 16
	%39 = alloca i64, align 16
	%40 = alloca %runtime.Type_Info_Enum, align 16
	%41 = alloca %..string, align 16
	%42 = alloca i64, align 16
	%43 = alloca i64, align 16
	%44 = alloca i64, align 16
	%45 = alloca %runtime.Type_Info_Bit_Field, align 16
	%46 = alloca %..string, align 16
	%47 = alloca i64, align 16
	%48 = alloca i64, align 16
	%49 = alloca i64, align 16
	%50 = alloca %runtime.Type_Info_Bit_Set, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	store %runtime.Type_Info* %ti, %runtime.Type_Info** %1
	; IfStmt
	%51 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%52 = icmp eq %runtime.Type_Info* %51, zeroinitializer
	%53 = zext i1 %52 to i8
	%54 = trunc i8 %53 to i1
	br i1 %54, label %if.then-1, label %if.done-2

if.then-1:
	%55 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %55, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$ac, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-2:
	; TypeSwitchStmt
	; SelectorExpr
	%56 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%57 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %56, i64 0
	%58 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %57, i64 0, i32 3
	%59 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %58, align 8
	; get union's tag
	%60 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %58, i64 0, i32 2 ; UnionTagPtr
	%61 = load i8, i8* %60, align 1
	%62 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %58 to %..rawptr
	%63 = icmp eq i8 %61, 1
	br i1 %63, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.next-3:
	%64 = icmp eq i8 %61, 2
	br i1 %64, label %typeswitch.body-6, label %typeswitch.next-5

typeswitch.body-4:
	%65 = bitcast %..rawptr %62 to %runtime.Type_Info_Named*
	%66 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %65, align 8
	store %runtime.Type_Info_Named %66, %runtime.Type_Info_Named* %2
	%67 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%68 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2, i64 0, i32 0
	%69 = load %..string, %..string* %68, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %67, %..string %69, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-5:
	%70 = icmp eq i8 %61, 3
	br i1 %70, label %typeswitch.body-18, label %typeswitch.next-17

typeswitch.body-6:
	%71 = bitcast %..rawptr %62 to %runtime.Type_Info_Integer*
	%72 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %71, align 1
	store %runtime.Type_Info_Integer %72, %runtime.Type_Info_Integer* %3
	; SwitchStmt
	; SelectorExpr
	%73 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%74 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %73, i64 0
	%75 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %74, i64 0, i32 2
	%76 = load %..typeid, %..typeid* %75, align 8
	%77 = icmp eq %..typeid %76, 4683743612465315846
	br i1 %77, label %switch.case.body-8, label %switch.case.next-7

switch.case.next-7:
	%78 = icmp eq %..typeid %76, 72057594037928001
	br i1 %78, label %switch.fall.body-10, label %switch.case.next-9

switch.case.body-8:
	%79 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %79, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$ad, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

switch.case.next-9:
	%80 = icmp eq %..typeid %76, 72057594037927982
	br i1 %80, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	%81 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %81, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$ae, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

switch.case.next-11:
	%82 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; TernaryExpr
	; SelectorExpr
	%83 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %3, i64 0, i32 0
	%84 = load i8, i8* %83, align 1
	%85 = trunc i8 %84 to i1
	br i1 %85, label %if.then-13, label %if.else-14

switch.fall.body-12:
	%86 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %86, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$af, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

if.then-13:
	br label %if.done-15

if.else-14:
	br label %if.done-15

if.done-15:
	%87 = phi i32 [ 105, %if.then-13 ], [ 117, %if.else-14 ]
	%88 = trunc i32 %87 to i8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %82, i8 %88, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%89 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%90 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%91 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %90, i64 0
	%92 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %91, i64 0, i32 0
	%93 = load i64, i64* %92, align 8
	%94 = mul i64 8, %93
	%95 = bitcast i64 %94 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %89, i64 %95, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-16

switch.done-16:
	br label %typeswitch.done-124

typeswitch.next-17:
	%96 = icmp eq i8 %61, 4
	br i1 %96, label %typeswitch.body-20, label %typeswitch.next-19

typeswitch.body-18:
	%97 = bitcast %..rawptr %62 to %runtime.Type_Info_Rune*
	%98 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %97, align 1
	store %runtime.Type_Info_Rune %98, %runtime.Type_Info_Rune* %4
	%99 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %99, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$b0, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-19:
	%100 = icmp eq i8 %61, 5
	br i1 %100, label %typeswitch.body-22, label %typeswitch.next-21

typeswitch.body-20:
	%101 = bitcast %..rawptr %62 to %runtime.Type_Info_Float*
	%102 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %101, align 1
	store %runtime.Type_Info_Float %102, %runtime.Type_Info_Float* %5
	%103 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %103, i8 102, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%104 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%105 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%106 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %105, i64 0
	%107 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %106, i64 0, i32 0
	%108 = load i64, i64* %107, align 8
	%109 = mul i64 8, %108
	%110 = bitcast i64 %109 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %104, i64 %110, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-21:
	%111 = icmp eq i8 %61, 6
	br i1 %111, label %typeswitch.body-24, label %typeswitch.next-23

typeswitch.body-22:
	%112 = bitcast %..rawptr %62 to %runtime.Type_Info_Complex*
	%113 = load %runtime.Type_Info_Complex, %runtime.Type_Info_Complex* %112, align 1
	store %runtime.Type_Info_Complex %113, %runtime.Type_Info_Complex* %6
	%114 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %114, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$b1, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%115 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%116 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%117 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %116, i64 0
	%118 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %117, i64 0, i32 0
	%119 = load i64, i64* %118, align 8
	%120 = mul i64 8, %119
	%121 = bitcast i64 %120 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %115, i64 %121, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-23:
	%122 = icmp eq i8 %61, 7
	br i1 %122, label %typeswitch.body-29, label %typeswitch.next-28

typeswitch.body-24:
	%123 = bitcast %..rawptr %62 to %runtime.Type_Info_String*
	%124 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %123, align 1
	store %runtime.Type_Info_String %124, %runtime.Type_Info_String* %7
	; IfStmt
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_String, %runtime.Type_Info_String* %7, i64 0, i32 0
	%126 = load i8, i8* %125, align 1
	%127 = trunc i8 %126 to i1
	br i1 %127, label %if.then-25, label %if.else-26

if.then-25:
	%128 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %128, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$b2, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-27

if.else-26:
	%129 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %129, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$b3, i64 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-27

if.done-27:
	br label %typeswitch.done-124

typeswitch.next-28:
	%130 = icmp eq i8 %61, 8
	br i1 %130, label %typeswitch.body-34, label %typeswitch.next-33

typeswitch.body-29:
	%131 = bitcast %..rawptr %62 to %runtime.Type_Info_Boolean*
	%132 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %131, align 1
	store %runtime.Type_Info_Boolean %132, %runtime.Type_Info_Boolean* %8
	; SwitchStmt
	; SelectorExpr
	%133 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%134 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %133, i64 0
	%135 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %134, i64 0, i32 2
	%136 = load %..typeid, %..typeid* %135, align 8
	%137 = icmp eq %..typeid %136, 432345564227567632
	br i1 %137, label %switch.case.body-31, label %switch.case.next-30

switch.case.next-30:
	%138 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %138, i8 98, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%139 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%140 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%141 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %140, i64 0
	%142 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %141, i64 0, i32 0
	%143 = load i64, i64* %142, align 8
	%144 = mul i64 8, %143
	%145 = bitcast i64 %144 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %139, i64 %145, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-32

switch.case.body-31:
	%146 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %146, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$b4, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-32

switch.done-32:
	br label %typeswitch.done-124

typeswitch.next-33:
	%147 = icmp eq i8 %61, 9
	br i1 %147, label %typeswitch.body-36, label %typeswitch.next-35

typeswitch.body-34:
	%148 = bitcast %..rawptr %62 to %runtime.Type_Info_Any*
	%149 = load %runtime.Type_Info_Any, %runtime.Type_Info_Any* %148, align 1
	store %runtime.Type_Info_Any %149, %runtime.Type_Info_Any* %9
	%150 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %150, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$b5, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-35:
	%151 = icmp eq i8 %61, 10
	br i1 %151, label %typeswitch.body-38, label %typeswitch.next-37

typeswitch.body-36:
	%152 = bitcast %..rawptr %62 to %runtime.Type_Info_Type_Id*
	%153 = load %runtime.Type_Info_Type_Id, %runtime.Type_Info_Type_Id* %152, align 1
	store %runtime.Type_Info_Type_Id %153, %runtime.Type_Info_Type_Id* %10
	%154 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %154, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$b6, i64 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-37:
	%155 = icmp eq i8 %61, 11
	br i1 %155, label %typeswitch.body-43, label %typeswitch.next-42

typeswitch.body-38:
	%156 = bitcast %..rawptr %62 to %runtime.Type_Info_Pointer*
	%157 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %156, align 8
	store %runtime.Type_Info_Pointer %157, %runtime.Type_Info_Pointer* %11
	; IfStmt
	; SelectorExpr
	%158 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %11, i64 0, i32 0
	%159 = load %runtime.Type_Info*, %runtime.Type_Info** %158, align 8
	%160 = icmp eq %runtime.Type_Info* %159, zeroinitializer
	%161 = zext i1 %160 to i8
	%162 = trunc i8 %161 to i1
	br i1 %162, label %if.then-39, label %if.else-40

if.then-39:
	%163 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %163, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$b7, i64 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-41

if.else-40:
	%164 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %164, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$b8, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%165 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%166 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %11, i64 0, i32 0
	%167 = load %runtime.Type_Info*, %runtime.Type_Info** %166, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %165, %runtime.Type_Info* %167, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-41

if.done-41:
	br label %typeswitch.done-124

typeswitch.next-42:
	%168 = icmp eq i8 %61, 15
	br i1 %168, label %typeswitch.body-57, label %typeswitch.next-56

typeswitch.body-43:
	%169 = bitcast %..rawptr %62 to %runtime.Type_Info_Procedure*
	%170 = load %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %169, align 8
	store %runtime.Type_Info_Procedure %170, %runtime.Type_Info_Procedure* %12
	%171 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %171, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$b9, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%172 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 0
	%173 = load %runtime.Type_Info*, %runtime.Type_Info** %172, align 8
	%174 = icmp eq %runtime.Type_Info* %173, zeroinitializer
	%175 = zext i1 %174 to i8
	%176 = trunc i8 %175 to i1
	br i1 %176, label %if.then-44, label %if.else-45

if.then-44:
	%177 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %177, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$ba, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-53

if.else-45:
	; t
	; SelectorExpr
	; SelectorExpr
	%178 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 0
	%179 = load %runtime.Type_Info*, %runtime.Type_Info** %178, align 8
	%180 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %179, i64 0
	%181 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %180, i64 0, i32 3
	%182 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %181, align 8
	; cast - union_cast
	%183 = bitcast {%runtime.Type_Info_Tuple, i8}* %14 to %..rawptr
	%184 = call %..rawptr @mem.zero(%..rawptr %183, i64 40) noinline
	store {%runtime.Type_Info_Tuple, i8} zeroinitializer, {%runtime.Type_Info_Tuple, i8}* %14
	%185 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %181, i64 0, i32 2 ; UnionTagPtr
	%186 = load i8, i8* %185, align 1
	%187 = icmp eq i8 %186, 15
	br i1 %187, label %union_cast.ok-46, label %union_cast.end-47

union_cast.ok-46:
	%188 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 0
	%189 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 1
	%190 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %181 to %runtime.Type_Info_Tuple*
	%191 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %190, align 8
	store %runtime.Type_Info_Tuple %191, %runtime.Type_Info_Tuple* %188
	store i8 1, i8* %189
	br label %union_cast.end-47

union_cast.end-47:
	%192 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 1
	%193 = load i8, i8* %192, align 1
	%194 = trunc i8 %193 to i1
	call void @runtime.type_assertion_check(i1 %194, %..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$bb, i64 0, i32 0), i64 53}, i64 289, i64 21, %..typeid 1152921504606846984, %..typeid 3386706919782613029)
	%195 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i64 0, i32 0
	%196 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %195, align 8
	store %runtime.Type_Info_Tuple %196, %runtime.Type_Info_Tuple* %13
	%197 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %197, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$bc, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; t
	%198 = bitcast %runtime.Type_Info** %15 to %..rawptr
	%199 = call %..rawptr @mem.zero(%..rawptr %198, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %15
	; i
	%200 = bitcast i64* %16 to %..rawptr
	%201 = call %..rawptr @mem.zero(%..rawptr %200, i64 8) noinline
	store i64 zeroinitializer, i64* %16
	; SelectorExpr
	%202 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %13, i64 0, i32 0
	%203 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %202, align 8
	%204 = bitcast i64* %17 to %..rawptr
	%205 = call %..rawptr @mem.zero(%..rawptr %204, i64 8) noinline
	store i64 zeroinitializer, i64* %17
	%206 = extractvalue {%runtime.Type_Info**, i64} %203, 1
	store i64 %206, i64* %17
	%207 = bitcast i64* %18 to %..rawptr
	%208 = call %..rawptr @mem.zero(%..rawptr %207, i64 8) noinline
	store i64 zeroinitializer, i64* %18
	store i64 -1, i64* %18
	br label %for.index.loop-48

for.index.loop-48:
	%209 = load i64, i64* %18, align 8
	%210 = add i64 %209, 1
	store i64 %210, i64* %18
	%211 = load i64, i64* %17, align 8
	%212 = icmp slt i64 %210, %211
	br i1 %212, label %for.index.body-49, label %for.index.done-52

for.index.body-49:
	%213 = load i64, i64* %18, align 8
	%214 = extractvalue {%runtime.Type_Info**, i64} %203, 0
	%215 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %214, i64 %213
	%216 = load %runtime.Type_Info*, %runtime.Type_Info** %215, align 8
	store %runtime.Type_Info* %216, %runtime.Type_Info** %15
	store i64 %213, i64* %16
	; IfStmt
	%217 = load i64, i64* %16, align 8
	%218 = icmp sgt i64 %217, 0
	%219 = zext i1 %218 to i8
	%220 = trunc i8 %219 to i1
	br i1 %220, label %if.then-50, label %if.done-51

if.then-50:
	%221 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %221, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$bd, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-51

if.done-51:
	%222 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%223 = load %runtime.Type_Info*, %runtime.Type_Info** %15, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %222, %runtime.Type_Info* %223, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-48

for.index.done-52:
	%224 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %224, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$be, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-53

if.done-53:
	; IfStmt
	; SelectorExpr
	%225 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 1
	%226 = load %runtime.Type_Info*, %runtime.Type_Info** %225, align 8
	%227 = icmp ne %runtime.Type_Info* %226, zeroinitializer
	%228 = zext i1 %227 to i8
	%229 = trunc i8 %228 to i1
	br i1 %229, label %if.then-54, label %if.done-55

if.then-54:
	%230 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %230, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$bf, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%231 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%232 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i64 0, i32 1
	%233 = load %runtime.Type_Info*, %runtime.Type_Info** %232, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %231, %runtime.Type_Info* %233, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-55

if.done-55:
	br label %typeswitch.done-124

typeswitch.next-56:
	%234 = icmp eq i8 %61, 12
	br i1 %234, label %typeswitch.body-70, label %typeswitch.next-69

typeswitch.body-57:
	%235 = bitcast %..rawptr %62 to %runtime.Type_Info_Tuple*
	%236 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %235, align 8
	store %runtime.Type_Info_Tuple %236, %runtime.Type_Info_Tuple* %19
	; count
	; SelectorExpr
	%237 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %19, i64 0, i32 1
	%238 = load {%..string*, i64}, {%..string*, i64}* %237, align 8
	%239 = extractvalue {%..string*, i64} %238, 1
	store i64 %239, i64* %20
	; IfStmt
	%240 = load i64, i64* %20, align 8
	%241 = icmp ne i64 %240, 1
	%242 = zext i1 %241 to i8
	%243 = trunc i8 %242 to i1
	br i1 %243, label %if.then-58, label %if.done-59

if.then-58:
	%244 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %244, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$c0, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-59

if.done-59:
	; RangeStmt
	; name
	%245 = bitcast %..string* %21 to %..rawptr
	%246 = call %..rawptr @mem.zero(%..rawptr %245, i64 16) noinline
	store %..string zeroinitializer, %..string* %21
	; i
	%247 = bitcast i64* %22 to %..rawptr
	%248 = call %..rawptr @mem.zero(%..rawptr %247, i64 8) noinline
	store i64 zeroinitializer, i64* %22
	; SelectorExpr
	%249 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %19, i64 0, i32 1
	%250 = load {%..string*, i64}, {%..string*, i64}* %249, align 8
	%251 = bitcast i64* %23 to %..rawptr
	%252 = call %..rawptr @mem.zero(%..rawptr %251, i64 8) noinline
	store i64 zeroinitializer, i64* %23
	%253 = extractvalue {%..string*, i64} %250, 1
	store i64 %253, i64* %23
	%254 = bitcast i64* %24 to %..rawptr
	%255 = call %..rawptr @mem.zero(%..rawptr %254, i64 8) noinline
	store i64 zeroinitializer, i64* %24
	store i64 -1, i64* %24
	br label %for.index.loop-60

for.index.loop-60:
	%256 = load i64, i64* %24, align 8
	%257 = add i64 %256, 1
	store i64 %257, i64* %24
	%258 = load i64, i64* %23, align 8
	%259 = icmp slt i64 %257, %258
	br i1 %259, label %for.index.body-61, label %for.index.done-66

for.index.body-61:
	%260 = load i64, i64* %24, align 8
	%261 = extractvalue {%..string*, i64} %250, 0
	%262 = getelementptr inbounds %..string, %..string* %261, i64 %260
	%263 = load %..string, %..string* %262, align 8
	store %..string %263, %..string* %21
	store i64 %260, i64* %22
	; IfStmt
	%264 = load i64, i64* %22, align 8
	%265 = icmp sgt i64 %264, 0
	%266 = zext i1 %265 to i8
	%267 = trunc i8 %266 to i1
	br i1 %267, label %if.then-62, label %if.done-63

if.then-62:
	%268 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %268, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$c1, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-63

if.done-63:
	; t
	; IndexExpr
	; SelectorExpr
	%269 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %19, i64 0, i32 0
	%270 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %269, align 8
	%271 = extractvalue {%runtime.Type_Info**, i64} %270, 0
	%272 = load i64, i64* %22, align 8
	%273 = extractvalue {%runtime.Type_Info**, i64} %270, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$c2, i64 0, i32 0), i64 53}, i64 307, i64 20, i64 %272, i64 %273)
	%274 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %271, i64 %272
	%275 = load %runtime.Type_Info*, %runtime.Type_Info** %274, align 8
	store %runtime.Type_Info* %275, %runtime.Type_Info** %25
	; IfStmt
	%276 = load %..string, %..string* %21, align 8
	%277 = extractvalue %..string %276, 1
	%278 = icmp sgt i64 %277, 0
	%279 = zext i1 %278 to i8
	%280 = trunc i8 %279 to i1
	br i1 %280, label %if.then-64, label %if.done-65

if.then-64:
	%281 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%282 = load %..string, %..string* %21, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %281, %..string %282, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%283 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %283, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$c3, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-65

if.done-65:
	%284 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%285 = load %runtime.Type_Info*, %runtime.Type_Info** %25, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %284, %runtime.Type_Info* %285, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-60

for.index.done-66:
	; IfStmt
	%286 = load i64, i64* %20, align 8
	%287 = icmp ne i64 %286, 1
	%288 = zext i1 %287 to i8
	%289 = trunc i8 %288 to i1
	br i1 %289, label %if.then-67, label %if.done-68

if.then-67:
	%290 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %290, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$c4, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-68

if.done-68:
	br label %typeswitch.done-124

typeswitch.next-69:
	%291 = icmp eq i8 %61, 13
	br i1 %291, label %typeswitch.body-72, label %typeswitch.next-71

typeswitch.body-70:
	%292 = bitcast %..rawptr %62 to %runtime.Type_Info_Array*
	%293 = load %runtime.Type_Info_Array, %runtime.Type_Info_Array* %292, align 8
	store %runtime.Type_Info_Array %293, %runtime.Type_Info_Array* %26
	%294 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %294, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$c5, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%295 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%296 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %26, i64 0, i32 2
	%297 = load i64, i64* %296, align 8
	%298 = bitcast i64 %297 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %295, i64 %298, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%299 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %299, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$c6, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%300 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%301 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %26, i64 0, i32 0
	%302 = load %runtime.Type_Info*, %runtime.Type_Info** %301, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %300, %runtime.Type_Info* %302, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-71:
	%303 = icmp eq i8 %61, 14
	br i1 %303, label %typeswitch.body-74, label %typeswitch.next-73

typeswitch.body-72:
	%304 = bitcast %..rawptr %62 to %runtime.Type_Info_Dynamic_Array*
	%305 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %304, align 8
	store %runtime.Type_Info_Dynamic_Array %305, %runtime.Type_Info_Dynamic_Array* %27
	%306 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %306, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$c7, i64 0, i32 0), i64 9}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%307 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%308 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %27, i64 0, i32 0
	%309 = load %runtime.Type_Info*, %runtime.Type_Info** %308, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %307, %runtime.Type_Info* %309, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-73:
	%310 = icmp eq i8 %61, 19
	br i1 %310, label %typeswitch.body-76, label %typeswitch.next-75

typeswitch.body-74:
	%311 = bitcast %..rawptr %62 to %runtime.Type_Info_Slice*
	%312 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %311, align 8
	store %runtime.Type_Info_Slice %312, %runtime.Type_Info_Slice* %28
	%313 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %313, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$c8, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%314 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%315 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %28, i64 0, i32 0
	%316 = load %runtime.Type_Info*, %runtime.Type_Info** %315, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %314, %runtime.Type_Info* %316, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-75:
	%317 = icmp eq i8 %61, 16
	br i1 %317, label %typeswitch.body-78, label %typeswitch.next-77

typeswitch.body-76:
	%318 = bitcast %..rawptr %62 to %runtime.Type_Info_Map*
	%319 = load %runtime.Type_Info_Map, %runtime.Type_Info_Map* %318, align 8
	store %runtime.Type_Info_Map %319, %runtime.Type_Info_Map* %29
	%320 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %320, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$c9, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%321 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%322 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %29, i64 0, i32 0
	%323 = load %runtime.Type_Info*, %runtime.Type_Info** %322, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %321, %runtime.Type_Info* %323, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%324 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %324, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%325 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%326 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %29, i64 0, i32 1
	%327 = load %runtime.Type_Info*, %runtime.Type_Info** %326, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %325, %runtime.Type_Info* %327, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-77:
	%328 = icmp eq i8 %61, 17
	br i1 %328, label %typeswitch.body-91, label %typeswitch.next-90

typeswitch.body-78:
	%329 = bitcast %..rawptr %62 to %runtime.Type_Info_Struct*
	%330 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %329, align 8
	store %runtime.Type_Info_Struct %330, %runtime.Type_Info_Struct* %30
	%331 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %331, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$ca, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%332 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 4
	%333 = load i8, i8* %332, align 1
	%334 = trunc i8 %333 to i1
	br i1 %334, label %if.then-79, label %if.done-80

if.then-79:
	%335 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %335, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$cb, i64 0, i32 0), i64 8}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-80

if.done-80:
	; IfStmt
	; SelectorExpr
	%336 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 5
	%337 = load i8, i8* %336, align 1
	%338 = trunc i8 %337 to i1
	br i1 %338, label %if.then-81, label %if.done-82

if.then-81:
	%339 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %339, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$cc, i64 0, i32 0), i64 11}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-82

if.done-82:
	; IfStmt
	; SelectorExpr
	%340 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 6
	%341 = load i8, i8* %340, align 1
	%342 = trunc i8 %341 to i1
	br i1 %342, label %if.then-83, label %if.done-84

if.then-83:
	%343 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %343, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$cd, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%344 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%345 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%346 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %345, i64 0
	%347 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %346, i64 0, i32 1
	%348 = load i64, i64* %347, align 8
	%349 = bitcast i64 %348 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %344, i64 %349, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%350 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %350, i8 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-84

if.done-84:
	%351 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %351, i8 123, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; name
	%352 = bitcast %..string* %31 to %..rawptr
	%353 = call %..rawptr @mem.zero(%..rawptr %352, i64 16) noinline
	store %..string zeroinitializer, %..string* %31
	; i
	%354 = bitcast i64* %32 to %..rawptr
	%355 = call %..rawptr @mem.zero(%..rawptr %354, i64 8) noinline
	store i64 zeroinitializer, i64* %32
	; SelectorExpr
	%356 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 1
	%357 = load {%..string*, i64}, {%..string*, i64}* %356, align 8
	%358 = bitcast i64* %33 to %..rawptr
	%359 = call %..rawptr @mem.zero(%..rawptr %358, i64 8) noinline
	store i64 zeroinitializer, i64* %33
	%360 = extractvalue {%..string*, i64} %357, 1
	store i64 %360, i64* %33
	%361 = bitcast i64* %34 to %..rawptr
	%362 = call %..rawptr @mem.zero(%..rawptr %361, i64 8) noinline
	store i64 zeroinitializer, i64* %34
	store i64 -1, i64* %34
	br label %for.index.loop-85

for.index.loop-85:
	%363 = load i64, i64* %34, align 8
	%364 = add i64 %363, 1
	store i64 %364, i64* %34
	%365 = load i64, i64* %33, align 8
	%366 = icmp slt i64 %364, %365
	br i1 %366, label %for.index.body-86, label %for.index.done-89

for.index.body-86:
	%367 = load i64, i64* %34, align 8
	%368 = extractvalue {%..string*, i64} %357, 0
	%369 = getelementptr inbounds %..string, %..string* %368, i64 %367
	%370 = load %..string, %..string* %369, align 8
	store %..string %370, %..string* %31
	store i64 %367, i64* %32
	; IfStmt
	%371 = load i64, i64* %32, align 8
	%372 = icmp sgt i64 %371, 0
	%373 = zext i1 %372 to i8
	%374 = trunc i8 %373 to i1
	br i1 %374, label %if.then-87, label %if.done-88

if.then-87:
	%375 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %375, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$ce, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-88

if.done-88:
	%376 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%377 = load %..string, %..string* %31, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %376, %..string %377, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%378 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %378, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$cf, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%379 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; IndexExpr
	; SelectorExpr
	%380 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i64 0, i32 0
	%381 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %380, align 8
	%382 = extractvalue {%runtime.Type_Info**, i64} %381, 0
	%383 = load i64, i64* %32, align 8
	%384 = extractvalue {%runtime.Type_Info**, i64} %381, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$d0, i64 0, i32 0), i64 53}, i64 349, i64 31, i64 %383, i64 %384)
	%385 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %382, i64 %383
	%386 = load %runtime.Type_Info*, %runtime.Type_Info** %385, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %379, %runtime.Type_Info* %386, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-85

for.index.done-89:
	%387 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %387, i8 125, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-90:
	%388 = icmp eq i8 %61, 18
	br i1 %388, label %typeswitch.body-100, label %typeswitch.next-99

typeswitch.body-91:
	%389 = bitcast %..rawptr %62 to %runtime.Type_Info_Union*
	%390 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %389, align 8
	store %runtime.Type_Info_Union %390, %runtime.Type_Info_Union* %35
	%391 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %391, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$d1, i64 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%392 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %35, i64 0, i32 3
	%393 = load i8, i8* %392, align 1
	%394 = trunc i8 %393 to i1
	br i1 %394, label %if.then-92, label %if.done-93

if.then-92:
	%395 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %395, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$d2, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%396 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%397 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%398 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %397, i64 0
	%399 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %398, i64 0, i32 1
	%400 = load i64, i64* %399, align 8
	%401 = bitcast i64 %400 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %396, i64 %401, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%402 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %402, i8 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-93

if.done-93:
	%403 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %403, i8 123, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; variant
	%404 = bitcast %runtime.Type_Info** %36 to %..rawptr
	%405 = call %..rawptr @mem.zero(%..rawptr %404, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %36
	; i
	%406 = bitcast i64* %37 to %..rawptr
	%407 = call %..rawptr @mem.zero(%..rawptr %406, i64 8) noinline
	store i64 zeroinitializer, i64* %37
	; SelectorExpr
	%408 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %35, i64 0, i32 0
	%409 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %408, align 8
	%410 = bitcast i64* %38 to %..rawptr
	%411 = call %..rawptr @mem.zero(%..rawptr %410, i64 8) noinline
	store i64 zeroinitializer, i64* %38
	%412 = extractvalue {%runtime.Type_Info**, i64} %409, 1
	store i64 %412, i64* %38
	%413 = bitcast i64* %39 to %..rawptr
	%414 = call %..rawptr @mem.zero(%..rawptr %413, i64 8) noinline
	store i64 zeroinitializer, i64* %39
	store i64 -1, i64* %39
	br label %for.index.loop-94

for.index.loop-94:
	%415 = load i64, i64* %39, align 8
	%416 = add i64 %415, 1
	store i64 %416, i64* %39
	%417 = load i64, i64* %38, align 8
	%418 = icmp slt i64 %416, %417
	br i1 %418, label %for.index.body-95, label %for.index.done-98

for.index.body-95:
	%419 = load i64, i64* %39, align 8
	%420 = extractvalue {%runtime.Type_Info**, i64} %409, 0
	%421 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %420, i64 %419
	%422 = load %runtime.Type_Info*, %runtime.Type_Info** %421, align 8
	store %runtime.Type_Info* %422, %runtime.Type_Info** %36
	store i64 %419, i64* %37
	; IfStmt
	%423 = load i64, i64* %37, align 8
	%424 = icmp sgt i64 %423, 0
	%425 = zext i1 %424 to i8
	%426 = trunc i8 %425 to i1
	br i1 %426, label %if.then-96, label %if.done-97

if.then-96:
	%427 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %427, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$d3, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-97

if.done-97:
	%428 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%429 = load %runtime.Type_Info*, %runtime.Type_Info** %36, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %428, %runtime.Type_Info* %429, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-94

for.index.done-98:
	%430 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %430, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$d4, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-99:
	%431 = icmp eq i8 %61, 20
	br i1 %431, label %typeswitch.body-107, label %typeswitch.next-106

typeswitch.body-100:
	%432 = bitcast %..rawptr %62 to %runtime.Type_Info_Enum*
	%433 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %432, align 8
	store %runtime.Type_Info_Enum %433, %runtime.Type_Info_Enum* %40
	%434 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %434, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$d5, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%435 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%436 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %40, i64 0, i32 0
	%437 = load %runtime.Type_Info*, %runtime.Type_Info** %436, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %435, %runtime.Type_Info* %437, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%438 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %438, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$d6, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; name
	%439 = bitcast %..string* %41 to %..rawptr
	%440 = call %..rawptr @mem.zero(%..rawptr %439, i64 16) noinline
	store %..string zeroinitializer, %..string* %41
	; i
	%441 = bitcast i64* %42 to %..rawptr
	%442 = call %..rawptr @mem.zero(%..rawptr %441, i64 8) noinline
	store i64 zeroinitializer, i64* %42
	; SelectorExpr
	%443 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %40, i64 0, i32 1
	%444 = load {%..string*, i64}, {%..string*, i64}* %443, align 8
	%445 = bitcast i64* %43 to %..rawptr
	%446 = call %..rawptr @mem.zero(%..rawptr %445, i64 8) noinline
	store i64 zeroinitializer, i64* %43
	%447 = extractvalue {%..string*, i64} %444, 1
	store i64 %447, i64* %43
	%448 = bitcast i64* %44 to %..rawptr
	%449 = call %..rawptr @mem.zero(%..rawptr %448, i64 8) noinline
	store i64 zeroinitializer, i64* %44
	store i64 -1, i64* %44
	br label %for.index.loop-101

for.index.loop-101:
	%450 = load i64, i64* %44, align 8
	%451 = add i64 %450, 1
	store i64 %451, i64* %44
	%452 = load i64, i64* %43, align 8
	%453 = icmp slt i64 %451, %452
	br i1 %453, label %for.index.body-102, label %for.index.done-105

for.index.body-102:
	%454 = load i64, i64* %44, align 8
	%455 = extractvalue {%..string*, i64} %444, 0
	%456 = getelementptr inbounds %..string, %..string* %455, i64 %454
	%457 = load %..string, %..string* %456, align 8
	store %..string %457, %..string* %41
	store i64 %454, i64* %42
	; IfStmt
	%458 = load i64, i64* %42, align 8
	%459 = icmp sgt i64 %458, 0
	%460 = zext i1 %459 to i8
	%461 = trunc i8 %460 to i1
	br i1 %461, label %if.then-103, label %if.done-104

if.then-103:
	%462 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %462, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$d7, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-104

if.done-104:
	%463 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%464 = load %..string, %..string* %41, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %463, %..string %464, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-101

for.index.done-105:
	%465 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %465, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$d8, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-106:
	%466 = icmp eq i8 %61, 21
	br i1 %466, label %typeswitch.body-116, label %typeswitch.next-115

typeswitch.body-107:
	%467 = bitcast %..rawptr %62 to %runtime.Type_Info_Bit_Field*
	%468 = load %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %467, align 8
	store %runtime.Type_Info_Bit_Field %468, %runtime.Type_Info_Bit_Field* %45
	%469 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %469, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$d9, i64 0, i32 0), i64 10}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%470 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%471 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %470, i64 0
	%472 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %471, i64 0, i32 1
	%473 = load i64, i64* %472, align 8
	%474 = icmp ne i64 %473, 1
	%475 = zext i1 %474 to i8
	%476 = trunc i8 %475 to i1
	br i1 %476, label %if.then-108, label %if.done-109

if.then-108:
	%477 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %477, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$da, i64 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%478 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%479 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%480 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %479, i64 0
	%481 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %480, i64 0, i32 1
	%482 = load i64, i64* %481, align 8
	%483 = bitcast i64 %482 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %478, i64 %483, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%484 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %484, i32 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-109

if.done-109:
	%485 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %485, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$db, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; name
	%486 = bitcast %..string* %46 to %..rawptr
	%487 = call %..rawptr @mem.zero(%..rawptr %486, i64 16) noinline
	store %..string zeroinitializer, %..string* %46
	; i
	%488 = bitcast i64* %47 to %..rawptr
	%489 = call %..rawptr @mem.zero(%..rawptr %488, i64 8) noinline
	store i64 zeroinitializer, i64* %47
	; SelectorExpr
	%490 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %45, i64 0, i32 0
	%491 = load {%..string*, i64}, {%..string*, i64}* %490, align 8
	%492 = bitcast i64* %48 to %..rawptr
	%493 = call %..rawptr @mem.zero(%..rawptr %492, i64 8) noinline
	store i64 zeroinitializer, i64* %48
	%494 = extractvalue {%..string*, i64} %491, 1
	store i64 %494, i64* %48
	%495 = bitcast i64* %49 to %..rawptr
	%496 = call %..rawptr @mem.zero(%..rawptr %495, i64 8) noinline
	store i64 zeroinitializer, i64* %49
	store i64 -1, i64* %49
	br label %for.index.loop-110

for.index.loop-110:
	%497 = load i64, i64* %49, align 8
	%498 = add i64 %497, 1
	store i64 %498, i64* %49
	%499 = load i64, i64* %48, align 8
	%500 = icmp slt i64 %498, %499
	br i1 %500, label %for.index.body-111, label %for.index.done-114

for.index.body-111:
	%501 = load i64, i64* %49, align 8
	%502 = extractvalue {%..string*, i64} %491, 0
	%503 = getelementptr inbounds %..string, %..string* %502, i64 %501
	%504 = load %..string, %..string* %503, align 8
	store %..string %504, %..string* %46
	store i64 %501, i64* %47
	; IfStmt
	%505 = load i64, i64* %47, align 8
	%506 = icmp sgt i64 %505, 0
	%507 = zext i1 %506 to i8
	%508 = trunc i8 %507 to i1
	br i1 %508, label %if.then-112, label %if.done-113

if.then-112:
	%509 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %509, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$dc, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-113

if.done-113:
	%510 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%511 = load %..string, %..string* %46, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %510, %..string %511, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%512 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %512, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$dd, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%513 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; IndexExpr
	; SelectorExpr
	%514 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %45, i64 0, i32 1
	%515 = load {i32*, i64}, {i32*, i64}* %514, align 8
	%516 = extractvalue {i32*, i64} %515, 0
	%517 = load i64, i64* %47, align 8
	%518 = extractvalue {i32*, i64} %515, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$de, i64 0, i32 0), i64 53}, i64 389, i64 33, i64 %517, i64 %518)
	%519 = getelementptr inbounds i32, i32* %516, i64 %517
	%520 = load i32, i32* %519, align 4
	%521 = sext i32 %520 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %513, i64 %521, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-110

for.index.done-114:
	%522 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %522, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$df, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.next-115:
	br label %typeswitch.done-124

typeswitch.body-116:
	%523 = bitcast %..rawptr %62 to %runtime.Type_Info_Bit_Set*
	%524 = load %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %523, align 8
	store %runtime.Type_Info_Bit_Set %524, %runtime.Type_Info_Bit_Set* %50
	%525 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %525, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$e0, i64 0, i32 0), i64 8}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SwitchStmt
	; SelectorExpr
	; SelectorExpr
	%526 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 0
	%527 = load %runtime.Type_Info*, %runtime.Type_Info** %526, align 8
	%528 = call i8 @types.is_enum(%runtime.Type_Info* %527, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%529 = icmp eq i8 1, %528
	br i1 %529, label %switch.case.body-118, label %switch.case.next-117

switch.case.next-117:
	; SelectorExpr
	; SelectorExpr
	%530 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 0
	%531 = load %runtime.Type_Info*, %runtime.Type_Info** %530, align 8
	%532 = call i8 @types.is_rune(%runtime.Type_Info* %531, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%533 = icmp eq i8 1, %532
	br i1 %533, label %switch.fall.body-120, label %switch.case.next-119

switch.case.body-118:
	%534 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%535 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 0
	%536 = load %runtime.Type_Info*, %runtime.Type_Info** %535, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %534, %runtime.Type_Info* %536, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-121

switch.case.next-119:
	%537 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%538 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 2
	%539 = load i64, i64* %538, align 8
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %537, i64 %539, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%540 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %540, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$e1, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%541 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%542 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 3
	%543 = load i64, i64* %542, align 8
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %541, i64 %543, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-121

switch.fall.body-120:
	%544 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%545 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 2
	%546 = load i64, i64* %545, align 8
	%547 = trunc i64 %546 to i32
	call void @fmt.write_encoded_rune({i8*, i64, i64, %mem.Allocator}* %544, i32 %547, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%548 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %548, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$e2, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%549 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%550 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 3
	%551 = load i64, i64* %550, align 8
	%552 = trunc i64 %551 to i32
	call void @fmt.write_encoded_rune({i8*, i64, i64, %mem.Allocator}* %549, i32 %552, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-121

switch.done-121:
	; IfStmt
	; SelectorExpr
	%553 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 1
	%554 = load %runtime.Type_Info*, %runtime.Type_Info** %553, align 8
	%555 = icmp ne %runtime.Type_Info* %554, zeroinitializer
	%556 = zext i1 %555 to i8
	%557 = trunc i8 %556 to i1
	br i1 %557, label %if.then-122, label %if.done-123

if.then-122:
	%558 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %558, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$e3, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%559 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	; SelectorExpr
	%560 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i64 0, i32 1
	%561 = load %runtime.Type_Info*, %runtime.Type_Info** %560, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %559, %runtime.Type_Info* %561, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-123

if.done-123:
	%562 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %562, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-124

typeswitch.done-124:
	ret void
}

define void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %fi, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i32, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store i32 %verb, i32* %1
	%2 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%3 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %2, i64 0
	%4 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %3, i64 0, i32 12
	%5 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %4, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %5, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$e4, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%6 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%7 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %6, i64 0
	%8 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %7, i64 0, i32 12
	%9 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %8, align 8
	%10 = load i32, i32* %1, align 4
	call void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %9, i32 %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%11 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%12 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %11, i64 0
	%13 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %12, i64 0, i32 12
	%14 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %13, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %14, i8 40, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%15 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%16 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %15, i64 0
	%17 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %16, i64 0, i32 13
	%18 = getelementptr inbounds %..any, %..any* %17, i64 0, i32 1
	%19 = load %..typeid, %..typeid* %18, align 8
	%20 = icmp ne %..typeid %19, 0
	%21 = zext i1 %20 to i8
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.else-2

if.then-1:
	%23 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%24 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %23, i64 0
	%25 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %24, i64 0, i32 12
	%26 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %25, align 8
	; SelectorExpr
	%27 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%28 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %27, i64 0
	%29 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %28, i64 0, i32 13
	%30 = getelementptr inbounds %..any, %..any* %29, i64 0, i32 1
	%31 = load %..typeid, %..typeid* %30, align 8
	call void @fmt.write_typeid({i8*, i64, i64, %mem.Allocator}* %26, %..typeid %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%32 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%33 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %32, i64 0
	%34 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %33, i64 0, i32 12
	%35 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %34, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %35, i8 61, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%36 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%37 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%38 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %37, i64 0
	%39 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %38, i64 0, i32 13
	%40 = load %..any, %..any* %39, align 8
	call void @fmt.fmt_value(%fmt.Fmt_Info* %36, %..any %40, i32 118, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-3

if.else-2:
	%41 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%42 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %41, i64 0
	%43 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %42, i64 0, i32 12
	%44 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %43, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %44, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$e5, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-3

if.done-3:
	%45 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%46 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %45, i64 0
	%47 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %46, i64 0, i32 12
	%48 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %47, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %48, i8 41, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.fmt_bool(%fmt.Fmt_Info* %fi, i1 %b, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i8, align 16
	%2 = alloca i32, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	%3 = zext i1 %b to i8
	store i8 %3, i8* %1
	store i32 %verb, i32* %2
	; SwitchStmt
	%4 = load i32, i32* %2, align 4
	%5 = icmp eq i32 %4, 116
	br i1 %5, label %switch.case.body-3, label %switch.case.next-1

switch.case.next-1:
	%6 = icmp eq i32 %4, 118
	br i1 %6, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%7 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%8 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %7, i32 %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-7

switch.case.body-3:
	%9 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%10 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %9, i64 0
	%11 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %10, i64 0, i32 12
	%12 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %11, align 8
	; TernaryExpr
	%13 = load i8, i8* %1, align 1
	%14 = trunc i8 %13 to i1
	br i1 %14, label %if.then-4, label %if.else-5

if.then-4:
	br label %if.done-6

if.else-5:
	br label %if.done-6

if.done-6:
	%15 = phi %..string [ {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$e6, i64 0, i32 0), i64 4}, %if.then-4 ], [ {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$e7, i64 0, i32 0), i64 5}, %if.else-5 ]
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %12, %..string %15, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-7

switch.done-7:
	ret void
}

define void @fmt.fmt_write_padding(%fmt.Fmt_Info* %fi, i64 %width, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store i64 %width, i64* %1
	; IfStmt
	%5 = load i64, i64* %1, align 8
	%6 = icmp sle i64 %5, 0
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	br i1 %8, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; pad_byte
	store i8 48, i8* %2
	; IfStmt
	; SelectorExpr
	%9 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%10 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %9, i64 0
	%11 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %10, i64 0, i32 2
	%12 = load i8, i8* %11, align 1
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-3, label %if.done-4

if.then-3:
	; AssignStmt
	store i8 32, i8* %2
	br label %if.done-4

if.done-4:
	; RangeStmt
	%14 = bitcast i64* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	store i64 0, i64* %3
	%16 = bitcast i64* %4 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 0, i64* %4
	br label %for.interval.loop-5

for.interval.loop-5:
	%18 = load i64, i64* %1, align 8
	%19 = sub i64 %18, 1
	%20 = load i64, i64* %3, align 8
	%21 = icmp sle i64 %20, %19
	br i1 %21, label %for.interval.body-6, label %for.interval.done-7

for.interval.body-6:
	%22 = load i64, i64* %3, align 8
	%23 = load i64, i64* %4, align 8
	%24 = load i64, i64* %3, align 8
	%25 = add i64 %24, 1
	store i64 %25, i64* %3
	%26 = load i64, i64* %4, align 8
	%27 = add i64 %26, 1
	store i64 %27, i64* %4
	; SelectorExpr
	%28 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%29 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %28, i64 0
	%30 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %29, i64 0, i32 12
	%31 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %30, align 8
	%32 = load i8, i8* %2, align 1
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %31, i8 %32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-5

for.interval.done-7:
	ret void
}

define void @fmt._fmt_int(%fmt.Fmt_Info* %fi, i64 %u, i64 %base, i1 %is_signed, i64 %bit_size, %..string %digits, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i8, align 16
	%4 = alloca i64, align 16
	%5 = alloca %..string, align 16
	%6 = alloca i8, align 16
	%7 = alloca i64, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	%9 = alloca i64, align 16
	%10 = alloca i8, align 16
	%11 = alloca %runtime.Source_Code_Location, align 16
	%12 = alloca [256 x i8], align 16
	%13 = alloca i64, align 16
	%14 = alloca i8, align 16
	%15 = alloca %..string, align 16
	%16 = alloca {i8*, i64}, align 16
	%17 = alloca {i8*, i64}, align 16
	%18 = alloca i8, align 16
	%19 = alloca i8, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store i64 %u, i64* %1
	store i64 %base, i64* %2
	%20 = zext i1 %is_signed to i8
	store i8 %20, i8* %3
	store i64 %bit_size, i64* %4
	store %..string %digits, %..string* %5
	; neg
	; SelectorExpr
	%21 = load i64, i64* %1, align 8
	%22 = load i8, i8* %3, align 1
	%23 = load i64, i64* %4, align 8
	%24 = trunc i8 %22 to i1
	%25 = call {i64, i8} @strconv.is_integer_negative(i64 %21, i1 %24, i64 %23, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%26 = extractvalue {i64, i8} %25, 0
	%27 = extractvalue {i64, i8} %25, 1
	store i8 %27, i8* %6
	; IfStmt
	; SelectorExpr
	%28 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%29 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %28, i64 0
	%30 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %29, i64 0, i32 5
	%31 = load i8, i8* %30, align 1
	%32 = trunc i8 %31 to i1
	br i1 %32, label %if.then-2, label %cmp.or-1

cmp.or-1:
	; SelectorExpr
	%33 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%34 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %33, i64 0
	%35 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %34, i64 0, i32 6
	%36 = load i8, i8* %35, align 1
	%37 = trunc i8 %36 to i1
	br i1 %37, label %if.then-2, label %if.done-5

if.then-2:
	; width
	; SelectorExpr
	%38 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%39 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %38, i64 0
	%40 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %39, i64 0, i32 7
	%41 = load i64, i64* %40, align 8
	; SelectorExpr
	%42 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%43 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %42, i64 0
	%44 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %43, i64 0, i32 8
	%45 = load i64, i64* %44, align 8
	%46 = add i64 %41, %45
	%47 = add i64 %46, 3
	store i64 %47, i64* %7
	; IfStmt
	%48 = load i64, i64* %7, align 8
	%49 = icmp sgt i64 %48, 256
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-3, label %if.done-4

if.then-3:
	%52 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$e8, i64 0, i32 0), i64 53}, i64 533, i64 4, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$e9, i64 0, i32 0), i64 8}}, %runtime.Source_Code_Location* %8
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$ea, i64 0, i32 0), i64 53}, %runtime.Source_Code_Location* %8) noreturn
	br label %if.done-4

if.done-4:
	br label %if.done-5

if.done-5:
	; prec
	store i64 0, i64* %9
	; IfStmt
	; SelectorExpr
	%54 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%55 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %54, i64 0
	%56 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %55, i64 0, i32 6
	%57 = load i8, i8* %56, align 1
	%58 = trunc i8 %57 to i1
	br i1 %58, label %if.then-6, label %if.else-10

if.then-6:
	; AssignStmt
	; SelectorExpr
	%59 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%60 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %59, i64 0
	%61 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %60, i64 0, i32 8
	%62 = load i64, i64* %61, align 8
	store i64 %62, i64* %9
	; IfStmt
	%63 = load i64, i64* %9, align 8
	%64 = icmp eq i64 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %cmp.and-7, label %if.done-9

cmp.and-7:
	%67 = load i64, i64* %1, align 8
	%68 = icmp eq i64 %67, 0
	%69 = zext i1 %68 to i8
	%70 = trunc i8 %69 to i1
	br i1 %70, label %if.then-8, label %if.done-9

if.then-8:
	; prev_zero
	; SelectorExpr
	%71 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%72 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %71, i64 0
	%73 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %72, i64 0, i32 3
	%74 = load i8, i8* %73, align 1
	store i8 %74, i8* %10
	; AssignStmt
	; SelectorExpr
	%75 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%76 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %75, i64 0
	%77 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %76, i64 0, i32 3
	store i8 0, i8* %77
	%78 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; SelectorExpr
	%79 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%80 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %79, i64 0
	%81 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %80, i64 0, i32 7
	%82 = load i64, i64* %81, align 8
	call void @fmt.fmt_write_padding(%fmt.Fmt_Info* %78, i64 %82, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	; SelectorExpr
	%83 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%84 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %83, i64 0
	%85 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %84, i64 0, i32 3
	%86 = load i8, i8* %10, align 1
	store i8 %86, i8* %85
	; ReturnStmt
	ret void

if.done-9:
	br label %if.done-18

if.else-10:
	; IfStmt
	; SelectorExpr
	%87 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%88 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %87, i64 0
	%89 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %88, i64 0, i32 3
	%90 = load i8, i8* %89, align 1
	%91 = trunc i8 %90 to i1
	br i1 %91, label %cmp.and-11, label %if.done-17

cmp.and-11:
	; SelectorExpr
	%92 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%93 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %92, i64 0
	%94 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %93, i64 0, i32 5
	%95 = load i8, i8* %94, align 1
	%96 = trunc i8 %95 to i1
	br i1 %96, label %if.then-12, label %if.done-17

if.then-12:
	; AssignStmt
	; SelectorExpr
	%97 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%98 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %97, i64 0
	%99 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %98, i64 0, i32 7
	%100 = load i64, i64* %99, align 8
	store i64 %100, i64* %9
	; IfStmt
	%101 = load i8, i8* %6, align 1
	%102 = trunc i8 %101 to i1
	br i1 %102, label %if.then-15, label %cmp.or-13

cmp.or-13:
	; SelectorExpr
	%103 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%104 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %103, i64 0
	%105 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %104, i64 0, i32 1
	%106 = load i8, i8* %105, align 1
	%107 = trunc i8 %106 to i1
	br i1 %107, label %if.then-15, label %cmp.or-14

cmp.or-14:
	; SelectorExpr
	%108 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%109 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %108, i64 0
	%110 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %109, i64 0, i32 2
	%111 = load i8, i8* %110, align 1
	%112 = trunc i8 %111 to i1
	br i1 %112, label %if.then-15, label %if.done-16

if.then-15:
	; AssignStmt
	%113 = load i64, i64* %9, align 8
	%114 = sub i64 %113, 1
	store i64 %114, i64* %9
	br label %if.done-16

if.done-16:
	br label %if.done-17

if.done-17:
	br label %if.done-18

if.done-18:
	; SwitchStmt
	%115 = load i64, i64* %2, align 8
	%116 = icmp eq i64 %115, 2
	br i1 %116, label %switch.case.body-24, label %switch.case.next-19

switch.case.next-19:
	%117 = icmp eq i64 %115, 8
	br i1 %117, label %switch.case.body-24, label %switch.case.next-20

switch.case.next-20:
	%118 = icmp eq i64 %115, 10
	br i1 %118, label %switch.case.body-24, label %switch.case.next-21

switch.case.next-21:
	%119 = icmp eq i64 %115, 12
	br i1 %119, label %switch.case.body-24, label %switch.case.next-22

switch.case.next-22:
	%120 = icmp eq i64 %115, 16
	br i1 %120, label %switch.case.body-24, label %switch.case.next-23

switch.case.next-23:
	%121 = bitcast %runtime.Source_Code_Location* %11 to %..rawptr
	%122 = call %..rawptr @mem.zero(%..rawptr %121, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %11
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$eb, i64 0, i32 0), i64 53}, i64 559, i64 3, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$ec, i64 0, i32 0), i64 8}}, %runtime.Source_Code_Location* %11
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([31 x i8], [31 x i8]* @str$ed, i64 0, i32 0), i64 30}, %runtime.Source_Code_Location* %11) noreturn
	br label %switch.done-25

switch.case.body-24:
	; break
	br label %switch.done-25

switch.done-25:
	; buf
	%123 = bitcast [256 x i8]* %12 to %..rawptr
	%124 = call %..rawptr @mem.zero(%..rawptr %123, i64 256) noinline
	store [256 x i8] zeroinitializer, [256 x i8]* %12
	; start
	store i64 0, i64* %13
	; flags
	%125 = bitcast i8* %14 to %..rawptr
	%126 = call %..rawptr @mem.zero(%..rawptr %125, i64 1) noinline
	store i8 zeroinitializer, i8* %14
	; IfStmt
	; SelectorExpr
	%127 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%128 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %127, i64 0
	%129 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %128, i64 0, i32 4
	%130 = load i8, i8* %129, align 1
	%131 = trunc i8 %130 to i1
	br i1 %131, label %cmp.and-26, label %if.done-28

cmp.and-26:
	; SelectorExpr
	%132 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%133 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %132, i64 0
	%134 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %133, i64 0, i32 3
	%135 = load i8, i8* %134, align 1
	%136 = trunc i8 %135 to i1
	br i1 %136, label %if.done-28, label %if.then-27

if.then-27:
	; AssignStmt
	%137 = load i8, i8* %14, align 1
	%138 = or i8 %137, 1
	store i8 %138, i8* %14
	br label %if.done-28

if.done-28:
	; IfStmt
	; SelectorExpr
	%139 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%140 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %139, i64 0
	%141 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %140, i64 0, i32 1
	%142 = load i8, i8* %141, align 1
	%143 = trunc i8 %142 to i1
	br i1 %143, label %if.then-29, label %if.done-30

if.then-29:
	; AssignStmt
	%144 = load i8, i8* %14, align 1
	%145 = or i8 %144, 2
	store i8 %145, i8* %14
	br label %if.done-30

if.done-30:
	; IfStmt
	; SelectorExpr
	%146 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%147 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %146, i64 0
	%148 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %147, i64 0, i32 2
	%149 = load i8, i8* %148, align 1
	%150 = trunc i8 %149 to i1
	br i1 %150, label %if.then-31, label %if.done-32

if.then-31:
	; AssignStmt
	%151 = load i8, i8* %14, align 1
	%152 = or i8 %151, 4
	store i8 %152, i8* %14
	br label %if.done-32

if.done-32:
	; s
	; SelectorExpr
	; SliceExpr
	%153 = load i64, i64* %13, align 8
	%154 = load [256 x i8], [256 x i8]* %12, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$ee, i64 0, i32 0), i64 53}, i64 570, i64 30, i64 %153, i64 256, i64 256)
	%155 = getelementptr inbounds [256 x i8], [256 x i8]* %12, i64 0, i32 0
	%156 = getelementptr inbounds i8, i8* %155, i64 %153
	%157 = sub i64 256, %153
	%158 = bitcast {i8*, i64}* %16 to %..rawptr
	%159 = call %..rawptr @mem.zero(%..rawptr %158, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %16
	%160 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i64 0, i32 0
	store i8* %156, i8** %160
	%161 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i64 0, i32 1
	store i64 %157, i64* %161
	%162 = load {i8*, i64}, {i8*, i64}* %16, align 8
	%163 = load i64, i64* %1, align 8
	%164 = load i64, i64* %2, align 8
	%165 = load i8, i8* %3, align 1
	%166 = load i64, i64* %4, align 8
	%167 = load %..string, %..string* %5, align 8
	%168 = load i8, i8* %14, align 1
	%169 = bitcast {i8*, i64}* %17 to %..rawptr
	%170 = call %..rawptr @mem.zero(%..rawptr %169, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %17
	store {i8*, i64} %162, {i8*, i64}* %17
	%171 = trunc i8 %165 to i1
	%172 = call %..string @strconv.append_bits({i8*, i64}* %17, i64 %163, i64 %164, i1 %171, i64 %166, %..string %167, i8 %168, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %172, %..string* %15
	; IfStmt
	; SelectorExpr
	%173 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%174 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %173, i64 0
	%175 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %174, i64 0, i32 4
	%176 = load i8, i8* %175, align 1
	%177 = trunc i8 %176 to i1
	br i1 %177, label %cmp.and-33, label %if.done-46

cmp.and-33:
	; SelectorExpr
	%178 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%179 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %178, i64 0
	%180 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %179, i64 0, i32 3
	%181 = load i8, i8* %180, align 1
	%182 = trunc i8 %181 to i1
	br i1 %182, label %if.then-34, label %if.done-46

if.then-34:
	; c
	store i8 0, i8* %18
	; SwitchStmt
	%183 = load i64, i64* %2, align 8
	%184 = icmp eq i64 %183, 2
	br i1 %184, label %switch.case.body-36, label %switch.case.next-35

switch.case.next-35:
	%185 = icmp eq i64 %183, 8
	br i1 %185, label %switch.fall.body-38, label %switch.case.next-37

switch.case.body-36:
	; AssignStmt
	store i8 98, i8* %18
	br label %switch.done-43

switch.case.next-37:
	%186 = icmp eq i64 %183, 12
	br i1 %186, label %switch.fall.body-40, label %switch.case.next-39

switch.fall.body-38:
	; AssignStmt
	store i8 111, i8* %18
	br label %switch.done-43

switch.case.next-39:
	%187 = icmp eq i64 %183, 16
	br i1 %187, label %switch.fall.body-42, label %switch.case.next-41

switch.fall.body-40:
	; AssignStmt
	store i8 122, i8* %18
	br label %switch.done-43

switch.case.next-41:
	br label %switch.done-43

switch.fall.body-42:
	; AssignStmt
	store i8 120, i8* %18
	br label %switch.done-43

switch.done-43:
	; IfStmt
	%188 = load i8, i8* %18, align 1
	%189 = icmp ne i8 %188, 0
	%190 = zext i1 %189 to i8
	%191 = trunc i8 %190 to i1
	br i1 %191, label %if.then-44, label %if.done-45

if.then-44:
	; SelectorExpr
	%192 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%193 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %192, i64 0
	%194 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %193, i64 0, i32 12
	%195 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %194, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %195, i8 48, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%196 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%197 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %196, i64 0
	%198 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %197, i64 0, i32 12
	%199 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %198, align 8
	%200 = load i8, i8* %18, align 1
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %199, i8 %200, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-45

if.done-45:
	br label %if.done-46

if.done-46:
	; prev_zero
	; SelectorExpr
	%201 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%202 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %201, i64 0
	%203 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %202, i64 0, i32 3
	%204 = load i8, i8* %203, align 1
	store i8 %204, i8* %19
	; DeferStmt
	; AssignStmt
	; SelectorExpr
	%205 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%206 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %205, i64 0
	%207 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %206, i64 0, i32 3
	store i8 0, i8* %207
	%208 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%209 = load %..string, %..string* %15, align 8
	call void @fmt._pad(%fmt.Fmt_Info* %208, %..string %209, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; defer
	; AssignStmt
	; SelectorExpr
	%210 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%211 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %210, i64 0
	%212 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %211, i64 0, i32 3
	%213 = load i8, i8* %19, align 1
	store i8 %213, i8* %212
	ret void
}

define void @fmt.fmt_rune(%fmt.Fmt_Info* %fi, i32 %r, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i32, align 16
	%2 = alloca i32, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store i32 %r, i32* %1
	store i32 %verb, i32* %2
	; SwitchStmt
	%3 = load i32, i32* %2, align 4
	%4 = icmp eq i32 %3, 99
	br i1 %4, label %switch.case.body-4, label %switch.case.next-1

switch.case.next-1:
	%5 = icmp eq i32 %3, 114
	br i1 %5, label %switch.case.body-4, label %switch.case.next-2

switch.case.next-2:
	%6 = icmp eq i32 %3, 118
	br i1 %6, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%7 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%8 = load i32, i32* %1, align 4
	%9 = sext i32 %8 to i64
	%10 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %7, i64 %9, i1 false, i64 32, i32 %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-5

switch.case.body-4:
	; SelectorExpr
	%11 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%12 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %11, i64 0
	%13 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %12, i64 0, i32 12
	%14 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %13, align 8
	%15 = load i32, i32* %1, align 4
	call void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %14, i32 %15, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-5

switch.done-5:
	ret void
}

define void @fmt.fmt_int(%fmt.Fmt_Info* %fi, i64 %u, i1 %is_signed, i64 %bit_size, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8, align 16
	%3 = alloca i64, align 16
	%4 = alloca i32, align 16
	%5 = alloca i32, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store i64 %u, i64* %1
	%6 = zext i1 %is_signed to i8
	store i8 %6, i8* %2
	store i64 %bit_size, i64* %3
	store i32 %verb, i32* %4
	; SwitchStmt
	%7 = load i32, i32* %4, align 4
	%8 = icmp eq i32 %7, 118
	br i1 %8, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%9 = icmp eq i32 %7, 98
	br i1 %9, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	%10 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%11 = load i64, i64* %1, align 8
	%12 = load i8, i8* %2, align 1
	%13 = load i64, i64* %3, align 8
	%14 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%15 = trunc i8 %12 to i1
	call void @fmt._fmt_int(%fmt.Fmt_Info* %10, i64 %11, i64 10, i1 %15, i64 %13, %..string %14, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-3:
	%16 = icmp eq i32 %7, 111
	br i1 %16, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	%17 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%18 = load i64, i64* %1, align 8
	%19 = load i8, i8* %2, align 1
	%20 = load i64, i64* %3, align 8
	%21 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%22 = trunc i8 %19 to i1
	call void @fmt._fmt_int(%fmt.Fmt_Info* %17, i64 %18, i64 2, i1 %22, i64 %20, %..string %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-5:
	%23 = icmp eq i32 %7, 100
	br i1 %23, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	%24 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%25 = load i64, i64* %1, align 8
	%26 = load i8, i8* %2, align 1
	%27 = load i64, i64* %3, align 8
	%28 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%29 = trunc i8 %26 to i1
	call void @fmt._fmt_int(%fmt.Fmt_Info* %24, i64 %25, i64 8, i1 %29, i64 %27, %..string %28, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-7:
	%30 = icmp eq i32 %7, 122
	br i1 %30, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	%31 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%32 = load i64, i64* %1, align 8
	%33 = load i8, i8* %2, align 1
	%34 = load i64, i64* %3, align 8
	%35 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%36 = trunc i8 %33 to i1
	call void @fmt._fmt_int(%fmt.Fmt_Info* %31, i64 %32, i64 10, i1 %36, i64 %34, %..string %35, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-9:
	%37 = icmp eq i32 %7, 120
	br i1 %37, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	%38 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%39 = load i64, i64* %1, align 8
	%40 = load i8, i8* %2, align 1
	%41 = load i64, i64* %3, align 8
	%42 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%43 = trunc i8 %40 to i1
	call void @fmt._fmt_int(%fmt.Fmt_Info* %38, i64 %39, i64 12, i1 %43, i64 %41, %..string %42, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-11:
	%44 = icmp eq i32 %7, 88
	br i1 %44, label %switch.fall.body-14, label %switch.case.next-13

switch.fall.body-12:
	%45 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%46 = load i64, i64* %1, align 8
	%47 = load i8, i8* %2, align 1
	%48 = load i64, i64* %3, align 8
	%49 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%50 = trunc i8 %47 to i1
	call void @fmt._fmt_int(%fmt.Fmt_Info* %45, i64 %46, i64 16, i1 %50, i64 %48, %..string %49, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-13:
	%51 = icmp eq i32 %7, 99
	br i1 %51, label %switch.fall.body-17, label %switch.case.next-15

switch.fall.body-14:
	%52 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%53 = load i64, i64* %1, align 8
	%54 = load i8, i8* %2, align 1
	%55 = load i64, i64* %3, align 8
	%56 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	%57 = trunc i8 %54 to i1
	call void @fmt._fmt_int(%fmt.Fmt_Info* %52, i64 %53, i64 16, i1 %57, i64 %55, %..string %56, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-15:
	%58 = icmp eq i32 %7, 114
	br i1 %58, label %switch.fall.body-17, label %switch.case.next-16

switch.case.next-16:
	%59 = icmp eq i32 %7, 85
	br i1 %59, label %switch.fall.body-19, label %switch.case.next-18

switch.fall.body-17:
	%60 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%61 = load i64, i64* %1, align 8
	%62 = trunc i64 %61 to i32
	%63 = load i32, i32* %4, align 4
	call void @fmt.fmt_rune(%fmt.Fmt_Info* %60, i32 %62, i32 %63, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.case.next-18:
	%64 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%65 = load i32, i32* %4, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %64, i32 %65, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-24

switch.fall.body-19:
	; r
	%66 = load i64, i64* %1, align 8
	%67 = trunc i64 %66 to i32
	store i32 %67, i32* %5
	; IfStmt
	%68 = load i32, i32* %5, align 4
	%69 = icmp slt i32 %68, 0
	%70 = zext i1 %69 to i8
	%71 = trunc i8 %70 to i1
	br i1 %71, label %if.then-21, label %cmp.or-20

cmp.or-20:
	%72 = load i32, i32* %5, align 4
	%73 = icmp sgt i32 %72, 1114111
	%74 = zext i1 %73 to i8
	%75 = trunc i8 %74 to i1
	br i1 %75, label %if.then-21, label %if.else-22

if.then-21:
	%76 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%77 = load i32, i32* %4, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %76, i32 %77, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-23

if.else-22:
	; SelectorExpr
	%78 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%79 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %78, i64 0
	%80 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %79, i64 0, i32 12
	%81 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %80, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %81, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$ef, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%82 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%83 = load i64, i64* %1, align 8
	%84 = load i64, i64* %3, align 8
	%85 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	call void @fmt._fmt_int(%fmt.Fmt_Info* %82, i64 %83, i64 16, i1 false, i64 %84, %..string %85, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-23

if.done-23:
	br label %switch.done-24

switch.done-24:
	ret void
}

define void @fmt._pad(%fmt.Fmt_Info* %fi, %..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i64, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..string %s, %..string* %1
	; IfStmt
	; SelectorExpr
	%3 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%4 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %3, i64 0
	%5 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %4, i64 0, i32 5
	%6 = load i8, i8* %5, align 1
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.done-2, label %if.then-1

if.then-1:
	; SelectorExpr
	%8 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%9 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %8, i64 0
	%10 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %9, i64 0, i32 12
	%11 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %10, align 8
	%12 = load %..string, %..string* %1, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %11, %..string %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-2:
	; width
	; SelectorExpr
	%13 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%14 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %13, i64 0
	%15 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %14, i64 0, i32 7
	%16 = load i64, i64* %15, align 8
	; SelectorExpr
	%17 = load %..string, %..string* %1, align 8
	%18 = call i64 @utf8.rune_count_from_string(%..string %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%19 = sub i64 %16, %18
	store i64 %19, i64* %2
	; IfStmt
	; SelectorExpr
	%20 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%21 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %20, i64 0
	%22 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %21, i64 0, i32 0
	%23 = load i8, i8* %22, align 1
	%24 = trunc i8 %23 to i1
	br i1 %24, label %if.then-3, label %if.else-4

if.then-3:
	; SelectorExpr
	%25 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%26 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %25, i64 0
	%27 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %26, i64 0, i32 12
	%28 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %27, align 8
	%29 = load %..string, %..string* %1, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %28, %..string %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%30 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%31 = load i64, i64* %2, align 8
	call void @fmt.fmt_write_padding(%fmt.Fmt_Info* %30, i64 %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-5

if.else-4:
	%32 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%33 = load i64, i64* %2, align 8
	call void @fmt.fmt_write_padding(%fmt.Fmt_Info* %32, i64 %33, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%34 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%35 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %34, i64 0
	%36 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %35, i64 0, i32 12
	%37 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %36, align 8
	%38 = load %..string, %..string* %1, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %37, %..string %38, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-5

if.done-5:
	ret void
}

define void @fmt.fmt_float(%fmt.Fmt_Info* %fi, double %v, i64 %bit_size, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca double, align 16
	%2 = alloca i64, align 16
	%3 = alloca i32, align 16
	%4 = alloca i64, align 16
	%5 = alloca [386 x i8], align 16
	%6 = alloca %..string, align 16
	%7 = alloca {i8*, i64}, align 16
	%8 = alloca {i8*, i64}, align 16
	%9 = alloca {i8*, i64}, align 16
	%10 = alloca %..string, align 16
	%11 = alloca %..string, align 16
	%12 = alloca %..string, align 16
	%13 = alloca %..string, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store double %v, double* %1
	store i64 %bit_size, i64* %2
	store i32 %verb, i32* %3
	; SwitchStmt
	%14 = load i32, i32* %3, align 4
	%15 = icmp eq i32 %14, 102
	br i1 %15, label %switch.case.body-4, label %switch.case.next-1

switch.case.next-1:
	%16 = icmp eq i32 %14, 70
	br i1 %16, label %switch.case.body-4, label %switch.case.next-2

switch.case.next-2:
	%17 = icmp eq i32 %14, 118
	br i1 %17, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%18 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%19 = load i32, i32* %3, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %18, i32 %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-28

switch.case.body-4:
	; prec
	store i64 3, i64* %4
	; IfStmt
	; SelectorExpr
	%20 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%21 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %20, i64 0
	%22 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %21, i64 0, i32 6
	%23 = load i8, i8* %22, align 1
	%24 = trunc i8 %23 to i1
	br i1 %24, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%25 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%26 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %25, i64 0
	%27 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %26, i64 0, i32 8
	%28 = load i64, i64* %27, align 8
	store i64 %28, i64* %4
	br label %if.done-6

if.done-6:
	; buf
	%29 = bitcast [386 x i8]* %5 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 386) noinline
	store [386 x i8] zeroinitializer, [386 x i8]* %5
	; str
	; SelectorExpr
	; SliceExpr
	%31 = load [386 x i8], [386 x i8]* %5, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$f0, i64 0, i32 0), i64 53}, i64 657, i64 34, i64 1, i64 386, i64 386)
	%32 = getelementptr inbounds [386 x i8], [386 x i8]* %5, i64 0, i32 0
	%33 = getelementptr inbounds i8, i8* %32, i64 1
	%34 = sub i64 386, 1
	%35 = bitcast {i8*, i64}* %7 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %7
	%37 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i64 0, i32 0
	store i8* %33, i8** %37
	%38 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i64 0, i32 1
	store i64 %34, i64* %38
	%39 = load {i8*, i64}, {i8*, i64}* %7, align 8
	%40 = load double, double* %1, align 8
	%41 = load i64, i64* %4, align 8
	%42 = load i64, i64* %2, align 8
	%43 = bitcast {i8*, i64}* %8 to %..rawptr
	%44 = call %..rawptr @mem.zero(%..rawptr %43, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %8
	store {i8*, i64} %39, {i8*, i64}* %8
	%45 = call %..string @strconv.append_float({i8*, i64}* %8, double %40, i8 102, i64 %41, i64 %42, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %45, %..string* %6
	; AssignStmt
	; SliceExpr
	%46 = load %..string, %..string* %6, align 8
	%47 = extractvalue %..string %46, 1
	%48 = add i64 %47, 1
	%49 = load [386 x i8], [386 x i8]* %5, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$f1, i64 0, i32 0), i64 53}, i64 658, i64 19, i64 0, i64 %48, i64 386)
	%50 = getelementptr inbounds [386 x i8], [386 x i8]* %5, i64 0, i32 0
	%51 = getelementptr inbounds i8, i8* %50, i64 0
	%52 = sub i64 %48, 0
	%53 = bitcast {i8*, i64}* %9 to %..rawptr
	%54 = call %..rawptr @mem.zero(%..rawptr %53, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %9
	%55 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %9, i64 0, i32 0
	store i8* %51, i8** %55
	%56 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %9, i64 0, i32 1
	store i64 %52, i64* %56
	%57 = load {i8*, i64}, {i8*, i64}* %9, align 8
	%58 = extractvalue {i8*, i64} %57, 0
	%59 = extractvalue {i8*, i64} %57, 1
	%60 = bitcast %..string* %10 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 16) noinline
	store %..string zeroinitializer, %..string* %10
	%62 = getelementptr inbounds %..string, %..string* %10, i64 0, i32 0
	store i8* %58, i8** %62
	%63 = getelementptr inbounds %..string, %..string* %10, i64 0, i32 1
	store i64 %59, i64* %63
	%64 = load %..string, %..string* %10, align 8
	store %..string %64, %..string* %6
	; IfStmt
	; IndexExpr
	%65 = load %..string, %..string* %6, align 8
	%66 = extractvalue %..string %65, 0
	%67 = extractvalue %..string %65, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$f2, i64 0, i32 0), i64 53}, i64 659, i64 10, i64 1, i64 %67)
	%68 = getelementptr inbounds i8, i8* %66, i64 1
	%69 = load i8, i8* %68, align 1
	%70 = icmp eq i8 %69, 43
	%71 = zext i1 %70 to i8
	%72 = trunc i8 %71 to i1
	br i1 %72, label %if.then-8, label %cmp.or-7

cmp.or-7:
	; IndexExpr
	%73 = load %..string, %..string* %6, align 8
	%74 = extractvalue %..string %73, 0
	%75 = extractvalue %..string %73, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$f3, i64 0, i32 0), i64 53}, i64 659, i64 27, i64 1, i64 %75)
	%76 = getelementptr inbounds i8, i8* %74, i64 1
	%77 = load i8, i8* %76, align 1
	%78 = icmp eq i8 %77, 45
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-8, label %if.else-9

if.then-8:
	; AssignStmt
	; SliceExpr
	%81 = load %..string, %..string* %6, align 8
	%82 = extractvalue %..string %81, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$f4, i64 0, i32 0), i64 53}, i64 660, i64 13, i64 1, i64 %82, i64 %82)
	%83 = extractvalue %..string %81, 0
	%84 = getelementptr inbounds i8, i8* %83, i64 1
	%85 = sub i64 %82, 1
	%86 = bitcast %..string* %11 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %..string zeroinitializer, %..string* %11
	%88 = getelementptr inbounds %..string, %..string* %11, i64 0, i32 0
	store i8* %84, i8** %88
	%89 = getelementptr inbounds %..string, %..string* %11, i64 0, i32 1
	store i64 %85, i64* %89
	%90 = load %..string, %..string* %11, align 8
	store %..string %90, %..string* %6
	br label %if.done-10

if.else-9:
	; AssignStmt
	; IndexExpr
	%91 = load %..string, %..string* %6, align 8
	%92 = extractvalue %..string %91, 0
	%93 = extractvalue %..string %91, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$f5, i64 0, i32 0), i64 53}, i64 662, i64 8, i64 0, i64 %93)
	%94 = getelementptr inbounds i8, i8* %92, i64 0
	store i8 43, i8* %94
	br label %if.done-10

if.done-10:
	; IfStmt
	; SelectorExpr
	%95 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%96 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %95, i64 0
	%97 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %96, i64 0, i32 2
	%98 = load i8, i8* %97, align 1
	%99 = trunc i8 %98 to i1
	br i1 %99, label %cmp.and-11, label %if.done-14

cmp.and-11:
	; SelectorExpr
	%100 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%101 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %100, i64 0
	%102 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %101, i64 0, i32 1
	%103 = load i8, i8* %102, align 1
	%104 = trunc i8 %103 to i1
	br i1 %104, label %if.done-14, label %cmp.and-12

cmp.and-12:
	; IndexExpr
	%105 = load %..string, %..string* %6, align 8
	%106 = extractvalue %..string %105, 0
	%107 = extractvalue %..string %105, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$f6, i64 0, i32 0), i64 53}, i64 665, i64 34, i64 0, i64 %107)
	%108 = getelementptr inbounds i8, i8* %106, i64 0
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 43
	%111 = zext i1 %110 to i8
	%112 = trunc i8 %111 to i1
	br i1 %112, label %if.then-13, label %if.done-14

if.then-13:
	; AssignStmt
	; IndexExpr
	%113 = load %..string, %..string* %6, align 8
	%114 = extractvalue %..string %113, 0
	%115 = extractvalue %..string %113, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$f7, i64 0, i32 0), i64 53}, i64 666, i64 8, i64 0, i64 %115)
	%116 = getelementptr inbounds i8, i8* %114, i64 0
	store i8 32, i8* %116
	br label %if.done-14

if.done-14:
	; IfStmt
	%117 = load %..string, %..string* %6, align 8
	%118 = extractvalue %..string %117, 1
	%119 = icmp sgt i64 %118, 1
	%120 = zext i1 %119 to i8
	%121 = trunc i8 %120 to i1
	br i1 %121, label %cmp.and-15, label %if.done-18

cmp.and-15:
	; IndexExpr
	%122 = load %..string, %..string* %6, align 8
	%123 = extractvalue %..string %122, 0
	%124 = extractvalue %..string %122, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$f8, i64 0, i32 0), i64 53}, i64 669, i64 26, i64 1, i64 %124)
	%125 = getelementptr inbounds i8, i8* %123, i64 1
	%126 = load i8, i8* %125, align 1
	%127 = icmp eq i8 %126, 78
	%128 = zext i1 %127 to i8
	%129 = trunc i8 %128 to i1
	br i1 %129, label %cmp.and-16, label %if.done-18

cmp.and-16:
	; IndexExpr
	%130 = load %..string, %..string* %6, align 8
	%131 = extractvalue %..string %130, 0
	%132 = extractvalue %..string %130, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$f9, i64 0, i32 0), i64 53}, i64 669, i64 43, i64 1, i64 %132)
	%133 = getelementptr inbounds i8, i8* %131, i64 1
	%134 = load i8, i8* %133, align 1
	%135 = icmp eq i8 %134, 73
	%136 = zext i1 %135 to i8
	%137 = trunc i8 %136 to i1
	br i1 %137, label %if.then-17, label %if.done-18

if.then-17:
	; SelectorExpr
	%138 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%139 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %138, i64 0
	%140 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %139, i64 0, i32 12
	%141 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %140, align 8
	%142 = load %..string, %..string* %6, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %141, %..string %142, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-18:
	; IfStmt
	; SelectorExpr
	%143 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%144 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %143, i64 0
	%145 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %144, i64 0, i32 1
	%146 = load i8, i8* %145, align 1
	%147 = trunc i8 %146 to i1
	br i1 %147, label %if.then-20, label %cmp.or-19

cmp.or-19:
	; IndexExpr
	%148 = load %..string, %..string* %6, align 8
	%149 = extractvalue %..string %148, 0
	%150 = extractvalue %..string %148, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$fa, i64 0, i32 0), i64 53}, i64 674, i64 21, i64 0, i64 %150)
	%151 = getelementptr inbounds i8, i8* %149, i64 0
	%152 = load i8, i8* %151, align 1
	%153 = icmp ne i8 %152, 43
	%154 = zext i1 %153 to i8
	%155 = trunc i8 %154 to i1
	br i1 %155, label %if.then-20, label %if.else-26

if.then-20:
	; IfStmt
	; SelectorExpr
	%156 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%157 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %156, i64 0
	%158 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %157, i64 0, i32 3
	%159 = load i8, i8* %158, align 1
	%160 = trunc i8 %159 to i1
	br i1 %160, label %cmp.and-21, label %if.else-24

cmp.and-21:
	; SelectorExpr
	%161 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%162 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %161, i64 0
	%163 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %162, i64 0, i32 5
	%164 = load i8, i8* %163, align 1
	%165 = trunc i8 %164 to i1
	br i1 %165, label %cmp.and-22, label %if.else-24

cmp.and-22:
	; SelectorExpr
	%166 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%167 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %166, i64 0
	%168 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %167, i64 0, i32 7
	%169 = load i64, i64* %168, align 8
	%170 = load %..string, %..string* %6, align 8
	%171 = extractvalue %..string %170, 1
	%172 = icmp sgt i64 %169, %171
	%173 = zext i1 %172 to i8
	%174 = trunc i8 %173 to i1
	br i1 %174, label %if.then-23, label %if.else-24

if.then-23:
	; SelectorExpr
	%175 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%176 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %175, i64 0
	%177 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %176, i64 0, i32 12
	%178 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %177, align 8
	; IndexExpr
	%179 = load %..string, %..string* %6, align 8
	%180 = extractvalue %..string %179, 0
	%181 = extractvalue %..string %179, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$fb, i64 0, i32 0), i64 53}, i64 676, i64 28, i64 0, i64 %181)
	%182 = getelementptr inbounds i8, i8* %180, i64 0
	%183 = load i8, i8* %182, align 1
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %178, i8 %183, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%184 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; SelectorExpr
	%185 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%186 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %185, i64 0
	%187 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %186, i64 0, i32 7
	%188 = load i64, i64* %187, align 8
	%189 = load %..string, %..string* %6, align 8
	%190 = extractvalue %..string %189, 1
	%191 = sub i64 %188, %190
	call void @fmt.fmt_write_padding(%fmt.Fmt_Info* %184, i64 %191, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%192 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%193 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %192, i64 0
	%194 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %193, i64 0, i32 12
	%195 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %194, align 8
	; SliceExpr
	%196 = load %..string, %..string* %6, align 8
	%197 = extractvalue %..string %196, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$fc, i64 0, i32 0), i64 53}, i64 678, i64 29, i64 1, i64 %197, i64 %197)
	%198 = extractvalue %..string %196, 0
	%199 = getelementptr inbounds i8, i8* %198, i64 1
	%200 = sub i64 %197, 1
	%201 = bitcast %..string* %12 to %..rawptr
	%202 = call %..rawptr @mem.zero(%..rawptr %201, i64 16) noinline
	store %..string zeroinitializer, %..string* %12
	%203 = getelementptr inbounds %..string, %..string* %12, i64 0, i32 0
	store i8* %199, i8** %203
	%204 = getelementptr inbounds %..string, %..string* %12, i64 0, i32 1
	store i64 %200, i64* %204
	%205 = load %..string, %..string* %12, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %195, %..string %205, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-25

if.else-24:
	%206 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%207 = load %..string, %..string* %6, align 8
	call void @fmt._pad(%fmt.Fmt_Info* %206, %..string %207, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-25

if.done-25:
	br label %if.done-27

if.else-26:
	%208 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; SliceExpr
	%209 = load %..string, %..string* %6, align 8
	%210 = extractvalue %..string %209, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$fd, i64 0, i32 0), i64 53}, i64 683, i64 16, i64 1, i64 %210, i64 %210)
	%211 = extractvalue %..string %209, 0
	%212 = getelementptr inbounds i8, i8* %211, i64 1
	%213 = sub i64 %210, 1
	%214 = bitcast %..string* %13 to %..rawptr
	%215 = call %..rawptr @mem.zero(%..rawptr %214, i64 16) noinline
	store %..string zeroinitializer, %..string* %13
	%216 = getelementptr inbounds %..string, %..string* %13, i64 0, i32 0
	store i8* %212, i8** %216
	%217 = getelementptr inbounds %..string, %..string* %13, i64 0, i32 1
	store i64 %213, i64* %217
	%218 = load %..string, %..string* %13, align 8
	call void @fmt._pad(%fmt.Fmt_Info* %208, %..string %218, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-27

if.done-27:
	br label %switch.done-28

switch.done-28:
	ret void
}

define void @fmt.fmt_string(%fmt.Fmt_Info* %fi, %..string %s, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i32, align 16
	%3 = alloca i8, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca %..string, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..string %s, %..string* %1
	store i32 %verb, i32* %2
	; SwitchStmt
	%8 = load i32, i32* %2, align 4
	%9 = icmp eq i32 %8, 115
	br i1 %9, label %switch.case.body-3, label %switch.case.next-1

switch.case.next-1:
	%10 = icmp eq i32 %8, 118
	br i1 %10, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%11 = icmp eq i32 %8, 120
	br i1 %11, label %switch.fall.body-6, label %switch.case.next-4

switch.case.body-3:
	; SelectorExpr
	%12 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%13 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %12, i64 0
	%14 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %13, i64 0, i32 12
	%15 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %14, align 8
	%16 = load %..string, %..string* %1, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %15, %..string %16, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-15

switch.case.next-4:
	%17 = icmp eq i32 %8, 88
	br i1 %17, label %switch.fall.body-6, label %switch.case.next-5

switch.case.next-5:
	%18 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%19 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %18, i32 %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-15

switch.fall.body-6:
	; space
	; SelectorExpr
	%20 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%21 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %20, i64 0
	%22 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %21, i64 0, i32 2
	%23 = load i8, i8* %22, align 1
	store i8 %23, i8* %3
	; AssignStmt
	; SelectorExpr
	%24 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%25 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %24, i64 0
	%26 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %25, i64 0, i32 2
	store i8 0, i8* %26
	; DeferStmt
	; RangeStmt
	; i
	%27 = bitcast i64* %4 to %..rawptr
	%28 = call %..rawptr @mem.zero(%..rawptr %27, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	%29 = bitcast i64* %5 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	store i64 0, i64* %5
	%31 = bitcast i64* %6 to %..rawptr
	%32 = call %..rawptr @mem.zero(%..rawptr %31, i64 8) noinline
	store i64 zeroinitializer, i64* %6
	store i64 0, i64* %6
	br label %for.interval.loop-7

for.interval.loop-7:
	%33 = load %..string, %..string* %1, align 8
	%34 = extractvalue %..string %33, 1
	%35 = sub i64 %34, 1
	%36 = load i64, i64* %5, align 8
	%37 = icmp sle i64 %36, %35
	br i1 %37, label %for.interval.body-8, label %for.interval.done-14

for.interval.body-8:
	%38 = load i64, i64* %5, align 8
	%39 = load i64, i64* %6, align 8
	%40 = load i64, i64* %5, align 8
	%41 = add i64 %40, 1
	store i64 %41, i64* %5
	%42 = load i64, i64* %6, align 8
	%43 = add i64 %42, 1
	store i64 %43, i64* %6
	store i64 %38, i64* %4
	; IfStmt
	%44 = load i64, i64* %4, align 8
	%45 = icmp sgt i64 %44, 0
	%46 = zext i1 %45 to i8
	%47 = trunc i8 %46 to i1
	br i1 %47, label %cmp.and-9, label %if.done-11

cmp.and-9:
	%48 = load i8, i8* %3, align 1
	%49 = trunc i8 %48 to i1
	br i1 %49, label %if.then-10, label %if.done-11

if.then-10:
	; SelectorExpr
	%50 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%51 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %50, i64 0
	%52 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %51, i64 0, i32 12
	%53 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %52, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %53, i8 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-11

if.done-11:
	; char_set
	%54 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	store %..string %54, %..string* %7
	; IfStmt
	%55 = load i32, i32* %2, align 4
	%56 = icmp eq i32 %55, 120
	%57 = zext i1 %56 to i8
	%58 = trunc i8 %57 to i1
	br i1 %58, label %if.then-12, label %if.done-13

if.then-12:
	; AssignStmt
	%59 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	store %..string %59, %..string* %7
	br label %if.done-13

if.done-13:
	%60 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; IndexExpr
	%61 = load %..string, %..string* %1, align 8
	%62 = extractvalue %..string %61, 0
	%63 = extractvalue %..string %61, 1
	%64 = load i64, i64* %4, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$fe, i64 0, i32 0), i64 53}, i64 704, i64 23, i64 %64, i64 %63)
	%65 = getelementptr inbounds i8, i8* %62, i64 %64
	%66 = load i8, i8* %65, align 1
	%67 = zext i8 %66 to i64
	%68 = load %..string, %..string* %7, align 8
	call void @fmt._fmt_int(%fmt.Fmt_Info* %60, i64 %67, i64 16, i1 false, i64 8, %..string %68, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-7

for.interval.done-14:
	; defer
	; AssignStmt
	; SelectorExpr
	%69 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%70 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %69, i64 0
	%71 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %70, i64 0, i32 2
	%72 = load i8, i8* %3, align 1
	store i8 %72, i8* %71
	br label %switch.done-15

switch.done-15:
	ret void
}

define void @fmt.fmt_cstring(%fmt.Fmt_Info* %fi, i8* %s, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i8*, align 16
	%2 = alloca i32, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store i8* %s, i8** %1
	store i32 %verb, i32* %2
	%3 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%4 = load i8*, i8** %1, align 8
	%5 = call %..string @runtime.cstring_to_string(i8* %4)
	%6 = load i32, i32* %2, align 4
	call void @fmt.fmt_string(%fmt.Fmt_Info* %3, %..string %5, i32 %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.fmt_pointer(%fmt.Fmt_Info* %fi, %..rawptr %p, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca i32, align 16
	%3 = alloca i64, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..rawptr %p, %..rawptr* %1
	store i32 %verb, i32* %2
	; SwitchStmt
	%4 = load i32, i32* %2, align 4
	%5 = icmp eq i32 %4, 112
	br i1 %5, label %switch.case.body-3, label %switch.case.next-1

switch.case.next-1:
	%6 = icmp eq i32 %4, 118
	br i1 %6, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%7 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%8 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %7, i32 %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-7

switch.case.body-3:
	; u
	%9 = load %..rawptr, %..rawptr* %1, align 8
	%10 = ptrtoint %..rawptr %9 to i64
	%11 = bitcast i64 %10 to i64
	store i64 %11, i64* %3
	; IfStmt
	; SelectorExpr
	%12 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%13 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %12, i64 0
	%14 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %13, i64 0, i32 4
	%15 = load i8, i8* %14, align 1
	%16 = trunc i8 %15 to i1
	br i1 %16, label %cmp.or-4, label %if.then-5

cmp.or-4:
	%17 = load i32, i32* %2, align 4
	%18 = icmp eq i32 %17, 118
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-5, label %if.done-6

if.then-5:
	; SelectorExpr
	%21 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%22 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %21, i64 0
	%23 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %22, i64 0, i32 12
	%24 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %23, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %24, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$ff, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-6

if.done-6:
	%25 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%26 = load i64, i64* %3, align 8
	%27 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	call void @fmt._fmt_int(%fmt.Fmt_Info* %25, i64 %26, i64 16, i1 false, i64 64, %..string %27, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-7

switch.done-7:
	ret void
}

define {%..string, i8} @fmt.enum_value_to_string(%..any %v, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..any, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	%2 = alloca %runtime.Type_Info_Enum, align 16
	%3 = alloca %..any, align 16
	%4 = alloca %..any, align 16
	%5 = alloca %runtime.Type_Info*, align 16
	%6 = alloca i32, align 16
	%7 = alloca %runtime.Type_Info_Enum, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca i8, align 16
	%10 = alloca %runtime.Type_Info_Enum, align 16
	%11 = alloca {%..string, i8}, align 16
	%12 = alloca i16, align 16
	%13 = alloca %runtime.Type_Info_Enum, align 16
	%14 = alloca {%..string, i8}, align 16
	%15 = alloca i32, align 16
	%16 = alloca %runtime.Type_Info_Enum, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca i64, align 16
	%19 = alloca %runtime.Type_Info_Enum, align 16
	%20 = alloca {%..string, i8}, align 16
	%21 = alloca i64, align 16
	%22 = alloca %runtime.Type_Info_Enum, align 16
	%23 = alloca {%..string, i8}, align 16
	%24 = alloca i8, align 16
	%25 = alloca %runtime.Type_Info_Enum, align 16
	%26 = alloca {%..string, i8}, align 16
	%27 = alloca i16, align 16
	%28 = alloca %runtime.Type_Info_Enum, align 16
	%29 = alloca {%..string, i8}, align 16
	%30 = alloca i32, align 16
	%31 = alloca %runtime.Type_Info_Enum, align 16
	%32 = alloca {%..string, i8}, align 16
	%33 = alloca i64, align 16
	%34 = alloca %runtime.Type_Info_Enum, align 16
	%35 = alloca {%..string, i8}, align 16
	%36 = alloca i64, align 16
	%37 = alloca %runtime.Type_Info_Enum, align 16
	%38 = alloca {%..string, i8}, align 16
	%39 = alloca i64, align 16
	%40 = alloca %runtime.Type_Info_Enum, align 16
	%41 = alloca {%..string, i8}, align 16
	%42 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	%43 = alloca {%..string, i8}, align 16
	%44 = alloca {%..string, i8}, align 16
	store %..any %v, %..any* %0
	; AssignStmt
	; SelectorExpr
	%45 = getelementptr inbounds %..any, %..any* %0, i64 0, i32 1
	; SelectorExpr
	; SelectorExpr
	%46 = getelementptr inbounds %..any, %..any* %0, i64 0, i32 1
	%47 = load %..typeid, %..typeid* %46, align 8
	%48 = call %..typeid @runtime.typeid_base(%..typeid %47)
	store %..typeid %48, %..typeid* %45
	; type_info
	; SelectorExpr
	%49 = getelementptr inbounds %..any, %..any* %0, i64 0, i32 1
	%50 = load %..typeid, %..typeid* %49, align 8
	%51 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %50)
	store %runtime.Type_Info* %51, %runtime.Type_Info** %1
	; TypeSwitchStmt
	; SelectorExpr
	%52 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%53 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %52, i64 0
	%54 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %53, i64 0, i32 3
	%55 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %54, align 8
	; get union's tag
	%56 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %54, i64 0, i32 2 ; UnionTagPtr
	%57 = load i8, i8* %56, align 1
	%58 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %54 to %..rawptr
	%59 = icmp eq i8 %57, 18
	br i1 %59, label %typeswitch.body-2, label %typeswitch.next-1

typeswitch.next-1:
	store {[0 x <8 x i8>], [72 x i8], i8} %55, {[0 x <8 x i8>], [72 x i8], i8}* %42
	; ReturnStmt
	%60 = bitcast {%..string, i8}* %43 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %43
	%62 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %43, i64 0, i32 0
	store %..string zeroinitializer, %..string* %62
	%63 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %43, i64 0, i32 1
	store i8 0, i8* %63
	%64 = load {%..string, i8}, {%..string, i8}* %43, align 8
	ret {%..string, i8} %64

typeswitch.body-2:
	%65 = bitcast %..rawptr %58 to %runtime.Type_Info_Enum*
	%66 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %65, align 8
	store %runtime.Type_Info_Enum %66, %runtime.Type_Info_Enum* %2
	; a
	; CompoundLit
	%67 = bitcast %..any* %4 to %..rawptr
	%68 = call %..rawptr @mem.zero(%..rawptr %67, i64 16) noinline
	store %..any zeroinitializer, %..any* %4
	store %..any zeroinitializer, %..any* %4
	; SelectorExpr
	%69 = getelementptr inbounds %..any, %..any* %0, i64 0, i32 0
	%70 = load %..rawptr, %..rawptr* %69, align 8
	%71 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	store %..rawptr %70, %..rawptr* %71
	; SelectorExpr
	; SelectorExpr
	; SelectorExpr
	%72 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, i64 0, i32 0
	%73 = load %runtime.Type_Info*, %runtime.Type_Info** %72, align 8
	%74 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %73)
	%75 = bitcast %runtime.Type_Info** %5 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %5
	store %runtime.Type_Info* %74, %runtime.Type_Info** %5
	%77 = load %runtime.Type_Info*, %runtime.Type_Info** %5, align 8
	%78 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %77, i64 0
	%79 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %78, i64 0, i32 2
	%80 = load %..typeid, %..typeid* %79, align 8
	%81 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	store %..typeid %80, %..typeid* %81
	%82 = load %..any, %..any* %4, align 8
	store %..any %82, %..any* %3
	; TypeSwitchStmt
	%83 = load %..any, %..any* %3, align 8
	%84 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%85 = load %..typeid, %..typeid* %84, align 8
	%86 = icmp eq %..typeid %85, 4755801206503243833
	br i1 %86, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.next-3:
	%87 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%88 = load %..typeid, %..typeid* %87, align 8
	%89 = icmp eq %..typeid %88, 4683743612465315898
	br i1 %89, label %typeswitch.body-6, label %typeswitch.next-5

typeswitch.body-4:
	%90 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%91 = load %..rawptr, %..rawptr* %90, align 8
	%92 = bitcast %..rawptr %91 to i32*
	%93 = load i32, i32* %92, align 4
	store i32 %93, i32* %6
	; ReturnStmt
	%94 = load i32, i32* %6, align 4
	%95 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%96 = bitcast %runtime.Type_Info_Enum* %7 to %..rawptr
	%97 = call %..rawptr @mem.zero(%..rawptr %96, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %7
	store %runtime.Type_Info_Enum %95, %runtime.Type_Info_Enum* %7
	%98 = call {%..string, i8} @fmt.enum_value_to_string.get_str-0(i32 %94, %runtime.Type_Info_Enum* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%99 = extractvalue {%..string, i8} %98, 0
	%100 = extractvalue {%..string, i8} %98, 1
	%101 = bitcast {%..string, i8}* %8 to %..rawptr
	%102 = call %..rawptr @mem.zero(%..rawptr %101, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%103 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %99, %..string* %103
	%104 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 %100, i8* %104
	%105 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %105

typeswitch.next-5:
	%106 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%107 = load %..typeid, %..typeid* %106, align 8
	%108 = icmp eq %..typeid %107, 4683743612465315899
	br i1 %108, label %typeswitch.body-8, label %typeswitch.next-7

typeswitch.body-6:
	%109 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%110 = load %..rawptr, %..rawptr* %109, align 8
	%111 = bitcast %..rawptr %110 to i8*
	%112 = load i8, i8* %111, align 1
	store i8 %112, i8* %9
	; ReturnStmt
	%113 = load i8, i8* %9, align 1
	%114 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%115 = bitcast %runtime.Type_Info_Enum* %10 to %..rawptr
	%116 = call %..rawptr @mem.zero(%..rawptr %115, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %10
	store %runtime.Type_Info_Enum %114, %runtime.Type_Info_Enum* %10
	%117 = call {%..string, i8} @fmt.enum_value_to_string.get_str-1(i8 %113, %runtime.Type_Info_Enum* %10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%118 = extractvalue {%..string, i8} %117, 0
	%119 = extractvalue {%..string, i8} %117, 1
	%120 = bitcast {%..string, i8}* %11 to %..rawptr
	%121 = call %..rawptr @mem.zero(%..rawptr %120, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %11
	%122 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %11, i64 0, i32 0
	store %..string %118, %..string* %122
	%123 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %11, i64 0, i32 1
	store i8 %119, i8* %123
	%124 = load {%..string, i8}, {%..string, i8}* %11, align 8
	ret {%..string, i8} %124

typeswitch.next-7:
	%125 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%126 = load %..typeid, %..typeid* %125, align 8
	%127 = icmp eq %..typeid %126, 4683743612465315900
	br i1 %127, label %typeswitch.body-10, label %typeswitch.next-9

typeswitch.body-8:
	%128 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%129 = load %..rawptr, %..rawptr* %128, align 8
	%130 = bitcast %..rawptr %129 to i16*
	%131 = load i16, i16* %130, align 2
	store i16 %131, i16* %12
	; ReturnStmt
	%132 = load i16, i16* %12, align 2
	%133 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%134 = bitcast %runtime.Type_Info_Enum* %13 to %..rawptr
	%135 = call %..rawptr @mem.zero(%..rawptr %134, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %13
	store %runtime.Type_Info_Enum %133, %runtime.Type_Info_Enum* %13
	%136 = call {%..string, i8} @fmt.enum_value_to_string.get_str-2(i16 %132, %runtime.Type_Info_Enum* %13, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%137 = extractvalue {%..string, i8} %136, 0
	%138 = extractvalue {%..string, i8} %136, 1
	%139 = bitcast {%..string, i8}* %14 to %..rawptr
	%140 = call %..rawptr @mem.zero(%..rawptr %139, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %14
	%141 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %14, i64 0, i32 0
	store %..string %137, %..string* %141
	%142 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %14, i64 0, i32 1
	store i8 %138, i8* %142
	%143 = load {%..string, i8}, {%..string, i8}* %14, align 8
	ret {%..string, i8} %143

typeswitch.next-9:
	%144 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%145 = load %..typeid, %..typeid* %144, align 8
	%146 = icmp eq %..typeid %145, 4683743612465315901
	br i1 %146, label %typeswitch.body-12, label %typeswitch.next-11

typeswitch.body-10:
	%147 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%148 = load %..rawptr, %..rawptr* %147, align 8
	%149 = bitcast %..rawptr %148 to i32*
	%150 = load i32, i32* %149, align 4
	store i32 %150, i32* %15
	; ReturnStmt
	%151 = load i32, i32* %15, align 4
	%152 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%153 = bitcast %runtime.Type_Info_Enum* %16 to %..rawptr
	%154 = call %..rawptr @mem.zero(%..rawptr %153, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %16
	store %runtime.Type_Info_Enum %152, %runtime.Type_Info_Enum* %16
	%155 = call {%..string, i8} @fmt.enum_value_to_string.get_str-3(i32 %151, %runtime.Type_Info_Enum* %16, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%156 = extractvalue {%..string, i8} %155, 0
	%157 = extractvalue {%..string, i8} %155, 1
	%158 = bitcast {%..string, i8}* %17 to %..rawptr
	%159 = call %..rawptr @mem.zero(%..rawptr %158, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%160 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %156, %..string* %160
	%161 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 %157, i8* %161
	%162 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %162

typeswitch.next-11:
	%163 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%164 = load %..typeid, %..typeid* %163, align 8
	%165 = icmp eq %..typeid %164, 4683743612465315846
	br i1 %165, label %typeswitch.body-14, label %typeswitch.next-13

typeswitch.body-12:
	%166 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%167 = load %..rawptr, %..rawptr* %166, align 8
	%168 = bitcast %..rawptr %167 to i64*
	%169 = load i64, i64* %168, align 8
	store i64 %169, i64* %18
	; ReturnStmt
	%170 = load i64, i64* %18, align 8
	%171 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%172 = bitcast %runtime.Type_Info_Enum* %19 to %..rawptr
	%173 = call %..rawptr @mem.zero(%..rawptr %172, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %19
	store %runtime.Type_Info_Enum %171, %runtime.Type_Info_Enum* %19
	%174 = call {%..string, i8} @fmt.enum_value_to_string.get_str-4(i64 %170, %runtime.Type_Info_Enum* %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%175 = extractvalue {%..string, i8} %174, 0
	%176 = extractvalue {%..string, i8} %174, 1
	%177 = bitcast {%..string, i8}* %20 to %..rawptr
	%178 = call %..rawptr @mem.zero(%..rawptr %177, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %20
	%179 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %20, i64 0, i32 0
	store %..string %175, %..string* %179
	%180 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %20, i64 0, i32 1
	store i8 %176, i8* %180
	%181 = load {%..string, i8}, {%..string, i8}* %20, align 8
	ret {%..string, i8} %181

typeswitch.next-13:
	%182 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%183 = load %..typeid, %..typeid* %182, align 8
	%184 = icmp eq %..typeid %183, 72057594037927939
	br i1 %184, label %typeswitch.body-16, label %typeswitch.next-15

typeswitch.body-14:
	%185 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%186 = load %..rawptr, %..rawptr* %185, align 8
	%187 = bitcast %..rawptr %186 to i64*
	%188 = load i64, i64* %187, align 8
	store i64 %188, i64* %21
	; ReturnStmt
	%189 = load i64, i64* %21, align 8
	%190 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%191 = bitcast %runtime.Type_Info_Enum* %22 to %..rawptr
	%192 = call %..rawptr @mem.zero(%..rawptr %191, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %22
	store %runtime.Type_Info_Enum %190, %runtime.Type_Info_Enum* %22
	%193 = call {%..string, i8} @fmt.enum_value_to_string.get_str-5(i64 %189, %runtime.Type_Info_Enum* %22, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%194 = extractvalue {%..string, i8} %193, 0
	%195 = extractvalue {%..string, i8} %193, 1
	%196 = bitcast {%..string, i8}* %23 to %..rawptr
	%197 = call %..rawptr @mem.zero(%..rawptr %196, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %23
	%198 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %23, i64 0, i32 0
	store %..string %194, %..string* %198
	%199 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %23, i64 0, i32 1
	store i8 %195, i8* %199
	%200 = load {%..string, i8}, {%..string, i8}* %23, align 8
	ret {%..string, i8} %200

typeswitch.next-15:
	%201 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%202 = load %..typeid, %..typeid* %201, align 8
	%203 = icmp eq %..typeid %202, 72057594037927998
	br i1 %203, label %typeswitch.body-18, label %typeswitch.next-17

typeswitch.body-16:
	%204 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%205 = load %..rawptr, %..rawptr* %204, align 8
	%206 = bitcast %..rawptr %205 to i8*
	%207 = load i8, i8* %206, align 1
	store i8 %207, i8* %24
	; ReturnStmt
	%208 = load i8, i8* %24, align 1
	%209 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%210 = bitcast %runtime.Type_Info_Enum* %25 to %..rawptr
	%211 = call %..rawptr @mem.zero(%..rawptr %210, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %25
	store %runtime.Type_Info_Enum %209, %runtime.Type_Info_Enum* %25
	%212 = call {%..string, i8} @fmt.enum_value_to_string.get_str-6(i8 %208, %runtime.Type_Info_Enum* %25, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%213 = extractvalue {%..string, i8} %212, 0
	%214 = extractvalue {%..string, i8} %212, 1
	%215 = bitcast {%..string, i8}* %26 to %..rawptr
	%216 = call %..rawptr @mem.zero(%..rawptr %215, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %26
	%217 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %26, i64 0, i32 0
	store %..string %213, %..string* %217
	%218 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %26, i64 0, i32 1
	store i8 %214, i8* %218
	%219 = load {%..string, i8}, {%..string, i8}* %26, align 8
	ret {%..string, i8} %219

typeswitch.next-17:
	%220 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%221 = load %..typeid, %..typeid* %220, align 8
	%222 = icmp eq %..typeid %221, 72057594037927999
	br i1 %222, label %typeswitch.body-20, label %typeswitch.next-19

typeswitch.body-18:
	%223 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%224 = load %..rawptr, %..rawptr* %223, align 8
	%225 = bitcast %..rawptr %224 to i16*
	%226 = load i16, i16* %225, align 2
	store i16 %226, i16* %27
	; ReturnStmt
	%227 = load i16, i16* %27, align 2
	%228 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%229 = bitcast %runtime.Type_Info_Enum* %28 to %..rawptr
	%230 = call %..rawptr @mem.zero(%..rawptr %229, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %28
	store %runtime.Type_Info_Enum %228, %runtime.Type_Info_Enum* %28
	%231 = call {%..string, i8} @fmt.enum_value_to_string.get_str-7(i16 %227, %runtime.Type_Info_Enum* %28, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%232 = extractvalue {%..string, i8} %231, 0
	%233 = extractvalue {%..string, i8} %231, 1
	%234 = bitcast {%..string, i8}* %29 to %..rawptr
	%235 = call %..rawptr @mem.zero(%..rawptr %234, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %29
	%236 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %29, i64 0, i32 0
	store %..string %232, %..string* %236
	%237 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %29, i64 0, i32 1
	store i8 %233, i8* %237
	%238 = load {%..string, i8}, {%..string, i8}* %29, align 8
	ret {%..string, i8} %238

typeswitch.next-19:
	%239 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%240 = load %..typeid, %..typeid* %239, align 8
	%241 = icmp eq %..typeid %240, 72057594037928000
	br i1 %241, label %typeswitch.body-22, label %typeswitch.next-21

typeswitch.body-20:
	%242 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%243 = load %..rawptr, %..rawptr* %242, align 8
	%244 = bitcast %..rawptr %243 to i32*
	%245 = load i32, i32* %244, align 4
	store i32 %245, i32* %30
	; ReturnStmt
	%246 = load i32, i32* %30, align 4
	%247 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%248 = bitcast %runtime.Type_Info_Enum* %31 to %..rawptr
	%249 = call %..rawptr @mem.zero(%..rawptr %248, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %31
	store %runtime.Type_Info_Enum %247, %runtime.Type_Info_Enum* %31
	%250 = call {%..string, i8} @fmt.enum_value_to_string.get_str-8(i32 %246, %runtime.Type_Info_Enum* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%251 = extractvalue {%..string, i8} %250, 0
	%252 = extractvalue {%..string, i8} %250, 1
	%253 = bitcast {%..string, i8}* %32 to %..rawptr
	%254 = call %..rawptr @mem.zero(%..rawptr %253, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %32
	%255 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %32, i64 0, i32 0
	store %..string %251, %..string* %255
	%256 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %32, i64 0, i32 1
	store i8 %252, i8* %256
	%257 = load {%..string, i8}, {%..string, i8}* %32, align 8
	ret {%..string, i8} %257

typeswitch.next-21:
	%258 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%259 = load %..typeid, %..typeid* %258, align 8
	%260 = icmp eq %..typeid %259, 72057594037928001
	br i1 %260, label %typeswitch.body-24, label %typeswitch.next-23

typeswitch.body-22:
	%261 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%262 = load %..rawptr, %..rawptr* %261, align 8
	%263 = bitcast %..rawptr %262 to i64*
	%264 = load i64, i64* %263, align 8
	store i64 %264, i64* %33
	; ReturnStmt
	%265 = load i64, i64* %33, align 8
	%266 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%267 = bitcast %runtime.Type_Info_Enum* %34 to %..rawptr
	%268 = call %..rawptr @mem.zero(%..rawptr %267, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %34
	store %runtime.Type_Info_Enum %266, %runtime.Type_Info_Enum* %34
	%269 = call {%..string, i8} @fmt.enum_value_to_string.get_str-9(i64 %265, %runtime.Type_Info_Enum* %34, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%270 = extractvalue {%..string, i8} %269, 0
	%271 = extractvalue {%..string, i8} %269, 1
	%272 = bitcast {%..string, i8}* %35 to %..rawptr
	%273 = call %..rawptr @mem.zero(%..rawptr %272, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %35
	%274 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %35, i64 0, i32 0
	store %..string %270, %..string* %274
	%275 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %35, i64 0, i32 1
	store i8 %271, i8* %275
	%276 = load {%..string, i8}, {%..string, i8}* %35, align 8
	ret {%..string, i8} %276

typeswitch.next-23:
	%277 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%278 = load %..typeid, %..typeid* %277, align 8
	%279 = icmp eq %..typeid %278, 72057594037927982
	br i1 %279, label %typeswitch.body-26, label %typeswitch.next-25

typeswitch.body-24:
	%280 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%281 = load %..rawptr, %..rawptr* %280, align 8
	%282 = bitcast %..rawptr %281 to i64*
	%283 = load i64, i64* %282, align 8
	store i64 %283, i64* %36
	; ReturnStmt
	%284 = load i64, i64* %36, align 8
	%285 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%286 = bitcast %runtime.Type_Info_Enum* %37 to %..rawptr
	%287 = call %..rawptr @mem.zero(%..rawptr %286, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %37
	store %runtime.Type_Info_Enum %285, %runtime.Type_Info_Enum* %37
	%288 = call {%..string, i8} @fmt.enum_value_to_string.get_str-10(i64 %284, %runtime.Type_Info_Enum* %37, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%289 = extractvalue {%..string, i8} %288, 0
	%290 = extractvalue {%..string, i8} %288, 1
	%291 = bitcast {%..string, i8}* %38 to %..rawptr
	%292 = call %..rawptr @mem.zero(%..rawptr %291, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %38
	%293 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %38, i64 0, i32 0
	store %..string %289, %..string* %293
	%294 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %38, i64 0, i32 1
	store i8 %290, i8* %294
	%295 = load {%..string, i8}, {%..string, i8}* %38, align 8
	ret {%..string, i8} %295

typeswitch.next-25:
	; ReturnStmt
	%296 = bitcast {%..string, i8}* %44 to %..rawptr
	%297 = call %..rawptr @mem.zero(%..rawptr %296, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %44
	%298 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %44, i64 0, i32 0
	store %..string zeroinitializer, %..string* %298
	%299 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %44, i64 0, i32 1
	store i8 0, i8* %299
	%300 = load {%..string, i8}, {%..string, i8}* %44, align 8
	ret {%..string, i8} %300

typeswitch.body-26:
	%301 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	%302 = load %..rawptr, %..rawptr* %301, align 8
	%303 = bitcast %..rawptr %302 to i64*
	%304 = load i64, i64* %303, align 8
	store i64 %304, i64* %39
	; ReturnStmt
	%305 = load i64, i64* %39, align 8
	%306 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2, align 8
	%307 = bitcast %runtime.Type_Info_Enum* %40 to %..rawptr
	%308 = call %..rawptr @mem.zero(%..rawptr %307, i64 40) noinline
	store %runtime.Type_Info_Enum zeroinitializer, %runtime.Type_Info_Enum* %40
	store %runtime.Type_Info_Enum %306, %runtime.Type_Info_Enum* %40
	%309 = call {%..string, i8} @fmt.enum_value_to_string.get_str-11(i64 %305, %runtime.Type_Info_Enum* %40, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%310 = extractvalue {%..string, i8} %309, 0
	%311 = extractvalue {%..string, i8} %309, 1
	%312 = bitcast {%..string, i8}* %41 to %..rawptr
	%313 = call %..rawptr @mem.zero(%..rawptr %312, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %41
	%314 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %41, i64 0, i32 0
	store %..string %310, %..string* %314
	%315 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %41, i64 0, i32 1
	store i8 %311, i8* %315
	%316 = load {%..string, i8}, {%..string, i8}* %41, align 8
	ret {%..string, i8} %316
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-0(i32 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i32, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i32, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i32, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i32, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i32 %i, i32* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i32, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 1
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i32*
	%52 = load i32, i32* %51, align 4
	store i32 %52, i32* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i32, i8}, {i32, i8}* %7, align 4
	%54 = extractvalue {i32, i8} %53, 0
	%55 = extractvalue {i32, i8} %53, 1
	store i32 %54, i32* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i32, i32* %5, align 4
	%59 = load i32, i32* %0, align 4
	%60 = icmp eq i32 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$100, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i32, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 1
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i32*
	%114 = load i32, i32* %113, align 4
	store i32 %114, i32* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i32, i8}, {i32, i8}* %16, align 4
	%116 = extractvalue {i32, i8} %115, 0
	%117 = extractvalue {i32, i8} %115, 1
	store i32 %116, i32* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i32, i32* %14, align 4
	%121 = load i32, i32* %0, align 4
	%122 = icmp eq i32 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$101, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-1(i8 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i8, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i8, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i8, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i8, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i8 %i, i8* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i8, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 2) noinline
	store {i8, i8} zeroinitializer, {i8, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 2
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i8, i8}, {i8, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i8, i8}, {i8, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i8*
	%52 = load i8, i8* %51, align 1
	store i8 %52, i8* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i8, i8}, {i8, i8}* %7, align 1
	%54 = extractvalue {i8, i8} %53, 0
	%55 = extractvalue {i8, i8} %53, 1
	store i8 %54, i8* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i8, i8* %5, align 1
	%59 = load i8, i8* %0, align 1
	%60 = icmp eq i8 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$102, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i8, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 2) noinline
	store {i8, i8} zeroinitializer, {i8, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 2
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i8, i8}, {i8, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i8, i8}, {i8, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i8*
	%114 = load i8, i8* %113, align 1
	store i8 %114, i8* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i8, i8}, {i8, i8}* %16, align 1
	%116 = extractvalue {i8, i8} %115, 0
	%117 = extractvalue {i8, i8} %115, 1
	store i8 %116, i8* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i8, i8* %14, align 1
	%121 = load i8, i8* %0, align 1
	%122 = icmp eq i8 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$103, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-2(i16 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i16, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i16, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i16, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i16, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i16, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i16 %i, i16* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i16, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 4) noinline
	store {i16, i8} zeroinitializer, {i16, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 3
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i16, i8}, {i16, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i16, i8}, {i16, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i16*
	%52 = load i16, i16* %51, align 2
	store i16 %52, i16* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i16, i8}, {i16, i8}* %7, align 2
	%54 = extractvalue {i16, i8} %53, 0
	%55 = extractvalue {i16, i8} %53, 1
	store i16 %54, i16* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i16, i16* %5, align 2
	%59 = load i16, i16* %0, align 2
	%60 = icmp eq i16 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$104, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i16, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 4) noinline
	store {i16, i8} zeroinitializer, {i16, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 3
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i16, i8}, {i16, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i16, i8}, {i16, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i16*
	%114 = load i16, i16* %113, align 2
	store i16 %114, i16* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i16, i8}, {i16, i8}* %16, align 2
	%116 = extractvalue {i16, i8} %115, 0
	%117 = extractvalue {i16, i8} %115, 1
	store i16 %116, i16* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i16, i16* %14, align 2
	%121 = load i16, i16* %0, align 2
	%122 = icmp eq i16 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$105, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-3(i32 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i32, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i32, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i32, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i32, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i32 %i, i32* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i32, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 4
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i32*
	%52 = load i32, i32* %51, align 4
	store i32 %52, i32* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i32, i8}, {i32, i8}* %7, align 4
	%54 = extractvalue {i32, i8} %53, 0
	%55 = extractvalue {i32, i8} %53, 1
	store i32 %54, i32* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i32, i32* %5, align 4
	%59 = load i32, i32* %0, align 4
	%60 = icmp eq i32 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$106, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i32, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 4
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i32*
	%114 = load i32, i32* %113, align 4
	store i32 %114, i32* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i32, i8}, {i32, i8}* %16, align 4
	%116 = extractvalue {i32, i8} %115, 0
	%117 = extractvalue {i32, i8} %115, 1
	store i32 %116, i32* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i32, i32* %14, align 4
	%121 = load i32, i32* %0, align 4
	%122 = icmp eq i32 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$107, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-4(i64 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i64, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i64 %i, i64* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i64, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 5
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i64*
	%52 = load i64, i64* %51, align 8
	store i64 %52, i64* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i64, i8}, {i64, i8}* %7, align 8
	%54 = extractvalue {i64, i8} %53, 0
	%55 = extractvalue {i64, i8} %53, 1
	store i64 %54, i64* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i64, i64* %5, align 8
	%59 = load i64, i64* %0, align 8
	%60 = icmp eq i64 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$108, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i64, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 5
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i64*
	%114 = load i64, i64* %113, align 8
	store i64 %114, i64* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i64, i8}, {i64, i8}* %16, align 8
	%116 = extractvalue {i64, i8} %115, 0
	%117 = extractvalue {i64, i8} %115, 1
	store i64 %116, i64* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i64, i64* %14, align 8
	%121 = load i64, i64* %0, align 8
	%122 = icmp eq i64 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$109, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-5(i64 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i64, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i64 %i, i64* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i64, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 6
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i64*
	%52 = load i64, i64* %51, align 8
	store i64 %52, i64* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i64, i8}, {i64, i8}* %7, align 8
	%54 = extractvalue {i64, i8} %53, 0
	%55 = extractvalue {i64, i8} %53, 1
	store i64 %54, i64* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i64, i64* %5, align 8
	%59 = load i64, i64* %0, align 8
	%60 = icmp eq i64 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$10a, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i64, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 6
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i64*
	%114 = load i64, i64* %113, align 8
	store i64 %114, i64* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i64, i8}, {i64, i8}* %16, align 8
	%116 = extractvalue {i64, i8} %115, 0
	%117 = extractvalue {i64, i8} %115, 1
	store i64 %116, i64* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i64, i64* %14, align 8
	%121 = load i64, i64* %0, align 8
	%122 = icmp eq i64 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$10b, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-6(i8 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i8, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i8, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i8, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i8, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i8 %i, i8* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i8, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 2) noinline
	store {i8, i8} zeroinitializer, {i8, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 7
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i8, i8}, {i8, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i8, i8}, {i8, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i8*
	%52 = load i8, i8* %51, align 1
	store i8 %52, i8* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i8, i8}, {i8, i8}* %7, align 1
	%54 = extractvalue {i8, i8} %53, 0
	%55 = extractvalue {i8, i8} %53, 1
	store i8 %54, i8* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i8, i8* %5, align 1
	%59 = load i8, i8* %0, align 1
	%60 = icmp eq i8 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$10c, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i8, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 2) noinline
	store {i8, i8} zeroinitializer, {i8, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 7
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i8, i8}, {i8, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i8, i8}, {i8, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i8*
	%114 = load i8, i8* %113, align 1
	store i8 %114, i8* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i8, i8}, {i8, i8}* %16, align 1
	%116 = extractvalue {i8, i8} %115, 0
	%117 = extractvalue {i8, i8} %115, 1
	store i8 %116, i8* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i8, i8* %14, align 1
	%121 = load i8, i8* %0, align 1
	%122 = icmp eq i8 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$10d, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-7(i16 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i16, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i16, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i16, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i16, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i16, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i16 %i, i16* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i16, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 4) noinline
	store {i16, i8} zeroinitializer, {i16, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 8
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i16, i8}, {i16, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i16, i8}, {i16, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i16*
	%52 = load i16, i16* %51, align 2
	store i16 %52, i16* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i16, i8}, {i16, i8}* %7, align 2
	%54 = extractvalue {i16, i8} %53, 0
	%55 = extractvalue {i16, i8} %53, 1
	store i16 %54, i16* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i16, i16* %5, align 2
	%59 = load i16, i16* %0, align 2
	%60 = icmp eq i16 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$10e, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i16, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 4) noinline
	store {i16, i8} zeroinitializer, {i16, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 8
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i16, i8}, {i16, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i16, i8}, {i16, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i16*
	%114 = load i16, i16* %113, align 2
	store i16 %114, i16* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i16, i8}, {i16, i8}* %16, align 2
	%116 = extractvalue {i16, i8} %115, 0
	%117 = extractvalue {i16, i8} %115, 1
	store i16 %116, i16* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i16, i16* %14, align 2
	%121 = load i16, i16* %0, align 2
	%122 = icmp eq i16 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$10f, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-8(i32 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i32, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i32, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i32, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i32, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i32 %i, i32* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i32, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 9
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i32*
	%52 = load i32, i32* %51, align 4
	store i32 %52, i32* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i32, i8}, {i32, i8}* %7, align 4
	%54 = extractvalue {i32, i8} %53, 0
	%55 = extractvalue {i32, i8} %53, 1
	store i32 %54, i32* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i32, i32* %5, align 4
	%59 = load i32, i32* %0, align 4
	%60 = icmp eq i32 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$110, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i32, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 8) noinline
	store {i32, i8} zeroinitializer, {i32, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 9
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i32*
	%114 = load i32, i32* %113, align 4
	store i32 %114, i32* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i32, i8}, {i32, i8}* %16, align 4
	%116 = extractvalue {i32, i8} %115, 0
	%117 = extractvalue {i32, i8} %115, 1
	store i32 %116, i32* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i32, i32* %14, align 4
	%121 = load i32, i32* %0, align 4
	%122 = icmp eq i32 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$111, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-9(i64 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i64, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i64 %i, i64* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i64, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 10
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i64*
	%52 = load i64, i64* %51, align 8
	store i64 %52, i64* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i64, i8}, {i64, i8}* %7, align 8
	%54 = extractvalue {i64, i8} %53, 0
	%55 = extractvalue {i64, i8} %53, 1
	store i64 %54, i64* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i64, i64* %5, align 8
	%59 = load i64, i64* %0, align 8
	%60 = icmp eq i64 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$112, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i64, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 10
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i64*
	%114 = load i64, i64* %113, align 8
	store i64 %114, i64* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i64, i8}, {i64, i8}* %16, align 8
	%116 = extractvalue {i64, i8} %115, 0
	%117 = extractvalue {i64, i8} %115, 1
	store i64 %116, i64* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i64, i64* %14, align 8
	%121 = load i64, i64* %0, align 8
	%122 = icmp eq i64 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$113, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-10(i64 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i64, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i64 %i, i64* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i64, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 11
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i64*
	%52 = load i64, i64* %51, align 8
	store i64 %52, i64* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i64, i8}, {i64, i8}* %7, align 8
	%54 = extractvalue {i64, i8} %53, 0
	%55 = extractvalue {i64, i8} %53, 1
	store i64 %54, i64* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i64, i64* %5, align 8
	%59 = load i64, i64* %0, align 8
	%60 = icmp eq i64 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$114, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i64, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 11
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i64*
	%114 = load i64, i64* %113, align 8
	store i64 %114, i64* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i64, i8}, {i64, i8}* %16, align 8
	%116 = extractvalue {i64, i8} %115, 0
	%117 = extractvalue {i64, i8} %115, 1
	store i64 %116, i64* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i64, i64* %14, align 8
	%121 = load i64, i64* %0, align 8
	%122 = icmp eq i64 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$115, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define {%..string, i8} @fmt.enum_value_to_string.get_str-11(i64 %i, %runtime.Type_Info_Enum* %e, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i64, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i64 %i, i64* %0
	%19 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, align 8
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%20 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 0
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %20, align 8
	%22 = call i8 @types.is_string(%runtime.Type_Info* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	%24 = bitcast %runtime.Type_Info_Enum_Value* %1 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1
	; idx
	%26 = bitcast i64* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	; SelectorExpr
	%28 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%29 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %28, align 8
	%30 = bitcast i64* %3 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%32 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 1
	store i64 %32, i64* %3
	%33 = bitcast i64* %4 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%35 = load i64, i64* %4, align 8
	%36 = add i64 %35, 1
	store i64 %36, i64* %4
	%37 = load i64, i64* %3, align 8
	%38 = icmp slt i64 %36, %37
	br i1 %38, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%39 = load i64, i64* %4, align 8
	%40 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %29, 0
	%41 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %40, i64 %39
	%42 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %41, align 8
	store %runtime.Type_Info_Enum_Value %42, %runtime.Type_Info_Enum_Value* %1
	store i64 %39, i64* %2
	; IfStmt
	; v
	; ok
	%43 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, align 8
	; cast - union_cast
	%44 = bitcast {i64, i8}* %7 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %7
	%46 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%47 = load i8, i8* %46, align 1
	%48 = icmp eq i8 %47, 12
	br i1 %48, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%49 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 0
	%50 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i64 0, i32 1
	%51 = bitcast %runtime.Type_Info_Enum_Value* %1 to i64*
	%52 = load i64, i64* %51, align 8
	store i64 %52, i64* %49
	store i8 1, i8* %50
	br label %union_cast.end-5

union_cast.end-5:
	%53 = load {i64, i8}, {i64, i8}* %7, align 8
	%54 = extractvalue {i64, i8} %53, 0
	%55 = extractvalue {i64, i8} %53, 1
	store i64 %54, i64* %5
	store i8 %55, i8* %6
	%56 = load i8, i8* %6, align 1
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%58 = load i64, i64* %5, align 8
	%59 = load i64, i64* %0, align 8
	%60 = icmp eq i64 %58, %59
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%63 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%64 = load {%..string*, i64}, {%..string*, i64}* %63, align 8
	%65 = extractvalue {%..string*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = extractvalue {%..string*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$116, i64 0, i32 0), i64 53}, i64 739, i64 22, i64 %66, i64 %67)
	%68 = getelementptr inbounds %..string, %..string* %65, i64 %66
	%69 = load %..string, %..string* %68, align 8
	%70 = bitcast {%..string, i8}* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %8
	%72 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 0
	store %..string %69, %..string* %72
	%73 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i64 0, i32 1
	store i8 1, i8* %73
	%74 = load {%..string, i8}, {%..string, i8}* %8, align 8
	ret {%..string, i8} %74

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%76 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %75, align 8
	%77 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %76, 1
	%78 = icmp eq i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%81 = bitcast {%..string, i8}* %9 to %..rawptr
	%82 = call %..rawptr @mem.zero(%..rawptr %81, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %9
	%83 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 0
	store %..string zeroinitializer, %..string* %83
	%84 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i64 0, i32 1
	store i8 1, i8* %84
	%85 = load {%..string, i8}, {%..string, i8}* %9, align 8
	ret {%..string, i8} %85

if.else-12:
	; RangeStmt
	; val
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to %..rawptr
	%87 = call %..rawptr @mem.zero(%..rawptr %86, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10
	; idx
	%88 = bitcast i64* %11 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	; SelectorExpr
	%90 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 2
	%91 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %90, align 8
	%92 = bitcast i64* %12 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%94 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 1
	store i64 %94, i64* %12
	%95 = bitcast i64* %13 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%97 = load i64, i64* %13, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %13
	%99 = load i64, i64* %12, align 8
	%100 = icmp slt i64 %98, %99
	br i1 %100, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%101 = load i64, i64* %13, align 8
	%102 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %91, 0
	%103 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %102, i64 %101
	%104 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %103, align 8
	store %runtime.Type_Info_Enum_Value %104, %runtime.Type_Info_Enum_Value* %10
	store i64 %101, i64* %11
	; IfStmt
	; v
	; ok
	%105 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, align 8
	; cast - union_cast
	%106 = bitcast {i64, i8}* %16 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %16
	%108 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%109 = load i8, i8* %108, align 1
	%110 = icmp eq i8 %109, 12
	br i1 %110, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%111 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 0
	%112 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i64 0, i32 1
	%113 = bitcast %runtime.Type_Info_Enum_Value* %10 to i64*
	%114 = load i64, i64* %113, align 8
	store i64 %114, i64* %111
	store i8 1, i8* %112
	br label %union_cast.end-16

union_cast.end-16:
	%115 = load {i64, i8}, {i64, i8}* %16, align 8
	%116 = extractvalue {i64, i8} %115, 0
	%117 = extractvalue {i64, i8} %115, 1
	store i64 %116, i64* %14
	store i8 %117, i8* %15
	%118 = load i8, i8* %15, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%120 = load i64, i64* %14, align 8
	%121 = load i64, i64* %0, align 8
	%122 = icmp eq i64 %120, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%125 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %e, i64 0, i32 1
	%126 = load {%..string*, i64}, {%..string*, i64}* %125, align 8
	%127 = extractvalue {%..string*, i64} %126, 0
	%128 = load i64, i64* %11, align 8
	%129 = extractvalue {%..string*, i64} %126, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$117, i64 0, i32 0), i64 53}, i64 747, i64 22, i64 %128, i64 %129)
	%130 = getelementptr inbounds %..string, %..string* %127, i64 %128
	%131 = load %..string, %..string* %130, align 8
	%132 = bitcast {%..string, i8}* %17 to %..rawptr
	%133 = call %..rawptr @mem.zero(%..rawptr %132, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %17
	%134 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 0
	store %..string %131, %..string* %134
	%135 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i64 0, i32 1
	store i8 1, i8* %135
	%136 = load {%..string, i8}, {%..string, i8}* %17, align 8
	ret {%..string, i8} %136

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%137 = bitcast {%..string, i8}* %18 to %..rawptr
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 24) noinline
	store {%..string, i8} zeroinitializer, {%..string, i8}* %18
	%139 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 0
	store %..string zeroinitializer, %..string* %139
	%140 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i64 0, i32 1
	store i8 0, i8* %140
	%141 = load {%..string, i8}, {%..string, i8}* %18, align 8
	ret {%..string, i8} %141
}

define void @fmt.fmt_enum(%fmt.Fmt_Info* %fi, %..any %v, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca i32, align 16
	%3 = alloca %runtime.Type_Info*, align 16
	%4 = alloca %runtime.Type_Info_Enum, align 16
	%5 = alloca %..any, align 16
	%6 = alloca %runtime.Type_Info*, align 16
	%7 = alloca %..string, align 16
	%8 = alloca i8, align 16
	%9 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..any %v, %..any* %1
	store i32 %verb, i32* %2
	; IfStmt
	; SelectorExpr
	%10 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%11 = load %..typeid, %..typeid* %10, align 8
	%12 = icmp eq %..typeid %11, 0
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %if.then-2, label %cmp.or-1

cmp.or-1:
	; SelectorExpr
	%15 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%16 = load %..rawptr, %..rawptr* %15, align 8
	%17 = icmp eq %..rawptr %16, zeroinitializer
	%18 = zext i1 %17 to i8
	%19 = trunc i8 %18 to i1
	br i1 %19, label %if.then-2, label %if.done-3

if.then-2:
	; SelectorExpr
	%20 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%21 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %20, i64 0
	%22 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %21, i64 0, i32 12
	%23 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %22, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %23, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$118, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-3:
	; type_info
	; SelectorExpr
	%24 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%25 = load %..typeid, %..typeid* %24, align 8
	%26 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %25)
	store %runtime.Type_Info* %26, %runtime.Type_Info** %3
	; TypeSwitchStmt
	; SelectorExpr
	%27 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%28 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %27, i64 0
	%29 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %28, i64 0, i32 3
	%30 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %29, align 8
	; get union's tag
	%31 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %29, i64 0, i32 2 ; UnionTagPtr
	%32 = load i8, i8* %31, align 1
	%33 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %29 to %..rawptr
	%34 = icmp eq i8 %32, 18
	br i1 %34, label %typeswitch.body-5, label %typeswitch.next-4

typeswitch.next-4:
	store {[0 x <8 x i8>], [72 x i8], i8} %30, {[0 x <8 x i8>], [72 x i8], i8}* %9
	%35 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%36 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %35, i32 %36, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-15

typeswitch.body-5:
	%37 = bitcast %..rawptr %33 to %runtime.Type_Info_Enum*
	%38 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %37, align 8
	store %runtime.Type_Info_Enum %38, %runtime.Type_Info_Enum* %4
	; SwitchStmt
	%39 = load i32, i32* %2, align 4
	%40 = icmp eq i32 %39, 100
	br i1 %40, label %switch.fall.body-8, label %switch.case.next-6

switch.case.next-6:
	%41 = icmp eq i32 %39, 102
	br i1 %41, label %switch.fall.body-8, label %switch.case.next-7

switch.case.next-7:
	%42 = icmp eq i32 %39, 115
	br i1 %42, label %switch.fall.body-11, label %switch.case.next-9

switch.fall.body-8:
	%43 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%44 = bitcast %..any* %5 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 16) noinline
	store %..any zeroinitializer, %..any* %5
	store %..any zeroinitializer, %..any* %5
	; SelectorExpr
	%46 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%47 = load %..rawptr, %..rawptr* %46, align 8
	%48 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	store %..rawptr %47, %..rawptr* %48
	; SelectorExpr
	; SelectorExpr
	; SelectorExpr
	%49 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %4, i64 0, i32 0
	%50 = load %runtime.Type_Info*, %runtime.Type_Info** %49, align 8
	%51 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %50)
	%52 = bitcast %runtime.Type_Info** %6 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %6
	store %runtime.Type_Info* %51, %runtime.Type_Info** %6
	%54 = load %runtime.Type_Info*, %runtime.Type_Info** %6, align 8
	%55 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %54, i64 0
	%56 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %55, i64 0, i32 2
	%57 = load %..typeid, %..typeid* %56, align 8
	%58 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	store %..typeid %57, %..typeid* %58
	%59 = load %..any, %..any* %5, align 8
	%60 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %43, %..any %59, i32 %60, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-14

switch.case.next-9:
	%61 = icmp eq i32 %39, 118
	br i1 %61, label %switch.fall.body-11, label %switch.case.next-10

switch.case.next-10:
	%62 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%63 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %62, i32 %63, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-14

switch.fall.body-11:
	; str
	; ok
	%64 = load %..any, %..any* %1, align 8
	%65 = call {%..string, i8} @fmt.enum_value_to_string(%..any %64, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%66 = extractvalue {%..string, i8} %65, 0
	%67 = extractvalue {%..string, i8} %65, 1
	store %..string %66, %..string* %7
	store i8 %67, i8* %8
	; IfStmt
	%68 = load i8, i8* %8, align 1
	%69 = trunc i8 %68 to i1
	br i1 %69, label %if.done-13, label %if.then-12

if.then-12:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$119, i64 0, i32 0), i64 18}, %..string* %7
	br label %if.done-13

if.done-13:
	; SelectorExpr
	%70 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%71 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %70, i64 0
	%72 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %71, i64 0, i32 12
	%73 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %72, align 8
	%74 = load %..string, %..string* %7, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %73, %..string %74, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-14

switch.done-14:
	br label %typeswitch.done-15

typeswitch.done-15:
	ret void
}

define i64 @fmt.enum_value_to_u64(%runtime.Type_Info_Enum_Value* %ev, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i8, align 16
	%2 = alloca i16, align 16
	%3 = alloca i32, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca i16, align 16
	%8 = alloca i32, align 16
	%9 = alloca i64, align 16
	%10 = alloca i64, align 16
	%11 = alloca i64, align 16
	%12 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %ev, align 8
	; TypeSwitchStmt
	%13 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %ev, align 8
	; get union's tag
	%14 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %ev, i64 0, i32 2 ; UnionTagPtr
	%15 = load i8, i8* %14, align 1
	%16 = bitcast %runtime.Type_Info_Enum_Value* %ev to %..rawptr
	%17 = icmp eq i8 %15, 1
	br i1 %17, label %typeswitch.body-2, label %typeswitch.next-1

typeswitch.next-1:
	%18 = icmp eq i8 %15, 2
	br i1 %18, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.body-2:
	%19 = bitcast %..rawptr %16 to i32*
	%20 = load i32, i32* %19, align 4
	store i32 %20, i32* %0
	; ReturnStmt
	%21 = load i32, i32* %0, align 4
	%22 = sext i32 %21 to i64
	ret i64 %22

typeswitch.next-3:
	%23 = icmp eq i8 %15, 3
	br i1 %23, label %typeswitch.body-6, label %typeswitch.next-5

typeswitch.body-4:
	%24 = bitcast %..rawptr %16 to i8*
	%25 = load i8, i8* %24, align 1
	store i8 %25, i8* %1
	; ReturnStmt
	%26 = load i8, i8* %1, align 1
	%27 = sext i8 %26 to i64
	ret i64 %27

typeswitch.next-5:
	%28 = icmp eq i8 %15, 4
	br i1 %28, label %typeswitch.body-8, label %typeswitch.next-7

typeswitch.body-6:
	%29 = bitcast %..rawptr %16 to i16*
	%30 = load i16, i16* %29, align 2
	store i16 %30, i16* %2
	; ReturnStmt
	%31 = load i16, i16* %2, align 2
	%32 = sext i16 %31 to i64
	ret i64 %32

typeswitch.next-7:
	%33 = icmp eq i8 %15, 5
	br i1 %33, label %typeswitch.body-10, label %typeswitch.next-9

typeswitch.body-8:
	%34 = bitcast %..rawptr %16 to i32*
	%35 = load i32, i32* %34, align 4
	store i32 %35, i32* %3
	; ReturnStmt
	%36 = load i32, i32* %3, align 4
	%37 = sext i32 %36 to i64
	ret i64 %37

typeswitch.next-9:
	%38 = icmp eq i8 %15, 6
	br i1 %38, label %typeswitch.body-12, label %typeswitch.next-11

typeswitch.body-10:
	%39 = bitcast %..rawptr %16 to i64*
	%40 = load i64, i64* %39, align 8
	store i64 %40, i64* %4
	; ReturnStmt
	%41 = load i64, i64* %4, align 8
	%42 = bitcast i64 %41 to i64
	ret i64 %42

typeswitch.next-11:
	%43 = icmp eq i8 %15, 7
	br i1 %43, label %typeswitch.body-14, label %typeswitch.next-13

typeswitch.body-12:
	%44 = bitcast %..rawptr %16 to i64*
	%45 = load i64, i64* %44, align 8
	store i64 %45, i64* %5
	; ReturnStmt
	%46 = load i64, i64* %5, align 8
	%47 = bitcast i64 %46 to i64
	ret i64 %47

typeswitch.next-13:
	%48 = icmp eq i8 %15, 8
	br i1 %48, label %typeswitch.body-16, label %typeswitch.next-15

typeswitch.body-14:
	%49 = bitcast %..rawptr %16 to i8*
	%50 = load i8, i8* %49, align 1
	store i8 %50, i8* %6
	; ReturnStmt
	%51 = load i8, i8* %6, align 1
	%52 = zext i8 %51 to i64
	ret i64 %52

typeswitch.next-15:
	%53 = icmp eq i8 %15, 9
	br i1 %53, label %typeswitch.body-18, label %typeswitch.next-17

typeswitch.body-16:
	%54 = bitcast %..rawptr %16 to i16*
	%55 = load i16, i16* %54, align 2
	store i16 %55, i16* %7
	; ReturnStmt
	%56 = load i16, i16* %7, align 2
	%57 = zext i16 %56 to i64
	ret i64 %57

typeswitch.next-17:
	%58 = icmp eq i8 %15, 10
	br i1 %58, label %typeswitch.body-20, label %typeswitch.next-19

typeswitch.body-18:
	%59 = bitcast %..rawptr %16 to i32*
	%60 = load i32, i32* %59, align 4
	store i32 %60, i32* %8
	; ReturnStmt
	%61 = load i32, i32* %8, align 4
	%62 = zext i32 %61 to i64
	ret i64 %62

typeswitch.next-19:
	%63 = icmp eq i8 %15, 11
	br i1 %63, label %typeswitch.body-22, label %typeswitch.next-21

typeswitch.body-20:
	%64 = bitcast %..rawptr %16 to i64*
	%65 = load i64, i64* %64, align 8
	store i64 %65, i64* %9
	; ReturnStmt
	%66 = load i64, i64* %9, align 8
	ret i64 %66

typeswitch.next-21:
	%67 = icmp eq i8 %15, 12
	br i1 %67, label %typeswitch.body-24, label %typeswitch.next-23

typeswitch.body-22:
	%68 = bitcast %..rawptr %16 to i64*
	%69 = load i64, i64* %68, align 8
	store i64 %69, i64* %10
	; ReturnStmt
	%70 = load i64, i64* %10, align 8
	%71 = bitcast i64 %70 to i64
	ret i64 %71

typeswitch.next-23:
	; ReturnStmt
	ret i64 0

typeswitch.body-24:
	%72 = bitcast %..rawptr %16 to i64*
	%73 = load i64, i64* %72, align 8
	store i64 %73, i64* %11
	; ReturnStmt
	%74 = load i64, i64* %11, align 8
	%75 = bitcast i64 %74 to i64
	ret i64 %75
}

define void @fmt.fmt_bit_set(%fmt.Fmt_Info* %fi, %..any %v, %..string %name, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca %..string, align 16
	%3 = alloca %runtime.Type_Info*, align 16
	%4 = alloca %runtime.Type_Info_Named, align 16
	%5 = alloca %..any, align 16
	%6 = alloca %runtime.Type_Info_Bit_Set, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca i32, align 16
	%10 = alloca %runtime.Source_Code_Location, align 16
	%11 = alloca %runtime.Type_Info*, align 16
	%12 = alloca %runtime.Type_Info_Enum, align 16
	%13 = alloca i8, align 16
	%14 = alloca {%runtime.Type_Info_Enum, i8}, align 16
	%15 = alloca i64, align 16
	%16 = alloca i64, align 16
	%17 = alloca i64, align 16
	%18 = alloca i64, align 16
	%19 = alloca %runtime.Type_Info_Enum_Value, align 16
	%20 = alloca i64, align 16
	%21 = alloca i64, align 16
	%22 = alloca i64, align 16
	%23 = alloca i64, align 16
	%24 = alloca %runtime.Type_Info_Enum_Value, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..any %v, %..any* %1
	store %..string %name, %..string* %2
	; type_info
	; SelectorExpr
	%25 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%26 = load %..typeid, %..typeid* %25, align 8
	%27 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %26)
	store %runtime.Type_Info* %27, %runtime.Type_Info** %3
	; TypeSwitchStmt
	; SelectorExpr
	%28 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%29 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %28, i64 0
	%30 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %29, i64 0, i32 3
	%31 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %30, align 8
	; get union's tag
	%32 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %30, i64 0, i32 2 ; UnionTagPtr
	%33 = load i8, i8* %32, align 1
	%34 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %30 to %..rawptr
	%35 = icmp eq i8 %33, 1
	br i1 %35, label %typeswitch.body-2, label %typeswitch.next-1

typeswitch.next-1:
	%36 = icmp eq i8 %33, 21
	br i1 %36, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.body-2:
	%37 = bitcast %..rawptr %34 to %runtime.Type_Info_Named*
	%38 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %37, align 8
	store %runtime.Type_Info_Named %38, %runtime.Type_Info_Named* %4
	; val
	%39 = load %..any, %..any* %1, align 8
	store %..any %39, %..any* %5
	; AssignStmt
	; SelectorExpr
	%40 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	; SelectorExpr
	; SelectorExpr
	%41 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 1
	%42 = load %runtime.Type_Info*, %runtime.Type_Info** %41, align 8
	%43 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %42, i64 0
	%44 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %43, i64 0, i32 2
	%45 = load %..typeid, %..typeid* %44, align 8
	store %..typeid %45, %..typeid* %40
	%46 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%47 = load %..any, %..any* %5, align 8
	; SelectorExpr
	%48 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 0
	%49 = load %..string, %..string* %48, align 8
	call void @fmt.fmt_bit_set(%fmt.Fmt_Info* %46, %..any %47, %..string %49, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-35

typeswitch.next-3:
	br label %typeswitch.done-35

typeswitch.body-4:
	%50 = bitcast %..rawptr %34 to %runtime.Type_Info_Bit_Set*
	%51 = load %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, align 8
	store %runtime.Type_Info_Bit_Set %51, %runtime.Type_Info_Bit_Set* %6
	; bits
	%52 = bitcast i64* %7 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 8) noinline
	store i64 zeroinitializer, i64* %7
	; bit_size
	; SelectorExpr
	%54 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%55 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %54, i64 0
	%56 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %55, i64 0, i32 0
	%57 = load i64, i64* %56, align 8
	%58 = mul i64 8, %57
	%59 = bitcast i64 %58 to i64
	store i64 %59, i64* %8
	; verb
	store i32 98, i32* %9
	; SwitchStmt
	%60 = load i64, i64* %8, align 8
	%61 = icmp eq i64 %60, 0
	br i1 %61, label %switch.case.body-6, label %switch.case.next-5

switch.case.next-5:
	%62 = icmp eq i64 %60, 8
	br i1 %62, label %switch.fall.body-8, label %switch.case.next-7

switch.case.body-6:
	; AssignStmt
	store i64 0, i64* %7
	br label %switch.done-15

switch.case.next-7:
	%63 = icmp eq i64 %60, 16
	br i1 %63, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	; AssignStmt
	; SelectorExpr
	%64 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%65 = load %..rawptr, %..rawptr* %64, align 8
	%66 = bitcast %..rawptr %65 to i8*
	%67 = getelementptr inbounds i8, i8* %66, i64 0
	%68 = load i8, i8* %67, align 1
	%69 = zext i8 %68 to i64
	store i64 %69, i64* %7
	br label %switch.done-15

switch.case.next-9:
	%70 = icmp eq i64 %60, 32
	br i1 %70, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	; AssignStmt
	; SelectorExpr
	%71 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%72 = load %..rawptr, %..rawptr* %71, align 8
	%73 = bitcast %..rawptr %72 to i16*
	%74 = getelementptr inbounds i16, i16* %73, i64 0
	%75 = load i16, i16* %74, align 2
	%76 = zext i16 %75 to i64
	store i64 %76, i64* %7
	br label %switch.done-15

switch.case.next-11:
	%77 = icmp eq i64 %60, 64
	br i1 %77, label %switch.fall.body-14, label %switch.case.next-13

switch.fall.body-12:
	; AssignStmt
	; SelectorExpr
	%78 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%79 = load %..rawptr, %..rawptr* %78, align 8
	%80 = bitcast %..rawptr %79 to i32*
	%81 = getelementptr inbounds i32, i32* %80, i64 0
	%82 = load i32, i32* %81, align 4
	%83 = zext i32 %82 to i64
	store i64 %83, i64* %7
	br label %switch.done-15

switch.case.next-13:
	%84 = bitcast %runtime.Source_Code_Location* %10 to %..rawptr
	%85 = call %..rawptr @mem.zero(%..rawptr %84, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %10
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$11a, i64 0, i32 0), i64 53}, i64 849, i64 9, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$11b, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %10
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$11c, i64 0, i32 0), i64 21}, %runtime.Source_Code_Location* %10) noreturn
	br label %switch.done-15

switch.fall.body-14:
	; AssignStmt
	; SelectorExpr
	%86 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%87 = load %..rawptr, %..rawptr* %86, align 8
	%88 = bitcast %..rawptr %87 to i64*
	%89 = getelementptr inbounds i64, i64* %88, i64 0
	%90 = load i64, i64* %89, align 8
	store i64 %90, i64* %7
	br label %switch.done-15

switch.done-15:
	; et
	; SelectorExpr
	; SelectorExpr
	%91 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %6, i64 0, i32 0
	%92 = load %runtime.Type_Info*, %runtime.Type_Info** %91, align 8
	%93 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %92)
	store %runtime.Type_Info* %93, %runtime.Type_Info** %11
	; IfStmt
	%94 = load %..string, %..string* %2, align 8
	%95 = call i8 @runtime.string_ne(%..string %94, %..string zeroinitializer)
	%96 = trunc i8 %95 to i1
	br i1 %96, label %if.then-16, label %if.else-17

if.then-16:
	; SelectorExpr
	%97 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%98 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %97, i64 0
	%99 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %98, i64 0, i32 12
	%100 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %99, align 8
	%101 = load %..string, %..string* %2, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %100, %..string %101, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-18

if.else-17:
	; SelectorExpr
	%102 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%103 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %102, i64 0
	%104 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %103, i64 0, i32 12
	%105 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %104, align 8
	%106 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %105, %runtime.Type_Info* %106, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-18

if.done-18:
	; SelectorExpr
	%107 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%108 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %107, i64 0
	%109 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %108, i64 0, i32 12
	%110 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %109, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %110, i8 123, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	; e
	; is_enum
	; SelectorExpr
	%111 = load %runtime.Type_Info*, %runtime.Type_Info** %11, align 8
	%112 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %111, i64 0
	%113 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %112, i64 0, i32 3
	%114 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %113, align 8
	; cast - union_cast
	%115 = bitcast {%runtime.Type_Info_Enum, i8}* %14 to %..rawptr
	%116 = call %..rawptr @mem.zero(%..rawptr %115, i64 48) noinline
	store {%runtime.Type_Info_Enum, i8} zeroinitializer, {%runtime.Type_Info_Enum, i8}* %14
	%117 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %113, i64 0, i32 2 ; UnionTagPtr
	%118 = load i8, i8* %117, align 1
	%119 = icmp eq i8 %118, 18
	br i1 %119, label %union_cast.ok-19, label %union_cast.end-20

union_cast.ok-19:
	%120 = getelementptr inbounds {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %14, i64 0, i32 0
	%121 = getelementptr inbounds {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %14, i64 0, i32 1
	%122 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %113 to %runtime.Type_Info_Enum*
	%123 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %122, align 8
	store %runtime.Type_Info_Enum %123, %runtime.Type_Info_Enum* %120
	store i8 1, i8* %121
	br label %union_cast.end-20

union_cast.end-20:
	%124 = load {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %14, align 8
	%125 = extractvalue {%runtime.Type_Info_Enum, i8} %124, 0
	%126 = extractvalue {%runtime.Type_Info_Enum, i8} %124, 1
	store %runtime.Type_Info_Enum %125, %runtime.Type_Info_Enum* %12
	store i8 %126, i8* %13
	; commas
	store i64 0, i64* %15
	; RangeStmt
	; i
	%127 = bitcast i64* %16 to %..rawptr
	%128 = call %..rawptr @mem.zero(%..rawptr %127, i64 8) noinline
	store i64 zeroinitializer, i64* %16
	%129 = bitcast i64* %17 to %..rawptr
	%130 = call %..rawptr @mem.zero(%..rawptr %129, i64 8) noinline
	store i64 zeroinitializer, i64* %17
	store i64 0, i64* %17
	%131 = bitcast i64* %18 to %..rawptr
	%132 = call %..rawptr @mem.zero(%..rawptr %131, i64 8) noinline
	store i64 zeroinitializer, i64* %18
	store i64 0, i64* %18
	br label %for.interval.loop-21

for.interval.loop-21:
	%133 = load i64, i64* %8, align 8
	%134 = sub i64 %133, 1
	%135 = load i64, i64* %17, align 8
	%136 = icmp ule i64 %135, %134
	br i1 %136, label %for.interval.body-22, label %for.interval.done-34

for.interval.body-22:
	%137 = load i64, i64* %17, align 8
	%138 = load i64, i64* %18, align 8
	%139 = load i64, i64* %17, align 8
	%140 = add i64 %139, 1
	store i64 %140, i64* %17
	%141 = load i64, i64* %18, align 8
	%142 = add i64 %141, 1
	store i64 %142, i64* %18
	store i64 %137, i64* %16
	; IfStmt
	%143 = load i64, i64* %7, align 8
	%144 = load i64, i64* %16, align 8
	%145 = shl i64 1, %144
	%146 = and i64 %143, %145
	%147 = icmp eq i64 %146, 0
	%148 = zext i1 %147 to i8
	%149 = trunc i8 %148 to i1
	br i1 %149, label %if.then-23, label %if.done-24

if.then-23:
	; continue
	br label %for.interval.loop-21

if.done-24:
	; IfStmt
	%150 = load i64, i64* %15, align 8
	%151 = icmp sgt i64 %150, 0
	%152 = zext i1 %151 to i8
	%153 = trunc i8 %152 to i1
	br i1 %153, label %if.then-25, label %if.done-26

if.then-25:
	; SelectorExpr
	%154 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%155 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %154, i64 0
	%156 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %155, i64 0, i32 12
	%157 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %156, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %157, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$11d, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-26

if.done-26:
	; DeferStmt
	; IfStmt
	%158 = load i8, i8* %13, align 1
	%159 = trunc i8 %158 to i1
	br i1 %159, label %if.then-27, label %if.done-33

if.then-27:
	; RangeStmt
	; ev
	%160 = bitcast %runtime.Type_Info_Enum_Value* %19 to %..rawptr
	%161 = call %..rawptr @mem.zero(%..rawptr %160, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %19
	; evi
	%162 = bitcast i64* %20 to %..rawptr
	%163 = call %..rawptr @mem.zero(%..rawptr %162, i64 8) noinline
	store i64 zeroinitializer, i64* %20
	; SelectorExpr
	%164 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %12, i64 0, i32 2
	%165 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %164, align 8
	%166 = bitcast i64* %21 to %..rawptr
	%167 = call %..rawptr @mem.zero(%..rawptr %166, i64 8) noinline
	store i64 zeroinitializer, i64* %21
	%168 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %165, 1
	store i64 %168, i64* %21
	%169 = bitcast i64* %22 to %..rawptr
	%170 = call %..rawptr @mem.zero(%..rawptr %169, i64 8) noinline
	store i64 zeroinitializer, i64* %22
	store i64 -1, i64* %22
	br label %for.index.loop-28

for.index.loop-28:
	%171 = load i64, i64* %22, align 8
	%172 = add i64 %171, 1
	store i64 %172, i64* %22
	%173 = load i64, i64* %21, align 8
	%174 = icmp slt i64 %172, %173
	br i1 %174, label %for.index.body-29, label %for.index.done-32

for.index.body-29:
	%175 = load i64, i64* %22, align 8
	%176 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %165, 0
	%177 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %176, i64 %175
	%178 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %177, align 8
	store %runtime.Type_Info_Enum_Value %178, %runtime.Type_Info_Enum_Value* %19
	store i64 %175, i64* %20
	; v
	%179 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %19, align 8
	%180 = bitcast %runtime.Type_Info_Enum_Value* %24 to %..rawptr
	%181 = call %..rawptr @mem.zero(%..rawptr %180, i64 16) noinline
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %24
	store %runtime.Type_Info_Enum_Value %179, %runtime.Type_Info_Enum_Value* %24
	%182 = call i64 @fmt.enum_value_to_u64(%runtime.Type_Info_Enum_Value* %24, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %182, i64* %23
	; IfStmt
	%183 = load i64, i64* %23, align 8
	%184 = load i64, i64* %16, align 8
	%185 = icmp eq i64 %183, %184
	%186 = zext i1 %185 to i8
	%187 = trunc i8 %186 to i1
	br i1 %187, label %if.then-30, label %if.done-31

if.then-30:
	; SelectorExpr
	%188 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%189 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %188, i64 0
	%190 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %189, i64 0, i32 12
	%191 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %190, align 8
	; IndexExpr
	; SelectorExpr
	%192 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %12, i64 0, i32 1
	%193 = load {%..string*, i64}, {%..string*, i64}* %192, align 8
	%194 = extractvalue {%..string*, i64} %193, 0
	%195 = load i64, i64* %20, align 8
	%196 = extractvalue {%..string*, i64} %193, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$11e, i64 0, i32 0), i64 53}, i64 876, i64 35, i64 %195, i64 %196)
	%197 = getelementptr inbounds %..string, %..string* %194, i64 %195
	%198 = load %..string, %..string* %197, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %191, %..string %198, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; defer
	; AssignStmt
	%199 = load i64, i64* %15, align 8
	%200 = add i64 %199, 1
	store i64 %200, i64* %15
	; continue
	br label %for.interval.loop-21

if.done-31:
	br label %for.index.loop-28

for.index.done-32:
	br label %if.done-33

if.done-33:
	; SelectorExpr
	%201 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%202 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %201, i64 0
	%203 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %202, i64 0, i32 12
	%204 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %203, align 8
	%205 = load i64, i64* %16, align 8
	%206 = bitcast i64 %205 to i64
	call void @fmt.write_i64({i8*, i64, i64, %mem.Allocator}* %204, i64 %206, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; defer
	; AssignStmt
	%207 = load i64, i64* %15, align 8
	%208 = add i64 %207, 1
	store i64 %208, i64* %15
	br label %for.interval.loop-21

for.interval.done-34:
	; defer
	; SelectorExpr
	%209 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%210 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %209, i64 0
	%211 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %210, i64 0, i32 12
	%212 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %211, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %212, i8 125, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-35

typeswitch.done-35:
	ret void
}

define void @fmt.fmt_bit_field(%fmt.Fmt_Info* %fi, %..any %v, %..string %name, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca %..string, align 16
	%3 = alloca %runtime.Type_Info*, align 16
	%4 = alloca %runtime.Type_Info_Named, align 16
	%5 = alloca %..any, align 16
	%6 = alloca %runtime.Type_Info_Bit_Field, align 16
	%7 = alloca i64, align 16
	%8 = alloca %..string, align 16
	%9 = alloca i64, align 16
	%10 = alloca i64, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i64, align 16
	%16 = alloca i64, align 16
	%17 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..any %v, %..any* %1
	store %..string %name, %..string* %2
	; type_info
	; SelectorExpr
	%18 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%19 = load %..typeid, %..typeid* %18, align 8
	%20 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %19)
	store %runtime.Type_Info* %20, %runtime.Type_Info** %3
	; TypeSwitchStmt
	; SelectorExpr
	%21 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%22 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %21, i64 0
	%23 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %22, i64 0, i32 3
	%24 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %23, align 8
	; get union's tag
	%25 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %23, i64 0, i32 2 ; UnionTagPtr
	%26 = load i8, i8* %25, align 1
	%27 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %23 to %..rawptr
	%28 = icmp eq i8 %26, 1
	br i1 %28, label %typeswitch.body-2, label %typeswitch.next-1

typeswitch.next-1:
	%29 = icmp eq i8 %26, 20
	br i1 %29, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.body-2:
	%30 = bitcast %..rawptr %27 to %runtime.Type_Info_Named*
	%31 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %30, align 8
	store %runtime.Type_Info_Named %31, %runtime.Type_Info_Named* %4
	; val
	%32 = load %..any, %..any* %1, align 8
	store %..any %32, %..any* %5
	; AssignStmt
	; SelectorExpr
	%33 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	; SelectorExpr
	; SelectorExpr
	%34 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 1
	%35 = load %runtime.Type_Info*, %runtime.Type_Info** %34, align 8
	%36 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %35, i64 0
	%37 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %36, i64 0, i32 2
	%38 = load %..typeid, %..typeid* %37, align 8
	store %..typeid %38, %..typeid* %33
	%39 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%40 = load %..any, %..any* %5, align 8
	; SelectorExpr
	%41 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 0
	%42 = load %..string, %..string* %41, align 8
	call void @fmt.fmt_bit_field(%fmt.Fmt_Info* %39, %..any %40, %..string %42, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-22

typeswitch.next-3:
	store {[0 x <8 x i8>], [72 x i8], i8} %24, {[0 x <8 x i8>], [72 x i8], i8}* %17
	; SelectorExpr
	%43 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%44 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %43, i64 0
	%45 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %44, i64 0, i32 12
	%46 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %45, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %46, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$11f, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-22

typeswitch.body-4:
	%47 = bitcast %..rawptr %27 to %runtime.Type_Info_Bit_Field*
	%48 = load %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %47, align 8
	store %runtime.Type_Info_Bit_Field %48, %runtime.Type_Info_Bit_Field* %6
	; data
	store i64 0, i64* %7
	; SwitchStmt
	; SelectorExpr
	%49 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%50 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %49, i64 0
	%51 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %50, i64 0, i32 0
	%52 = load i64, i64* %51, align 8
	%53 = icmp eq i64 %52, 1
	br i1 %53, label %switch.case.body-6, label %switch.case.next-5

switch.case.next-5:
	%54 = icmp eq i64 %52, 2
	br i1 %54, label %switch.fall.body-8, label %switch.case.next-7

switch.case.body-6:
	; AssignStmt
	; SelectorExpr
	%55 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%56 = load %..rawptr, %..rawptr* %55, align 8
	%57 = bitcast %..rawptr %56 to i8*
	%58 = getelementptr inbounds i8, i8* %57, i64 0
	%59 = load i8, i8* %58, align 1
	%60 = zext i8 %59 to i64
	store i64 %60, i64* %7
	br label %switch.done-13

switch.case.next-7:
	%61 = icmp eq i64 %52, 4
	br i1 %61, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	; AssignStmt
	; SelectorExpr
	%62 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%63 = load %..rawptr, %..rawptr* %62, align 8
	%64 = bitcast %..rawptr %63 to i16*
	%65 = getelementptr inbounds i16, i16* %64, i64 0
	%66 = load i16, i16* %65, align 2
	%67 = zext i16 %66 to i64
	store i64 %67, i64* %7
	br label %switch.done-13

switch.case.next-9:
	%68 = icmp eq i64 %52, 8
	br i1 %68, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	; AssignStmt
	; SelectorExpr
	%69 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%70 = load %..rawptr, %..rawptr* %69, align 8
	%71 = bitcast %..rawptr %70 to i32*
	%72 = getelementptr inbounds i32, i32* %71, i64 0
	%73 = load i32, i32* %72, align 4
	%74 = zext i32 %73 to i64
	store i64 %74, i64* %7
	br label %switch.done-13

switch.case.next-11:
	br label %switch.done-13

switch.fall.body-12:
	; AssignStmt
	; SelectorExpr
	%75 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%76 = load %..rawptr, %..rawptr* %75, align 8
	%77 = bitcast %..rawptr %76 to i64*
	%78 = getelementptr inbounds i64, i64* %77, i64 0
	%79 = load i64, i64* %78, align 8
	store i64 %79, i64* %7
	br label %switch.done-13

switch.done-13:
	; IfStmt
	%80 = load %..string, %..string* %2, align 8
	%81 = call i8 @runtime.string_ne(%..string %80, %..string zeroinitializer)
	%82 = trunc i8 %81 to i1
	br i1 %82, label %if.then-14, label %if.else-15

if.then-14:
	; SelectorExpr
	%83 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%84 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %83, i64 0
	%85 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %84, i64 0, i32 12
	%86 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %85, align 8
	%87 = load %..string, %..string* %2, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %86, %..string %87, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%88 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%89 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %88, i64 0
	%90 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %89, i64 0, i32 12
	%91 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %90, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %91, i8 123, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-16

if.else-15:
	; SelectorExpr
	%92 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%93 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %92, i64 0
	%94 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %93, i64 0, i32 12
	%95 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %94, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %95, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$120, i64 0, i32 0), i64 10}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-16

if.done-16:
	; RangeStmt
	; name
	%96 = bitcast %..string* %8 to %..rawptr
	%97 = call %..rawptr @mem.zero(%..rawptr %96, i64 16) noinline
	store %..string zeroinitializer, %..string* %8
	; i
	%98 = bitcast i64* %9 to %..rawptr
	%99 = call %..rawptr @mem.zero(%..rawptr %98, i64 8) noinline
	store i64 zeroinitializer, i64* %9
	; SelectorExpr
	%100 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %6, i64 0, i32 0
	%101 = load {%..string*, i64}, {%..string*, i64}* %100, align 8
	%102 = bitcast i64* %10 to %..rawptr
	%103 = call %..rawptr @mem.zero(%..rawptr %102, i64 8) noinline
	store i64 zeroinitializer, i64* %10
	%104 = extractvalue {%..string*, i64} %101, 1
	store i64 %104, i64* %10
	%105 = bitcast i64* %11 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	store i64 -1, i64* %11
	br label %for.index.loop-17

for.index.loop-17:
	%107 = load i64, i64* %11, align 8
	%108 = add i64 %107, 1
	store i64 %108, i64* %11
	%109 = load i64, i64* %10, align 8
	%110 = icmp slt i64 %108, %109
	br i1 %110, label %for.index.body-18, label %for.index.done-21

for.index.body-18:
	%111 = load i64, i64* %11, align 8
	%112 = extractvalue {%..string*, i64} %101, 0
	%113 = getelementptr inbounds %..string, %..string* %112, i64 %111
	%114 = load %..string, %..string* %113, align 8
	store %..string %114, %..string* %8
	store i64 %111, i64* %9
	; IfStmt
	%115 = load i64, i64* %9, align 8
	%116 = icmp sgt i64 %115, 0
	%117 = zext i1 %116 to i8
	%118 = trunc i8 %117 to i1
	br i1 %118, label %if.then-19, label %if.done-20

if.then-19:
	; SelectorExpr
	%119 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%120 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %119, i64 0
	%121 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %120, i64 0, i32 12
	%122 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %121, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %122, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$121, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-20

if.done-20:
	; bits
	; IndexExpr
	; SelectorExpr
	%123 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %6, i64 0, i32 1
	%124 = load {i32*, i64}, {i32*, i64}* %123, align 8
	%125 = extractvalue {i32*, i64} %124, 0
	%126 = load i64, i64* %9, align 8
	%127 = extractvalue {i32*, i64} %124, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$122, i64 0, i32 0), i64 53}, i64 910, i64 26, i64 %126, i64 %127)
	%128 = getelementptr inbounds i32, i32* %125, i64 %126
	%129 = load i32, i32* %128, align 4
	%130 = sext i32 %129 to i64
	store i64 %130, i64* %12
	; offset
	; IndexExpr
	; SelectorExpr
	%131 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %6, i64 0, i32 2
	%132 = load {i32*, i64}, {i32*, i64}* %131, align 8
	%133 = extractvalue {i32*, i64} %132, 0
	%134 = load i64, i64* %9, align 8
	%135 = extractvalue {i32*, i64} %132, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$123, i64 0, i32 0), i64 53}, i64 911, i64 31, i64 %134, i64 %135)
	%136 = getelementptr inbounds i32, i32* %133, i64 %134
	%137 = load i32, i32* %136, align 4
	%138 = sext i32 %137 to i64
	store i64 %138, i64* %13
	; SelectorExpr
	%139 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%140 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %139, i64 0
	%141 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %140, i64 0, i32 12
	%142 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %141, align 8
	%143 = load %..string, %..string* %8, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %142, %..string %143, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%144 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%145 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %144, i64 0
	%146 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %145, i64 0, i32 12
	%147 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %146, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %147, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$124, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; n
	store i64 64, i64* %14
	; sa
	%148 = load i64, i64* %14, align 8
	%149 = load i64, i64* %12, align 8
	%150 = sub i64 %148, %149
	store i64 %150, i64* %15
	; u
	%151 = load i64, i64* %7, align 8
	%152 = load i64, i64* %13, align 8
	%153 = lshr i64 %151, %152
	store i64 %153, i64* %16
	; AssignStmt
	%154 = load i64, i64* %15, align 8
	%155 = load i64, i64* %16, align 8
	%156 = shl i64 %155, %154
	store i64 %156, i64* %16
	; AssignStmt
	%157 = load i64, i64* %15, align 8
	%158 = load i64, i64* %16, align 8
	%159 = lshr i64 %158, %157
	store i64 %159, i64* %16
	; SelectorExpr
	%160 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%161 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %160, i64 0
	%162 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %161, i64 0, i32 12
	%163 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %162, align 8
	%164 = load i64, i64* %16, align 8
	call void @fmt.write_u64({i8*, i64, i64, %mem.Allocator}* %163, i64 %164, i64 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-17

for.index.done-21:
	; SelectorExpr
	%165 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%166 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %165, i64 0
	%167 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %166, i64 0, i32 12
	%168 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %167, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %168, i8 125, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-22

typeswitch.done-22:
	ret void
}

define void @fmt.fmt_value(%fmt.Fmt_Info* %fi, %..any %v, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca i32, align 16
	%3 = alloca %runtime.Type_Info*, align 16
	%4 = alloca %runtime.Type_Info_Named, align 16
	%5 = alloca %runtime.Type_Info_Struct, align 16
	%6 = alloca i8, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	%10 = alloca i64, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca %runtime.Type_Info*, align 16
	%14 = alloca %..rawptr, align 16
	%15 = alloca %..any, align 16
	%16 = alloca i64, align 16
	%17 = alloca i64, align 16
	%18 = alloca %runtime.Type_Info_Bit_Set, align 16
	%19 = alloca %runtime.Type_Info_Bit_Field, align 16
	%20 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	%21 = alloca %..any, align 16
	%22 = alloca %runtime.Type_Info_Boolean, align 16
	%23 = alloca %runtime.Type_Info_Integer, align 16
	%24 = alloca %runtime.Type_Info_Rune, align 16
	%25 = alloca %runtime.Type_Info_Float, align 16
	%26 = alloca %runtime.Type_Info_Complex, align 16
	%27 = alloca %runtime.Type_Info_String, align 16
	%28 = alloca %runtime.Type_Info_Pointer, align 16
	%29 = alloca %runtime.Type_Info_Array, align 16
	%30 = alloca i64, align 16
	%31 = alloca i64, align 16
	%32 = alloca i64, align 16
	%33 = alloca i64, align 16
	%34 = alloca %..any, align 16
	%35 = alloca %runtime.Type_Info_Dynamic_Array, align 16
	%36 = alloca %mem.Raw_Dynamic_Array*, align 16
	%37 = alloca i64, align 16
	%38 = alloca i64, align 16
	%39 = alloca i64, align 16
	%40 = alloca i64, align 16
	%41 = alloca %..any, align 16
	%42 = alloca %runtime.Type_Info_Slice, align 16
	%43 = alloca %mem.Raw_Slice*, align 16
	%44 = alloca i64, align 16
	%45 = alloca i64, align 16
	%46 = alloca i64, align 16
	%47 = alloca i64, align 16
	%48 = alloca %..any, align 16
	%49 = alloca %runtime.Type_Info_Map, align 16
	%50 = alloca %mem.Raw_Map*, align 16
	%51 = alloca %mem.Raw_Dynamic_Array*, align 16
	%52 = alloca %runtime.Type_Info_Struct, align 16
	%53 = alloca %runtime.Type_Info*, align 16
	%54 = alloca {%runtime.Type_Info_Struct, i8}, align 16
	%55 = alloca %runtime.Type_Info_Dynamic_Array, align 16
	%56 = alloca %runtime.Type_Info*, align 16
	%57 = alloca {%runtime.Type_Info_Dynamic_Array, i8}, align 16
	%58 = alloca %runtime.Type_Info_Struct, align 16
	%59 = alloca {%runtime.Type_Info_Struct, i8}, align 16
	%60 = alloca i64, align 16
	%61 = alloca i64, align 16
	%62 = alloca i64, align 16
	%63 = alloca i64, align 16
	%64 = alloca i64, align 16
	%65 = alloca %runtime.Map_Entry_Header*, align 16
	%66 = alloca %fmt.Fmt_Info, align 16
	%67 = alloca %fmt.Fmt_Info, align 16
	%68 = alloca %..any, align 16
	%69 = alloca i64, align 16
	%70 = alloca %..any, align 16
	%71 = alloca %runtime.Type_Info_Struct, align 16
	%72 = alloca i8, align 16
	%73 = alloca i64, align 16
	%74 = alloca i64, align 16
	%75 = alloca i64, align 16
	%76 = alloca i64, align 16
	%77 = alloca i64, align 16
	%78 = alloca %runtime.Type_Info*, align 16
	%79 = alloca i64, align 16
	%80 = alloca %..any, align 16
	%81 = alloca %runtime.Type_Info_Union, align 16
	%82 = alloca i64, align 16
	%83 = alloca %..any, align 16
	%84 = alloca %..any, align 16
	%85 = alloca i64, align 16
	%86 = alloca i8, align 16
	%87 = alloca i8, align 16
	%88 = alloca i16, align 16
	%89 = alloca i16, align 16
	%90 = alloca i32, align 16
	%91 = alloca i32, align 16
	%92 = alloca i64, align 16
	%93 = alloca i64, align 16
	%94 = alloca %..any, align 16
	%95 = alloca %runtime.Source_Code_Location, align 16
	%96 = alloca %..typeid, align 16
	%97 = alloca %..any, align 16
	%98 = alloca %runtime.Type_Info_Enum, align 16
	%99 = alloca %runtime.Type_Info_Procedure, align 16
	%100 = alloca %..rawptr, align 16
	%101 = alloca %runtime.Type_Info_Type_Id, align 16
	%102 = alloca %..typeid, align 16
	%103 = alloca %runtime.Type_Info_Bit_Field, align 16
	%104 = alloca %runtime.Type_Info_Bit_Set, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..any %v, %..any* %1
	store i32 %verb, i32* %2
	; IfStmt
	; SelectorExpr
	%105 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%106 = load %..rawptr, %..rawptr* %105, align 8
	%107 = icmp eq %..rawptr %106, zeroinitializer
	%108 = zext i1 %107 to i8
	%109 = trunc i8 %108 to i1
	br i1 %109, label %if.then-2, label %cmp.or-1

cmp.or-1:
	; SelectorExpr
	%110 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%111 = load %..typeid, %..typeid* %110, align 8
	%112 = icmp eq %..typeid %111, 0
	%113 = zext i1 %112 to i8
	%114 = trunc i8 %113 to i1
	br i1 %114, label %if.then-2, label %if.done-3

if.then-2:
	; SelectorExpr
	%115 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%116 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %115, i64 0
	%117 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %116, i64 0, i32 12
	%118 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %117, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %118, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$125, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-3:
	; type_info
	; SelectorExpr
	%119 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%120 = load %..typeid, %..typeid* %119, align 8
	%121 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %120)
	store %runtime.Type_Info* %121, %runtime.Type_Info** %3
	; TypeSwitchStmt
	; SelectorExpr
	%122 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%123 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %122, i64 0
	%124 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %123, i64 0, i32 3
	%125 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %124, align 8
	; get union's tag
	%126 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %124, i64 0, i32 2 ; UnionTagPtr
	%127 = load i8, i8* %126, align 1
	%128 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %124 to %..rawptr
	%129 = icmp eq i8 %127, 1
	br i1 %129, label %typeswitch.body-5, label %typeswitch.next-4

typeswitch.next-4:
	%130 = icmp eq i8 %127, 7
	br i1 %130, label %typeswitch.body-41, label %typeswitch.next-40

typeswitch.body-5:
	%131 = bitcast %..rawptr %128 to %runtime.Type_Info_Named*
	%132 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %131, align 8
	store %runtime.Type_Info_Named %132, %runtime.Type_Info_Named* %4
	; TypeSwitchStmt
	; SelectorExpr
	; SelectorExpr
	%133 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 1
	%134 = load %runtime.Type_Info*, %runtime.Type_Info** %133, align 8
	%135 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %134, i64 0
	%136 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %135, i64 0, i32 3
	%137 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %136, align 8
	; get union's tag
	%138 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %136, i64 0, i32 2 ; UnionTagPtr
	%139 = load i8, i8* %138, align 1
	%140 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %136 to %..rawptr
	%141 = icmp eq i8 %139, 16
	br i1 %141, label %typeswitch.body-7, label %typeswitch.next-6

typeswitch.next-6:
	%142 = icmp eq i8 %139, 21
	br i1 %142, label %typeswitch.body-36, label %typeswitch.next-35

typeswitch.body-7:
	%143 = bitcast %..rawptr %140 to %runtime.Type_Info_Struct*
	%144 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %143, align 8
	store %runtime.Type_Info_Struct %144, %runtime.Type_Info_Struct* %5
	; IfStmt
	%145 = load i32, i32* %2, align 4
	%146 = icmp ne i32 %145, 118
	%147 = zext i1 %146 to i8
	%148 = trunc i8 %147 to i1
	br i1 %148, label %if.then-8, label %if.done-9

if.then-8:
	%149 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%150 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %149, i32 %150, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-9:
	; IfStmt
	; SelectorExpr
	%151 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %5, i64 0, i32 5
	%152 = load i8, i8* %151, align 1
	%153 = trunc i8 %152 to i1
	br i1 %153, label %if.then-10, label %if.done-11

if.then-10:
	; SelectorExpr
	%154 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%155 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %154, i64 0
	%156 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %155, i64 0, i32 12
	%157 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %156, align 8
	; SelectorExpr
	%158 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 0
	%159 = load %..string, %..string* %158, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %157, %..string %159, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%160 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%161 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %160, i64 0
	%162 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %161, i64 0, i32 12
	%163 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %162, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %163, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$126, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-11:
	; SelectorExpr
	%164 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%165 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %164, i64 0
	%166 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %165, i64 0, i32 12
	%167 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %166, align 8
	; SelectorExpr
	%168 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 0
	%169 = load %..string, %..string* %168, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %167, %..string %169, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%170 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%171 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %170, i64 0
	%172 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %171, i64 0, i32 12
	%173 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %172, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %173, i8 123, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; hash
	; SelectorExpr
	%174 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%175 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %174, i64 0
	%176 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %175, i64 0, i32 4
	%177 = load i8, i8* %176, align 1
	store i8 %177, i8* %6
	; DeferStmt
	; indent
	; SelectorExpr
	%178 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%179 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %178, i64 0
	%180 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %179, i64 0, i32 9
	%181 = load i64, i64* %180, align 8
	store i64 %181, i64* %7
	; DeferStmt
	; AssignStmt
	; SelectorExpr
	%182 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%183 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %182, i64 0
	%184 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %183, i64 0, i32 4
	store i8 0, i8* %184
	; AssignStmt
	; SelectorExpr
	%185 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%186 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %185, i64 0
	%187 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %186, i64 0, i32 9
	%188 = load i64, i64* %187, align 8
	%189 = add i64 %188, 1
	store i64 %189, i64* %187
	; IfStmt
	%190 = load i8, i8* %6, align 1
	%191 = trunc i8 %190 to i1
	br i1 %191, label %if.then-12, label %if.done-13

if.then-12:
	; SelectorExpr
	%192 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%193 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %192, i64 0
	%194 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %193, i64 0, i32 12
	%195 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %194, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %195, i8 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-13

if.done-13:
	; RangeStmt
	; i
	%196 = bitcast i64* %8 to %..rawptr
	%197 = call %..rawptr @mem.zero(%..rawptr %196, i64 8) noinline
	store i64 zeroinitializer, i64* %8
	; SelectorExpr
	%198 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %5, i64 0, i32 1
	%199 = load {%..string*, i64}, {%..string*, i64}* %198, align 8
	%200 = bitcast i64* %9 to %..rawptr
	%201 = call %..rawptr @mem.zero(%..rawptr %200, i64 8) noinline
	store i64 zeroinitializer, i64* %9
	%202 = extractvalue {%..string*, i64} %199, 1
	store i64 %202, i64* %9
	%203 = bitcast i64* %10 to %..rawptr
	%204 = call %..rawptr @mem.zero(%..rawptr %203, i64 8) noinline
	store i64 zeroinitializer, i64* %10
	store i64 -1, i64* %10
	br label %for.index.loop-14

for.index.loop-14:
	%205 = load i64, i64* %10, align 8
	%206 = add i64 %205, 1
	store i64 %206, i64* %10
	%207 = load i64, i64* %9, align 8
	%208 = icmp slt i64 %206, %207
	br i1 %208, label %for.index.body-15, label %for.index.done-29

for.index.body-15:
	%209 = load i64, i64* %10, align 8
	store i64 %209, i64* %8
	; IfStmt
	%210 = load i8, i8* %6, align 1
	%211 = trunc i8 %210 to i1
	br i1 %211, label %if.done-18, label %cmp.and-16

cmp.and-16:
	%212 = load i64, i64* %8, align 8
	%213 = icmp sgt i64 %212, 0
	%214 = zext i1 %213 to i8
	%215 = trunc i8 %214 to i1
	br i1 %215, label %if.then-17, label %if.done-18

if.then-17:
	; SelectorExpr
	%216 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%217 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %216, i64 0
	%218 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %217, i64 0, i32 12
	%219 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %218, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %219, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$127, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-18

if.done-18:
	; IfStmt
	%220 = load i8, i8* %6, align 1
	%221 = trunc i8 %220 to i1
	br i1 %221, label %if.then-19, label %if.done-23

if.then-19:
	; RangeStmt
	%222 = bitcast i64* %11 to %..rawptr
	%223 = call %..rawptr @mem.zero(%..rawptr %222, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	store i64 0, i64* %11
	%224 = bitcast i64* %12 to %..rawptr
	%225 = call %..rawptr @mem.zero(%..rawptr %224, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	store i64 0, i64* %12
	br label %for.interval.loop-20

for.interval.loop-20:
	; SelectorExpr
	%226 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%227 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %226, i64 0
	%228 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %227, i64 0, i32 9
	%229 = load i64, i64* %228, align 8
	%230 = sub i64 %229, 1
	%231 = load i64, i64* %11, align 8
	%232 = icmp sle i64 %231, %230
	br i1 %232, label %for.interval.body-21, label %for.interval.done-22

for.interval.body-21:
	%233 = load i64, i64* %11, align 8
	%234 = load i64, i64* %12, align 8
	%235 = load i64, i64* %11, align 8
	%236 = add i64 %235, 1
	store i64 %236, i64* %11
	%237 = load i64, i64* %12, align 8
	%238 = add i64 %237, 1
	store i64 %238, i64* %12
	; SelectorExpr
	%239 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%240 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %239, i64 0
	%241 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %240, i64 0, i32 12
	%242 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %241, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %242, i8 9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-20

for.interval.done-22:
	br label %if.done-23

if.done-23:
	; SelectorExpr
	%243 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%244 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %243, i64 0
	%245 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %244, i64 0, i32 12
	%246 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %245, align 8
	; IndexExpr
	; SelectorExpr
	%247 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %5, i64 0, i32 1
	%248 = load {%..string*, i64}, {%..string*, i64}* %247, align 8
	%249 = extractvalue {%..string*, i64} %248, 0
	%250 = load i64, i64* %8, align 8
	%251 = extractvalue {%..string*, i64} %248, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$128, i64 0, i32 0), i64 53}, i64 965, i64 34, i64 %250, i64 %251)
	%252 = getelementptr inbounds %..string, %..string* %249, i64 %250
	%253 = load %..string, %..string* %252, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %246, %..string %253, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%254 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%255 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %254, i64 0
	%256 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %255, i64 0, i32 12
	%257 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %256, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %257, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$129, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; t
	; IndexExpr
	; SelectorExpr
	%258 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %5, i64 0, i32 0
	%259 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %258, align 8
	%260 = extractvalue {%runtime.Type_Info**, i64} %259, 0
	%261 = load i64, i64* %8, align 8
	%262 = extractvalue {%runtime.Type_Info**, i64} %259, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$12a, i64 0, i32 0), i64 53}, i64 968, i64 21, i64 %261, i64 %262)
	%263 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %260, i64 %261
	%264 = load %runtime.Type_Info*, %runtime.Type_Info** %263, align 8
	store %runtime.Type_Info* %264, %runtime.Type_Info** %13
	; SelectorExpr
	%265 = load %runtime.Type_Info*, %runtime.Type_Info** %13, align 8
	%266 = call i8 @types.is_any(%runtime.Type_Info* %265, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%267 = trunc i8 %266 to i1
	br i1 %267, label %if.then-24, label %if.else-25

if.then-24:
	; SelectorExpr
	%268 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%269 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %268, i64 0
	%270 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %269, i64 0, i32 12
	%271 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %270, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %271, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$12b, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-26

if.else-25:
	; data
	; SelectorExpr
	%272 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%273 = load %..rawptr, %..rawptr* %272, align 8
	%274 = ptrtoint %..rawptr %273 to i64
	; IndexExpr
	; SelectorExpr
	%275 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %5, i64 0, i32 2
	%276 = load {i64*, i64}, {i64*, i64}* %275, align 8
	%277 = extractvalue {i64*, i64} %276, 0
	%278 = load i64, i64* %8, align 8
	%279 = extractvalue {i64*, i64} %276, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$12c, i64 0, i32 0), i64 53}, i64 971, i64 49, i64 %278, i64 %279)
	%280 = getelementptr inbounds i64, i64* %277, i64 %278
	%281 = load i64, i64* %280, align 8
	%282 = add i64 %274, %281
	%283 = inttoptr i64 %282 to %..rawptr
	store %..rawptr %283, %..rawptr* %14
	%284 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%285 = bitcast %..any* %15 to %..rawptr
	%286 = call %..rawptr @mem.zero(%..rawptr %285, i64 16) noinline
	store %..any zeroinitializer, %..any* %15
	store %..any zeroinitializer, %..any* %15
	%287 = load %..rawptr, %..rawptr* %14, align 8
	%288 = getelementptr inbounds %..any, %..any* %15, i64 0, i32 0
	store %..rawptr %287, %..rawptr* %288
	; SelectorExpr
	%289 = load %runtime.Type_Info*, %runtime.Type_Info** %13, align 8
	%290 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %289, i64 0
	%291 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %290, i64 0, i32 2
	%292 = load %..typeid, %..typeid* %291, align 8
	%293 = getelementptr inbounds %..any, %..any* %15, i64 0, i32 1
	store %..typeid %292, %..typeid* %293
	%294 = load %..any, %..any* %15, align 8
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %284, %..any %294, i32 118, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-26

if.done-26:
	; IfStmt
	%295 = load i8, i8* %6, align 1
	%296 = trunc i8 %295 to i1
	br i1 %296, label %if.then-27, label %if.done-28

if.then-27:
	; SelectorExpr
	%297 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%298 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %297, i64 0
	%299 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %298, i64 0, i32 12
	%300 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %299, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %300, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$12d, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-28

if.done-28:
	br label %for.index.loop-14

for.index.done-29:
	; IfStmt
	%301 = load i8, i8* %6, align 1
	%302 = trunc i8 %301 to i1
	br i1 %302, label %if.then-30, label %if.done-34

if.then-30:
	; RangeStmt
	%303 = bitcast i64* %16 to %..rawptr
	%304 = call %..rawptr @mem.zero(%..rawptr %303, i64 8) noinline
	store i64 zeroinitializer, i64* %16
	store i64 0, i64* %16
	%305 = bitcast i64* %17 to %..rawptr
	%306 = call %..rawptr @mem.zero(%..rawptr %305, i64 8) noinline
	store i64 zeroinitializer, i64* %17
	store i64 0, i64* %17
	br label %for.interval.loop-31

for.interval.loop-31:
	%307 = load i64, i64* %7, align 8
	%308 = sub i64 %307, 1
	%309 = load i64, i64* %16, align 8
	%310 = icmp sle i64 %309, %308
	br i1 %310, label %for.interval.body-32, label %for.interval.done-33

for.interval.body-32:
	%311 = load i64, i64* %16, align 8
	%312 = load i64, i64* %17, align 8
	%313 = load i64, i64* %16, align 8
	%314 = add i64 %313, 1
	store i64 %314, i64* %16
	%315 = load i64, i64* %17, align 8
	%316 = add i64 %315, 1
	store i64 %316, i64* %17
	; SelectorExpr
	%317 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%318 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %317, i64 0
	%319 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %318, i64 0, i32 12
	%320 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %319, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %320, i8 9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-31

for.interval.done-33:
	br label %if.done-34

if.done-34:
	; SelectorExpr
	%321 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%322 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %321, i64 0
	%323 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %322, i64 0, i32 12
	%324 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %323, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %324, i8 125, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; defer
	; AssignStmt
	; SelectorExpr
	%325 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%326 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %325, i64 0
	%327 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %326, i64 0, i32 9
	%328 = load i64, i64* %327, align 8
	%329 = sub i64 %328, 1
	store i64 %329, i64* %327
	; defer
	; AssignStmt
	; SelectorExpr
	%330 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%331 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %330, i64 0
	%332 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %331, i64 0, i32 4
	%333 = load i8, i8* %6, align 1
	store i8 %333, i8* %332
	br label %typeswitch.done-39

typeswitch.next-35:
	%334 = icmp eq i8 %139, 20
	br i1 %334, label %typeswitch.body-38, label %typeswitch.next-37

typeswitch.body-36:
	%335 = bitcast %..rawptr %140 to %runtime.Type_Info_Bit_Set*
	%336 = load %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %335, align 8
	store %runtime.Type_Info_Bit_Set %336, %runtime.Type_Info_Bit_Set* %18
	%337 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%338 = load %..any, %..any* %1, align 8
	call void @fmt.fmt_bit_set(%fmt.Fmt_Info* %337, %..any %338, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-39

typeswitch.next-37:
	store {[0 x <8 x i8>], [72 x i8], i8} %137, {[0 x <8 x i8>], [72 x i8], i8}* %20
	%339 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%340 = bitcast %..any* %21 to %..rawptr
	%341 = call %..rawptr @mem.zero(%..rawptr %340, i64 16) noinline
	store %..any zeroinitializer, %..any* %21
	store %..any zeroinitializer, %..any* %21
	; SelectorExpr
	%342 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%343 = load %..rawptr, %..rawptr* %342, align 8
	%344 = getelementptr inbounds %..any, %..any* %21, i64 0, i32 0
	store %..rawptr %343, %..rawptr* %344
	; SelectorExpr
	; SelectorExpr
	%345 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i64 0, i32 1
	%346 = load %runtime.Type_Info*, %runtime.Type_Info** %345, align 8
	%347 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %346, i64 0
	%348 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %347, i64 0, i32 2
	%349 = load %..typeid, %..typeid* %348, align 8
	%350 = getelementptr inbounds %..any, %..any* %21, i64 0, i32 1
	store %..typeid %349, %..typeid* %350
	%351 = load %..any, %..any* %21, align 8
	%352 = load i32, i32* %2, align 4
	call void @fmt.fmt_value(%fmt.Fmt_Info* %339, %..any %351, i32 %352, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-39

typeswitch.body-38:
	%353 = bitcast %..rawptr %140 to %runtime.Type_Info_Bit_Field*
	%354 = load %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %353, align 8
	store %runtime.Type_Info_Bit_Field %354, %runtime.Type_Info_Bit_Field* %19
	%355 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%356 = load %..any, %..any* %1, align 8
	call void @fmt.fmt_bit_field(%fmt.Fmt_Info* %355, %..any %356, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-39

typeswitch.done-39:
	br label %typeswitch.done-158

typeswitch.next-40:
	%357 = icmp eq i8 %127, 2
	br i1 %357, label %typeswitch.body-43, label %typeswitch.next-42

typeswitch.body-41:
	%358 = bitcast %..rawptr %128 to %runtime.Type_Info_Boolean*
	%359 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %358, align 1
	store %runtime.Type_Info_Boolean %359, %runtime.Type_Info_Boolean* %22
	%360 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%361 = load %..any, %..any* %1, align 8
	%362 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %360, %..any %361, i32 %362, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-42:
	%363 = icmp eq i8 %127, 3
	br i1 %363, label %typeswitch.body-45, label %typeswitch.next-44

typeswitch.body-43:
	%364 = bitcast %..rawptr %128 to %runtime.Type_Info_Integer*
	%365 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %364, align 1
	store %runtime.Type_Info_Integer %365, %runtime.Type_Info_Integer* %23
	%366 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%367 = load %..any, %..any* %1, align 8
	%368 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %366, %..any %367, i32 %368, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-44:
	%369 = icmp eq i8 %127, 4
	br i1 %369, label %typeswitch.body-47, label %typeswitch.next-46

typeswitch.body-45:
	%370 = bitcast %..rawptr %128 to %runtime.Type_Info_Rune*
	%371 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %370, align 1
	store %runtime.Type_Info_Rune %371, %runtime.Type_Info_Rune* %24
	%372 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%373 = load %..any, %..any* %1, align 8
	%374 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %372, %..any %373, i32 %374, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-46:
	%375 = icmp eq i8 %127, 5
	br i1 %375, label %typeswitch.body-49, label %typeswitch.next-48

typeswitch.body-47:
	%376 = bitcast %..rawptr %128 to %runtime.Type_Info_Float*
	%377 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %376, align 1
	store %runtime.Type_Info_Float %377, %runtime.Type_Info_Float* %25
	%378 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%379 = load %..any, %..any* %1, align 8
	%380 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %378, %..any %379, i32 %380, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-48:
	%381 = icmp eq i8 %127, 6
	br i1 %381, label %typeswitch.body-51, label %typeswitch.next-50

typeswitch.body-49:
	%382 = bitcast %..rawptr %128 to %runtime.Type_Info_Complex*
	%383 = load %runtime.Type_Info_Complex, %runtime.Type_Info_Complex* %382, align 1
	store %runtime.Type_Info_Complex %383, %runtime.Type_Info_Complex* %26
	%384 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%385 = load %..any, %..any* %1, align 8
	%386 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %384, %..any %385, i32 %386, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-50:
	%387 = icmp eq i8 %127, 10
	br i1 %387, label %typeswitch.body-53, label %typeswitch.next-52

typeswitch.body-51:
	%388 = bitcast %..rawptr %128 to %runtime.Type_Info_String*
	%389 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %388, align 1
	store %runtime.Type_Info_String %389, %runtime.Type_Info_String* %27
	%390 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%391 = load %..any, %..any* %1, align 8
	%392 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %390, %..any %391, i32 %392, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-52:
	%393 = icmp eq i8 %127, 12
	br i1 %393, label %typeswitch.body-58, label %typeswitch.next-57

typeswitch.body-53:
	%394 = bitcast %..rawptr %128 to %runtime.Type_Info_Pointer*
	%395 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %394, align 8
	store %runtime.Type_Info_Pointer %395, %runtime.Type_Info_Pointer* %28
	; IfStmt
	; SelectorExpr
	%396 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%397 = load %..typeid, %..typeid* %396, align 8
	%398 = icmp eq %..typeid %397, 648518346341351433
	%399 = zext i1 %398 to i8
	%400 = trunc i8 %399 to i1
	br i1 %400, label %if.then-54, label %if.else-55

if.then-54:
	; SelectorExpr
	%401 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%402 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %401, i64 0
	%403 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %402, i64 0, i32 12
	%404 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %403, align 8
	; SelectorExpr
	%405 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%406 = load %..rawptr, %..rawptr* %405, align 8
	%407 = bitcast %..rawptr %406 to %runtime.Type_Info**
	%408 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %407, i64 0
	%409 = load %runtime.Type_Info*, %runtime.Type_Info** %408, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %404, %runtime.Type_Info* %409, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-56

if.else-55:
	%410 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; SelectorExpr
	%411 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%412 = load %..rawptr, %..rawptr* %411, align 8
	%413 = bitcast %..rawptr %412 to %..rawptr*
	%414 = getelementptr inbounds %..rawptr, %..rawptr* %413, i64 0
	%415 = load %..rawptr, %..rawptr* %414, align 8
	%416 = load i32, i32* %2, align 4
	call void @fmt.fmt_pointer(%fmt.Fmt_Info* %410, %..rawptr %415, i32 %416, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-56

if.done-56:
	br label %typeswitch.done-158

typeswitch.next-57:
	%417 = icmp eq i8 %127, 13
	br i1 %417, label %typeswitch.body-65, label %typeswitch.next-64

typeswitch.body-58:
	%418 = bitcast %..rawptr %128 to %runtime.Type_Info_Array*
	%419 = load %runtime.Type_Info_Array, %runtime.Type_Info_Array* %418, align 8
	store %runtime.Type_Info_Array %419, %runtime.Type_Info_Array* %29
	; SelectorExpr
	%420 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%421 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %420, i64 0
	%422 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %421, i64 0, i32 12
	%423 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %422, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %423, i8 91, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	; RangeStmt
	; i
	%424 = bitcast i64* %30 to %..rawptr
	%425 = call %..rawptr @mem.zero(%..rawptr %424, i64 8) noinline
	store i64 zeroinitializer, i64* %30
	%426 = bitcast i64* %31 to %..rawptr
	%427 = call %..rawptr @mem.zero(%..rawptr %426, i64 8) noinline
	store i64 zeroinitializer, i64* %31
	store i64 0, i64* %31
	%428 = bitcast i64* %32 to %..rawptr
	%429 = call %..rawptr @mem.zero(%..rawptr %428, i64 8) noinline
	store i64 zeroinitializer, i64* %32
	store i64 0, i64* %32
	br label %for.interval.loop-59

for.interval.loop-59:
	; SelectorExpr
	%430 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %29, i64 0, i32 2
	%431 = load i64, i64* %430, align 8
	%432 = sub i64 %431, 1
	%433 = load i64, i64* %31, align 8
	%434 = icmp sle i64 %433, %432
	br i1 %434, label %for.interval.body-60, label %for.interval.done-63

for.interval.body-60:
	%435 = load i64, i64* %31, align 8
	%436 = load i64, i64* %32, align 8
	%437 = load i64, i64* %31, align 8
	%438 = add i64 %437, 1
	store i64 %438, i64* %31
	%439 = load i64, i64* %32, align 8
	%440 = add i64 %439, 1
	store i64 %440, i64* %32
	store i64 %435, i64* %30
	; IfStmt
	%441 = load i64, i64* %30, align 8
	%442 = icmp sgt i64 %441, 0
	%443 = zext i1 %442 to i8
	%444 = trunc i8 %443 to i1
	br i1 %444, label %if.then-61, label %if.done-62

if.then-61:
	; SelectorExpr
	%445 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%446 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %445, i64 0
	%447 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %446, i64 0, i32 12
	%448 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %447, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %448, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$12e, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-62

if.done-62:
	; data
	; SelectorExpr
	%449 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%450 = load %..rawptr, %..rawptr* %449, align 8
	%451 = ptrtoint %..rawptr %450 to i64
	%452 = load i64, i64* %30, align 8
	; SelectorExpr
	%453 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %29, i64 0, i32 1
	%454 = load i64, i64* %453, align 8
	%455 = mul i64 %452, %454
	%456 = bitcast i64 %455 to i64
	%457 = add i64 %451, %456
	store i64 %457, i64* %33
	%458 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%459 = bitcast %..any* %34 to %..rawptr
	%460 = call %..rawptr @mem.zero(%..rawptr %459, i64 16) noinline
	store %..any zeroinitializer, %..any* %34
	store %..any zeroinitializer, %..any* %34
	%461 = load i64, i64* %33, align 8
	%462 = inttoptr i64 %461 to %..rawptr
	%463 = getelementptr inbounds %..any, %..any* %34, i64 0, i32 0
	store %..rawptr %462, %..rawptr* %463
	; SelectorExpr
	; SelectorExpr
	%464 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %29, i64 0, i32 0
	%465 = load %runtime.Type_Info*, %runtime.Type_Info** %464, align 8
	%466 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %465, i64 0
	%467 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %466, i64 0, i32 2
	%468 = load %..typeid, %..typeid* %467, align 8
	%469 = getelementptr inbounds %..any, %..any* %34, i64 0, i32 1
	store %..typeid %468, %..typeid* %469
	%470 = load %..any, %..any* %34, align 8
	%471 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %458, %..any %470, i32 %471, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-59

for.interval.done-63:
	; defer
	; SelectorExpr
	%472 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%473 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %472, i64 0
	%474 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %473, i64 0, i32 12
	%475 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %474, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %475, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-64:
	%476 = icmp eq i8 %127, 14
	br i1 %476, label %typeswitch.body-72, label %typeswitch.next-71

typeswitch.body-65:
	%477 = bitcast %..rawptr %128 to %runtime.Type_Info_Dynamic_Array*
	%478 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %477, align 8
	store %runtime.Type_Info_Dynamic_Array %478, %runtime.Type_Info_Dynamic_Array* %35
	; SelectorExpr
	%479 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%480 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %479, i64 0
	%481 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %480, i64 0, i32 12
	%482 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %481, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %482, i8 91, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	; array
	; SelectorExpr
	%483 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%484 = load %..rawptr, %..rawptr* %483, align 8
	%485 = bitcast %..rawptr %484 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %485, %mem.Raw_Dynamic_Array** %36
	; RangeStmt
	; i
	%486 = bitcast i64* %37 to %..rawptr
	%487 = call %..rawptr @mem.zero(%..rawptr %486, i64 8) noinline
	store i64 zeroinitializer, i64* %37
	%488 = bitcast i64* %38 to %..rawptr
	%489 = call %..rawptr @mem.zero(%..rawptr %488, i64 8) noinline
	store i64 zeroinitializer, i64* %38
	store i64 0, i64* %38
	%490 = bitcast i64* %39 to %..rawptr
	%491 = call %..rawptr @mem.zero(%..rawptr %490, i64 8) noinline
	store i64 zeroinitializer, i64* %39
	store i64 0, i64* %39
	br label %for.interval.loop-66

for.interval.loop-66:
	; SelectorExpr
	%492 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %36, align 8
	%493 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %492, i64 0
	%494 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %493, i64 0, i32 1
	%495 = load i64, i64* %494, align 8
	%496 = sub i64 %495, 1
	%497 = load i64, i64* %38, align 8
	%498 = icmp sle i64 %497, %496
	br i1 %498, label %for.interval.body-67, label %for.interval.done-70

for.interval.body-67:
	%499 = load i64, i64* %38, align 8
	%500 = load i64, i64* %39, align 8
	%501 = load i64, i64* %38, align 8
	%502 = add i64 %501, 1
	store i64 %502, i64* %38
	%503 = load i64, i64* %39, align 8
	%504 = add i64 %503, 1
	store i64 %504, i64* %39
	store i64 %499, i64* %37
	; IfStmt
	%505 = load i64, i64* %37, align 8
	%506 = icmp sgt i64 %505, 0
	%507 = zext i1 %506 to i8
	%508 = trunc i8 %507 to i1
	br i1 %508, label %if.then-68, label %if.done-69

if.then-68:
	; SelectorExpr
	%509 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%510 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %509, i64 0
	%511 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %510, i64 0, i32 12
	%512 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %511, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %512, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$12f, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-69

if.done-69:
	; data
	; SelectorExpr
	%513 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %36, align 8
	%514 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %513, i64 0
	%515 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %514, i64 0, i32 0
	%516 = load %..rawptr, %..rawptr* %515, align 8
	%517 = ptrtoint %..rawptr %516 to i64
	%518 = load i64, i64* %37, align 8
	; SelectorExpr
	%519 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %35, i64 0, i32 1
	%520 = load i64, i64* %519, align 8
	%521 = mul i64 %518, %520
	%522 = bitcast i64 %521 to i64
	%523 = add i64 %517, %522
	store i64 %523, i64* %40
	%524 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%525 = bitcast %..any* %41 to %..rawptr
	%526 = call %..rawptr @mem.zero(%..rawptr %525, i64 16) noinline
	store %..any zeroinitializer, %..any* %41
	store %..any zeroinitializer, %..any* %41
	%527 = load i64, i64* %40, align 8
	%528 = inttoptr i64 %527 to %..rawptr
	%529 = getelementptr inbounds %..any, %..any* %41, i64 0, i32 0
	store %..rawptr %528, %..rawptr* %529
	; SelectorExpr
	; SelectorExpr
	%530 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %35, i64 0, i32 0
	%531 = load %runtime.Type_Info*, %runtime.Type_Info** %530, align 8
	%532 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %531, i64 0
	%533 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %532, i64 0, i32 2
	%534 = load %..typeid, %..typeid* %533, align 8
	%535 = getelementptr inbounds %..any, %..any* %41, i64 0, i32 1
	store %..typeid %534, %..typeid* %535
	%536 = load %..any, %..any* %41, align 8
	%537 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %524, %..any %536, i32 %537, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-66

for.interval.done-70:
	; defer
	; SelectorExpr
	%538 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%539 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %538, i64 0
	%540 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %539, i64 0, i32 12
	%541 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %540, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %541, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-71:
	%542 = icmp eq i8 %127, 19
	br i1 %542, label %typeswitch.body-79, label %typeswitch.next-78

typeswitch.body-72:
	%543 = bitcast %..rawptr %128 to %runtime.Type_Info_Slice*
	%544 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %543, align 8
	store %runtime.Type_Info_Slice %544, %runtime.Type_Info_Slice* %42
	; SelectorExpr
	%545 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%546 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %545, i64 0
	%547 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %546, i64 0, i32 12
	%548 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %547, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %548, i8 91, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	; slice
	; SelectorExpr
	%549 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%550 = load %..rawptr, %..rawptr* %549, align 8
	%551 = bitcast %..rawptr %550 to %mem.Raw_Slice*
	store %mem.Raw_Slice* %551, %mem.Raw_Slice** %43
	; RangeStmt
	; i
	%552 = bitcast i64* %44 to %..rawptr
	%553 = call %..rawptr @mem.zero(%..rawptr %552, i64 8) noinline
	store i64 zeroinitializer, i64* %44
	%554 = bitcast i64* %45 to %..rawptr
	%555 = call %..rawptr @mem.zero(%..rawptr %554, i64 8) noinline
	store i64 zeroinitializer, i64* %45
	store i64 0, i64* %45
	%556 = bitcast i64* %46 to %..rawptr
	%557 = call %..rawptr @mem.zero(%..rawptr %556, i64 8) noinline
	store i64 zeroinitializer, i64* %46
	store i64 0, i64* %46
	br label %for.interval.loop-73

for.interval.loop-73:
	; SelectorExpr
	%558 = load %mem.Raw_Slice*, %mem.Raw_Slice** %43, align 8
	%559 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %558, i64 0
	%560 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %559, i64 0, i32 1
	%561 = load i64, i64* %560, align 8
	%562 = sub i64 %561, 1
	%563 = load i64, i64* %45, align 8
	%564 = icmp sle i64 %563, %562
	br i1 %564, label %for.interval.body-74, label %for.interval.done-77

for.interval.body-74:
	%565 = load i64, i64* %45, align 8
	%566 = load i64, i64* %46, align 8
	%567 = load i64, i64* %45, align 8
	%568 = add i64 %567, 1
	store i64 %568, i64* %45
	%569 = load i64, i64* %46, align 8
	%570 = add i64 %569, 1
	store i64 %570, i64* %46
	store i64 %565, i64* %44
	; IfStmt
	%571 = load i64, i64* %44, align 8
	%572 = icmp sgt i64 %571, 0
	%573 = zext i1 %572 to i8
	%574 = trunc i8 %573 to i1
	br i1 %574, label %if.then-75, label %if.done-76

if.then-75:
	; SelectorExpr
	%575 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%576 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %575, i64 0
	%577 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %576, i64 0, i32 12
	%578 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %577, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %578, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$130, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-76

if.done-76:
	; data
	; SelectorExpr
	%579 = load %mem.Raw_Slice*, %mem.Raw_Slice** %43, align 8
	%580 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %579, i64 0
	%581 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %580, i64 0, i32 0
	%582 = load %..rawptr, %..rawptr* %581, align 8
	%583 = ptrtoint %..rawptr %582 to i64
	%584 = load i64, i64* %44, align 8
	; SelectorExpr
	%585 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %42, i64 0, i32 1
	%586 = load i64, i64* %585, align 8
	%587 = mul i64 %584, %586
	%588 = bitcast i64 %587 to i64
	%589 = add i64 %583, %588
	store i64 %589, i64* %47
	%590 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%591 = bitcast %..any* %48 to %..rawptr
	%592 = call %..rawptr @mem.zero(%..rawptr %591, i64 16) noinline
	store %..any zeroinitializer, %..any* %48
	store %..any zeroinitializer, %..any* %48
	%593 = load i64, i64* %47, align 8
	%594 = inttoptr i64 %593 to %..rawptr
	%595 = getelementptr inbounds %..any, %..any* %48, i64 0, i32 0
	store %..rawptr %594, %..rawptr* %595
	; SelectorExpr
	; SelectorExpr
	%596 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %42, i64 0, i32 0
	%597 = load %runtime.Type_Info*, %runtime.Type_Info** %596, align 8
	%598 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %597, i64 0
	%599 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %598, i64 0, i32 2
	%600 = load %..typeid, %..typeid* %599, align 8
	%601 = getelementptr inbounds %..any, %..any* %48, i64 0, i32 1
	store %..typeid %600, %..typeid* %601
	%602 = load %..any, %..any* %48, align 8
	%603 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %590, %..any %602, i32 %603, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-73

for.interval.done-77:
	; defer
	; SelectorExpr
	%604 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%605 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %604, i64 0
	%606 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %605, i64 0, i32 12
	%607 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %606, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %607, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-78:
	%608 = icmp eq i8 %127, 16
	br i1 %608, label %typeswitch.body-101, label %typeswitch.next-100

typeswitch.body-79:
	%609 = bitcast %..rawptr %128 to %runtime.Type_Info_Map*
	%610 = load %runtime.Type_Info_Map, %runtime.Type_Info_Map* %609, align 8
	store %runtime.Type_Info_Map %610, %runtime.Type_Info_Map* %49
	; IfStmt
	%611 = load i32, i32* %2, align 4
	%612 = icmp ne i32 %611, 118
	%613 = zext i1 %612 to i8
	%614 = trunc i8 %613 to i1
	br i1 %614, label %if.then-80, label %if.done-81

if.then-80:
	%615 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%616 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %615, i32 %616, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-81:
	; SelectorExpr
	%617 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%618 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %617, i64 0
	%619 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %618, i64 0, i32 12
	%620 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %619, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %620, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$131, i64 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	; m
	; SelectorExpr
	%621 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%622 = load %..rawptr, %..rawptr* %621, align 8
	%623 = bitcast %..rawptr %622 to %mem.Raw_Map*
	store %mem.Raw_Map* %623, %mem.Raw_Map** %50
	; IfStmt
	%624 = load %mem.Raw_Map*, %mem.Raw_Map** %50, align 8
	%625 = icmp ne %mem.Raw_Map* %624, zeroinitializer
	%626 = zext i1 %625 to i8
	%627 = trunc i8 %626 to i1
	br i1 %627, label %if.then-82, label %if.done-99

if.then-82:
	; IfStmt
	; SelectorExpr
	%628 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %49, i64 0, i32 2
	%629 = load %runtime.Type_Info*, %runtime.Type_Info** %628, align 8
	%630 = icmp eq %runtime.Type_Info* %629, zeroinitializer
	%631 = zext i1 %630 to i8
	%632 = trunc i8 %631 to i1
	br i1 %632, label %if.then-83, label %if.done-84

if.then-83:
	; ReturnStmt
	; defer
	; SelectorExpr
	%633 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%634 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %633, i64 0
	%635 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %634, i64 0, i32 12
	%636 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %635, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %636, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void

if.done-84:
	; entries
	; SelectorExpr
	%637 = load %mem.Raw_Map*, %mem.Raw_Map** %50, align 8
	%638 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %637, i64 0
	%639 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %638, i64 0, i32 1
	store %mem.Raw_Dynamic_Array* %639, %mem.Raw_Dynamic_Array** %51
	; gs
	; SelectorExpr
	; SelectorExpr
	; SelectorExpr
	%640 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %49, i64 0, i32 2
	%641 = load %runtime.Type_Info*, %runtime.Type_Info** %640, align 8
	%642 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %641)
	%643 = bitcast %runtime.Type_Info** %53 to %..rawptr
	%644 = call %..rawptr @mem.zero(%..rawptr %643, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %53
	store %runtime.Type_Info* %642, %runtime.Type_Info** %53
	%645 = load %runtime.Type_Info*, %runtime.Type_Info** %53, align 8
	%646 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %645, i64 0
	%647 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %646, i64 0, i32 3
	%648 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %647, align 8
	; cast - union_cast
	%649 = bitcast {%runtime.Type_Info_Struct, i8}* %54 to %..rawptr
	%650 = call %..rawptr @mem.zero(%..rawptr %649, i64 80) noinline
	store {%runtime.Type_Info_Struct, i8} zeroinitializer, {%runtime.Type_Info_Struct, i8}* %54
	%651 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %647, i64 0, i32 2 ; UnionTagPtr
	%652 = load i8, i8* %651, align 1
	%653 = icmp eq i8 %652, 16
	br i1 %653, label %union_cast.ok-85, label %union_cast.end-86

union_cast.ok-85:
	%654 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %54, i64 0, i32 0
	%655 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %54, i64 0, i32 1
	%656 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %647 to %runtime.Type_Info_Struct*
	%657 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %656, align 8
	store %runtime.Type_Info_Struct %657, %runtime.Type_Info_Struct* %654
	store i8 1, i8* %655
	br label %union_cast.end-86

union_cast.end-86:
	%658 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %54, i64 0, i32 1
	%659 = load i8, i8* %658, align 1
	%660 = trunc i8 %659 to i1
	call void @runtime.type_assertion_check(i1 %660, %..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$132, i64 0, i32 0), i64 53}, i64 1050, i64 64, %..typeid 1152921504606846984, %..typeid 3386706919782613035)
	%661 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %54, i64 0, i32 0
	%662 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %661, align 8
	store %runtime.Type_Info_Struct %662, %runtime.Type_Info_Struct* %52
	; ed
	; SelectorExpr
	; SelectorExpr
	; IndexExpr
	; SelectorExpr
	%663 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %52, i64 0, i32 0
	%664 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %663, align 8
	%665 = extractvalue {%runtime.Type_Info**, i64} %664, 0
	%666 = extractvalue {%runtime.Type_Info**, i64} %664, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$133, i64 0, i32 0), i64 53}, i64 1051, i64 50, i64 1, i64 %666)
	%667 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %665, i64 1
	%668 = load %runtime.Type_Info*, %runtime.Type_Info** %667, align 8
	%669 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %668)
	%670 = bitcast %runtime.Type_Info** %56 to %..rawptr
	%671 = call %..rawptr @mem.zero(%..rawptr %670, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %56
	store %runtime.Type_Info* %669, %runtime.Type_Info** %56
	%672 = load %runtime.Type_Info*, %runtime.Type_Info** %56, align 8
	%673 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %672, i64 0
	%674 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %673, i64 0, i32 3
	%675 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %674, align 8
	; cast - union_cast
	%676 = bitcast {%runtime.Type_Info_Dynamic_Array, i8}* %57 to %..rawptr
	%677 = call %..rawptr @mem.zero(%..rawptr %676, i64 24) noinline
	store {%runtime.Type_Info_Dynamic_Array, i8} zeroinitializer, {%runtime.Type_Info_Dynamic_Array, i8}* %57
	%678 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %674, i64 0, i32 2 ; UnionTagPtr
	%679 = load i8, i8* %678, align 1
	%680 = icmp eq i8 %679, 13
	br i1 %680, label %union_cast.ok-87, label %union_cast.end-88

union_cast.ok-87:
	%681 = getelementptr inbounds {%runtime.Type_Info_Dynamic_Array, i8}, {%runtime.Type_Info_Dynamic_Array, i8}* %57, i64 0, i32 0
	%682 = getelementptr inbounds {%runtime.Type_Info_Dynamic_Array, i8}, {%runtime.Type_Info_Dynamic_Array, i8}* %57, i64 0, i32 1
	%683 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %674 to %runtime.Type_Info_Dynamic_Array*
	%684 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %683, align 8
	store %runtime.Type_Info_Dynamic_Array %684, %runtime.Type_Info_Dynamic_Array* %681
	store i8 1, i8* %682
	br label %union_cast.end-88

union_cast.end-88:
	%685 = getelementptr inbounds {%runtime.Type_Info_Dynamic_Array, i8}, {%runtime.Type_Info_Dynamic_Array, i8}* %57, i64 0, i32 1
	%686 = load i8, i8* %685, align 1
	%687 = trunc i8 %686 to i1
	call void @runtime.type_assertion_check(i1 %687, %..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$134, i64 0, i32 0), i64 53}, i64 1051, i64 54, %..typeid 1152921504606846984, %..typeid 3386706919782613026)
	%688 = getelementptr inbounds {%runtime.Type_Info_Dynamic_Array, i8}, {%runtime.Type_Info_Dynamic_Array, i8}* %57, i64 0, i32 0
	%689 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %688, align 8
	store %runtime.Type_Info_Dynamic_Array %689, %runtime.Type_Info_Dynamic_Array* %55
	; entry_type
	; SelectorExpr
	; SelectorExpr
	%690 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %55, i64 0, i32 0
	%691 = load %runtime.Type_Info*, %runtime.Type_Info** %690, align 8
	%692 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %691, i64 0
	%693 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %692, i64 0, i32 3
	%694 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %693, align 8
	; cast - union_cast
	%695 = bitcast {%runtime.Type_Info_Struct, i8}* %59 to %..rawptr
	%696 = call %..rawptr @mem.zero(%..rawptr %695, i64 80) noinline
	store {%runtime.Type_Info_Struct, i8} zeroinitializer, {%runtime.Type_Info_Struct, i8}* %59
	%697 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %693, i64 0, i32 2 ; UnionTagPtr
	%698 = load i8, i8* %697, align 1
	%699 = icmp eq i8 %698, 16
	br i1 %699, label %union_cast.ok-89, label %union_cast.end-90

union_cast.ok-89:
	%700 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %59, i64 0, i32 0
	%701 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %59, i64 0, i32 1
	%702 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %693 to %runtime.Type_Info_Struct*
	%703 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %702, align 8
	store %runtime.Type_Info_Struct %703, %runtime.Type_Info_Struct* %700
	store i8 1, i8* %701
	br label %union_cast.end-90

union_cast.end-90:
	%704 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %59, i64 0, i32 1
	%705 = load i8, i8* %704, align 1
	%706 = trunc i8 %705 to i1
	call void @runtime.type_assertion_check(i1 %706, %..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$135, i64 0, i32 0), i64 53}, i64 1052, i64 26, %..typeid 1152921504606846984, %..typeid 3386706919782613035)
	%707 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %59, i64 0, i32 0
	%708 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %707, align 8
	store %runtime.Type_Info_Struct %708, %runtime.Type_Info_Struct* %58
	; entry_size
	; SelectorExpr
	%709 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %55, i64 0, i32 1
	%710 = load i64, i64* %709, align 8
	store i64 %710, i64* %60
	; RangeStmt
	; i
	%711 = bitcast i64* %61 to %..rawptr
	%712 = call %..rawptr @mem.zero(%..rawptr %711, i64 8) noinline
	store i64 zeroinitializer, i64* %61
	%713 = bitcast i64* %62 to %..rawptr
	%714 = call %..rawptr @mem.zero(%..rawptr %713, i64 8) noinline
	store i64 zeroinitializer, i64* %62
	store i64 0, i64* %62
	%715 = bitcast i64* %63 to %..rawptr
	%716 = call %..rawptr @mem.zero(%..rawptr %715, i64 8) noinline
	store i64 zeroinitializer, i64* %63
	store i64 0, i64* %63
	br label %for.interval.loop-91

for.interval.loop-91:
	; SelectorExpr
	%717 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %51, align 8
	%718 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %717, i64 0
	%719 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %718, i64 0, i32 1
	%720 = load i64, i64* %719, align 8
	%721 = sub i64 %720, 1
	%722 = load i64, i64* %62, align 8
	%723 = icmp sle i64 %722, %721
	br i1 %723, label %for.interval.body-92, label %for.interval.done-98

for.interval.body-92:
	%724 = load i64, i64* %62, align 8
	%725 = load i64, i64* %63, align 8
	%726 = load i64, i64* %62, align 8
	%727 = add i64 %726, 1
	store i64 %727, i64* %62
	%728 = load i64, i64* %63, align 8
	%729 = add i64 %728, 1
	store i64 %729, i64* %63
	store i64 %724, i64* %61
	; IfStmt
	%730 = load i64, i64* %61, align 8
	%731 = icmp sgt i64 %730, 0
	%732 = zext i1 %731 to i8
	%733 = trunc i8 %732 to i1
	br i1 %733, label %if.then-93, label %if.done-94

if.then-93:
	; SelectorExpr
	%734 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%735 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %734, i64 0
	%736 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %735, i64 0, i32 12
	%737 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %736, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %737, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$136, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-94

if.done-94:
	; data
	; SelectorExpr
	%738 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %51, align 8
	%739 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %738, i64 0
	%740 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %739, i64 0, i32 0
	%741 = load %..rawptr, %..rawptr* %740, align 8
	%742 = ptrtoint %..rawptr %741 to i64
	%743 = load i64, i64* %61, align 8
	%744 = load i64, i64* %60, align 8
	%745 = mul i64 %743, %744
	%746 = bitcast i64 %745 to i64
	%747 = add i64 %742, %746
	store i64 %747, i64* %64
	; header
	%748 = load i64, i64* %64, align 8
	%749 = inttoptr i64 %748 to %runtime.Map_Entry_Header*
	store %runtime.Map_Entry_Header* %749, %runtime.Map_Entry_Header** %65
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%750 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %49, i64 0, i32 0
	%751 = load %runtime.Type_Info*, %runtime.Type_Info** %750, align 8
	%752 = call i8 @types.is_string(%runtime.Type_Info* %751, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%753 = trunc i8 %752 to i1
	br i1 %753, label %if.then-95, label %if.else-96

if.then-95:
	; SelectorExpr
	%754 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%755 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %754, i64 0
	%756 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %755, i64 0, i32 12
	%757 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %756, align 8
	; SelectorExpr
	; SelectorExpr
	%758 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %65, align 8
	%759 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %758, i64 0
	%760 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %759, i64 0, i32 0
	%761 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %760, i64 0, i32 1
	%762 = load %..string, %..string* %761, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %757, %..string %762, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-97

if.else-96:
	; fi
	; CompoundLit
	%763 = bitcast %fmt.Fmt_Info* %67 to %..rawptr
	%764 = call %..rawptr @mem.zero(%..rawptr %763, i64 64) noinline
	store %fmt.Fmt_Info zeroinitializer, %fmt.Fmt_Info* %67
	store %fmt.Fmt_Info {i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, {i8*, i64, i64, %mem.Allocator}* zeroinitializer, %..any zeroinitializer}, %fmt.Fmt_Info* %67
	; SelectorExpr
	%765 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%766 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %765, i64 0
	%767 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %766, i64 0, i32 12
	%768 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %767, align 8
	%769 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %67, i64 0, i32 12
	store {i8*, i64, i64, %mem.Allocator}* %768, {i8*, i64, i64, %mem.Allocator}** %769
	%770 = load %fmt.Fmt_Info, %fmt.Fmt_Info* %67, align 8
	store %fmt.Fmt_Info %770, %fmt.Fmt_Info* %66
	; CompoundLit
	%771 = bitcast %..any* %68 to %..rawptr
	%772 = call %..rawptr @mem.zero(%..rawptr %771, i64 16) noinline
	store %..any zeroinitializer, %..any* %68
	store %..any zeroinitializer, %..any* %68
	; SelectorExpr
	; SelectorExpr
	%773 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %65, align 8
	%774 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %773, i64 0
	%775 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %774, i64 0, i32 0
	%776 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %775, i64 0, i32 0
	%777 = bitcast i64* %776 to %..rawptr
	%778 = getelementptr inbounds %..any, %..any* %68, i64 0, i32 0
	store %..rawptr %777, %..rawptr* %778
	; SelectorExpr
	; SelectorExpr
	%779 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %49, i64 0, i32 0
	%780 = load %runtime.Type_Info*, %runtime.Type_Info** %779, align 8
	%781 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %780, i64 0
	%782 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %781, i64 0, i32 2
	%783 = load %..typeid, %..typeid* %782, align 8
	%784 = getelementptr inbounds %..any, %..any* %68, i64 0, i32 1
	store %..typeid %783, %..typeid* %784
	%785 = load %..any, %..any* %68, align 8
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %66, %..any %785, i32 118, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-97

if.done-97:
	; SelectorExpr
	%786 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%787 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %786, i64 0
	%788 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %787, i64 0, i32 12
	%789 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %788, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %789, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$137, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; value
	%790 = load i64, i64* %64, align 8
	; IndexExpr
	; SelectorExpr
	%791 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %58, i64 0, i32 2
	%792 = load {i64*, i64}, {i64*, i64}* %791, align 8
	%793 = extractvalue {i64*, i64} %792, 0
	%794 = extractvalue {i64*, i64} %792, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$138, i64 0, i32 0), i64 53}, i64 1070, i64 40, i64 2, i64 %794)
	%795 = getelementptr inbounds i64, i64* %793, i64 2
	%796 = load i64, i64* %795, align 8
	%797 = add i64 %790, %796
	store i64 %797, i64* %69
	%798 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%799 = bitcast %..any* %70 to %..rawptr
	%800 = call %..rawptr @mem.zero(%..rawptr %799, i64 16) noinline
	store %..any zeroinitializer, %..any* %70
	store %..any zeroinitializer, %..any* %70
	%801 = load i64, i64* %69, align 8
	%802 = inttoptr i64 %801 to %..rawptr
	%803 = getelementptr inbounds %..any, %..any* %70, i64 0, i32 0
	store %..rawptr %802, %..rawptr* %803
	; SelectorExpr
	; SelectorExpr
	%804 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %49, i64 0, i32 1
	%805 = load %runtime.Type_Info*, %runtime.Type_Info** %804, align 8
	%806 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %805, i64 0
	%807 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %806, i64 0, i32 2
	%808 = load %..typeid, %..typeid* %807, align 8
	%809 = getelementptr inbounds %..any, %..any* %70, i64 0, i32 1
	store %..typeid %808, %..typeid* %809
	%810 = load %..any, %..any* %70, align 8
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %798, %..any %810, i32 118, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-91

for.interval.done-98:
	br label %if.done-99

if.done-99:
	; defer
	; SelectorExpr
	%811 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%812 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %811, i64 0
	%813 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %812, i64 0, i32 12
	%814 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %813, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %814, i8 93, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-100:
	%815 = icmp eq i8 %127, 17
	br i1 %815, label %typeswitch.body-123, label %typeswitch.next-122

typeswitch.body-101:
	%816 = bitcast %..rawptr %128 to %runtime.Type_Info_Struct*
	%817 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %816, align 8
	store %runtime.Type_Info_Struct %817, %runtime.Type_Info_Struct* %71
	; IfStmt
	; SelectorExpr
	%818 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %71, i64 0, i32 5
	%819 = load i8, i8* %818, align 1
	%820 = trunc i8 %819 to i1
	br i1 %820, label %if.then-102, label %if.done-103

if.then-102:
	; SelectorExpr
	%821 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%822 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %821, i64 0
	%823 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %822, i64 0, i32 12
	%824 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %823, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %824, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$139, i64 0, i32 0), i64 11}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-103:
	; SelectorExpr
	%825 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%826 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %825, i64 0
	%827 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %826, i64 0, i32 12
	%828 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %827, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %828, i8 123, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; DeferStmt
	; AssignStmt
	; SelectorExpr
	%829 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%830 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %829, i64 0
	%831 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %830, i64 0, i32 9
	%832 = load i64, i64* %831, align 8
	%833 = add i64 %832, 1
	store i64 %833, i64* %831
	; DeferStmt
	; hash
	; SelectorExpr
	%834 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%835 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %834, i64 0
	%836 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %835, i64 0, i32 4
	%837 = load i8, i8* %836, align 1
	store i8 %837, i8* %72
	; DeferStmt
	; AssignStmt
	; SelectorExpr
	%838 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%839 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %838, i64 0
	%840 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %839, i64 0, i32 4
	store i8 0, i8* %840
	; IfStmt
	%841 = load i8, i8* %72, align 1
	%842 = trunc i8 %841 to i1
	br i1 %842, label %if.then-104, label %if.done-105

if.then-104:
	; SelectorExpr
	%843 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%844 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %843, i64 0
	%845 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %844, i64 0, i32 12
	%846 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %845, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %846, i8 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-105

if.done-105:
	; RangeStmt
	; i
	%847 = bitcast i64* %73 to %..rawptr
	%848 = call %..rawptr @mem.zero(%..rawptr %847, i64 8) noinline
	store i64 zeroinitializer, i64* %73
	; SelectorExpr
	%849 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %71, i64 0, i32 1
	%850 = load {%..string*, i64}, {%..string*, i64}* %849, align 8
	%851 = bitcast i64* %74 to %..rawptr
	%852 = call %..rawptr @mem.zero(%..rawptr %851, i64 8) noinline
	store i64 zeroinitializer, i64* %74
	%853 = extractvalue {%..string*, i64} %850, 1
	store i64 %853, i64* %74
	%854 = bitcast i64* %75 to %..rawptr
	%855 = call %..rawptr @mem.zero(%..rawptr %854, i64 8) noinline
	store i64 zeroinitializer, i64* %75
	store i64 -1, i64* %75
	br label %for.index.loop-106

for.index.loop-106:
	%856 = load i64, i64* %75, align 8
	%857 = add i64 %856, 1
	store i64 %857, i64* %75
	%858 = load i64, i64* %74, align 8
	%859 = icmp slt i64 %857, %858
	br i1 %859, label %for.index.body-107, label %for.index.done-121

for.index.body-107:
	%860 = load i64, i64* %75, align 8
	store i64 %860, i64* %73
	; IfStmt
	%861 = load i8, i8* %72, align 1
	%862 = trunc i8 %861 to i1
	br i1 %862, label %if.done-110, label %cmp.and-108

cmp.and-108:
	%863 = load i64, i64* %73, align 8
	%864 = icmp sgt i64 %863, 0
	%865 = zext i1 %864 to i8
	%866 = trunc i8 %865 to i1
	br i1 %866, label %if.then-109, label %if.done-110

if.then-109:
	; SelectorExpr
	%867 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%868 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %867, i64 0
	%869 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %868, i64 0, i32 12
	%870 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %869, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %870, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$13a, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-110

if.done-110:
	; IfStmt
	%871 = load i8, i8* %72, align 1
	%872 = trunc i8 %871 to i1
	br i1 %872, label %if.then-111, label %if.done-115

if.then-111:
	; RangeStmt
	%873 = bitcast i64* %76 to %..rawptr
	%874 = call %..rawptr @mem.zero(%..rawptr %873, i64 8) noinline
	store i64 zeroinitializer, i64* %76
	store i64 0, i64* %76
	%875 = bitcast i64* %77 to %..rawptr
	%876 = call %..rawptr @mem.zero(%..rawptr %875, i64 8) noinline
	store i64 zeroinitializer, i64* %77
	store i64 0, i64* %77
	br label %for.interval.loop-112

for.interval.loop-112:
	; SelectorExpr
	%877 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%878 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %877, i64 0
	%879 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %878, i64 0, i32 9
	%880 = load i64, i64* %879, align 8
	%881 = sub i64 %880, 1
	%882 = load i64, i64* %76, align 8
	%883 = icmp sle i64 %882, %881
	br i1 %883, label %for.interval.body-113, label %for.interval.done-114

for.interval.body-113:
	%884 = load i64, i64* %76, align 8
	%885 = load i64, i64* %77, align 8
	%886 = load i64, i64* %76, align 8
	%887 = add i64 %886, 1
	store i64 %887, i64* %76
	%888 = load i64, i64* %77, align 8
	%889 = add i64 %888, 1
	store i64 %889, i64* %77
	; SelectorExpr
	%890 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%891 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %890, i64 0
	%892 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %891, i64 0, i32 12
	%893 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %892, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %893, i8 9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-112

for.interval.done-114:
	br label %if.done-115

if.done-115:
	; SelectorExpr
	%894 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%895 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %894, i64 0
	%896 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %895, i64 0, i32 12
	%897 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %896, align 8
	; IndexExpr
	; SelectorExpr
	%898 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %71, i64 0, i32 1
	%899 = load {%..string*, i64}, {%..string*, i64}* %898, align 8
	%900 = extractvalue {%..string*, i64} %899, 0
	%901 = load i64, i64* %73, align 8
	%902 = extractvalue {%..string*, i64} %899, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$13b, i64 0, i32 0), i64 53}, i64 1099, i64 36, i64 %901, i64 %902)
	%903 = getelementptr inbounds %..string, %..string* %900, i64 %901
	%904 = load %..string, %..string* %903, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %897, %..string %904, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%905 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%906 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %905, i64 0
	%907 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %906, i64 0, i32 12
	%908 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %907, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %908, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$13c, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; t
	; IndexExpr
	; SelectorExpr
	%909 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %71, i64 0, i32 0
	%910 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %909, align 8
	%911 = extractvalue {%runtime.Type_Info**, i64} %910, 0
	%912 = load i64, i64* %73, align 8
	%913 = extractvalue {%runtime.Type_Info**, i64} %910, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$13d, i64 0, i32 0), i64 53}, i64 1102, i64 23, i64 %912, i64 %913)
	%914 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %911, i64 %912
	%915 = load %runtime.Type_Info*, %runtime.Type_Info** %914, align 8
	store %runtime.Type_Info* %915, %runtime.Type_Info** %78
	; SelectorExpr
	%916 = load %runtime.Type_Info*, %runtime.Type_Info** %78, align 8
	%917 = call i8 @types.is_any(%runtime.Type_Info* %916, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%918 = trunc i8 %917 to i1
	br i1 %918, label %if.then-116, label %if.else-117

if.then-116:
	; SelectorExpr
	%919 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%920 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %919, i64 0
	%921 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %920, i64 0, i32 12
	%922 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %921, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %922, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$13e, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-118

if.else-117:
	; data
	; SelectorExpr
	%923 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%924 = load %..rawptr, %..rawptr* %923, align 8
	%925 = ptrtoint %..rawptr %924 to i64
	; IndexExpr
	; SelectorExpr
	%926 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %71, i64 0, i32 2
	%927 = load {i64*, i64}, {i64*, i64}* %926, align 8
	%928 = extractvalue {i64*, i64} %927, 0
	%929 = load i64, i64* %73, align 8
	%930 = extractvalue {i64*, i64} %927, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$13f, i64 0, i32 0), i64 53}, i64 1105, i64 44, i64 %929, i64 %930)
	%931 = getelementptr inbounds i64, i64* %928, i64 %929
	%932 = load i64, i64* %931, align 8
	%933 = add i64 %925, %932
	store i64 %933, i64* %79
	%934 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%935 = bitcast %..any* %80 to %..rawptr
	%936 = call %..rawptr @mem.zero(%..rawptr %935, i64 16) noinline
	store %..any zeroinitializer, %..any* %80
	store %..any zeroinitializer, %..any* %80
	%937 = load i64, i64* %79, align 8
	%938 = inttoptr i64 %937 to %..rawptr
	%939 = getelementptr inbounds %..any, %..any* %80, i64 0, i32 0
	store %..rawptr %938, %..rawptr* %939
	; SelectorExpr
	%940 = load %runtime.Type_Info*, %runtime.Type_Info** %78, align 8
	%941 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %940, i64 0
	%942 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %941, i64 0, i32 2
	%943 = load %..typeid, %..typeid* %942, align 8
	%944 = getelementptr inbounds %..any, %..any* %80, i64 0, i32 1
	store %..typeid %943, %..typeid* %944
	%945 = load %..any, %..any* %80, align 8
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %934, %..any %945, i32 118, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-118

if.done-118:
	; IfStmt
	%946 = load i8, i8* %72, align 1
	%947 = trunc i8 %946 to i1
	br i1 %947, label %if.then-119, label %if.done-120

if.then-119:
	; SelectorExpr
	%948 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%949 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %948, i64 0
	%950 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %949, i64 0, i32 12
	%951 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %950, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %951, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$140, i64 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-120

if.done-120:
	br label %for.index.loop-106

for.index.done-121:
	; defer
	; AssignStmt
	; SelectorExpr
	%952 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%953 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %952, i64 0
	%954 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %953, i64 0, i32 4
	%955 = load i8, i8* %72, align 1
	store i8 %955, i8* %954
	; defer
	; AssignStmt
	; SelectorExpr
	%956 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%957 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %956, i64 0
	%958 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %957, i64 0, i32 9
	%959 = load i64, i64* %958, align 8
	%960 = sub i64 %959, 1
	store i64 %960, i64* %958
	; defer
	; SelectorExpr
	%961 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%962 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %961, i64 0
	%963 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %962, i64 0, i32 12
	%964 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %963, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %964, i8 125, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-122:
	%965 = icmp eq i8 %127, 18
	br i1 %965, label %typeswitch.body-146, label %typeswitch.next-145

typeswitch.body-123:
	%966 = bitcast %..rawptr %128 to %runtime.Type_Info_Union*
	%967 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %966, align 8
	store %runtime.Type_Info_Union %967, %runtime.Type_Info_Union* %81
	; tag_ptr
	; SelectorExpr
	%968 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%969 = load %..rawptr, %..rawptr* %968, align 8
	%970 = ptrtoint %..rawptr %969 to i64
	; SelectorExpr
	%971 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %81, i64 0, i32 1
	%972 = load i64, i64* %971, align 8
	%973 = add i64 %970, %972
	store i64 %973, i64* %82
	; tag_any
	; CompoundLit
	%974 = bitcast %..any* %84 to %..rawptr
	%975 = call %..rawptr @mem.zero(%..rawptr %974, i64 16) noinline
	store %..any zeroinitializer, %..any* %84
	store %..any zeroinitializer, %..any* %84
	%976 = load i64, i64* %82, align 8
	%977 = inttoptr i64 %976 to %..rawptr
	%978 = getelementptr inbounds %..any, %..any* %84, i64 0, i32 0
	store %..rawptr %977, %..rawptr* %978
	; SelectorExpr
	; SelectorExpr
	%979 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %81, i64 0, i32 2
	%980 = load %runtime.Type_Info*, %runtime.Type_Info** %979, align 8
	%981 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %980, i64 0
	%982 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %981, i64 0, i32 2
	%983 = load %..typeid, %..typeid* %982, align 8
	%984 = getelementptr inbounds %..any, %..any* %84, i64 0, i32 1
	store %..typeid %983, %..typeid* %984
	%985 = load %..any, %..any* %84, align 8
	store %..any %985, %..any* %83
	; tag
	store i64 -1, i64* %85
	; TypeSwitchStmt
	%986 = load %..any, %..any* %83, align 8
	%987 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%988 = load %..typeid, %..typeid* %987, align 8
	%989 = icmp eq %..typeid %988, 72057594037927939
	br i1 %989, label %typeswitch.body-125, label %typeswitch.next-124

typeswitch.next-124:
	%990 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%991 = load %..typeid, %..typeid* %990, align 8
	%992 = icmp eq %..typeid %991, 4683743612465315898
	br i1 %992, label %typeswitch.body-127, label %typeswitch.next-126

typeswitch.body-125:
	%993 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%994 = load %..rawptr, %..rawptr* %993, align 8
	%995 = bitcast %..rawptr %994 to i8*
	%996 = load i8, i8* %995, align 1
	store i8 %996, i8* %86
	; AssignStmt
	%997 = load i8, i8* %86, align 1
	%998 = zext i8 %997 to i64
	store i64 %998, i64* %85
	br label %typeswitch.done-140

typeswitch.next-126:
	%999 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%1000 = load %..typeid, %..typeid* %999, align 8
	%1001 = icmp eq %..typeid %1000, 72057594037927998
	br i1 %1001, label %typeswitch.body-129, label %typeswitch.next-128

typeswitch.body-127:
	%1002 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%1003 = load %..rawptr, %..rawptr* %1002, align 8
	%1004 = bitcast %..rawptr %1003 to i8*
	%1005 = load i8, i8* %1004, align 1
	store i8 %1005, i8* %87
	; AssignStmt
	%1006 = load i8, i8* %87, align 1
	%1007 = sext i8 %1006 to i64
	store i64 %1007, i64* %85
	br label %typeswitch.done-140

typeswitch.next-128:
	%1008 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%1009 = load %..typeid, %..typeid* %1008, align 8
	%1010 = icmp eq %..typeid %1009, 4683743612465315899
	br i1 %1010, label %typeswitch.body-131, label %typeswitch.next-130

typeswitch.body-129:
	%1011 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%1012 = load %..rawptr, %..rawptr* %1011, align 8
	%1013 = bitcast %..rawptr %1012 to i16*
	%1014 = load i16, i16* %1013, align 2
	store i16 %1014, i16* %88
	; AssignStmt
	%1015 = load i16, i16* %88, align 2
	%1016 = zext i16 %1015 to i64
	store i64 %1016, i64* %85
	br label %typeswitch.done-140

typeswitch.next-130:
	%1017 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%1018 = load %..typeid, %..typeid* %1017, align 8
	%1019 = icmp eq %..typeid %1018, 72057594037927999
	br i1 %1019, label %typeswitch.body-133, label %typeswitch.next-132

typeswitch.body-131:
	%1020 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%1021 = load %..rawptr, %..rawptr* %1020, align 8
	%1022 = bitcast %..rawptr %1021 to i16*
	%1023 = load i16, i16* %1022, align 2
	store i16 %1023, i16* %89
	; AssignStmt
	%1024 = load i16, i16* %89, align 2
	%1025 = sext i16 %1024 to i64
	store i64 %1025, i64* %85
	br label %typeswitch.done-140

typeswitch.next-132:
	%1026 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%1027 = load %..typeid, %..typeid* %1026, align 8
	%1028 = icmp eq %..typeid %1027, 4683743612465315900
	br i1 %1028, label %typeswitch.body-135, label %typeswitch.next-134

typeswitch.body-133:
	%1029 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%1030 = load %..rawptr, %..rawptr* %1029, align 8
	%1031 = bitcast %..rawptr %1030 to i32*
	%1032 = load i32, i32* %1031, align 4
	store i32 %1032, i32* %90
	; AssignStmt
	%1033 = load i32, i32* %90, align 4
	%1034 = zext i32 %1033 to i64
	store i64 %1034, i64* %85
	br label %typeswitch.done-140

typeswitch.next-134:
	%1035 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%1036 = load %..typeid, %..typeid* %1035, align 8
	%1037 = icmp eq %..typeid %1036, 72057594037928000
	br i1 %1037, label %typeswitch.body-137, label %typeswitch.next-136

typeswitch.body-135:
	%1038 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%1039 = load %..rawptr, %..rawptr* %1038, align 8
	%1040 = bitcast %..rawptr %1039 to i32*
	%1041 = load i32, i32* %1040, align 4
	store i32 %1041, i32* %91
	; AssignStmt
	%1042 = load i32, i32* %91, align 4
	%1043 = sext i32 %1042 to i64
	store i64 %1043, i64* %85
	br label %typeswitch.done-140

typeswitch.next-136:
	%1044 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	%1045 = load %..typeid, %..typeid* %1044, align 8
	%1046 = icmp eq %..typeid %1045, 4683743612465315901
	br i1 %1046, label %typeswitch.body-139, label %typeswitch.next-138

typeswitch.body-137:
	%1047 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%1048 = load %..rawptr, %..rawptr* %1047, align 8
	%1049 = bitcast %..rawptr %1048 to i64*
	%1050 = load i64, i64* %1049, align 8
	store i64 %1050, i64* %92
	; AssignStmt
	%1051 = load i64, i64* %92, align 8
	%1052 = bitcast i64 %1051 to i64
	store i64 %1052, i64* %85
	br label %typeswitch.done-140

typeswitch.next-138:
	store %..any %986, %..any* %94
	%1053 = bitcast %runtime.Source_Code_Location* %95 to %..rawptr
	%1054 = call %..rawptr @mem.zero(%..rawptr %1053, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %95
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$141, i64 0, i32 0), i64 53}, i64 1125, i64 9, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$142, i64 0, i32 0), i64 9}}, %runtime.Source_Code_Location* %95
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$143, i64 0, i32 0), i64 22}, %runtime.Source_Code_Location* %95) noreturn
	br label %typeswitch.done-140

typeswitch.body-139:
	%1055 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	%1056 = load %..rawptr, %..rawptr* %1055, align 8
	%1057 = bitcast %..rawptr %1056 to i64*
	%1058 = load i64, i64* %1057, align 8
	store i64 %1058, i64* %93
	; AssignStmt
	%1059 = load i64, i64* %93, align 8
	store i64 %1059, i64* %85
	br label %typeswitch.done-140

typeswitch.done-140:
	; IfStmt
	; SelectorExpr
	%1060 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%1061 = load %..rawptr, %..rawptr* %1060, align 8
	%1062 = icmp eq %..rawptr %1061, zeroinitializer
	%1063 = zext i1 %1062 to i8
	%1064 = trunc i8 %1063 to i1
	br i1 %1064, label %if.then-142, label %cmp.or-141

cmp.or-141:
	%1065 = load i64, i64* %85, align 8
	%1066 = icmp eq i64 %1065, 0
	%1067 = zext i1 %1066 to i8
	%1068 = trunc i8 %1067 to i1
	br i1 %1068, label %if.then-142, label %if.else-143

if.then-142:
	; SelectorExpr
	%1069 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1070 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1069, i64 0
	%1071 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1070, i64 0, i32 12
	%1072 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %1071, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %1072, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$144, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-144

if.else-143:
	; id
	; SelectorExpr
	; IndexExpr
	; SelectorExpr
	%1073 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %81, i64 0, i32 0
	%1074 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1073, align 8
	%1075 = extractvalue {%runtime.Type_Info**, i64} %1074, 0
	%1076 = load i64, i64* %85, align 8
	%1077 = sub i64 %1076, 1
	%1078 = bitcast i64 %1077 to i64
	%1079 = extractvalue {%runtime.Type_Info**, i64} %1074, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$145, i64 0, i32 0), i64 53}, i64 1131, i64 24, i64 %1078, i64 %1079)
	%1080 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1075, i64 %1078
	%1081 = load %runtime.Type_Info*, %runtime.Type_Info** %1080, align 8
	%1082 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1081, i64 0
	%1083 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1082, i64 0, i32 2
	%1084 = load %..typeid, %..typeid* %1083, align 8
	store %..typeid %1084, %..typeid* %96
	%1085 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	; CompoundLit
	%1086 = bitcast %..any* %97 to %..rawptr
	%1087 = call %..rawptr @mem.zero(%..rawptr %1086, i64 16) noinline
	store %..any zeroinitializer, %..any* %97
	store %..any zeroinitializer, %..any* %97
	; SelectorExpr
	%1088 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%1089 = load %..rawptr, %..rawptr* %1088, align 8
	%1090 = getelementptr inbounds %..any, %..any* %97, i64 0, i32 0
	store %..rawptr %1089, %..rawptr* %1090
	%1091 = load %..typeid, %..typeid* %96, align 8
	%1092 = getelementptr inbounds %..any, %..any* %97, i64 0, i32 1
	store %..typeid %1091, %..typeid* %1092
	%1093 = load %..any, %..any* %97, align 8
	%1094 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %1085, %..any %1093, i32 %1094, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-144

if.done-144:
	br label %typeswitch.done-158

typeswitch.next-145:
	%1095 = icmp eq i8 %127, 11
	br i1 %1095, label %typeswitch.body-148, label %typeswitch.next-147

typeswitch.body-146:
	%1096 = bitcast %..rawptr %128 to %runtime.Type_Info_Enum*
	%1097 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %1096, align 8
	store %runtime.Type_Info_Enum %1097, %runtime.Type_Info_Enum* %98
	%1098 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1099 = load %..any, %..any* %1, align 8
	%1100 = load i32, i32* %2, align 4
	call void @fmt.fmt_enum(%fmt.Fmt_Info* %1098, %..any %1099, i32 %1100, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-147:
	%1101 = icmp eq i8 %127, 9
	br i1 %1101, label %typeswitch.body-153, label %typeswitch.next-152

typeswitch.body-148:
	%1102 = bitcast %..rawptr %128 to %runtime.Type_Info_Procedure*
	%1103 = load %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %1102, align 8
	store %runtime.Type_Info_Procedure %1103, %runtime.Type_Info_Procedure* %99
	; ptr
	; SelectorExpr
	%1104 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%1105 = load %..rawptr, %..rawptr* %1104, align 8
	%1106 = bitcast %..rawptr %1105 to %..rawptr*
	%1107 = getelementptr inbounds %..rawptr, %..rawptr* %1106, i64 0
	%1108 = load %..rawptr, %..rawptr* %1107, align 8
	store %..rawptr %1108, %..rawptr* %100
	; IfStmt
	%1109 = load %..rawptr, %..rawptr* %100, align 8
	%1110 = icmp eq %..rawptr %1109, zeroinitializer
	%1111 = zext i1 %1110 to i8
	%1112 = trunc i8 %1111 to i1
	br i1 %1112, label %if.then-149, label %if.else-150

if.then-149:
	; SelectorExpr
	%1113 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1114 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1113, i64 0
	%1115 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1114, i64 0, i32 12
	%1116 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %1115, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %1116, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$146, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-151

if.else-150:
	; SelectorExpr
	%1117 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1118 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1117, i64 0
	%1119 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1118, i64 0, i32 12
	%1120 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %1119, align 8
	; SelectorExpr
	%1121 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%1122 = load %..typeid, %..typeid* %1121, align 8
	call void @fmt.write_typeid({i8*, i64, i64, %mem.Allocator}* %1120, %..typeid %1122, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%1123 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1124 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1123, i64 0
	%1125 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1124, i64 0, i32 12
	%1126 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %1125, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %1126, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$147, i64 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%1127 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1128 = load %..rawptr, %..rawptr* %100, align 8
	call void @fmt.fmt_pointer(%fmt.Fmt_Info* %1127, %..rawptr %1128, i32 112, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-151

if.done-151:
	br label %typeswitch.done-158

typeswitch.next-152:
	%1129 = icmp eq i8 %127, 20
	br i1 %1129, label %typeswitch.body-155, label %typeswitch.next-154

typeswitch.body-153:
	%1130 = bitcast %..rawptr %128 to %runtime.Type_Info_Type_Id*
	%1131 = load %runtime.Type_Info_Type_Id, %runtime.Type_Info_Type_Id* %1130, align 1
	store %runtime.Type_Info_Type_Id %1131, %runtime.Type_Info_Type_Id* %101
	; id
	; SelectorExpr
	%1132 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%1133 = load %..rawptr, %..rawptr* %1132, align 8
	%1134 = bitcast %..rawptr %1133 to %..typeid*
	%1135 = getelementptr inbounds %..typeid, %..typeid* %1134, i64 0
	%1136 = load %..typeid, %..typeid* %1135, align 8
	store %..typeid %1136, %..typeid* %102
	; SelectorExpr
	%1137 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1138 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1137, i64 0
	%1139 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1138, i64 0, i32 12
	%1140 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %1139, align 8
	%1141 = load %..typeid, %..typeid* %102, align 8
	call void @fmt.write_typeid({i8*, i64, i64, %mem.Allocator}* %1140, %..typeid %1141, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-154:
	%1142 = icmp eq i8 %127, 21
	br i1 %1142, label %typeswitch.body-157, label %typeswitch.next-156

typeswitch.body-155:
	%1143 = bitcast %..rawptr %128 to %runtime.Type_Info_Bit_Field*
	%1144 = load %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %1143, align 8
	store %runtime.Type_Info_Bit_Field %1144, %runtime.Type_Info_Bit_Field* %103
	%1145 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1146 = load %..any, %..any* %1, align 8
	call void @fmt.fmt_bit_field(%fmt.Fmt_Info* %1145, %..any %1146, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.next-156:
	br label %typeswitch.done-158

typeswitch.body-157:
	%1147 = bitcast %..rawptr %128 to %runtime.Type_Info_Bit_Set*
	%1148 = load %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %1147, align 8
	store %runtime.Type_Info_Bit_Set %1148, %runtime.Type_Info_Bit_Set* %104
	%1149 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%1150 = load %..any, %..any* %1, align 8
	call void @fmt.fmt_bit_set(%fmt.Fmt_Info* %1149, %..any %1150, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-158

typeswitch.done-158:
	ret void
}

define void @fmt.fmt_complex(%fmt.Fmt_Info* %fi, %..complex128* %c, i64 %bits, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i32, align 16
	%3 = alloca double, align 16
	%4 = alloca double, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	%5 = load %..complex128, %..complex128* %c, align 8
	store i64 %bits, i64* %1
	store i32 %verb, i32* %2
	; SwitchStmt
	%6 = load i32, i32* %2, align 4
	%7 = icmp eq i32 %6, 102
	br i1 %7, label %switch.case.body-4, label %switch.case.next-1

switch.case.next-1:
	%8 = icmp eq i32 %6, 70
	br i1 %8, label %switch.case.body-4, label %switch.case.next-2

switch.case.next-2:
	%9 = icmp eq i32 %6, 118
	br i1 %9, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%10 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%11 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Fmt_Info* %10, i32 %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

switch.case.body-4:
	; r
	; i
	; real
	%12 = load %..complex128, %..complex128* %c, align 8
	%13 = extractvalue %..complex128 %12, 0
	; imag
	%14 = load %..complex128, %..complex128* %c, align 8
	%15 = extractvalue %..complex128 %14, 1
	store double %13, double* %3
	store double %15, double* %4
	%16 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%17 = load double, double* %3, align 8
	%18 = load i64, i64* %1, align 8
	%19 = sdiv i64 %18, 2
	%20 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Fmt_Info* %16, double %17, i64 %19, i32 %20, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%21 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%22 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %21, i64 0
	%23 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %22, i64 0, i32 1
	%24 = load i8, i8* %23, align 1
	%25 = trunc i8 %24 to i1
	br i1 %25, label %if.done-7, label %cmp.and-5

cmp.and-5:
	%26 = load double, double* %4, align 8
	%27 = fcmp oge double %26, 0x0000000000000000
	%28 = zext i1 %27 to i8
	%29 = trunc i8 %28 to i1
	br i1 %29, label %if.then-6, label %if.done-7

if.then-6:
	; SelectorExpr
	%30 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%31 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %30, i64 0
	%32 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %31, i64 0, i32 12
	%33 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %32, align 8
	call void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %33, i32 43, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-7

if.done-7:
	%34 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%35 = load double, double* %4, align 8
	%36 = load i64, i64* %1, align 8
	%37 = sdiv i64 %36, 2
	%38 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Fmt_Info* %34, double %35, i64 %37, i32 %38, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%39 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%40 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %39, i64 0
	%41 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %40, i64 0, i32 12
	%42 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %41, align 8
	call void @fmt.write_rune({i8*, i64, i64, %mem.Allocator}* %42, i32 105, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @fmt.fmt_arg(%fmt.Fmt_Info* %fi, %..any %arg, i32 %verb, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Fmt_Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca i32, align 16
	%3 = alloca %runtime.Type_Info*, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca %..any, align 16
	%6 = alloca i8, align 16
	%7 = alloca i8, align 16
	%8 = alloca i16, align 16
	%9 = alloca i32, align 16
	%10 = alloca i64, align 16
	%11 = alloca %..any, align 16
	%12 = alloca i32, align 16
	%13 = alloca float, align 16
	%14 = alloca double, align 16
	%15 = alloca %..complex64, align 16
	%16 = alloca %..complex128, align 16
	%17 = alloca %..complex128, align 16
	%18 = alloca %..complex128, align 16
	%19 = alloca %..complex128, align 16
	%20 = alloca i8, align 16
	%21 = alloca i8, align 16
	%22 = alloca i16, align 16
	%23 = alloca i16, align 16
	%24 = alloca i32, align 16
	%25 = alloca i32, align 16
	%26 = alloca i64, align 16
	%27 = alloca i64, align 16
	%28 = alloca i64, align 16
	%29 = alloca i64, align 16
	%30 = alloca i64, align 16
	%31 = alloca %..string, align 16
	%32 = alloca i8*, align 16
	%33 = alloca %..typeid, align 16
	%34 = alloca %..any, align 16
	store %fmt.Fmt_Info* %fi, %fmt.Fmt_Info** %0
	store %..any %arg, %..any* %1
	store i32 %verb, i32* %2
	; IfStmt
	%35 = load %..any, %..any* %1, align 8
	%36 = extractvalue %..any %35, 0
	%37 = extractvalue %..any %35, 1
	%38 = icmp eq %..rawptr %36, null
	%39 = icmp eq %..typeid %37, 0
	%40 = zext i1 %38 to i8
	%41 = zext i1 %39 to i8
	%42 = or i8 %40, %41
	%43 = trunc i8 %42 to i1
	br i1 %43, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	%44 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%45 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %44, i64 0
	%46 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %45, i64 0, i32 12
	%47 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %46, align 8
	call void @fmt.write_string({i8*, i64, i64, %mem.Allocator}* %47, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$148, i64 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-2:
	; AssignStmt
	; SelectorExpr
	%48 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%49 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %48, i64 0
	%50 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %49, i64 0, i32 13
	%51 = load %..any, %..any* %1, align 8
	store %..any %51, %..any* %50
	; IfStmt
	%52 = load i32, i32* %2, align 4
	%53 = icmp eq i32 %52, 84
	%54 = zext i1 %53 to i8
	%55 = trunc i8 %54 to i1
	br i1 %55, label %if.then-3, label %if.done-7

if.then-3:
	; ti
	; SelectorExpr
	%56 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%57 = load %..typeid, %..typeid* %56, align 8
	%58 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %57)
	store %runtime.Type_Info* %58, %runtime.Type_Info** %3
	; TypeSwitchStmt
	%59 = load %..any, %..any* %1, align 8
	%60 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	%61 = load %..typeid, %..typeid* %60, align 8
	%62 = icmp eq %..typeid %61, 648518346341351433
	br i1 %62, label %typeswitch.body-5, label %typeswitch.next-4

typeswitch.next-4:
	br label %typeswitch.done-6

typeswitch.body-5:
	%63 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	%64 = load %..rawptr, %..rawptr* %63, align 8
	%65 = bitcast %..rawptr %64 to %runtime.Type_Info**
	%66 = load %runtime.Type_Info*, %runtime.Type_Info** %65, align 8
	store %runtime.Type_Info* %66, %runtime.Type_Info** %4
	; AssignStmt
	%67 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	store %runtime.Type_Info* %67, %runtime.Type_Info** %3
	br label %typeswitch.done-6

typeswitch.done-6:
	; SelectorExpr
	%68 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%69 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %68, i64 0
	%70 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %69, i64 0, i32 12
	%71 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %70, align 8
	%72 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	call void @fmt.write_type({i8*, i64, i64, %mem.Allocator}* %71, %runtime.Type_Info* %72, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-7:
	; base_arg
	%73 = load %..any, %..any* %1, align 8
	store %..any %73, %..any* %5
	; AssignStmt
	; SelectorExpr
	%74 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	; SelectorExpr
	; SelectorExpr
	%75 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%76 = load %..typeid, %..typeid* %75, align 8
	%77 = call %..typeid @runtime.typeid_base(%..typeid %76)
	store %..typeid %77, %..typeid* %74
	; TypeSwitchStmt
	%78 = load %..any, %..any* %5, align 8
	%79 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%80 = load %..typeid, %..typeid* %79, align 8
	%81 = icmp eq %..typeid %80, 432345564227567632
	br i1 %81, label %typeswitch.body-9, label %typeswitch.next-8

typeswitch.next-8:
	%82 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%83 = load %..typeid, %..typeid* %82, align 8
	%84 = icmp eq %..typeid %83, 432345564227567695
	br i1 %84, label %typeswitch.body-11, label %typeswitch.next-10

typeswitch.body-9:
	%85 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%86 = load %..rawptr, %..rawptr* %85, align 8
	%87 = bitcast %..rawptr %86 to i8*
	%88 = load i8, i8* %87, align 1
	store i8 %88, i8* %6
	%89 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%90 = load i8, i8* %6, align 1
	%91 = load i32, i32* %2, align 4
	%92 = trunc i8 %90 to i1
	call void @fmt.fmt_bool(%fmt.Fmt_Info* %89, i1 %92, i32 %91, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-10:
	%93 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%94 = load %..typeid, %..typeid* %93, align 8
	%95 = icmp eq %..typeid %94, 432345564227567696
	br i1 %95, label %typeswitch.body-13, label %typeswitch.next-12

typeswitch.body-11:
	%96 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%97 = load %..rawptr, %..rawptr* %96, align 8
	%98 = bitcast %..rawptr %97 to i8*
	%99 = load i8, i8* %98, align 1
	store i8 %99, i8* %7
	%100 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%101 = load i8, i8* %7, align 1
	%102 = icmp ne i8 %101, 0
	%103 = zext i1 %102 to i8
	%104 = load i32, i32* %2, align 4
	%105 = trunc i8 %103 to i1
	call void @fmt.fmt_bool(%fmt.Fmt_Info* %100, i1 %105, i32 %104, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-12:
	%106 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%107 = load %..typeid, %..typeid* %106, align 8
	%108 = icmp eq %..typeid %107, 432345564227567697
	br i1 %108, label %typeswitch.body-15, label %typeswitch.next-14

typeswitch.body-13:
	%109 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%110 = load %..rawptr, %..rawptr* %109, align 8
	%111 = bitcast %..rawptr %110 to i16*
	%112 = load i16, i16* %111, align 2
	store i16 %112, i16* %8
	%113 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%114 = load i16, i16* %8, align 2
	%115 = icmp ne i16 %114, 0
	%116 = zext i1 %115 to i8
	%117 = load i32, i32* %2, align 4
	%118 = trunc i8 %116 to i1
	call void @fmt.fmt_bool(%fmt.Fmt_Info* %113, i1 %118, i32 %117, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-14:
	%119 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%120 = load %..typeid, %..typeid* %119, align 8
	%121 = icmp eq %..typeid %120, 432345564227567698
	br i1 %121, label %typeswitch.body-17, label %typeswitch.next-16

typeswitch.body-15:
	%122 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%123 = load %..rawptr, %..rawptr* %122, align 8
	%124 = bitcast %..rawptr %123 to i32*
	%125 = load i32, i32* %124, align 4
	store i32 %125, i32* %9
	%126 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%127 = load i32, i32* %9, align 4
	%128 = icmp ne i32 %127, 0
	%129 = zext i1 %128 to i8
	%130 = load i32, i32* %2, align 4
	%131 = trunc i8 %129 to i1
	call void @fmt.fmt_bool(%fmt.Fmt_Info* %126, i1 %131, i32 %130, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-16:
	%132 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%133 = load %..typeid, %..typeid* %132, align 8
	%134 = icmp eq %..typeid %133, 77
	br i1 %134, label %typeswitch.body-19, label %typeswitch.next-18

typeswitch.body-17:
	%135 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%136 = load %..rawptr, %..rawptr* %135, align 8
	%137 = bitcast %..rawptr %136 to i64*
	%138 = load i64, i64* %137, align 8
	store i64 %138, i64* %10
	%139 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%140 = load i64, i64* %10, align 8
	%141 = icmp ne i64 %140, 0
	%142 = zext i1 %141 to i8
	%143 = load i32, i32* %2, align 4
	%144 = trunc i8 %142 to i1
	call void @fmt.fmt_bool(%fmt.Fmt_Info* %139, i1 %144, i32 %143, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-18:
	%145 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%146 = load %..typeid, %..typeid* %145, align 8
	%147 = icmp eq %..typeid %146, 4755801206503243833
	br i1 %147, label %typeswitch.body-21, label %typeswitch.next-20

typeswitch.body-19:
	%148 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%149 = load %..rawptr, %..rawptr* %148, align 8
	%150 = bitcast %..rawptr %149 to %..any*
	%151 = load %..any, %..any* %150, align 8
	store %..any %151, %..any* %11
	%152 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%153 = load %..any, %..any* %11, align 8
	%154 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Fmt_Info* %152, %..any %153, i32 %154, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-20:
	%155 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%156 = load %..typeid, %..typeid* %155, align 8
	%157 = icmp eq %..typeid %156, 216172782113783891
	br i1 %157, label %typeswitch.body-23, label %typeswitch.next-22

typeswitch.body-21:
	%158 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%159 = load %..rawptr, %..rawptr* %158, align 8
	%160 = bitcast %..rawptr %159 to i32*
	%161 = load i32, i32* %160, align 4
	store i32 %161, i32* %12
	%162 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%163 = load i32, i32* %12, align 4
	%164 = load i32, i32* %2, align 4
	call void @fmt.fmt_rune(%fmt.Fmt_Info* %162, i32 %163, i32 %164, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-22:
	%165 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%166 = load %..typeid, %..typeid* %165, align 8
	%167 = icmp eq %..typeid %166, 216172782113783892
	br i1 %167, label %typeswitch.body-25, label %typeswitch.next-24

typeswitch.body-23:
	%168 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%169 = load %..rawptr, %..rawptr* %168, align 8
	%170 = bitcast %..rawptr %169 to float*
	%171 = load float, float* %170, align 4
	store float %171, float* %13
	%172 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%173 = load float, float* %13, align 4
	%174 = fpext float %173 to double
	%175 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Fmt_Info* %172, double %174, i64 32, i32 %175, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-24:
	%176 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%177 = load %..typeid, %..typeid* %176, align 8
	%178 = icmp eq %..typeid %177, 288230376151711829
	br i1 %178, label %typeswitch.body-27, label %typeswitch.next-26

typeswitch.body-25:
	%179 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%180 = load %..rawptr, %..rawptr* %179, align 8
	%181 = bitcast %..rawptr %180 to double*
	%182 = load double, double* %181, align 8
	store double %182, double* %14
	%183 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%184 = load double, double* %14, align 8
	%185 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Fmt_Info* %183, double %184, i64 64, i32 %185, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-26:
	%186 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%187 = load %..typeid, %..typeid* %186, align 8
	%188 = icmp eq %..typeid %187, 288230376151711830
	br i1 %188, label %typeswitch.body-29, label %typeswitch.next-28

typeswitch.body-27:
	%189 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%190 = load %..rawptr, %..rawptr* %189, align 8
	%191 = bitcast %..rawptr %190 to %..complex64*
	%192 = load %..complex64, %..complex64* %191, align 4
	store %..complex64 %192, %..complex64* %15
	%193 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%194 = load %..complex64, %..complex64* %15, align 4
	%195 = bitcast %..complex128* %16 to %..rawptr
	%196 = call %..rawptr @mem.zero(%..rawptr %195, i64 16) noinline
	store %..complex128 zeroinitializer, %..complex128* %16
	%197 = extractvalue %..complex64 %194, 0
	%198 = fpext float %197 to double
	%199 = extractvalue %..complex64 %194, 1
	%200 = fpext float %199 to double
	%201 = getelementptr inbounds %..complex128, %..complex128* %16, i64 0, i32 0
	store double %198, double* %201
	%202 = getelementptr inbounds %..complex128, %..complex128* %16, i64 0, i32 1
	store double %200, double* %202
	%203 = load %..complex128, %..complex128* %16, align 8
	%204 = load i32, i32* %2, align 4
	%205 = bitcast %..complex128* %17 to %..rawptr
	%206 = call %..rawptr @mem.zero(%..rawptr %205, i64 16) noinline
	store %..complex128 zeroinitializer, %..complex128* %17
	store %..complex128 %203, %..complex128* %17
	call void @fmt.fmt_complex(%fmt.Fmt_Info* %193, %..complex128* %17, i64 64, i32 %204, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-28:
	%207 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%208 = load %..typeid, %..typeid* %207, align 8
	%209 = icmp eq %..typeid %208, 4683743612465315898
	br i1 %209, label %typeswitch.body-31, label %typeswitch.next-30

typeswitch.body-29:
	%210 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%211 = load %..rawptr, %..rawptr* %210, align 8
	%212 = bitcast %..rawptr %211 to %..complex128*
	%213 = load %..complex128, %..complex128* %212, align 8
	store %..complex128 %213, %..complex128* %18
	%214 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%215 = load %..complex128, %..complex128* %18, align 8
	%216 = load i32, i32* %2, align 4
	%217 = bitcast %..complex128* %19 to %..rawptr
	%218 = call %..rawptr @mem.zero(%..rawptr %217, i64 16) noinline
	store %..complex128 zeroinitializer, %..complex128* %19
	store %..complex128 %215, %..complex128* %19
	call void @fmt.fmt_complex(%fmt.Fmt_Info* %214, %..complex128* %19, i64 128, i32 %216, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-30:
	%219 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%220 = load %..typeid, %..typeid* %219, align 8
	%221 = icmp eq %..typeid %220, 72057594037927939
	br i1 %221, label %typeswitch.body-33, label %typeswitch.next-32

typeswitch.body-31:
	%222 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%223 = load %..rawptr, %..rawptr* %222, align 8
	%224 = bitcast %..rawptr %223 to i8*
	%225 = load i8, i8* %224, align 1
	store i8 %225, i8* %20
	%226 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%227 = load i8, i8* %20, align 1
	%228 = sext i8 %227 to i64
	%229 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %226, i64 %228, i1 true, i64 8, i32 %229, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-32:
	%230 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%231 = load %..typeid, %..typeid* %230, align 8
	%232 = icmp eq %..typeid %231, 4683743612465315899
	br i1 %232, label %typeswitch.body-35, label %typeswitch.next-34

typeswitch.body-33:
	%233 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%234 = load %..rawptr, %..rawptr* %233, align 8
	%235 = bitcast %..rawptr %234 to i8*
	%236 = load i8, i8* %235, align 1
	store i8 %236, i8* %21
	%237 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%238 = load i8, i8* %21, align 1
	%239 = zext i8 %238 to i64
	%240 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %237, i64 %239, i1 false, i64 8, i32 %240, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-34:
	%241 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%242 = load %..typeid, %..typeid* %241, align 8
	%243 = icmp eq %..typeid %242, 72057594037927998
	br i1 %243, label %typeswitch.body-37, label %typeswitch.next-36

typeswitch.body-35:
	%244 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%245 = load %..rawptr, %..rawptr* %244, align 8
	%246 = bitcast %..rawptr %245 to i16*
	%247 = load i16, i16* %246, align 2
	store i16 %247, i16* %22
	%248 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%249 = load i16, i16* %22, align 2
	%250 = sext i16 %249 to i64
	%251 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %248, i64 %250, i1 true, i64 16, i32 %251, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-36:
	%252 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%253 = load %..typeid, %..typeid* %252, align 8
	%254 = icmp eq %..typeid %253, 4683743612465315900
	br i1 %254, label %typeswitch.body-39, label %typeswitch.next-38

typeswitch.body-37:
	%255 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%256 = load %..rawptr, %..rawptr* %255, align 8
	%257 = bitcast %..rawptr %256 to i16*
	%258 = load i16, i16* %257, align 2
	store i16 %258, i16* %23
	%259 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%260 = load i16, i16* %23, align 2
	%261 = zext i16 %260 to i64
	%262 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %259, i64 %261, i1 false, i64 16, i32 %262, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-38:
	%263 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%264 = load %..typeid, %..typeid* %263, align 8
	%265 = icmp eq %..typeid %264, 72057594037927999
	br i1 %265, label %typeswitch.body-41, label %typeswitch.next-40

typeswitch.body-39:
	%266 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%267 = load %..rawptr, %..rawptr* %266, align 8
	%268 = bitcast %..rawptr %267 to i32*
	%269 = load i32, i32* %268, align 4
	store i32 %269, i32* %24
	%270 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%271 = load i32, i32* %24, align 4
	%272 = sext i32 %271 to i64
	%273 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %270, i64 %272, i1 true, i64 32, i32 %273, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-40:
	%274 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%275 = load %..typeid, %..typeid* %274, align 8
	%276 = icmp eq %..typeid %275, 4683743612465315901
	br i1 %276, label %typeswitch.body-43, label %typeswitch.next-42

typeswitch.body-41:
	%277 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%278 = load %..rawptr, %..rawptr* %277, align 8
	%279 = bitcast %..rawptr %278 to i32*
	%280 = load i32, i32* %279, align 4
	store i32 %280, i32* %25
	%281 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%282 = load i32, i32* %25, align 4
	%283 = zext i32 %282 to i64
	%284 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %281, i64 %283, i1 false, i64 32, i32 %284, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-42:
	%285 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%286 = load %..typeid, %..typeid* %285, align 8
	%287 = icmp eq %..typeid %286, 72057594037928000
	br i1 %287, label %typeswitch.body-45, label %typeswitch.next-44

typeswitch.body-43:
	%288 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%289 = load %..rawptr, %..rawptr* %288, align 8
	%290 = bitcast %..rawptr %289 to i64*
	%291 = load i64, i64* %290, align 8
	store i64 %291, i64* %26
	%292 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%293 = load i64, i64* %26, align 8
	%294 = bitcast i64 %293 to i64
	%295 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %292, i64 %294, i1 true, i64 64, i32 %295, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-44:
	%296 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%297 = load %..typeid, %..typeid* %296, align 8
	%298 = icmp eq %..typeid %297, 4683743612465315846
	br i1 %298, label %typeswitch.body-47, label %typeswitch.next-46

typeswitch.body-45:
	%299 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%300 = load %..rawptr, %..rawptr* %299, align 8
	%301 = bitcast %..rawptr %300 to i64*
	%302 = load i64, i64* %301, align 8
	store i64 %302, i64* %27
	%303 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%304 = load i64, i64* %27, align 8
	%305 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %303, i64 %304, i1 false, i64 64, i32 %305, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-46:
	%306 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%307 = load %..typeid, %..typeid* %306, align 8
	%308 = icmp eq %..typeid %307, 72057594037928001
	br i1 %308, label %typeswitch.body-49, label %typeswitch.next-48

typeswitch.body-47:
	%309 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%310 = load %..rawptr, %..rawptr* %309, align 8
	%311 = bitcast %..rawptr %310 to i64*
	%312 = load i64, i64* %311, align 8
	store i64 %312, i64* %28
	%313 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%314 = load i64, i64* %28, align 8
	%315 = bitcast i64 %314 to i64
	%316 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %313, i64 %315, i1 true, i64 64, i32 %316, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-48:
	%317 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%318 = load %..typeid, %..typeid* %317, align 8
	%319 = icmp eq %..typeid %318, 72057594037927982
	br i1 %319, label %typeswitch.body-51, label %typeswitch.next-50

typeswitch.body-49:
	%320 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%321 = load %..rawptr, %..rawptr* %320, align 8
	%322 = bitcast %..rawptr %321 to i64*
	%323 = load i64, i64* %322, align 8
	store i64 %323, i64* %29
	%324 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%325 = load i64, i64* %29, align 8
	%326 = bitcast i64 %325 to i64
	%327 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %324, i64 %326, i1 false, i64 64, i32 %327, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-50:
	%328 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%329 = load %..typeid, %..typeid* %328, align 8
	%330 = icmp eq %..typeid %329, 360287970189639684
	br i1 %330, label %typeswitch.body-53, label %typeswitch.next-52

typeswitch.body-51:
	%331 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%332 = load %..rawptr, %..rawptr* %331, align 8
	%333 = bitcast %..rawptr %332 to i64*
	%334 = load i64, i64* %333, align 8
	store i64 %334, i64* %30
	%335 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%336 = load i64, i64* %30, align 8
	%337 = bitcast i64 %336 to i64
	%338 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Fmt_Info* %335, i64 %337, i1 false, i64 64, i32 %338, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-52:
	%339 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%340 = load %..typeid, %..typeid* %339, align 8
	%341 = icmp eq %..typeid %340, 4971973988617027671
	br i1 %341, label %typeswitch.body-55, label %typeswitch.next-54

typeswitch.body-53:
	%342 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%343 = load %..rawptr, %..rawptr* %342, align 8
	%344 = bitcast %..rawptr %343 to %..string*
	%345 = load %..string, %..string* %344, align 8
	store %..string %345, %..string* %31
	%346 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%347 = load %..string, %..string* %31, align 8
	%348 = load i32, i32* %2, align 4
	call void @fmt.fmt_string(%fmt.Fmt_Info* %346, %..string %347, i32 %348, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-54:
	%349 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 1
	%350 = load %..typeid, %..typeid* %349, align 8
	%351 = icmp eq %..typeid %350, 7
	br i1 %351, label %typeswitch.body-57, label %typeswitch.next-56

typeswitch.body-55:
	%352 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%353 = load %..rawptr, %..rawptr* %352, align 8
	%354 = bitcast %..rawptr %353 to i8**
	%355 = load i8*, i8** %354, align 8
	store i8* %355, i8** %32
	%356 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%357 = load i8*, i8** %32, align 8
	%358 = load i32, i32* %2, align 4
	call void @fmt.fmt_cstring(%fmt.Fmt_Info* %356, i8* %357, i32 %358, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.next-56:
	store %..any %78, %..any* %34
	%359 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%360 = load %..any, %..any* %1, align 8
	%361 = load i32, i32* %2, align 4
	call void @fmt.fmt_value(%fmt.Fmt_Info* %359, %..any %360, i32 %361, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.body-57:
	%362 = getelementptr inbounds %..any, %..any* %5, i64 0, i32 0
	%363 = load %..rawptr, %..rawptr* %362, align 8
	%364 = bitcast %..rawptr %363 to %..typeid*
	%365 = load %..typeid, %..typeid* %364, align 8
	store %..typeid %365, %..typeid* %33
	; SelectorExpr
	%366 = load %fmt.Fmt_Info*, %fmt.Fmt_Info** %0, align 8
	%367 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %366, i64 0
	%368 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %367, i64 0, i32 12
	%369 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %368, align 8
	%370 = load %..typeid, %..typeid* %33, align 8
	call void @fmt.write_typeid({i8*, i64, i64, %mem.Allocator}* %369, %..typeid %370, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %typeswitch.done-58

typeswitch.done-58:
	ret void
}

define %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* %buf, {%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %fmt.Fmt_Info, align 16
	%2 = alloca i8, align 16
	%3 = alloca %..any, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i8, align 16
	%8 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	%9 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; fi
	%10 = bitcast %fmt.Fmt_Info* %1 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 64) noinline
	store %fmt.Fmt_Info zeroinitializer, %fmt.Fmt_Info* %1
	; prev_string
	store i8 0, i8* %2
	; AssignStmt
	; SelectorExpr
	%12 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1, i64 0, i32 12
	%13 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	store {i8*, i64, i64, %mem.Allocator}* %13, {i8*, i64, i64, %mem.Allocator}** %12
	; RangeStmt
	; arg
	%14 = bitcast %..any* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 16) noinline
	store %..any zeroinitializer, %..any* %3
	; i
	%16 = bitcast i64* %4 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	%18 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%19 = bitcast i64* %5 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	%21 = extractvalue {%..any*, i64} %18, 1
	store i64 %21, i64* %5
	%22 = bitcast i64* %6 to %..rawptr
	%23 = call %..rawptr @mem.zero(%..rawptr %22, i64 8) noinline
	store i64 zeroinitializer, i64* %6
	store i64 -1, i64* %6
	br label %for.index.loop-1

for.index.loop-1:
	%24 = load i64, i64* %6, align 8
	%25 = add i64 %24, 1
	store i64 %25, i64* %6
	%26 = load i64, i64* %5, align 8
	%27 = icmp slt i64 %25, %26
	br i1 %27, label %for.index.body-2, label %for.index.done-9

for.index.body-2:
	%28 = load i64, i64* %6, align 8
	%29 = extractvalue {%..any*, i64} %18, 0
	%30 = getelementptr inbounds %..any, %..any* %29, i64 %28
	%31 = load %..any, %..any* %30, align 8
	store %..any %31, %..any* %3
	store i64 %28, i64* %4
	; is_string
	%32 = load %..any, %..any* %3, align 8
	%33 = extractvalue %..any %32, 0
	%34 = extractvalue %..any %32, 1
	%35 = icmp ne %..rawptr %33, null
	%36 = icmp ne %..typeid %34, 0
	%37 = zext i1 %35 to i8
	%38 = zext i1 %36 to i8
	%39 = and i8 %37, %38
	%40 = load %..any, %..any* %3, align 8
	%41 = extractvalue %..any %40, 0
	%42 = extractvalue %..any %40, 1
	%43 = icmp ne %..rawptr %41, null
	%44 = icmp ne %..typeid %42, 0
	%45 = zext i1 %43 to i8
	%46 = zext i1 %44 to i8
	%47 = and i8 %45, %46
	%48 = trunc i8 %47 to i1
	br i1 %48, label %logical.cmp.rhs-3, label %logical.cmp.done-4

logical.cmp.rhs-3:
	; SelectorExpr
	; SelectorExpr
	%49 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	%50 = load %..typeid, %..typeid* %49, align 8
	%51 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %50)
	%52 = call i8 @types.is_string(%runtime.Type_Info* %51, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %logical.cmp.done-4

logical.cmp.done-4:
	%53 = phi i8 [ 0, %for.index.body-2 ], [ %52, %logical.cmp.rhs-3 ]
	store i8 %53, i8* %7
	; IfStmt
	%54 = load i64, i64* %4, align 8
	%55 = icmp sgt i64 %54, 0
	%56 = zext i1 %55 to i8
	%57 = trunc i8 %56 to i1
	br i1 %57, label %cmp.and-5, label %if.done-8

cmp.and-5:
	%58 = load i8, i8* %7, align 1
	%59 = trunc i8 %58 to i1
	br i1 %59, label %if.done-8, label %cmp.and-6

cmp.and-6:
	%60 = load i8, i8* %2, align 1
	%61 = trunc i8 %60 to i1
	br i1 %61, label %if.done-8, label %if.then-7

if.then-7:
	%62 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %62, i8 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-8

if.done-8:
	; IndexExpr
	%63 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%64 = extractvalue {%..any*, i64} %63, 0
	%65 = load i64, i64* %4, align 8
	%66 = extractvalue {%..any*, i64} %63, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$149, i64 0, i32 0), i64 53}, i64 1246, i64 23, i64 %65, i64 %66)
	%67 = getelementptr inbounds %..any, %..any* %64, i64 %65
	%68 = load %..any, %..any* %67, align 8
	call void @fmt.fmt_value(%fmt.Fmt_Info* %1, %..any %68, i32 118, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	%69 = load i8, i8* %7, align 1
	store i8 %69, i8* %2
	br label %for.index.loop-1

for.index.done-9:
	; ReturnStmt
	%70 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%71 = getelementptr inbounds {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %70, i64 0
	%72 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %71, align 8
	%73 = bitcast {i8*, i64, i64, %mem.Allocator}* %8 to %..rawptr
	%74 = call %..rawptr @mem.zero(%..rawptr %73, i64 40) noinline
	store {i8*, i64, i64, %mem.Allocator} zeroinitializer, {i8*, i64, i64, %mem.Allocator}* %8
	store {i8*, i64, i64, %mem.Allocator} %72, {i8*, i64, i64, %mem.Allocator}* %8
	%75 = call %..string @fmt.to_string({i8*, i64, i64, %mem.Allocator}* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret %..string %75
}

define %..string @fmt.sbprintln({i8*, i64, i64, %mem.Allocator}* %buf, {%..any*, i64}* %args, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %fmt.Fmt_Info, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	store {i8*, i64, i64, %mem.Allocator}* %buf, {i8*, i64, i64, %mem.Allocator}** %0
	%6 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	; fi
	%7 = bitcast %fmt.Fmt_Info* %1 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 64) noinline
	store %fmt.Fmt_Info zeroinitializer, %fmt.Fmt_Info* %1
	; AssignStmt
	; SelectorExpr
	%9 = getelementptr inbounds %fmt.Fmt_Info, %fmt.Fmt_Info* %1, i64 0, i32 12
	%10 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	store {i8*, i64, i64, %mem.Allocator}* %10, {i8*, i64, i64, %mem.Allocator}** %9
	; RangeStmt
	; i
	%11 = bitcast i64* %2 to %..rawptr
	%12 = call %..rawptr @mem.zero(%..rawptr %11, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	%13 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%14 = bitcast i64* %3 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%16 = extractvalue {%..any*, i64} %13, 1
	store i64 %16, i64* %3
	%17 = bitcast i64* %4 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	store i64 -1, i64* %4
	br label %for.index.loop-1

for.index.loop-1:
	%19 = load i64, i64* %4, align 8
	%20 = add i64 %19, 1
	store i64 %20, i64* %4
	%21 = load i64, i64* %3, align 8
	%22 = icmp slt i64 %20, %21
	br i1 %22, label %for.index.body-2, label %for.index.done-5

for.index.body-2:
	%23 = load i64, i64* %4, align 8
	store i64 %23, i64* %2
	; IfStmt
	%24 = load i64, i64* %2, align 8
	%25 = icmp sgt i64 %24, 0
	%26 = zext i1 %25 to i8
	%27 = trunc i8 %26 to i1
	br i1 %27, label %if.then-3, label %if.done-4

if.then-3:
	%28 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %28, i8 32, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; IndexExpr
	%29 = load {%..any*, i64}, {%..any*, i64}* %args, align 8
	%30 = extractvalue {%..any*, i64} %29, 0
	%31 = load i64, i64* %2, align 8
	%32 = extractvalue {%..any*, i64} %29, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$14a, i64 0, i32 0), i64 53}, i64 1259, i64 23, i64 %31, i64 %32)
	%33 = getelementptr inbounds %..any, %..any* %30, i64 %31
	%34 = load %..any, %..any* %33, align 8
	call void @fmt.fmt_value(%fmt.Fmt_Info* %1, %..any %34, i32 118, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-1

for.index.done-5:
	%35 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	call void @fmt.write_byte({i8*, i64, i64, %mem.Allocator}* %35, i8 10, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%36 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%37 = getelementptr inbounds {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %36, i64 0
	%38 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %37, align 8
	%39 = bitcast {i8*, i64, i64, %mem.Allocator}* %5 to %..rawptr
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 40) noinline
	store {i8*, i64, i64, %mem.Allocator} zeroinitializer, {i8*, i64, i64, %mem.Allocator}* %5
	store {i8*, i64, i64, %mem.Allocator} %38, {i8*, i64, i64, %mem.Allocator}* %5
	%41 = call %..string @fmt.to_string({i8*, i64, i64, %mem.Allocator}* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret %..string %41
}

define void @wbml.parse_value(%lexer.Lexer* %lexer, %lexer.Token* %parent_token, %..rawptr %data, %runtime.Type_Info* %ti, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %lexer.Lexer*, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca %lexer.Token_Symbol, align 16
	%4 = alloca %lexer.Token, align 16
	%5 = alloca i8, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca %lexer.Token_Symbol, align 16
	%9 = alloca i8, align 16
	%10 = alloca {%lexer.Token_Symbol, i8}, align 16
	%11 = alloca %lexer.Token_Identifier, align 16
	%12 = alloca i8, align 16
	%13 = alloca {%lexer.Token_Identifier, i8}, align 16
	%14 = alloca %runtime.Source_Code_Location, align 16
	%15 = alloca %..rawptr, align 16
	%16 = alloca %runtime.Type_Info*, align 16
	%17 = alloca %runtime.Type_Info_Struct*, align 16
	%18 = alloca %runtime.Type_Info_Named*, align 16
	%19 = alloca %runtime.Type_Info_Struct*, align 16
	%20 = alloca {[0 x <8 x i8>], [72 x i8], i8}*, align 16
	%21 = alloca %..any, align 16
	%22 = alloca {%..any*, i64}, align 16
	%23 = alloca [1 x %..any], align 16
	%24 = alloca {%..any*, i64}, align 16
	%25 = alloca %runtime.Source_Code_Location, align 16
	%26 = alloca %runtime.Source_Code_Location, align 16
	%27 = alloca %..string, align 16
	%28 = alloca i64, align 16
	%29 = alloca i64, align 16
	%30 = alloca i64, align 16
	%31 = alloca %..string, align 16
	%32 = alloca %..any, align 16
	%33 = alloca %..any, align 16
	%34 = alloca {%..any*, i64}, align 16
	%35 = alloca [2 x %..any], align 16
	%36 = alloca {%..any*, i64}, align 16
	%37 = alloca %runtime.Source_Code_Location, align 16
	%38 = alloca %lexer.Token, align 16
	%39 = alloca i8, align 16
	%40 = alloca %runtime.Source_Code_Location, align 16
	%41 = alloca %runtime.Source_Code_Location, align 16
	%42 = alloca %lexer.Token, align 16
	%43 = alloca %runtime.Type_Info_Array, align 16
	%44 = alloca i64, align 16
	%45 = alloca %runtime.Source_Code_Location, align 16
	%46 = alloca %lexer.Token, align 16
	%47 = alloca i8, align 16
	%48 = alloca %runtime.Source_Code_Location, align 16
	%49 = alloca %runtime.Source_Code_Location, align 16
	%50 = alloca %lexer.Token_Symbol, align 16
	%51 = alloca i8, align 16
	%52 = alloca {%lexer.Token_Symbol, i8}, align 16
	%53 = alloca %..string, align 16
	%54 = alloca %..any, align 16
	%55 = alloca %..any, align 16
	%56 = alloca {%..any*, i64}, align 16
	%57 = alloca [2 x %..any], align 16
	%58 = alloca {%..any*, i64}, align 16
	%59 = alloca %runtime.Source_Code_Location, align 16
	%60 = alloca %lexer.Token, align 16
	%61 = alloca %runtime.Type_Info_Dynamic_Array, align 16
	%62 = alloca {i8*, i64}, align 16
	%63 = alloca %mem.Allocator, align 16
	%64 = alloca %runtime.Source_Code_Location, align 16
	%65 = alloca i64, align 16
	%66 = alloca i64, align 16
	%67 = alloca %lexer.Token, align 16
	%68 = alloca i8, align 16
	%69 = alloca %runtime.Source_Code_Location, align 16
	%70 = alloca %runtime.Source_Code_Location, align 16
	%71 = alloca %lexer.Token_Symbol, align 16
	%72 = alloca i8, align 16
	%73 = alloca {%lexer.Token_Symbol, i8}, align 16
	%74 = alloca %..string, align 16
	%75 = alloca %..any, align 16
	%76 = alloca %..any, align 16
	%77 = alloca {%..any*, i64}, align 16
	%78 = alloca [2 x %..any], align 16
	%79 = alloca {%..any*, i64}, align 16
	%80 = alloca %runtime.Source_Code_Location, align 16
	%81 = alloca {i8*, i64}, align 16
	%82 = alloca %mem.Allocator, align 16
	%83 = alloca %runtime.Source_Code_Location, align 16
	%84 = alloca {i8*, i64}, align 16
	%85 = alloca %mem.Allocator, align 16
	%86 = alloca %runtime.Source_Code_Location, align 16
	%87 = alloca %lexer.Token, align 16
	%88 = alloca %mem.Raw_Dynamic_Array, align 16
	%89 = alloca %runtime.Type_Info_Slice, align 16
	%90 = alloca {i8*, i64}, align 16
	%91 = alloca %mem.Allocator, align 16
	%92 = alloca %runtime.Source_Code_Location, align 16
	%93 = alloca i64, align 16
	%94 = alloca i64, align 16
	%95 = alloca %lexer.Token, align 16
	%96 = alloca i8, align 16
	%97 = alloca %runtime.Source_Code_Location, align 16
	%98 = alloca %runtime.Source_Code_Location, align 16
	%99 = alloca %lexer.Token_Symbol, align 16
	%100 = alloca i8, align 16
	%101 = alloca {%lexer.Token_Symbol, i8}, align 16
	%102 = alloca %..string, align 16
	%103 = alloca %..any, align 16
	%104 = alloca %..any, align 16
	%105 = alloca {%..any*, i64}, align 16
	%106 = alloca [2 x %..any], align 16
	%107 = alloca {%..any*, i64}, align 16
	%108 = alloca %runtime.Source_Code_Location, align 16
	%109 = alloca {i8*, i64}, align 16
	%110 = alloca %mem.Allocator, align 16
	%111 = alloca %runtime.Source_Code_Location, align 16
	%112 = alloca {i8*, i64}, align 16
	%113 = alloca %mem.Allocator, align 16
	%114 = alloca %runtime.Source_Code_Location, align 16
	%115 = alloca %lexer.Token, align 16
	%116 = alloca %mem.Raw_Slice, align 16
	%117 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	%118 = alloca %..any, align 16
	%119 = alloca {%..any*, i64}, align 16
	%120 = alloca [1 x %..any], align 16
	%121 = alloca {%..any*, i64}, align 16
	%122 = alloca %runtime.Source_Code_Location, align 16
	%123 = alloca %lexer.Token_String, align 16
	%124 = alloca %lexer.Token_Identifier, align 16
	%125 = alloca %runtime.Source_Code_Location, align 16
	%126 = alloca %lexer.Token_Number, align 16
	%127 = alloca %runtime.Type_Info_Integer, align 16
	%128 = alloca %..any, align 16
	%129 = alloca {%..any*, i64}, align 16
	%130 = alloca [1 x %..any], align 16
	%131 = alloca {%..any*, i64}, align 16
	%132 = alloca %runtime.Source_Code_Location, align 16
	%133 = alloca %..any, align 16
	%134 = alloca {%..any*, i64}, align 16
	%135 = alloca [1 x %..any], align 16
	%136 = alloca {%..any*, i64}, align 16
	%137 = alloca %runtime.Source_Code_Location, align 16
	%138 = alloca %runtime.Type_Info_Float, align 16
	%139 = alloca %..any, align 16
	%140 = alloca {%..any*, i64}, align 16
	%141 = alloca [1 x %..any], align 16
	%142 = alloca {%..any*, i64}, align 16
	%143 = alloca %runtime.Source_Code_Location, align 16
	%144 = alloca {[0 x <8 x i8>], [72 x i8], i8}, align 16
	%145 = alloca %..any, align 16
	%146 = alloca {%..any*, i64}, align 16
	%147 = alloca [1 x %..any], align 16
	%148 = alloca {%..any*, i64}, align 16
	%149 = alloca %runtime.Source_Code_Location, align 16
	store %lexer.Lexer* %lexer, %lexer.Lexer** %0
	%150 = load %lexer.Token, %lexer.Token* %parent_token, align 8
	store %..rawptr %data, %..rawptr* %1
	store %runtime.Type_Info* %ti, %runtime.Type_Info** %2
	; TypeSwitchStmt
	; SelectorExpr
	%151 = getelementptr inbounds %lexer.Token, %lexer.Token* %parent_token, i64 0, i32 1
	%152 = load {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %151, align 8
	; get union's tag
	%153 = getelementptr inbounds {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %151, i64 0, i32 2 ; UnionTagPtr
	%154 = load i8, i8* %153, align 1
	%155 = bitcast {[0 x <8 x i8>], [32 x i8], i8}* %151 to %..rawptr
	%156 = icmp eq i8 %154, 4
	br i1 %156, label %typeswitch.body-2, label %typeswitch.next-1

typeswitch.next-1:
	%157 = icmp eq i8 %154, 3
	br i1 %157, label %typeswitch.body-73, label %typeswitch.next-72

typeswitch.body-2:
	%158 = bitcast %..rawptr %155 to %lexer.Token_Symbol*
	%159 = load %lexer.Token_Symbol, %lexer.Token_Symbol* %158, align 4
	store %lexer.Token_Symbol %159, %lexer.Token_Symbol* %3
	; SwitchStmt
	; SelectorExpr
	%160 = getelementptr inbounds %lexer.Token_Symbol, %lexer.Token_Symbol* %3, i64 0, i32 0
	%161 = load i32, i32* %160, align 4
	%162 = icmp eq i32 %161, 123
	br i1 %162, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%163 = icmp eq i32 %161, 91
	br i1 %163, label %switch.fall.body-24, label %switch.case.next-23

switch.case.body-4:
	; ForStmt
	br label %for.body-5

for.body-5:
	; token
	; ok
	%164 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%165 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%166 = call %..rawptr @mem.zero(%..rawptr %165, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$14b, i64 0, i32 0), i64 67}, i64 161, i64 20, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$14c, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	%167 = call {%lexer.Token, i8} @lexer.get_next_token(%lexer.Lexer* %164, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%168 = extractvalue {%lexer.Token, i8} %167, 0
	%169 = extractvalue {%lexer.Token, i8} %167, 1
	store %lexer.Token %168, %lexer.Token* %4
	store i8 %169, i8* %5
	%170 = load i8, i8* %5, align 1
	%171 = trunc i8 %170 to i1
	%172 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%173 = call %..rawptr @mem.zero(%..rawptr %172, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$14d, i64 0, i32 0), i64 67}, i64 161, i64 43, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$14e, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %7
	%174 = call i8 @runtime.assert(i1 %171, %..string zeroinitializer, %runtime.Source_Code_Location* %7)
	; IfStmt
	; right_curly
	; ok2
	; SelectorExpr
	%175 = getelementptr inbounds %lexer.Token, %lexer.Token* %4, i64 0, i32 1
	%176 = load {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %175, align 8
	; cast - union_cast
	%177 = bitcast {%lexer.Token_Symbol, i8}* %10 to %..rawptr
	%178 = call %..rawptr @mem.zero(%..rawptr %177, i64 8) noinline
	store {%lexer.Token_Symbol, i8} zeroinitializer, {%lexer.Token_Symbol, i8}* %10
	%179 = getelementptr inbounds {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %175, i64 0, i32 2 ; UnionTagPtr
	%180 = load i8, i8* %179, align 1
	%181 = icmp eq i8 %180, 4
	br i1 %181, label %union_cast.ok-6, label %union_cast.end-7

union_cast.ok-6:
	%182 = getelementptr inbounds {%lexer.Token_Symbol, i8}, {%lexer.Token_Symbol, i8}* %10, i64 0, i32 0
	%183 = getelementptr inbounds {%lexer.Token_Symbol, i8}, {%lexer.Token_Symbol, i8}* %10, i64 0, i32 1
	%184 = bitcast {[0 x <8 x i8>], [32 x i8], i8}* %175 to %lexer.Token_Symbol*
	%185 = load %lexer.Token_Symbol, %lexer.Token_Symbol* %184, align 4
	store %lexer.Token_Symbol %185, %lexer.Token_Symbol* %182
	store i8 1, i8* %183
	br label %union_cast.end-7

union_cast.end-7:
	%186 = load {%lexer.Token_Symbol, i8}, {%lexer.Token_Symbol, i8}* %10, align 4
	%187 = extractvalue {%lexer.Token_Symbol, i8} %186, 0
	%188 = extractvalue {%lexer.Token_Symbol, i8} %186, 1
	store %lexer.Token_Symbol %187, %lexer.Token_Symbol* %8
	store i8 %188, i8* %9
	%189 = load i8, i8* %9, align 1
	%190 = trunc i8 %189 to i1
	br i1 %190, label %cmp.and-8, label %if.done-10

cmp.and-8:
	; SelectorExpr
	%191 = getelementptr inbounds %lexer.Token_Symbol, %lexer.Token_Symbol* %8, i64 0, i32 0
	%192 = load i32, i32* %191, align 4
	%193 = icmp eq i32 %192, 125
	%194 = zext i1 %193 to i8
	%195 = trunc i8 %194 to i1
	br i1 %195, label %if.then-9, label %if.done-10

if.then-9:
	; break
	br label %switch.done-71

if.done-10:
	; variable_name
	; ok2
	; SelectorExpr
	%196 = getelementptr inbounds %lexer.Token, %lexer.Token* %4, i64 0, i32 1
	%197 = load {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %196, align 8
	; cast - union_cast
	%198 = bitcast {%lexer.Token_Identifier, i8}* %13 to %..rawptr
	%199 = call %..rawptr @mem.zero(%..rawptr %198, i64 24) noinline
	store {%lexer.Token_Identifier, i8} zeroinitializer, {%lexer.Token_Identifier, i8}* %13
	%200 = getelementptr inbounds {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %196, i64 0, i32 2 ; UnionTagPtr
	%201 = load i8, i8* %200, align 1
	%202 = icmp eq i8 %201, 1
	br i1 %202, label %union_cast.ok-11, label %union_cast.end-12

union_cast.ok-11:
	%203 = getelementptr inbounds {%lexer.Token_Identifier, i8}, {%lexer.Token_Identifier, i8}* %13, i64 0, i32 0
	%204 = getelementptr inbounds {%lexer.Token_Identifier, i8}, {%lexer.Token_Identifier, i8}* %13, i64 0, i32 1
	%205 = bitcast {[0 x <8 x i8>], [32 x i8], i8}* %196 to %lexer.Token_Identifier*
	%206 = load %lexer.Token_Identifier, %lexer.Token_Identifier* %205, align 8
	store %lexer.Token_Identifier %206, %lexer.Token_Identifier* %203
	store i8 1, i8* %204
	br label %union_cast.end-12

union_cast.end-12:
	%207 = load {%lexer.Token_Identifier, i8}, {%lexer.Token_Identifier, i8}* %13, align 8
	%208 = extractvalue {%lexer.Token_Identifier, i8} %207, 0
	%209 = extractvalue {%lexer.Token_Identifier, i8} %207, 1
	store %lexer.Token_Identifier %208, %lexer.Token_Identifier* %11
	store i8 %209, i8* %12
	%210 = load i8, i8* %12, align 1
	%211 = trunc i8 %210 to i1
	%212 = bitcast %runtime.Source_Code_Location* %14 to %..rawptr
	%213 = call %..rawptr @mem.zero(%..rawptr %212, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %14
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$14f, i64 0, i32 0), i64 67}, i64 167, i64 7, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$150, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %14
	%214 = call i8 @runtime.assert(i1 %211, %..string zeroinitializer, %runtime.Source_Code_Location* %14)
	; field_ptr
	store %..rawptr zeroinitializer, %..rawptr* %15
	; field_ti
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %16
	; struct_kind
	%215 = bitcast %runtime.Type_Info_Struct** %17 to %..rawptr
	%216 = call %..rawptr @mem.zero(%..rawptr %215, i64 8) noinline
	store %runtime.Type_Info_Struct* zeroinitializer, %runtime.Type_Info_Struct** %17
	; TypeSwitchStmt
	; SelectorExpr
	%217 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%218 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %217, i64 0
	%219 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %218, i64 0, i32 3
	; get union's tag
	%220 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %219, i64 0, i32 2 ; UnionTagPtr
	%221 = load i8, i8* %220, align 1
	%222 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %219 to %..rawptr
	%223 = icmp eq i8 %221, 1
	br i1 %223, label %typeswitch.body-14, label %typeswitch.next-13

typeswitch.next-13:
	%224 = icmp eq i8 %221, 16
	br i1 %224, label %typeswitch.body-16, label %typeswitch.next-15

typeswitch.body-14:
	%225 = bitcast %..rawptr %222 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named* %225, %runtime.Type_Info_Named** %18
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%226 = load %runtime.Type_Info_Named*, %runtime.Type_Info_Named** %18, align 8
	%227 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %226, i64 0
	%228 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %227, i64 0, i32 1
	%229 = load %runtime.Type_Info*, %runtime.Type_Info** %228, align 8
	%230 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %229, i64 0
	%231 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %230, i64 0, i32 3
	%232 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %231, align 8
	%233 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %231, i64 0, i32 2 ; UnionTagPtr
	%234 = load i8, i8* %233, align 1
	%235 = icmp eq i8 %234, 16
	call void @runtime.type_assertion_check(i1 %235, %..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$151, i64 0, i32 0), i64 67}, i64 172, i64 48, %..typeid 1152921504606846984, %..typeid 3386706919782613035)
	%236 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %231 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct* %236, %runtime.Type_Info_Struct** %17
	br label %typeswitch.done-17

typeswitch.next-15:
	store {[0 x <8 x i8>], [72 x i8], i8}* %219, {[0 x <8 x i8>], [72 x i8], i8}** %20
	%237 = load {[0 x <8 x i8>], [72 x i8], i8}*, {[0 x <8 x i8>], [72 x i8], i8}** %20, align 8
	%238 = bitcast %..any* %21 to %..rawptr
	%239 = call %..rawptr @mem.zero(%..rawptr %238, i64 16) noinline
	store %..any zeroinitializer, %..any* %21
	%240 = bitcast {[0 x <8 x i8>], [72 x i8], i8}** %20 to %..rawptr
	%241 = getelementptr inbounds %..any, %..any* %21, i64 0, i32 0
	store %..rawptr %240, %..rawptr* %241
	%242 = getelementptr inbounds %..any, %..any* %21, i64 0, i32 1
	store %..typeid 648518346341351526, %..typeid* %242
	%243 = load %..any, %..any* %21, align 8
	; variadic call argument generation
	%244 = bitcast {%..any*, i64}* %22 to %..rawptr
	%245 = call %..rawptr @mem.zero(%..rawptr %244, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %22
	%246 = bitcast [1 x %..any]* %23 to %..rawptr
	%247 = call %..rawptr @mem.zero(%..rawptr %246, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %23
	%248 = getelementptr inbounds [1 x %..any], [1 x %..any]* %23, i64 0, i32 0
	store %..any %243, %..any* %248
	%249 = getelementptr inbounds [1 x %..any], [1 x %..any]* %23, i64 0, i32 0
	%250 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %22, i64 0, i32 0
	store %..any* %249, %..any** %250
	%251 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %22, i64 0, i32 1
	store i64 1, i64* %251
	%252 = load {%..any*, i64}, {%..any*, i64}* %22, align 8
	%253 = bitcast {%..any*, i64}* %24 to %..rawptr
	%254 = call %..rawptr @mem.zero(%..rawptr %253, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %24
	store {%..any*, i64} %252, {%..any*, i64}* %24
	%255 = call %..string @fmt.tprint({%..any*, i64}* %24, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%256 = bitcast %runtime.Source_Code_Location* %25 to %..rawptr
	%257 = call %..rawptr @mem.zero(%..rawptr %256, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %25
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$152, i64 0, i32 0), i64 67}, i64 174, i64 14, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$153, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %25
	call void @runtime.panic(%..string %255, %runtime.Source_Code_Location* %25) noreturn
	br label %typeswitch.done-17

typeswitch.body-16:
	%258 = bitcast %..rawptr %222 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct* %258, %runtime.Type_Info_Struct** %19
	; AssignStmt
	%259 = load %runtime.Type_Info_Struct*, %runtime.Type_Info_Struct** %19, align 8
	store %runtime.Type_Info_Struct* %259, %runtime.Type_Info_Struct** %17
	br label %typeswitch.done-17

typeswitch.done-17:
	%260 = load %runtime.Type_Info_Struct*, %runtime.Type_Info_Struct** %17, align 8
	%261 = icmp ne %runtime.Type_Info_Struct* %260, zeroinitializer
	%262 = zext i1 %261 to i8
	%263 = trunc i8 %262 to i1
	%264 = bitcast %runtime.Source_Code_Location* %26 to %..rawptr
	%265 = call %..rawptr @mem.zero(%..rawptr %264, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %26
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$154, i64 0, i32 0), i64 67}, i64 176, i64 7, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$155, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %26
	%266 = call i8 @runtime.assert(i1 %263, %..string zeroinitializer, %runtime.Source_Code_Location* %26)
	; RangeStmt
	; name
	%267 = bitcast %..string* %27 to %..rawptr
	%268 = call %..rawptr @mem.zero(%..rawptr %267, i64 16) noinline
	store %..string zeroinitializer, %..string* %27
	; i
	%269 = bitcast i64* %28 to %..rawptr
	%270 = call %..rawptr @mem.zero(%..rawptr %269, i64 8) noinline
	store i64 zeroinitializer, i64* %28
	; SelectorExpr
	%271 = load %runtime.Type_Info_Struct*, %runtime.Type_Info_Struct** %17, align 8
	%272 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %271, i64 0
	%273 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %272, i64 0, i32 1
	%274 = load {%..string*, i64}, {%..string*, i64}* %273, align 8
	%275 = bitcast i64* %29 to %..rawptr
	%276 = call %..rawptr @mem.zero(%..rawptr %275, i64 8) noinline
	store i64 zeroinitializer, i64* %29
	%277 = extractvalue {%..string*, i64} %274, 1
	store i64 %277, i64* %29
	%278 = bitcast i64* %30 to %..rawptr
	%279 = call %..rawptr @mem.zero(%..rawptr %278, i64 8) noinline
	store i64 zeroinitializer, i64* %30
	store i64 -1, i64* %30
	br label %for.index.loop-18

for.index.loop-18:
	%280 = load i64, i64* %30, align 8
	%281 = add i64 %280, 1
	store i64 %281, i64* %30
	%282 = load i64, i64* %29, align 8
	%283 = icmp slt i64 %281, %282
	br i1 %283, label %for.index.body-19, label %for.index.done-22

for.index.body-19:
	%284 = load i64, i64* %30, align 8
	%285 = extractvalue {%..string*, i64} %274, 0
	%286 = getelementptr inbounds %..string, %..string* %285, i64 %284
	%287 = load %..string, %..string* %286, align 8
	store %..string %287, %..string* %27
	store i64 %284, i64* %28
	; IfStmt
	%288 = load %..string, %..string* %27, align 8
	; SelectorExpr
	%289 = getelementptr inbounds %lexer.Token_Identifier, %lexer.Token_Identifier* %11, i64 0, i32 0
	%290 = load %..string, %..string* %289, align 8
	%291 = call i8 @runtime.string_eq(%..string %288, %..string %290)
	%292 = trunc i8 %291 to i1
	br i1 %292, label %if.then-20, label %if.done-21

if.then-20:
	; AssignStmt
	; SelectorExpr
	%293 = load %..rawptr, %..rawptr* %1, align 8
	%294 = bitcast %..rawptr %293 to i8*
	; IndexExpr
	; SelectorExpr
	%295 = load %runtime.Type_Info_Struct*, %runtime.Type_Info_Struct** %17, align 8
	%296 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %295, i64 0
	%297 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %296, i64 0, i32 2
	%298 = load {i64*, i64}, {i64*, i64}* %297, align 8
	%299 = extractvalue {i64*, i64} %298, 0
	%300 = load i64, i64* %28, align 8
	%301 = extractvalue {i64*, i64} %298, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$156, i64 0, i32 0), i64 67}, i64 179, i64 82, i64 %300, i64 %301)
	%302 = getelementptr inbounds i64, i64* %299, i64 %300
	%303 = load i64, i64* %302, align 8
	%304 = bitcast i64 %303 to i64
	%305 = call i8* @mem.ptr_offset-13939(i8* %294, i64 %304)
	%306 = bitcast i8* %305 to %..rawptr
	store %..rawptr %306, %..rawptr* %15
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%307 = load %runtime.Type_Info_Struct*, %runtime.Type_Info_Struct** %17, align 8
	%308 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %307, i64 0
	%309 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %308, i64 0, i32 0
	%310 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %309, align 8
	%311 = extractvalue {%runtime.Type_Info**, i64} %310, 0
	%312 = load i64, i64* %28, align 8
	%313 = extractvalue {%runtime.Type_Info**, i64} %310, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$157, i64 0, i32 0), i64 67}, i64 180, i64 39, i64 %312, i64 %313)
	%314 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %311, i64 %312
	%315 = load %runtime.Type_Info*, %runtime.Type_Info** %314, align 8
	store %runtime.Type_Info* %315, %runtime.Type_Info** %16
	; break
	br label %for.index.done-22

if.done-21:
	br label %for.index.loop-18

for.index.done-22:
	%316 = load %..rawptr, %..rawptr* %15, align 8
	%317 = icmp ne %..rawptr %316, zeroinitializer
	%318 = zext i1 %317 to i8
	; SelectorExpr
	%319 = getelementptr inbounds %lexer.Token_Identifier, %lexer.Token_Identifier* %11, i64 0, i32 0
	%320 = load %..string, %..string* %319, align 8
	%321 = bitcast %..string* %31 to %..rawptr
	%322 = call %..rawptr @mem.zero(%..rawptr %321, i64 16) noinline
	store %..string zeroinitializer, %..string* %31
	store %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$158, i64 0, i32 0), i64 19}, %..string* %31
	%323 = load %..string, %..string* %31, align 8
	%324 = bitcast %..any* %32 to %..rawptr
	%325 = call %..rawptr @mem.zero(%..rawptr %324, i64 16) noinline
	store %..any zeroinitializer, %..any* %32
	%326 = bitcast %..string* %31 to %..rawptr
	%327 = getelementptr inbounds %..any, %..any* %32, i64 0, i32 0
	store %..rawptr %326, %..rawptr* %327
	%328 = getelementptr inbounds %..any, %..any* %32, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %328
	%329 = load %..any, %..any* %32, align 8
	%330 = bitcast %..any* %33 to %..rawptr
	%331 = call %..rawptr @mem.zero(%..rawptr %330, i64 16) noinline
	store %..any zeroinitializer, %..any* %33
	%332 = bitcast %..string* %319 to %..rawptr
	%333 = getelementptr inbounds %..any, %..any* %33, i64 0, i32 0
	store %..rawptr %332, %..rawptr* %333
	%334 = getelementptr inbounds %..any, %..any* %33, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %334
	%335 = load %..any, %..any* %33, align 8
	; variadic call argument generation
	%336 = bitcast {%..any*, i64}* %34 to %..rawptr
	%337 = call %..rawptr @mem.zero(%..rawptr %336, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %34
	%338 = bitcast [2 x %..any]* %35 to %..rawptr
	%339 = call %..rawptr @mem.zero(%..rawptr %338, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %35
	%340 = getelementptr inbounds [2 x %..any], [2 x %..any]* %35, i64 0, i32 0
	store %..any %329, %..any* %340
	%341 = getelementptr inbounds [2 x %..any], [2 x %..any]* %35, i64 0, i32 1
	store %..any %335, %..any* %341
	%342 = getelementptr inbounds [2 x %..any], [2 x %..any]* %35, i64 0, i32 0
	%343 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %34, i64 0, i32 0
	store %..any* %342, %..any** %343
	%344 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %34, i64 0, i32 1
	store i64 2, i64* %344
	%345 = load {%..any*, i64}, {%..any*, i64}* %34, align 8
	%346 = bitcast {%..any*, i64}* %36 to %..rawptr
	%347 = call %..rawptr @mem.zero(%..rawptr %346, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %36
	store {%..any*, i64} %345, {%..any*, i64}* %36
	%348 = call %..string @fmt.tprint({%..any*, i64}* %36, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%349 = trunc i8 %318 to i1
	%350 = bitcast %runtime.Source_Code_Location* %37 to %..rawptr
	%351 = call %..rawptr @mem.zero(%..rawptr %350, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %37
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$159, i64 0, i32 0), i64 67}, i64 184, i64 7, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$15a, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %37
	%352 = call i8 @runtime.assert(i1 %349, %..string %348, %runtime.Source_Code_Location* %37)
	; value_token
	; ok3
	%353 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%354 = bitcast %runtime.Source_Code_Location* %40 to %..rawptr
	%355 = call %..rawptr @mem.zero(%..rawptr %354, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %40
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$15b, i64 0, i32 0), i64 67}, i64 186, i64 27, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$15c, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %40
	%356 = call {%lexer.Token, i8} @lexer.get_next_token(%lexer.Lexer* %353, %runtime.Source_Code_Location* %40, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%357 = extractvalue {%lexer.Token, i8} %356, 0
	%358 = extractvalue {%lexer.Token, i8} %356, 1
	store %lexer.Token %357, %lexer.Token* %38
	store i8 %358, i8* %39
	%359 = load i8, i8* %39, align 1
	%360 = trunc i8 %359 to i1
	%361 = bitcast %runtime.Source_Code_Location* %41 to %..rawptr
	%362 = call %..rawptr @mem.zero(%..rawptr %361, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %41
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$15d, i64 0, i32 0), i64 67}, i64 186, i64 50, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$15e, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %41
	%363 = call i8 @runtime.assert(i1 %360, %..string zeroinitializer, %runtime.Source_Code_Location* %41)
	%364 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%365 = load %lexer.Token, %lexer.Token* %38, align 8
	%366 = load %..rawptr, %..rawptr* %15, align 8
	%367 = load %runtime.Type_Info*, %runtime.Type_Info** %16, align 8
	%368 = bitcast %lexer.Token* %42 to %..rawptr
	%369 = call %..rawptr @mem.zero(%..rawptr %368, i64 56) noinline
	store %lexer.Token zeroinitializer, %lexer.Token* %42
	store %lexer.Token %365, %lexer.Token* %42
	call void @wbml.parse_value(%lexer.Lexer* %364, %lexer.Token* %42, %..rawptr %366, %runtime.Type_Info* %367, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.body-5

switch.case.next-23:
	br label %switch.done-71

switch.fall.body-24:
	; TypeSwitchStmt
	; SelectorExpr
	%370 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%371 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %370, i64 0
	%372 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %371, i64 0, i32 3
	%373 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %372, align 8
	; get union's tag
	%374 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %372, i64 0, i32 2 ; UnionTagPtr
	%375 = load i8, i8* %374, align 1
	%376 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %372 to %..rawptr
	%377 = icmp eq i8 %375, 12
	br i1 %377, label %typeswitch.body-26, label %typeswitch.next-25

typeswitch.next-25:
	%378 = icmp eq i8 %375, 13
	br i1 %378, label %typeswitch.body-41, label %typeswitch.next-40

typeswitch.body-26:
	%379 = bitcast %..rawptr %376 to %runtime.Type_Info_Array*
	%380 = load %runtime.Type_Info_Array, %runtime.Type_Info_Array* %379, align 8
	store %runtime.Type_Info_Array %380, %runtime.Type_Info_Array* %43
	; i
	%381 = bitcast i64* %44 to %..rawptr
	%382 = call %..rawptr @mem.zero(%..rawptr %381, i64 8) noinline
	store i64 zeroinitializer, i64* %44
	; ForStmt
	br label %for.body-27

for.body-27:
	; DeferStmt
	; IfStmt
	%383 = load i64, i64* %44, align 8
	; SelectorExpr
	%384 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %43, i64 0, i32 2
	%385 = load i64, i64* %384, align 8
	%386 = icmp sgt i64 %383, %385
	%387 = zext i1 %386 to i8
	%388 = trunc i8 %387 to i1
	br i1 %388, label %if.then-28, label %if.done-29

if.then-28:
	%389 = bitcast %runtime.Source_Code_Location* %45 to %..rawptr
	%390 = call %..rawptr @mem.zero(%..rawptr %389, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %45
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$15f, i64 0, i32 0), i64 67}, i64 197, i64 10, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$160, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %45
	%391 = call i8 @runtime.assert(i1 false, %..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$161, i64 0, i32 0), i64 23}, %runtime.Source_Code_Location* %45)
	br label %if.done-29

if.done-29:
	; array_value_token
	; ok
	%392 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%393 = bitcast %runtime.Source_Code_Location* %48 to %..rawptr
	%394 = call %..rawptr @mem.zero(%..rawptr %393, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %48
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$162, i64 0, i32 0), i64 67}, i64 200, i64 34, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$163, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %48
	%395 = call {%lexer.Token, i8} @lexer.get_next_token(%lexer.Lexer* %392, %runtime.Source_Code_Location* %48, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%396 = extractvalue {%lexer.Token, i8} %395, 0
	%397 = extractvalue {%lexer.Token, i8} %395, 1
	store %lexer.Token %396, %lexer.Token* %46
	store i8 %397, i8* %47
	; IfStmt
	%398 = load i8, i8* %47, align 1
	%399 = trunc i8 %398 to i1
	br i1 %399, label %if.done-31, label %if.then-30

if.then-30:
	%400 = bitcast %runtime.Source_Code_Location* %49 to %..rawptr
	%401 = call %..rawptr @mem.zero(%..rawptr %400, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %49
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$164, i64 0, i32 0), i64 67}, i64 201, i64 19, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$165, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %49
	%402 = call i8 @runtime.assert(i1 false, %..string {i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$166, i64 0, i32 0), i64 29}, %runtime.Source_Code_Location* %49)
	br label %if.done-31

if.done-31:
	; IfStmt
	; symbol
	; is_symbol
	; SelectorExpr
	%403 = getelementptr inbounds %lexer.Token, %lexer.Token* %46, i64 0, i32 1
	%404 = load {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %403, align 8
	; cast - union_cast
	%405 = bitcast {%lexer.Token_Symbol, i8}* %52 to %..rawptr
	%406 = call %..rawptr @mem.zero(%..rawptr %405, i64 8) noinline
	store {%lexer.Token_Symbol, i8} zeroinitializer, {%lexer.Token_Symbol, i8}* %52
	%407 = getelementptr inbounds {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %403, i64 0, i32 2 ; UnionTagPtr
	%408 = load i8, i8* %407, align 1
	%409 = icmp eq i8 %408, 4
	br i1 %409, label %union_cast.ok-32, label %union_cast.end-33

union_cast.ok-32:
	%410 = getelementptr inbounds {%lexer.Token_Symbol, i8}, {%lexer.Token_Symbol, i8}* %52, i64 0, i32 0
	%411 = getelementptr inbounds {%lexer.Token_Symbol, i8}, {%lexer.Token_Symbol, i8}* %52, i64 0, i32 1
	%412 = bitcast {[0 x <8 x i8>], [32 x i8], i8}* %403 to %lexer.Token_Symbol*
	%413 = load %lexer.Token_Symbol, %lexer.Token_Symbol* %412, align 4
	store %lexer.Token_Symbol %413, %lexer.Token_Symbol* %410
	store i8 1, i8* %411
	br label %union_cast.end-33

union_cast.end-33:
	%414 = load {%lexer.Token_Symbol, i8}, {%lexer.Token_Symbol, i8}* %52, align 4
	%415 = extractvalue {%lexer.Token_Symbol, i8} %414, 0
	%416 = extractvalue {%lexer.Token_Symbol, i8} %414, 1
	store %lexer.Token_Symbol %415, %lexer.Token_Symbol* %50
	store i8 %416, i8* %51
	%417 = load i8, i8* %51, align 1
	%418 = trunc i8 %417 to i1
	br i1 %418, label %if.then-34, label %if.done-39

if.then-34:
	; IfStmt
	; SelectorExpr
	%419 = getelementptr inbounds %lexer.Token_Symbol, %lexer.Token_Symbol* %50, i64 0, i32 0
	%420 = load i32, i32* %419, align 4
	%421 = icmp eq i32 %420, 93
	%422 = zext i1 %421 to i8
	%423 = trunc i8 %422 to i1
	br i1 %423, label %if.then-35, label %if.done-36

if.then-35:
	; defer
	; AssignStmt
	%424 = load i64, i64* %44, align 8
	%425 = add i64 %424, 1
	store i64 %425, i64* %44
	; break
	br label %typeswitch.done-70

if.done-36:
	; IfStmt
	; SelectorExpr
	%426 = getelementptr inbounds %lexer.Token_Symbol, %lexer.Token_Symbol* %50, i64 0, i32 0
	%427 = load i32, i32* %426, align 4
	%428 = icmp ne i32 %427, 123
	%429 = zext i1 %428 to i8
	%430 = trunc i8 %429 to i1
	br i1 %430, label %if.then-37, label %if.done-38

if.then-37:
	%431 = load %lexer.Token_Symbol, %lexer.Token_Symbol* %50, align 4
	%432 = bitcast %..string* %53 to %..rawptr
	%433 = call %..rawptr @mem.zero(%..rawptr %432, i64 16) noinline
	store %..string zeroinitializer, %..string* %53
	store %..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$167, i64 0, i32 0), i64 23}, %..string* %53
	%434 = load %..string, %..string* %53, align 8
	%435 = bitcast %..any* %54 to %..rawptr
	%436 = call %..rawptr @mem.zero(%..rawptr %435, i64 16) noinline
	store %..any zeroinitializer, %..any* %54
	%437 = bitcast %..string* %53 to %..rawptr
	%438 = getelementptr inbounds %..any, %..any* %54, i64 0, i32 0
	store %..rawptr %437, %..rawptr* %438
	%439 = getelementptr inbounds %..any, %..any* %54, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %439
	%440 = load %..any, %..any* %54, align 8
	%441 = bitcast %..any* %55 to %..rawptr
	%442 = call %..rawptr @mem.zero(%..rawptr %441, i64 16) noinline
	store %..any zeroinitializer, %..any* %55
	%443 = bitcast %lexer.Token_Symbol* %50 to %..rawptr
	%444 = getelementptr inbounds %..any, %..any* %55, i64 0, i32 0
	store %..rawptr %443, %..rawptr* %444
	%445 = getelementptr inbounds %..any, %..any* %55, i64 0, i32 1
	store %..typeid 3386706919782613092, %..typeid* %445
	%446 = load %..any, %..any* %55, align 8
	; variadic call argument generation
	%447 = bitcast {%..any*, i64}* %56 to %..rawptr
	%448 = call %..rawptr @mem.zero(%..rawptr %447, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %56
	%449 = bitcast [2 x %..any]* %57 to %..rawptr
	%450 = call %..rawptr @mem.zero(%..rawptr %449, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %57
	%451 = getelementptr inbounds [2 x %..any], [2 x %..any]* %57, i64 0, i32 0
	store %..any %440, %..any* %451
	%452 = getelementptr inbounds [2 x %..any], [2 x %..any]* %57, i64 0, i32 1
	store %..any %446, %..any* %452
	%453 = getelementptr inbounds [2 x %..any], [2 x %..any]* %57, i64 0, i32 0
	%454 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %56, i64 0, i32 0
	store %..any* %453, %..any** %454
	%455 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %56, i64 0, i32 1
	store i64 2, i64* %455
	%456 = load {%..any*, i64}, {%..any*, i64}* %56, align 8
	%457 = bitcast {%..any*, i64}* %58 to %..rawptr
	%458 = call %..rawptr @mem.zero(%..rawptr %457, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %58
	store {%..any*, i64} %456, {%..any*, i64}* %58
	%459 = call %..string @fmt.tprint({%..any*, i64}* %58, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%460 = bitcast %runtime.Source_Code_Location* %59 to %..rawptr
	%461 = call %..rawptr @mem.zero(%..rawptr %460, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %59
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$168, i64 0, i32 0), i64 67}, i64 206, i64 11, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$169, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %59
	%462 = call i8 @runtime.assert(i1 false, %..string %459, %runtime.Source_Code_Location* %59)
	br label %if.done-38

if.done-38:
	br label %if.done-39

if.done-39:
	%463 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%464 = load %lexer.Token, %lexer.Token* %46, align 8
	; SelectorExpr
	%465 = load %..rawptr, %..rawptr* %1, align 8
	%466 = bitcast %..rawptr %465 to i8*
	; SelectorExpr
	%467 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %43, i64 0, i32 1
	%468 = load i64, i64* %467, align 8
	%469 = load i64, i64* %44, align 8
	%470 = mul i64 %468, %469
	%471 = call i8* @mem.ptr_offset-13939(i8* %466, i64 %470)
	; SelectorExpr
	%472 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %43, i64 0, i32 0
	%473 = load %runtime.Type_Info*, %runtime.Type_Info** %472, align 8
	%474 = bitcast i8* %471 to %..rawptr
	%475 = bitcast %lexer.Token* %60 to %..rawptr
	%476 = call %..rawptr @mem.zero(%..rawptr %475, i64 56) noinline
	store %lexer.Token zeroinitializer, %lexer.Token* %60
	store %lexer.Token %464, %lexer.Token* %60
	call void @wbml.parse_value(%lexer.Lexer* %463, %lexer.Token* %60, %..rawptr %474, %runtime.Type_Info* %473, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; defer
	; AssignStmt
	%477 = load i64, i64* %44, align 8
	%478 = add i64 %477, 1
	store i64 %478, i64* %44
	br label %for.body-27

typeswitch.next-40:
	%479 = icmp eq i8 %375, 14
	br i1 %479, label %typeswitch.body-56, label %typeswitch.next-55

typeswitch.body-41:
	%480 = bitcast %..rawptr %376 to %runtime.Type_Info_Dynamic_Array*
	%481 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %480, align 8
	store %runtime.Type_Info_Dynamic_Array %481, %runtime.Type_Info_Dynamic_Array* %61
	; memory
	; SelectorExpr
	%482 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%483 = load %mem.Allocator, %mem.Allocator* %482, align 8
	%484 = bitcast %mem.Allocator* %63 to %..rawptr
	%485 = call %..rawptr @mem.zero(%..rawptr %484, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %63
	store %mem.Allocator %483, %mem.Allocator* %63
	%486 = bitcast %runtime.Source_Code_Location* %64 to %..rawptr
	%487 = call %..rawptr @mem.zero(%..rawptr %486, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %64
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$16a, i64 0, i32 0), i64 67}, i64 214, i64 18, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$16b, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %64
	%488 = call {i8*, i64} @mem.make_slice-14294(i64 1024, %mem.Allocator* %63, %runtime.Source_Code_Location* %64, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64} %488, {i8*, i64}* %62
	; byte_index
	store i64 0, i64* %65
	; i
	%489 = bitcast i64* %66 to %..rawptr
	%490 = call %..rawptr @mem.zero(%..rawptr %489, i64 8) noinline
	store i64 zeroinitializer, i64* %66
	; ForStmt
	br label %for.body-42

for.body-42:
	; DeferStmt
	; array_value_token
	; ok
	%491 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%492 = bitcast %runtime.Source_Code_Location* %69 to %..rawptr
	%493 = call %..rawptr @mem.zero(%..rawptr %492, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %69
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$16c, i64 0, i32 0), i64 67}, i64 221, i64 34, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$16d, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %69
	%494 = call {%lexer.Token, i8} @lexer.get_next_token(%lexer.Lexer* %491, %runtime.Source_Code_Location* %69, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%495 = extractvalue {%lexer.Token, i8} %494, 0
	%496 = extractvalue {%lexer.Token, i8} %494, 1
	store %lexer.Token %495, %lexer.Token* %67
	store i8 %496, i8* %68
	; IfStmt
	%497 = load i8, i8* %68, align 1
	%498 = trunc i8 %497 to i1
	br i1 %498, label %if.done-44, label %if.then-43

if.then-43:
	%499 = bitcast %runtime.Source_Code_Location* %70 to %..rawptr
	%500 = call %..rawptr @mem.zero(%..rawptr %499, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %70
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$16e, i64 0, i32 0), i64 67}, i64 222, i64 19, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$16f, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %70
	%501 = call i8 @runtime.assert(i1 false, %..string {i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$170, i64 0, i32 0), i64 29}, %runtime.Source_Code_Location* %70)
	br label %if.done-44

if.done-44:
	; IfStmt
	; symbol
	; is_symbol
	; SelectorExpr
	%502 = getelementptr inbounds %lexer.Token, %lexer.Token* %67, i64 0, i32 1
	%503 = load {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %502, align 8
	; cast - union_cast
	%504 = bitcast {%lexer.Token_Symbol, i8}* %73 to %..rawptr
	%505 = call %..rawptr @mem.zero(%..rawptr %504, i64 8) noinline
	store {%lexer.Token_Symbol, i8} zeroinitializer, {%lexer.Token_Symbol, i8}* %73
	%506 = getelementptr inbounds {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %502, i64 0, i32 2 ; UnionTagPtr
	%507 = load i8, i8* %506, align 1
	%508 = icmp eq i8 %507, 4
	br i1 %508, label %union_cast.ok-45, label %union_cast.end-46

union_cast.ok-45:
	%509 = getelementptr inbounds {%lexer.Token_Symbol, i8}, {%lexer.Token_Symbol, i8}* %73, i64 0, i32 0
	%510 = getelementptr inbounds {%lexer.Token_Symbol, i8}, {%lexer.Token_Symbol, i8}* %73, i64 0, i32 1
	%511 = bitcast {[0 x <8 x i8>], [32 x i8], i8}* %502 to %lexer.Token_Symbol*
	%512 = load %lexer.Token_Symbol, %lexer.Token_Symbol* %511, align 4
	store %lexer.Token_Symbol %512, %lexer.Token_Symbol* %509
	store i8 1, i8* %510
	br label %union_cast.end-46

union_cast.end-46:
	%513 = load {%lexer.Token_Symbol, i8}, {%lexer.Token_Symbol, i8}* %73, align 4
	%514 = extractvalue {%lexer.Token_Symbol, i8} %513, 0
	%515 = extractvalue {%lexer.Token_Symbol, i8} %513, 1
	store %lexer.Token_Symbol %514, %lexer.Token_Symbol* %71
	store i8 %515, i8* %72
	%516 = load i8, i8* %72, align 1
	%517 = trunc i8 %516 to i1
	br i1 %517, label %if.then-47, label %if.done-52

if.then-47:
	; IfStmt
	; SelectorExpr
	%518 = getelementptr inbounds %lexer.Token_Symbol, %lexer.Token_Symbol* %71, i64 0, i32 0
	%519 = load i32, i32* %518, align 4
	%520 = icmp eq i32 %519, 93
	%521 = zext i1 %520 to i8
	%522 = trunc i8 %521 to i1
	br i1 %522, label %if.then-48, label %if.done-49

if.then-48:
	; defer
	; AssignStmt
	%523 = load i64, i64* %66, align 8
	%524 = add i64 %523, 1
	store i64 %524, i64* %66
	; break
	; AssignStmt
	%525 = load %..rawptr, %..rawptr* %1, align 8
	%526 = bitcast %..rawptr %525 to %mem.Raw_Dynamic_Array*
	%527 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %526, i64 0
	; CompoundLit
	%528 = bitcast %mem.Raw_Dynamic_Array* %88 to %..rawptr
	%529 = call %..rawptr @mem.zero(%..rawptr %528, i64 40) noinline
	store %mem.Raw_Dynamic_Array zeroinitializer, %mem.Raw_Dynamic_Array* %88
	store %mem.Raw_Dynamic_Array {%..rawptr zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %mem.Allocator zeroinitializer}, %mem.Raw_Dynamic_Array* %88
	; IndexExpr
	%530 = load {i8*, i64}, {i8*, i64}* %62, align 8
	%531 = extractvalue {i8*, i64} %530, 0
	%532 = extractvalue {i8*, i64} %530, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$171, i64 0, i32 0), i64 67}, i64 242, i64 76, i64 0, i64 %532)
	%533 = getelementptr inbounds i8, i8* %531, i64 0
	%534 = bitcast i8* %533 to %..rawptr
	%535 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %88, i64 0, i32 0
	store %..rawptr %534, %..rawptr* %535
	%536 = load i64, i64* %66, align 8
	%537 = sub i64 %536, 1
	%538 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %88, i64 0, i32 1
	store i64 %537, i64* %538
	%539 = load {i8*, i64}, {i8*, i64}* %62, align 8
	%540 = extractvalue {i8*, i64} %539, 1
	%541 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %88, i64 0, i32 2
	store i64 %540, i64* %541
	%542 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %88, align 8
	store %mem.Raw_Dynamic_Array %542, %mem.Raw_Dynamic_Array* %527
	br label %typeswitch.done-70

if.done-49:
	; IfStmt
	; SelectorExpr
	%543 = getelementptr inbounds %lexer.Token_Symbol, %lexer.Token_Symbol* %71, i64 0, i32 0
	%544 = load i32, i32* %543, align 4
	%545 = icmp ne i32 %544, 123
	%546 = zext i1 %545 to i8
	%547 = trunc i8 %546 to i1
	br i1 %547, label %if.then-50, label %if.done-51

if.then-50:
	%548 = load %lexer.Token_Symbol, %lexer.Token_Symbol* %71, align 4
	%549 = bitcast %..string* %74 to %..rawptr
	%550 = call %..rawptr @mem.zero(%..rawptr %549, i64 16) noinline
	store %..string zeroinitializer, %..string* %74
	store %..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$172, i64 0, i32 0), i64 23}, %..string* %74
	%551 = load %..string, %..string* %74, align 8
	%552 = bitcast %..any* %75 to %..rawptr
	%553 = call %..rawptr @mem.zero(%..rawptr %552, i64 16) noinline
	store %..any zeroinitializer, %..any* %75
	%554 = bitcast %..string* %74 to %..rawptr
	%555 = getelementptr inbounds %..any, %..any* %75, i64 0, i32 0
	store %..rawptr %554, %..rawptr* %555
	%556 = getelementptr inbounds %..any, %..any* %75, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %556
	%557 = load %..any, %..any* %75, align 8
	%558 = bitcast %..any* %76 to %..rawptr
	%559 = call %..rawptr @mem.zero(%..rawptr %558, i64 16) noinline
	store %..any zeroinitializer, %..any* %76
	%560 = bitcast %lexer.Token_Symbol* %71 to %..rawptr
	%561 = getelementptr inbounds %..any, %..any* %76, i64 0, i32 0
	store %..rawptr %560, %..rawptr* %561
	%562 = getelementptr inbounds %..any, %..any* %76, i64 0, i32 1
	store %..typeid 3386706919782613092, %..typeid* %562
	%563 = load %..any, %..any* %76, align 8
	; variadic call argument generation
	%564 = bitcast {%..any*, i64}* %77 to %..rawptr
	%565 = call %..rawptr @mem.zero(%..rawptr %564, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %77
	%566 = bitcast [2 x %..any]* %78 to %..rawptr
	%567 = call %..rawptr @mem.zero(%..rawptr %566, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %78
	%568 = getelementptr inbounds [2 x %..any], [2 x %..any]* %78, i64 0, i32 0
	store %..any %557, %..any* %568
	%569 = getelementptr inbounds [2 x %..any], [2 x %..any]* %78, i64 0, i32 1
	store %..any %563, %..any* %569
	%570 = getelementptr inbounds [2 x %..any], [2 x %..any]* %78, i64 0, i32 0
	%571 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %77, i64 0, i32 0
	store %..any* %570, %..any** %571
	%572 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %77, i64 0, i32 1
	store i64 2, i64* %572
	%573 = load {%..any*, i64}, {%..any*, i64}* %77, align 8
	%574 = bitcast {%..any*, i64}* %79 to %..rawptr
	%575 = call %..rawptr @mem.zero(%..rawptr %574, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %79
	store {%..any*, i64} %573, {%..any*, i64}* %79
	%576 = call %..string @fmt.tprint({%..any*, i64}* %79, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%577 = bitcast %runtime.Source_Code_Location* %80 to %..rawptr
	%578 = call %..rawptr @mem.zero(%..rawptr %577, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %80
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$173, i64 0, i32 0), i64 67}, i64 227, i64 11, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$174, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %80
	%579 = call i8 @runtime.assert(i1 false, %..string %576, %runtime.Source_Code_Location* %80)
	br label %if.done-51

if.done-51:
	br label %if.done-52

if.done-52:
	; IfStmt
	%580 = load i64, i64* %65, align 8
	; SelectorExpr
	%581 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %61, i64 0, i32 1
	%582 = load i64, i64* %581, align 8
	%583 = add i64 %580, %582
	%584 = load {i8*, i64}, {i8*, i64}* %62, align 8
	%585 = extractvalue {i8*, i64} %584, 1
	%586 = icmp sgt i64 %583, %585
	%587 = zext i1 %586 to i8
	%588 = trunc i8 %587 to i1
	br i1 %588, label %if.then-53, label %if.done-54

if.then-53:
	; old_mem
	%589 = load {i8*, i64}, {i8*, i64}* %62, align 8
	store {i8*, i64} %589, {i8*, i64}* %81
	; AssignStmt
	%590 = load {i8*, i64}, {i8*, i64}* %81, align 8
	%591 = extractvalue {i8*, i64} %590, 1
	%592 = mul i64 %591, 2
	; SelectorExpr
	%593 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%594 = load %mem.Allocator, %mem.Allocator* %593, align 8
	%595 = bitcast %mem.Allocator* %82 to %..rawptr
	%596 = call %..rawptr @mem.zero(%..rawptr %595, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %82
	store %mem.Allocator %594, %mem.Allocator* %82
	%597 = bitcast %runtime.Source_Code_Location* %83 to %..rawptr
	%598 = call %..rawptr @mem.zero(%..rawptr %597, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %83
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$175, i64 0, i32 0), i64 67}, i64 233, i64 19, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$176, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %83
	%599 = call {i8*, i64} @mem.make_slice-14294(i64 %592, %mem.Allocator* %82, %runtime.Source_Code_Location* %83, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64} %599, {i8*, i64}* %62
	; SelectorExpr
	; IndexExpr
	%600 = load {i8*, i64}, {i8*, i64}* %62, align 8
	%601 = extractvalue {i8*, i64} %600, 0
	%602 = extractvalue {i8*, i64} %600, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$177, i64 0, i32 0), i64 67}, i64 234, i64 27, i64 0, i64 %602)
	%603 = getelementptr inbounds i8, i8* %601, i64 0
	; IndexExpr
	%604 = load {i8*, i64}, {i8*, i64}* %81, align 8
	%605 = extractvalue {i8*, i64} %604, 0
	%606 = extractvalue {i8*, i64} %604, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$178, i64 0, i32 0), i64 67}, i64 234, i64 40, i64 0, i64 %606)
	%607 = getelementptr inbounds i8, i8* %605, i64 0
	%608 = load {i8*, i64}, {i8*, i64}* %81, align 8
	%609 = extractvalue {i8*, i64} %608, 1
	%610 = bitcast i8* %603 to %..rawptr
	%611 = bitcast i8* %607 to %..rawptr
	%612 = call %..rawptr @mem.copy(%..rawptr %610, %..rawptr %611, i64 %609)
	%613 = load {i8*, i64}, {i8*, i64}* %81, align 8
	; SelectorExpr
	%614 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%615 = load %mem.Allocator, %mem.Allocator* %614, align 8
	%616 = bitcast {i8*, i64}* %84 to %..rawptr
	%617 = call %..rawptr @mem.zero(%..rawptr %616, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %84
	store {i8*, i64} %613, {i8*, i64}* %84
	%618 = bitcast %mem.Allocator* %85 to %..rawptr
	%619 = call %..rawptr @mem.zero(%..rawptr %618, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %85
	store %mem.Allocator %615, %mem.Allocator* %85
	%620 = bitcast %runtime.Source_Code_Location* %86 to %..rawptr
	%621 = call %..rawptr @mem.zero(%..rawptr %620, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %86
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$179, i64 0, i32 0), i64 67}, i64 235, i64 10, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$17a, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %86
	call void @mem.delete_slice-14814({i8*, i64}* %84, %mem.Allocator* %85, %runtime.Source_Code_Location* %86, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-54

if.done-54:
	%622 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%623 = load %lexer.Token, %lexer.Token* %67, align 8
	; IndexExpr
	%624 = load {i8*, i64}, {i8*, i64}* %62, align 8
	%625 = extractvalue {i8*, i64} %624, 0
	%626 = load i64, i64* %65, align 8
	%627 = extractvalue {i8*, i64} %624, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$17b, i64 0, i32 0), i64 67}, i64 238, i64 55, i64 %626, i64 %627)
	%628 = getelementptr inbounds i8, i8* %625, i64 %626
	; SelectorExpr
	%629 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %61, i64 0, i32 0
	%630 = load %runtime.Type_Info*, %runtime.Type_Info** %629, align 8
	%631 = bitcast i8* %628 to %..rawptr
	%632 = bitcast %lexer.Token* %87 to %..rawptr
	%633 = call %..rawptr @mem.zero(%..rawptr %632, i64 56) noinline
	store %lexer.Token zeroinitializer, %lexer.Token* %87
	store %lexer.Token %623, %lexer.Token* %87
	call void @wbml.parse_value(%lexer.Lexer* %622, %lexer.Token* %87, %..rawptr %631, %runtime.Type_Info* %630, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	; SelectorExpr
	%634 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %61, i64 0, i32 1
	%635 = load i64, i64* %634, align 8
	%636 = load i64, i64* %65, align 8
	%637 = add i64 %636, %635
	store i64 %637, i64* %65
	; defer
	; AssignStmt
	%638 = load i64, i64* %66, align 8
	%639 = add i64 %638, 1
	store i64 %639, i64* %66
	br label %for.body-42

typeswitch.next-55:
	store {[0 x <8 x i8>], [72 x i8], i8} %373, {[0 x <8 x i8>], [72 x i8], i8}* %117
	%640 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %117, align 8
	%641 = bitcast %..any* %118 to %..rawptr
	%642 = call %..rawptr @mem.zero(%..rawptr %641, i64 16) noinline
	store %..any zeroinitializer, %..any* %118
	%643 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %117 to %..rawptr
	%644 = getelementptr inbounds %..any, %..any* %118, i64 0, i32 0
	store %..rawptr %643, %..rawptr* %644
	%645 = getelementptr inbounds %..any, %..any* %118, i64 0, i32 1
	store %..typeid 1152921504606846984, %..typeid* %645
	%646 = load %..any, %..any* %118, align 8
	; variadic call argument generation
	%647 = bitcast {%..any*, i64}* %119 to %..rawptr
	%648 = call %..rawptr @mem.zero(%..rawptr %647, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %119
	%649 = bitcast [1 x %..any]* %120 to %..rawptr
	%650 = call %..rawptr @mem.zero(%..rawptr %649, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %120
	%651 = getelementptr inbounds [1 x %..any], [1 x %..any]* %120, i64 0, i32 0
	store %..any %646, %..any* %651
	%652 = getelementptr inbounds [1 x %..any], [1 x %..any]* %120, i64 0, i32 0
	%653 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %119, i64 0, i32 0
	store %..any* %652, %..any** %653
	%654 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %119, i64 0, i32 1
	store i64 1, i64* %654
	%655 = load {%..any*, i64}, {%..any*, i64}* %119, align 8
	%656 = bitcast {%..any*, i64}* %121 to %..rawptr
	%657 = call %..rawptr @mem.zero(%..rawptr %656, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %121
	store {%..any*, i64} %655, {%..any*, i64}* %121
	%658 = call %..string @fmt.tprint({%..any*, i64}* %121, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%659 = bitcast %runtime.Source_Code_Location* %122 to %..rawptr
	%660 = call %..rawptr @mem.zero(%..rawptr %659, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %122
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$17c, i64 0, i32 0), i64 67}, i64 275, i64 13, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$17d, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %122
	call void @runtime.panic(%..string %658, %runtime.Source_Code_Location* %122) noreturn
	br label %typeswitch.done-70

typeswitch.body-56:
	%661 = bitcast %..rawptr %376 to %runtime.Type_Info_Slice*
	%662 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %661, align 8
	store %runtime.Type_Info_Slice %662, %runtime.Type_Info_Slice* %89
	; memory
	; SelectorExpr
	%663 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%664 = load %mem.Allocator, %mem.Allocator* %663, align 8
	%665 = bitcast %mem.Allocator* %91 to %..rawptr
	%666 = call %..rawptr @mem.zero(%..rawptr %665, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %91
	store %mem.Allocator %664, %mem.Allocator* %91
	%667 = bitcast %runtime.Source_Code_Location* %92 to %..rawptr
	%668 = call %..rawptr @mem.zero(%..rawptr %667, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %92
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$17e, i64 0, i32 0), i64 67}, i64 245, i64 18, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$17f, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %92
	%669 = call {i8*, i64} @mem.make_slice-14294(i64 1024, %mem.Allocator* %91, %runtime.Source_Code_Location* %92, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64} %669, {i8*, i64}* %90
	; byte_index
	store i64 0, i64* %93
	; i
	%670 = bitcast i64* %94 to %..rawptr
	%671 = call %..rawptr @mem.zero(%..rawptr %670, i64 8) noinline
	store i64 zeroinitializer, i64* %94
	; ForStmt
	br label %for.body-57

for.body-57:
	; DeferStmt
	; array_value_token
	; ok
	%672 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%673 = bitcast %runtime.Source_Code_Location* %97 to %..rawptr
	%674 = call %..rawptr @mem.zero(%..rawptr %673, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %97
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$180, i64 0, i32 0), i64 67}, i64 252, i64 34, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$181, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %97
	%675 = call {%lexer.Token, i8} @lexer.get_next_token(%lexer.Lexer* %672, %runtime.Source_Code_Location* %97, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%676 = extractvalue {%lexer.Token, i8} %675, 0
	%677 = extractvalue {%lexer.Token, i8} %675, 1
	store %lexer.Token %676, %lexer.Token* %95
	store i8 %677, i8* %96
	; IfStmt
	%678 = load i8, i8* %96, align 1
	%679 = trunc i8 %678 to i1
	br i1 %679, label %if.done-59, label %if.then-58

if.then-58:
	%680 = bitcast %runtime.Source_Code_Location* %98 to %..rawptr
	%681 = call %..rawptr @mem.zero(%..rawptr %680, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %98
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$182, i64 0, i32 0), i64 67}, i64 253, i64 19, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$183, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %98
	%682 = call i8 @runtime.assert(i1 false, %..string {i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$184, i64 0, i32 0), i64 29}, %runtime.Source_Code_Location* %98)
	br label %if.done-59

if.done-59:
	; IfStmt
	; symbol
	; is_symbol
	; SelectorExpr
	%683 = getelementptr inbounds %lexer.Token, %lexer.Token* %95, i64 0, i32 1
	%684 = load {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %683, align 8
	; cast - union_cast
	%685 = bitcast {%lexer.Token_Symbol, i8}* %101 to %..rawptr
	%686 = call %..rawptr @mem.zero(%..rawptr %685, i64 8) noinline
	store {%lexer.Token_Symbol, i8} zeroinitializer, {%lexer.Token_Symbol, i8}* %101
	%687 = getelementptr inbounds {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %683, i64 0, i32 2 ; UnionTagPtr
	%688 = load i8, i8* %687, align 1
	%689 = icmp eq i8 %688, 4
	br i1 %689, label %union_cast.ok-60, label %union_cast.end-61

union_cast.ok-60:
	%690 = getelementptr inbounds {%lexer.Token_Symbol, i8}, {%lexer.Token_Symbol, i8}* %101, i64 0, i32 0
	%691 = getelementptr inbounds {%lexer.Token_Symbol, i8}, {%lexer.Token_Symbol, i8}* %101, i64 0, i32 1
	%692 = bitcast {[0 x <8 x i8>], [32 x i8], i8}* %683 to %lexer.Token_Symbol*
	%693 = load %lexer.Token_Symbol, %lexer.Token_Symbol* %692, align 4
	store %lexer.Token_Symbol %693, %lexer.Token_Symbol* %690
	store i8 1, i8* %691
	br label %union_cast.end-61

union_cast.end-61:
	%694 = load {%lexer.Token_Symbol, i8}, {%lexer.Token_Symbol, i8}* %101, align 4
	%695 = extractvalue {%lexer.Token_Symbol, i8} %694, 0
	%696 = extractvalue {%lexer.Token_Symbol, i8} %694, 1
	store %lexer.Token_Symbol %695, %lexer.Token_Symbol* %99
	store i8 %696, i8* %100
	%697 = load i8, i8* %100, align 1
	%698 = trunc i8 %697 to i1
	br i1 %698, label %if.then-62, label %if.done-67

if.then-62:
	; IfStmt
	; SelectorExpr
	%699 = getelementptr inbounds %lexer.Token_Symbol, %lexer.Token_Symbol* %99, i64 0, i32 0
	%700 = load i32, i32* %699, align 4
	%701 = icmp eq i32 %700, 93
	%702 = zext i1 %701 to i8
	%703 = trunc i8 %702 to i1
	br i1 %703, label %if.then-63, label %if.done-64

if.then-63:
	; defer
	; AssignStmt
	%704 = load i64, i64* %94, align 8
	%705 = add i64 %704, 1
	store i64 %705, i64* %94
	; break
	; AssignStmt
	%706 = load %..rawptr, %..rawptr* %1, align 8
	%707 = bitcast %..rawptr %706 to %mem.Raw_Slice*
	%708 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %707, i64 0
	; CompoundLit
	%709 = bitcast %mem.Raw_Slice* %116 to %..rawptr
	%710 = call %..rawptr @mem.zero(%..rawptr %709, i64 16) noinline
	store %mem.Raw_Slice zeroinitializer, %mem.Raw_Slice* %116
	store %mem.Raw_Slice {%..rawptr zeroinitializer, i64 zeroinitializer}, %mem.Raw_Slice* %116
	; IndexExpr
	%711 = load {i8*, i64}, {i8*, i64}* %90, align 8
	%712 = extractvalue {i8*, i64} %711, 0
	%713 = extractvalue {i8*, i64} %711, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$185, i64 0, i32 0), i64 67}, i64 273, i64 60, i64 0, i64 %713)
	%714 = getelementptr inbounds i8, i8* %712, i64 0
	%715 = bitcast i8* %714 to %..rawptr
	%716 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %116, i64 0, i32 0
	store %..rawptr %715, %..rawptr* %716
	%717 = load i64, i64* %94, align 8
	%718 = sub i64 %717, 1
	%719 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %116, i64 0, i32 1
	store i64 %718, i64* %719
	%720 = load %mem.Raw_Slice, %mem.Raw_Slice* %116, align 8
	store %mem.Raw_Slice %720, %mem.Raw_Slice* %708
	br label %typeswitch.done-70

if.done-64:
	; IfStmt
	; SelectorExpr
	%721 = getelementptr inbounds %lexer.Token_Symbol, %lexer.Token_Symbol* %99, i64 0, i32 0
	%722 = load i32, i32* %721, align 4
	%723 = icmp ne i32 %722, 123
	%724 = zext i1 %723 to i8
	%725 = trunc i8 %724 to i1
	br i1 %725, label %if.then-65, label %if.done-66

if.then-65:
	%726 = load %lexer.Token_Symbol, %lexer.Token_Symbol* %99, align 4
	%727 = bitcast %..string* %102 to %..rawptr
	%728 = call %..rawptr @mem.zero(%..rawptr %727, i64 16) noinline
	store %..string zeroinitializer, %..string* %102
	store %..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$186, i64 0, i32 0), i64 23}, %..string* %102
	%729 = load %..string, %..string* %102, align 8
	%730 = bitcast %..any* %103 to %..rawptr
	%731 = call %..rawptr @mem.zero(%..rawptr %730, i64 16) noinline
	store %..any zeroinitializer, %..any* %103
	%732 = bitcast %..string* %102 to %..rawptr
	%733 = getelementptr inbounds %..any, %..any* %103, i64 0, i32 0
	store %..rawptr %732, %..rawptr* %733
	%734 = getelementptr inbounds %..any, %..any* %103, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %734
	%735 = load %..any, %..any* %103, align 8
	%736 = bitcast %..any* %104 to %..rawptr
	%737 = call %..rawptr @mem.zero(%..rawptr %736, i64 16) noinline
	store %..any zeroinitializer, %..any* %104
	%738 = bitcast %lexer.Token_Symbol* %99 to %..rawptr
	%739 = getelementptr inbounds %..any, %..any* %104, i64 0, i32 0
	store %..rawptr %738, %..rawptr* %739
	%740 = getelementptr inbounds %..any, %..any* %104, i64 0, i32 1
	store %..typeid 3386706919782613092, %..typeid* %740
	%741 = load %..any, %..any* %104, align 8
	; variadic call argument generation
	%742 = bitcast {%..any*, i64}* %105 to %..rawptr
	%743 = call %..rawptr @mem.zero(%..rawptr %742, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %105
	%744 = bitcast [2 x %..any]* %106 to %..rawptr
	%745 = call %..rawptr @mem.zero(%..rawptr %744, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %106
	%746 = getelementptr inbounds [2 x %..any], [2 x %..any]* %106, i64 0, i32 0
	store %..any %735, %..any* %746
	%747 = getelementptr inbounds [2 x %..any], [2 x %..any]* %106, i64 0, i32 1
	store %..any %741, %..any* %747
	%748 = getelementptr inbounds [2 x %..any], [2 x %..any]* %106, i64 0, i32 0
	%749 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %105, i64 0, i32 0
	store %..any* %748, %..any** %749
	%750 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %105, i64 0, i32 1
	store i64 2, i64* %750
	%751 = load {%..any*, i64}, {%..any*, i64}* %105, align 8
	%752 = bitcast {%..any*, i64}* %107 to %..rawptr
	%753 = call %..rawptr @mem.zero(%..rawptr %752, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %107
	store {%..any*, i64} %751, {%..any*, i64}* %107
	%754 = call %..string @fmt.tprint({%..any*, i64}* %107, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%755 = bitcast %runtime.Source_Code_Location* %108 to %..rawptr
	%756 = call %..rawptr @mem.zero(%..rawptr %755, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %108
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$187, i64 0, i32 0), i64 67}, i64 258, i64 11, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$188, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %108
	%757 = call i8 @runtime.assert(i1 false, %..string %754, %runtime.Source_Code_Location* %108)
	br label %if.done-66

if.done-66:
	br label %if.done-67

if.done-67:
	; IfStmt
	%758 = load i64, i64* %93, align 8
	; SelectorExpr
	%759 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %89, i64 0, i32 1
	%760 = load i64, i64* %759, align 8
	%761 = add i64 %758, %760
	%762 = load {i8*, i64}, {i8*, i64}* %90, align 8
	%763 = extractvalue {i8*, i64} %762, 1
	%764 = icmp sgt i64 %761, %763
	%765 = zext i1 %764 to i8
	%766 = trunc i8 %765 to i1
	br i1 %766, label %if.then-68, label %if.done-69

if.then-68:
	; old_mem
	%767 = load {i8*, i64}, {i8*, i64}* %90, align 8
	store {i8*, i64} %767, {i8*, i64}* %109
	; AssignStmt
	%768 = load {i8*, i64}, {i8*, i64}* %109, align 8
	%769 = extractvalue {i8*, i64} %768, 1
	%770 = mul i64 %769, 2
	; SelectorExpr
	%771 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%772 = load %mem.Allocator, %mem.Allocator* %771, align 8
	%773 = bitcast %mem.Allocator* %110 to %..rawptr
	%774 = call %..rawptr @mem.zero(%..rawptr %773, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %110
	store %mem.Allocator %772, %mem.Allocator* %110
	%775 = bitcast %runtime.Source_Code_Location* %111 to %..rawptr
	%776 = call %..rawptr @mem.zero(%..rawptr %775, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %111
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$189, i64 0, i32 0), i64 67}, i64 264, i64 19, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$18a, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %111
	%777 = call {i8*, i64} @mem.make_slice-14294(i64 %770, %mem.Allocator* %110, %runtime.Source_Code_Location* %111, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64} %777, {i8*, i64}* %90
	; SelectorExpr
	; IndexExpr
	%778 = load {i8*, i64}, {i8*, i64}* %90, align 8
	%779 = extractvalue {i8*, i64} %778, 0
	%780 = extractvalue {i8*, i64} %778, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$18b, i64 0, i32 0), i64 67}, i64 265, i64 27, i64 0, i64 %780)
	%781 = getelementptr inbounds i8, i8* %779, i64 0
	; IndexExpr
	%782 = load {i8*, i64}, {i8*, i64}* %109, align 8
	%783 = extractvalue {i8*, i64} %782, 0
	%784 = extractvalue {i8*, i64} %782, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$18c, i64 0, i32 0), i64 67}, i64 265, i64 40, i64 0, i64 %784)
	%785 = getelementptr inbounds i8, i8* %783, i64 0
	%786 = load {i8*, i64}, {i8*, i64}* %109, align 8
	%787 = extractvalue {i8*, i64} %786, 1
	%788 = bitcast i8* %781 to %..rawptr
	%789 = bitcast i8* %785 to %..rawptr
	%790 = call %..rawptr @mem.copy(%..rawptr %788, %..rawptr %789, i64 %787)
	%791 = load {i8*, i64}, {i8*, i64}* %109, align 8
	; SelectorExpr
	%792 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%793 = load %mem.Allocator, %mem.Allocator* %792, align 8
	%794 = bitcast {i8*, i64}* %112 to %..rawptr
	%795 = call %..rawptr @mem.zero(%..rawptr %794, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %112
	store {i8*, i64} %791, {i8*, i64}* %112
	%796 = bitcast %mem.Allocator* %113 to %..rawptr
	%797 = call %..rawptr @mem.zero(%..rawptr %796, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %113
	store %mem.Allocator %793, %mem.Allocator* %113
	%798 = bitcast %runtime.Source_Code_Location* %114 to %..rawptr
	%799 = call %..rawptr @mem.zero(%..rawptr %798, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %114
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$18d, i64 0, i32 0), i64 67}, i64 266, i64 10, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$18e, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %114
	call void @mem.delete_slice-14814({i8*, i64}* %112, %mem.Allocator* %113, %runtime.Source_Code_Location* %114, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-69

if.done-69:
	%800 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%801 = load %lexer.Token, %lexer.Token* %95, align 8
	; IndexExpr
	%802 = load {i8*, i64}, {i8*, i64}* %90, align 8
	%803 = extractvalue {i8*, i64} %802, 0
	%804 = load i64, i64* %93, align 8
	%805 = extractvalue {i8*, i64} %802, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$18f, i64 0, i32 0), i64 67}, i64 269, i64 55, i64 %804, i64 %805)
	%806 = getelementptr inbounds i8, i8* %803, i64 %804
	; SelectorExpr
	%807 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %89, i64 0, i32 0
	%808 = load %runtime.Type_Info*, %runtime.Type_Info** %807, align 8
	%809 = bitcast i8* %806 to %..rawptr
	%810 = bitcast %lexer.Token* %115 to %..rawptr
	%811 = call %..rawptr @mem.zero(%..rawptr %810, i64 56) noinline
	store %lexer.Token zeroinitializer, %lexer.Token* %115
	store %lexer.Token %801, %lexer.Token* %115
	call void @wbml.parse_value(%lexer.Lexer* %800, %lexer.Token* %115, %..rawptr %809, %runtime.Type_Info* %808, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	; SelectorExpr
	%812 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %89, i64 0, i32 1
	%813 = load i64, i64* %812, align 8
	%814 = load i64, i64* %93, align 8
	%815 = add i64 %814, %813
	store i64 %815, i64* %93
	; defer
	; AssignStmt
	%816 = load i64, i64* %94, align 8
	%817 = add i64 %816, 1
	store i64 %817, i64* %94
	br label %for.body-57

typeswitch.done-70:
	br label %switch.done-71

switch.done-71:
	br label %typeswitch.done-118

typeswitch.next-72:
	%818 = icmp eq i8 %154, 1
	br i1 %818, label %typeswitch.body-75, label %typeswitch.next-74

typeswitch.body-73:
	%819 = bitcast %..rawptr %155 to %lexer.Token_String*
	%820 = load %lexer.Token_String, %lexer.Token_String* %819, align 8
	store %lexer.Token_String %820, %lexer.Token_String* %123
	; AssignStmt
	%821 = load %..rawptr, %..rawptr* %1, align 8
	%822 = bitcast %..rawptr %821 to %..string*
	%823 = getelementptr inbounds %..string, %..string* %822, i64 0
	; SelectorExpr
	; SelectorExpr
	%824 = getelementptr inbounds %lexer.Token_String, %lexer.Token_String* %123, i64 0, i32 0
	%825 = load %..string, %..string* %824, align 8
	%826 = call %..string @strings.new_string(%..string %825, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..string %826, %..string* %823
	br label %typeswitch.done-118

typeswitch.next-74:
	%827 = icmp eq i8 %154, 2
	br i1 %827, label %typeswitch.body-86, label %typeswitch.next-85

typeswitch.body-75:
	%828 = bitcast %..rawptr %155 to %lexer.Token_Identifier*
	%829 = load %lexer.Token_Identifier, %lexer.Token_Identifier* %828, align 8
	store %lexer.Token_Identifier %829, %lexer.Token_Identifier* %124
	; SwitchStmt
	; SelectorExpr
	%830 = getelementptr inbounds %lexer.Token_Identifier, %lexer.Token_Identifier* %124, i64 0, i32 0
	%831 = load %..string, %..string* %830, align 8
	%832 = call i8 @runtime.string_eq(%..string %831, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$190, i64 0, i32 0), i64 4})
	%833 = trunc i8 %832 to i1
	br i1 %833, label %switch.case.body-79, label %switch.case.next-76

switch.case.next-76:
	%834 = call i8 @runtime.string_eq(%..string %831, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$191, i64 0, i32 0), i64 4})
	%835 = trunc i8 %834 to i1
	br i1 %835, label %switch.case.body-79, label %switch.case.next-77

switch.case.next-77:
	%836 = call i8 @runtime.string_eq(%..string %831, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$192, i64 0, i32 0), i64 4})
	%837 = trunc i8 %836 to i1
	br i1 %837, label %switch.case.body-79, label %switch.case.next-78

switch.case.next-78:
	%838 = call i8 @runtime.string_eq(%..string %831, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$193, i64 0, i32 0), i64 5})
	%839 = trunc i8 %838 to i1
	br i1 %839, label %switch.fall.body-83, label %switch.case.next-80

switch.case.body-79:
	; AssignStmt
	%840 = load %..rawptr, %..rawptr* %1, align 8
	%841 = bitcast %..rawptr %840 to i8*
	%842 = getelementptr inbounds i8, i8* %841, i64 0
	store i8 1, i8* %842
	br label %switch.done-84

switch.case.next-80:
	%843 = call i8 @runtime.string_eq(%..string %831, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$194, i64 0, i32 0), i64 5})
	%844 = trunc i8 %843 to i1
	br i1 %844, label %switch.fall.body-83, label %switch.case.next-81

switch.case.next-81:
	%845 = call i8 @runtime.string_eq(%..string %831, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$195, i64 0, i32 0), i64 5})
	%846 = trunc i8 %845 to i1
	br i1 %846, label %switch.fall.body-83, label %switch.case.next-82

switch.case.next-82:
	; SelectorExpr
	%847 = getelementptr inbounds %lexer.Token_Identifier, %lexer.Token_Identifier* %124, i64 0, i32 0
	%848 = load %..string, %..string* %847, align 8
	%849 = bitcast %runtime.Source_Code_Location* %125 to %..rawptr
	%850 = call %..rawptr @mem.zero(%..rawptr %849, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %125
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$196, i64 0, i32 0), i64 67}, i64 291, i64 6, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$197, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %125
	%851 = call i8 @runtime.assert(i1 false, %..string %848, %runtime.Source_Code_Location* %125)
	br label %switch.done-84

switch.fall.body-83:
	; AssignStmt
	%852 = load %..rawptr, %..rawptr* %1, align 8
	%853 = bitcast %..rawptr %852 to i8*
	%854 = getelementptr inbounds i8, i8* %853, i64 0
	store i8 0, i8* %854
	br label %switch.done-84

switch.done-84:
	br label %typeswitch.done-118

typeswitch.next-85:
	br label %typeswitch.done-118

typeswitch.body-86:
	%855 = bitcast %..rawptr %155 to %lexer.Token_Number*
	%856 = load %lexer.Token_Number, %lexer.Token_Number* %855, align 8
	store %lexer.Token_Number %856, %lexer.Token_Number* %126
	; TypeSwitchStmt
	; SelectorExpr
	%857 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%858 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %857, i64 0
	%859 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %858, i64 0, i32 3
	%860 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %859, align 8
	; get union's tag
	%861 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %859, i64 0, i32 2 ; UnionTagPtr
	%862 = load i8, i8* %861, align 1
	%863 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %859 to %..rawptr
	%864 = icmp eq i8 %862, 2
	br i1 %864, label %typeswitch.body-88, label %typeswitch.next-87

typeswitch.next-87:
	%865 = icmp eq i8 %862, 4
	br i1 %865, label %typeswitch.body-111, label %typeswitch.next-110

typeswitch.body-88:
	%866 = bitcast %..rawptr %863 to %runtime.Type_Info_Integer*
	%867 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %866, align 1
	store %runtime.Type_Info_Integer %867, %runtime.Type_Info_Integer* %127
	; IfStmt
	; SelectorExpr
	%868 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %127, i64 0, i32 0
	%869 = load i8, i8* %868, align 1
	%870 = trunc i8 %869 to i1
	br i1 %870, label %if.then-89, label %if.else-99

if.then-89:
	; SwitchStmt
	; SelectorExpr
	%871 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%872 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %871, i64 0
	%873 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %872, i64 0, i32 0
	%874 = load i64, i64* %873, align 8
	%875 = icmp eq i64 %874, 1
	br i1 %875, label %switch.case.body-91, label %switch.case.next-90

switch.case.next-90:
	%876 = icmp eq i64 %874, 2
	br i1 %876, label %switch.fall.body-93, label %switch.case.next-92

switch.case.body-91:
	; AssignStmt
	%877 = load %..rawptr, %..rawptr* %1, align 8
	%878 = bitcast %..rawptr %877 to i8*
	%879 = getelementptr inbounds i8, i8* %878, i64 0
	; SelectorExpr
	%880 = getelementptr inbounds %lexer.Token_Number, %lexer.Token_Number* %126, i64 0, i32 0
	%881 = load i64, i64* %880, align 8
	%882 = trunc i64 %881 to i8
	store i8 %882, i8* %879
	br label %switch.done-98

switch.case.next-92:
	%883 = icmp eq i64 %874, 4
	br i1 %883, label %switch.fall.body-95, label %switch.case.next-94

switch.fall.body-93:
	; AssignStmt
	%884 = load %..rawptr, %..rawptr* %1, align 8
	%885 = bitcast %..rawptr %884 to i16*
	%886 = getelementptr inbounds i16, i16* %885, i64 0
	; SelectorExpr
	%887 = getelementptr inbounds %lexer.Token_Number, %lexer.Token_Number* %126, i64 0, i32 0
	%888 = load i64, i64* %887, align 8
	%889 = trunc i64 %888 to i16
	store i16 %889, i16* %886
	br label %switch.done-98

switch.case.next-94:
	%890 = icmp eq i64 %874, 8
	br i1 %890, label %switch.fall.body-97, label %switch.case.next-96

switch.fall.body-95:
	; AssignStmt
	%891 = load %..rawptr, %..rawptr* %1, align 8
	%892 = bitcast %..rawptr %891 to i32*
	%893 = getelementptr inbounds i32, i32* %892, i64 0
	; SelectorExpr
	%894 = getelementptr inbounds %lexer.Token_Number, %lexer.Token_Number* %126, i64 0, i32 0
	%895 = load i64, i64* %894, align 8
	%896 = trunc i64 %895 to i32
	store i32 %896, i32* %893
	br label %switch.done-98

switch.case.next-96:
	; SelectorExpr
	%897 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%898 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %897, i64 0
	%899 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %898, i64 0, i32 0
	%900 = load i64, i64* %899, align 8
	%901 = bitcast %..any* %128 to %..rawptr
	%902 = call %..rawptr @mem.zero(%..rawptr %901, i64 16) noinline
	store %..any zeroinitializer, %..any* %128
	%903 = bitcast i64* %899 to %..rawptr
	%904 = getelementptr inbounds %..any, %..any* %128, i64 0, i32 0
	store %..rawptr %903, %..rawptr* %904
	%905 = getelementptr inbounds %..any, %..any* %128, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %905
	%906 = load %..any, %..any* %128, align 8
	; variadic call argument generation
	%907 = bitcast {%..any*, i64}* %129 to %..rawptr
	%908 = call %..rawptr @mem.zero(%..rawptr %907, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %129
	%909 = bitcast [1 x %..any]* %130 to %..rawptr
	%910 = call %..rawptr @mem.zero(%..rawptr %909, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %130
	%911 = getelementptr inbounds [1 x %..any], [1 x %..any]* %130, i64 0, i32 0
	store %..any %906, %..any* %911
	%912 = getelementptr inbounds [1 x %..any], [1 x %..any]* %130, i64 0, i32 0
	%913 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %129, i64 0, i32 0
	store %..any* %912, %..any** %913
	%914 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %129, i64 0, i32 1
	store i64 1, i64* %914
	%915 = load {%..any*, i64}, {%..any*, i64}* %129, align 8
	%916 = bitcast {%..any*, i64}* %131 to %..rawptr
	%917 = call %..rawptr @mem.zero(%..rawptr %916, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %131
	store {%..any*, i64} %915, {%..any*, i64}* %131
	%918 = call %..string @fmt.tprint({%..any*, i64}* %131, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%919 = bitcast %runtime.Source_Code_Location* %132 to %..rawptr
	%920 = call %..rawptr @mem.zero(%..rawptr %919, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %132
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$198, i64 0, i32 0), i64 67}, i64 305, i64 14, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$199, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %132
	call void @runtime.panic(%..string %918, %runtime.Source_Code_Location* %132) noreturn
	br label %switch.done-98

switch.fall.body-97:
	; AssignStmt
	%921 = load %..rawptr, %..rawptr* %1, align 8
	%922 = bitcast %..rawptr %921 to i64*
	%923 = getelementptr inbounds i64, i64* %922, i64 0
	; SelectorExpr
	%924 = getelementptr inbounds %lexer.Token_Number, %lexer.Token_Number* %126, i64 0, i32 0
	%925 = load i64, i64* %924, align 8
	store i64 %925, i64* %923
	br label %switch.done-98

switch.done-98:
	br label %if.done-109

if.else-99:
	; SwitchStmt
	; SelectorExpr
	%926 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%927 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %926, i64 0
	%928 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %927, i64 0, i32 0
	%929 = load i64, i64* %928, align 8
	%930 = icmp eq i64 %929, 1
	br i1 %930, label %switch.case.body-101, label %switch.case.next-100

switch.case.next-100:
	%931 = icmp eq i64 %929, 2
	br i1 %931, label %switch.fall.body-103, label %switch.case.next-102

switch.case.body-101:
	; AssignStmt
	%932 = load %..rawptr, %..rawptr* %1, align 8
	%933 = bitcast %..rawptr %932 to i8*
	%934 = getelementptr inbounds i8, i8* %933, i64 0
	; SelectorExpr
	%935 = getelementptr inbounds %lexer.Token_Number, %lexer.Token_Number* %126, i64 0, i32 1
	%936 = load i64, i64* %935, align 8
	%937 = trunc i64 %936 to i8
	store i8 %937, i8* %934
	br label %switch.done-108

switch.case.next-102:
	%938 = icmp eq i64 %929, 4
	br i1 %938, label %switch.fall.body-105, label %switch.case.next-104

switch.fall.body-103:
	; AssignStmt
	%939 = load %..rawptr, %..rawptr* %1, align 8
	%940 = bitcast %..rawptr %939 to i16*
	%941 = getelementptr inbounds i16, i16* %940, i64 0
	; SelectorExpr
	%942 = getelementptr inbounds %lexer.Token_Number, %lexer.Token_Number* %126, i64 0, i32 1
	%943 = load i64, i64* %942, align 8
	%944 = trunc i64 %943 to i16
	store i16 %944, i16* %941
	br label %switch.done-108

switch.case.next-104:
	%945 = icmp eq i64 %929, 8
	br i1 %945, label %switch.fall.body-107, label %switch.case.next-106

switch.fall.body-105:
	; AssignStmt
	%946 = load %..rawptr, %..rawptr* %1, align 8
	%947 = bitcast %..rawptr %946 to i32*
	%948 = getelementptr inbounds i32, i32* %947, i64 0
	; SelectorExpr
	%949 = getelementptr inbounds %lexer.Token_Number, %lexer.Token_Number* %126, i64 0, i32 1
	%950 = load i64, i64* %949, align 8
	%951 = trunc i64 %950 to i32
	store i32 %951, i32* %948
	br label %switch.done-108

switch.case.next-106:
	; SelectorExpr
	%952 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%953 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %952, i64 0
	%954 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %953, i64 0, i32 0
	%955 = load i64, i64* %954, align 8
	%956 = bitcast %..any* %133 to %..rawptr
	%957 = call %..rawptr @mem.zero(%..rawptr %956, i64 16) noinline
	store %..any zeroinitializer, %..any* %133
	%958 = bitcast i64* %954 to %..rawptr
	%959 = getelementptr inbounds %..any, %..any* %133, i64 0, i32 0
	store %..rawptr %958, %..rawptr* %959
	%960 = getelementptr inbounds %..any, %..any* %133, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %960
	%961 = load %..any, %..any* %133, align 8
	; variadic call argument generation
	%962 = bitcast {%..any*, i64}* %134 to %..rawptr
	%963 = call %..rawptr @mem.zero(%..rawptr %962, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %134
	%964 = bitcast [1 x %..any]* %135 to %..rawptr
	%965 = call %..rawptr @mem.zero(%..rawptr %964, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %135
	%966 = getelementptr inbounds [1 x %..any], [1 x %..any]* %135, i64 0, i32 0
	store %..any %961, %..any* %966
	%967 = getelementptr inbounds [1 x %..any], [1 x %..any]* %135, i64 0, i32 0
	%968 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %134, i64 0, i32 0
	store %..any* %967, %..any** %968
	%969 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %134, i64 0, i32 1
	store i64 1, i64* %969
	%970 = load {%..any*, i64}, {%..any*, i64}* %134, align 8
	%971 = bitcast {%..any*, i64}* %136 to %..rawptr
	%972 = call %..rawptr @mem.zero(%..rawptr %971, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %136
	store {%..any*, i64} %970, {%..any*, i64}* %136
	%973 = call %..string @fmt.tprint({%..any*, i64}* %136, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%974 = bitcast %runtime.Source_Code_Location* %137 to %..rawptr
	%975 = call %..rawptr @mem.zero(%..rawptr %974, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %137
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$19a, i64 0, i32 0), i64 67}, i64 314, i64 14, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$19b, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %137
	call void @runtime.panic(%..string %973, %runtime.Source_Code_Location* %137) noreturn
	br label %switch.done-108

switch.fall.body-107:
	; AssignStmt
	%976 = load %..rawptr, %..rawptr* %1, align 8
	%977 = bitcast %..rawptr %976 to i64*
	%978 = getelementptr inbounds i64, i64* %977, i64 0
	; SelectorExpr
	%979 = getelementptr inbounds %lexer.Token_Number, %lexer.Token_Number* %126, i64 0, i32 1
	%980 = load i64, i64* %979, align 8
	store i64 %980, i64* %978
	br label %switch.done-108

switch.done-108:
	br label %if.done-109

if.done-109:
	br label %typeswitch.done-117

typeswitch.next-110:
	store {[0 x <8 x i8>], [72 x i8], i8} %860, {[0 x <8 x i8>], [72 x i8], i8}* %144
	%981 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %144, align 8
	%982 = bitcast %..any* %145 to %..rawptr
	%983 = call %..rawptr @mem.zero(%..rawptr %982, i64 16) noinline
	store %..any zeroinitializer, %..any* %145
	%984 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %144 to %..rawptr
	%985 = getelementptr inbounds %..any, %..any* %145, i64 0, i32 0
	store %..rawptr %984, %..rawptr* %985
	%986 = getelementptr inbounds %..any, %..any* %145, i64 0, i32 1
	store %..typeid 1152921504606846984, %..typeid* %986
	%987 = load %..any, %..any* %145, align 8
	; variadic call argument generation
	%988 = bitcast {%..any*, i64}* %146 to %..rawptr
	%989 = call %..rawptr @mem.zero(%..rawptr %988, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %146
	%990 = bitcast [1 x %..any]* %147 to %..rawptr
	%991 = call %..rawptr @mem.zero(%..rawptr %990, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %147
	%992 = getelementptr inbounds [1 x %..any], [1 x %..any]* %147, i64 0, i32 0
	store %..any %987, %..any* %992
	%993 = getelementptr inbounds [1 x %..any], [1 x %..any]* %147, i64 0, i32 0
	%994 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %146, i64 0, i32 0
	store %..any* %993, %..any** %994
	%995 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %146, i64 0, i32 1
	store i64 1, i64* %995
	%996 = load {%..any*, i64}, {%..any*, i64}* %146, align 8
	%997 = bitcast {%..any*, i64}* %148 to %..rawptr
	%998 = call %..rawptr @mem.zero(%..rawptr %997, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %148
	store {%..any*, i64} %996, {%..any*, i64}* %148
	%999 = call %..string @fmt.tprint({%..any*, i64}* %148, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%1000 = bitcast %runtime.Source_Code_Location* %149 to %..rawptr
	%1001 = call %..rawptr @mem.zero(%..rawptr %1000, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %149
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$19c, i64 0, i32 0), i64 67}, i64 326, i64 6, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$19d, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %149
	%1002 = call i8 @runtime.assert(i1 false, %..string %999, %runtime.Source_Code_Location* %149)
	br label %typeswitch.done-117

typeswitch.body-111:
	%1003 = bitcast %..rawptr %863 to %runtime.Type_Info_Float*
	%1004 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %1003, align 1
	store %runtime.Type_Info_Float %1004, %runtime.Type_Info_Float* %138
	; SwitchStmt
	; SelectorExpr
	%1005 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%1006 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1005, i64 0
	%1007 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1006, i64 0, i32 0
	%1008 = load i64, i64* %1007, align 8
	%1009 = icmp eq i64 %1008, 4
	br i1 %1009, label %switch.case.body-113, label %switch.case.next-112

switch.case.next-112:
	%1010 = icmp eq i64 %1008, 8
	br i1 %1010, label %switch.fall.body-115, label %switch.case.next-114

switch.case.body-113:
	; AssignStmt
	%1011 = load %..rawptr, %..rawptr* %1, align 8
	%1012 = bitcast %..rawptr %1011 to float*
	%1013 = getelementptr inbounds float, float* %1012, i64 0
	; SelectorExpr
	%1014 = getelementptr inbounds %lexer.Token_Number, %lexer.Token_Number* %126, i64 0, i32 2
	%1015 = load double, double* %1014, align 8
	%1016 = fptrunc double %1015 to float
	store float %1016, float* %1013
	br label %switch.done-116

switch.case.next-114:
	; SelectorExpr
	%1017 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%1018 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1017, i64 0
	%1019 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1018, i64 0, i32 0
	%1020 = load i64, i64* %1019, align 8
	%1021 = bitcast %..any* %139 to %..rawptr
	%1022 = call %..rawptr @mem.zero(%..rawptr %1021, i64 16) noinline
	store %..any zeroinitializer, %..any* %139
	%1023 = bitcast i64* %1019 to %..rawptr
	%1024 = getelementptr inbounds %..any, %..any* %139, i64 0, i32 0
	store %..rawptr %1023, %..rawptr* %1024
	%1025 = getelementptr inbounds %..any, %..any* %139, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %1025
	%1026 = load %..any, %..any* %139, align 8
	; variadic call argument generation
	%1027 = bitcast {%..any*, i64}* %140 to %..rawptr
	%1028 = call %..rawptr @mem.zero(%..rawptr %1027, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %140
	%1029 = bitcast [1 x %..any]* %141 to %..rawptr
	%1030 = call %..rawptr @mem.zero(%..rawptr %1029, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %141
	%1031 = getelementptr inbounds [1 x %..any], [1 x %..any]* %141, i64 0, i32 0
	store %..any %1026, %..any* %1031
	%1032 = getelementptr inbounds [1 x %..any], [1 x %..any]* %141, i64 0, i32 0
	%1033 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %140, i64 0, i32 0
	store %..any* %1032, %..any** %1033
	%1034 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %140, i64 0, i32 1
	store i64 1, i64* %1034
	%1035 = load {%..any*, i64}, {%..any*, i64}* %140, align 8
	%1036 = bitcast {%..any*, i64}* %142 to %..rawptr
	%1037 = call %..rawptr @mem.zero(%..rawptr %1036, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %142
	store {%..any*, i64} %1035, {%..any*, i64}* %142
	%1038 = call %..string @fmt.tprint({%..any*, i64}* %142, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%1039 = bitcast %runtime.Source_Code_Location* %143 to %..rawptr
	%1040 = call %..rawptr @mem.zero(%..rawptr %1039, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %143
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$19e, i64 0, i32 0), i64 67}, i64 322, i64 13, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$19f, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %143
	call void @runtime.panic(%..string %1038, %runtime.Source_Code_Location* %143) noreturn
	br label %switch.done-116

switch.fall.body-115:
	; AssignStmt
	%1041 = load %..rawptr, %..rawptr* %1, align 8
	%1042 = bitcast %..rawptr %1041 to double*
	%1043 = getelementptr inbounds double, double* %1042, i64 0
	; SelectorExpr
	%1044 = getelementptr inbounds %lexer.Token_Number, %lexer.Token_Number* %126, i64 0, i32 2
	%1045 = load double, double* %1044, align 8
	store double %1045, double* %1043
	br label %switch.done-116

switch.done-116:
	br label %typeswitch.done-117

typeswitch.done-117:
	br label %typeswitch.done-118

typeswitch.done-118:
	ret void
}

define i64 @strconv._digit_value(i32 %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store i32 %r, i32* %0
	; ri
	%3 = load i32, i32* %0, align 4
	%4 = sext i32 %3 to i64
	store i64 %4, i64* %1
	; v
	store i64 16, i64* %2
	; SwitchStmt
	%5 = load i32, i32* %0, align 4
	%6 = icmp sle i32 48, %5
	%7 = icmp sle i32 %5, 57
	%8 = zext i1 %6 to i8
	%9 = zext i1 %7 to i8
	%10 = and i8 %8, %9
	%11 = trunc i8 %10 to i1
	br i1 %11, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%12 = icmp sle i32 97, %5
	%13 = icmp sle i32 %5, 122
	%14 = zext i1 %12 to i8
	%15 = zext i1 %13 to i8
	%16 = and i8 %14, %15
	%17 = trunc i8 %16 to i1
	br i1 %17, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	; AssignStmt
	%18 = load i64, i64* %1, align 8
	%19 = sub i64 %18, 48
	store i64 %19, i64* %2
	br label %switch.done-7

switch.case.next-3:
	%20 = icmp sle i32 65, %5
	%21 = icmp sle i32 %5, 90
	%22 = zext i1 %20 to i8
	%23 = zext i1 %21 to i8
	%24 = and i8 %22, %23
	%25 = trunc i8 %24 to i1
	br i1 %25, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	; AssignStmt
	%26 = load i64, i64* %1, align 8
	%27 = sub i64 %26, 97
	%28 = add i64 %27, 10
	store i64 %28, i64* %2
	br label %switch.done-7

switch.case.next-5:
	br label %switch.done-7

switch.fall.body-6:
	; AssignStmt
	%29 = load i64, i64* %1, align 8
	%30 = sub i64 %29, 65
	%31 = add i64 %30, 10
	store i64 %31, i64* %2
	br label %switch.done-7

switch.done-7:
	; ReturnStmt
	%32 = load i64, i64* %2, align 8
	ret i64 %32
}

define i64 @strconv.parse_i64(%..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i8, align 16
	%2 = alloca %..string, align 16
	%3 = alloca %..string, align 16
	%4 = alloca i64, align 16
	%5 = alloca %..string, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..string, align 16
	%8 = alloca %..string, align 16
	%9 = alloca %..string, align 16
	%10 = alloca i64, align 16
	%11 = alloca i32, align 16
	%12 = alloca i64, align 16
	%13 = alloca %..string, align 16
	%14 = alloca i64, align 16
	store %..string %s, %..string* %0
	; neg
	store i8 0, i8* %1
	; IfStmt
	%15 = load %..string, %..string* %0, align 8
	%16 = extractvalue %..string %15, 1
	%17 = icmp sgt i64 %16, 1
	%18 = zext i1 %17 to i8
	%19 = trunc i8 %18 to i1
	br i1 %19, label %if.then-1, label %if.done-7

if.then-1:
	; SwitchStmt
	; IndexExpr
	%20 = load %..string, %..string* %0, align 8
	%21 = extractvalue %..string %20, 0
	%22 = extractvalue %..string %20, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1a0, i64 0, i32 0), i64 61}, i64 37, i64 12, i64 0, i64 %22)
	%23 = getelementptr inbounds i8, i8* %21, i64 0
	%24 = load i8, i8* %23, align 1
	%25 = icmp eq i8 %24, 45
	br i1 %25, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%26 = icmp eq i8 %24, 43
	br i1 %26, label %switch.fall.body-5, label %switch.case.next-4

switch.case.body-3:
	; AssignStmt
	store i8 1, i8* %1
	; AssignStmt
	; SliceExpr
	%27 = load %..string, %..string* %0, align 8
	%28 = extractvalue %..string %27, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1a1, i64 0, i32 0), i64 61}, i64 40, i64 9, i64 1, i64 %28, i64 %28)
	%29 = extractvalue %..string %27, 0
	%30 = getelementptr inbounds i8, i8* %29, i64 1
	%31 = sub i64 %28, 1
	%32 = bitcast %..string* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	%34 = getelementptr inbounds %..string, %..string* %2, i64 0, i32 0
	store i8* %30, i8** %34
	%35 = getelementptr inbounds %..string, %..string* %2, i64 0, i32 1
	store i64 %31, i64* %35
	%36 = load %..string, %..string* %2, align 8
	store %..string %36, %..string* %0
	br label %switch.done-6

switch.case.next-4:
	br label %switch.done-6

switch.fall.body-5:
	; AssignStmt
	; SliceExpr
	%37 = load %..string, %..string* %0, align 8
	%38 = extractvalue %..string %37, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1a2, i64 0, i32 0), i64 61}, i64 42, i64 9, i64 1, i64 %38, i64 %38)
	%39 = extractvalue %..string %37, 0
	%40 = getelementptr inbounds i8, i8* %39, i64 1
	%41 = sub i64 %38, 1
	%42 = bitcast %..string* %3 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 16) noinline
	store %..string zeroinitializer, %..string* %3
	%44 = getelementptr inbounds %..string, %..string* %3, i64 0, i32 0
	store i8* %40, i8** %44
	%45 = getelementptr inbounds %..string, %..string* %3, i64 0, i32 1
	store i64 %41, i64* %45
	%46 = load %..string, %..string* %3, align 8
	store %..string %46, %..string* %0
	br label %switch.done-6

switch.done-6:
	br label %if.done-7

if.done-7:
	; base
	store i64 10, i64* %4
	; IfStmt
	%47 = load %..string, %..string* %0, align 8
	%48 = extractvalue %..string %47, 1
	%49 = icmp sgt i64 %48, 2
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %cmp.and-8, label %if.done-21

cmp.and-8:
	; IndexExpr
	%52 = load %..string, %..string* %0, align 8
	%53 = extractvalue %..string %52, 0
	%54 = extractvalue %..string %52, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1a3, i64 0, i32 0), i64 61}, i64 48, i64 21, i64 0, i64 %54)
	%55 = getelementptr inbounds i8, i8* %53, i64 0
	%56 = load i8, i8* %55, align 1
	%57 = icmp eq i8 %56, 48
	%58 = zext i1 %57 to i8
	%59 = trunc i8 %58 to i1
	br i1 %59, label %if.then-9, label %if.done-21

if.then-9:
	; SwitchStmt
	; IndexExpr
	%60 = load %..string, %..string* %0, align 8
	%61 = extractvalue %..string %60, 0
	%62 = extractvalue %..string %60, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1a4, i64 0, i32 0), i64 61}, i64 49, i64 12, i64 1, i64 %62)
	%63 = getelementptr inbounds i8, i8* %61, i64 1
	%64 = load i8, i8* %63, align 1
	%65 = icmp eq i8 %64, 98
	br i1 %65, label %switch.case.body-11, label %switch.case.next-10

switch.case.next-10:
	%66 = icmp eq i8 %64, 111
	br i1 %66, label %switch.fall.body-13, label %switch.case.next-12

switch.case.body-11:
	; AssignStmt
	store i64 2, i64* %4
	; AssignStmt
	; SliceExpr
	%67 = load %..string, %..string* %0, align 8
	%68 = extractvalue %..string %67, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1a5, i64 0, i32 0), i64 61}, i64 50, i64 30, i64 2, i64 %68, i64 %68)
	%69 = extractvalue %..string %67, 0
	%70 = getelementptr inbounds i8, i8* %69, i64 2
	%71 = sub i64 %68, 2
	%72 = bitcast %..string* %5 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 16) noinline
	store %..string zeroinitializer, %..string* %5
	%74 = getelementptr inbounds %..string, %..string* %5, i64 0, i32 0
	store i8* %70, i8** %74
	%75 = getelementptr inbounds %..string, %..string* %5, i64 0, i32 1
	store i64 %71, i64* %75
	%76 = load %..string, %..string* %5, align 8
	store %..string %76, %..string* %0
	br label %switch.done-20

switch.case.next-12:
	%77 = icmp eq i8 %64, 100
	br i1 %77, label %switch.fall.body-15, label %switch.case.next-14

switch.fall.body-13:
	; AssignStmt
	store i64 8, i64* %4
	; AssignStmt
	; SliceExpr
	%78 = load %..string, %..string* %0, align 8
	%79 = extractvalue %..string %78, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1a6, i64 0, i32 0), i64 61}, i64 51, i64 30, i64 2, i64 %79, i64 %79)
	%80 = extractvalue %..string %78, 0
	%81 = getelementptr inbounds i8, i8* %80, i64 2
	%82 = sub i64 %79, 2
	%83 = bitcast %..string* %6 to %..rawptr
	%84 = call %..rawptr @mem.zero(%..rawptr %83, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	%85 = getelementptr inbounds %..string, %..string* %6, i64 0, i32 0
	store i8* %81, i8** %85
	%86 = getelementptr inbounds %..string, %..string* %6, i64 0, i32 1
	store i64 %82, i64* %86
	%87 = load %..string, %..string* %6, align 8
	store %..string %87, %..string* %0
	br label %switch.done-20

switch.case.next-14:
	%88 = icmp eq i8 %64, 122
	br i1 %88, label %switch.fall.body-17, label %switch.case.next-16

switch.fall.body-15:
	; AssignStmt
	store i64 10, i64* %4
	; AssignStmt
	; SliceExpr
	%89 = load %..string, %..string* %0, align 8
	%90 = extractvalue %..string %89, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1a7, i64 0, i32 0), i64 61}, i64 52, i64 30, i64 2, i64 %90, i64 %90)
	%91 = extractvalue %..string %89, 0
	%92 = getelementptr inbounds i8, i8* %91, i64 2
	%93 = sub i64 %90, 2
	%94 = bitcast %..string* %7 to %..rawptr
	%95 = call %..rawptr @mem.zero(%..rawptr %94, i64 16) noinline
	store %..string zeroinitializer, %..string* %7
	%96 = getelementptr inbounds %..string, %..string* %7, i64 0, i32 0
	store i8* %92, i8** %96
	%97 = getelementptr inbounds %..string, %..string* %7, i64 0, i32 1
	store i64 %93, i64* %97
	%98 = load %..string, %..string* %7, align 8
	store %..string %98, %..string* %0
	br label %switch.done-20

switch.case.next-16:
	%99 = icmp eq i8 %64, 120
	br i1 %99, label %switch.fall.body-19, label %switch.case.next-18

switch.fall.body-17:
	; AssignStmt
	store i64 12, i64* %4
	; AssignStmt
	; SliceExpr
	%100 = load %..string, %..string* %0, align 8
	%101 = extractvalue %..string %100, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1a8, i64 0, i32 0), i64 61}, i64 53, i64 30, i64 2, i64 %101, i64 %101)
	%102 = extractvalue %..string %100, 0
	%103 = getelementptr inbounds i8, i8* %102, i64 2
	%104 = sub i64 %101, 2
	%105 = bitcast %..string* %8 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store %..string zeroinitializer, %..string* %8
	%107 = getelementptr inbounds %..string, %..string* %8, i64 0, i32 0
	store i8* %103, i8** %107
	%108 = getelementptr inbounds %..string, %..string* %8, i64 0, i32 1
	store i64 %104, i64* %108
	%109 = load %..string, %..string* %8, align 8
	store %..string %109, %..string* %0
	br label %switch.done-20

switch.case.next-18:
	br label %switch.done-20

switch.fall.body-19:
	; AssignStmt
	store i64 16, i64* %4
	; AssignStmt
	; SliceExpr
	%110 = load %..string, %..string* %0, align 8
	%111 = extractvalue %..string %110, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1a9, i64 0, i32 0), i64 61}, i64 54, i64 30, i64 2, i64 %111, i64 %111)
	%112 = extractvalue %..string %110, 0
	%113 = getelementptr inbounds i8, i8* %112, i64 2
	%114 = sub i64 %111, 2
	%115 = bitcast %..string* %9 to %..rawptr
	%116 = call %..rawptr @mem.zero(%..rawptr %115, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	%117 = getelementptr inbounds %..string, %..string* %9, i64 0, i32 0
	store i8* %113, i8** %117
	%118 = getelementptr inbounds %..string, %..string* %9, i64 0, i32 1
	store i64 %114, i64* %118
	%119 = load %..string, %..string* %9, align 8
	store %..string %119, %..string* %0
	br label %switch.done-20

switch.done-20:
	br label %if.done-21

if.done-21:
	; value
	%120 = bitcast i64* %10 to %..rawptr
	%121 = call %..rawptr @mem.zero(%..rawptr %120, i64 8) noinline
	store i64 zeroinitializer, i64* %10
	; RangeStmt
	; r
	%122 = bitcast i32* %11 to %..rawptr
	%123 = call %..rawptr @mem.zero(%..rawptr %122, i64 4) noinline
	store i32 zeroinitializer, i32* %11
	%124 = load %..string, %..string* %0, align 8
	%125 = extractvalue %..string %124, 1
	%126 = bitcast i64* %12 to %..rawptr
	%127 = call %..rawptr @mem.zero(%..rawptr %126, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	store i64 0, i64* %12
	br label %for.string.loop-22

for.string.loop-22:
	%128 = load i64, i64* %12, align 8
	%129 = icmp slt i64 %128, %125
	br i1 %129, label %for.string.body-23, label %for.string.done-28

for.string.body-23:
	%130 = extractvalue %..string %124, 0
	%131 = getelementptr inbounds i8, i8* %130, i64 %128
	%132 = sub i64 %125, %128
	%133 = bitcast %..string* %13 to %..rawptr
	%134 = call %..rawptr @mem.zero(%..rawptr %133, i64 16) noinline
	store %..string zeroinitializer, %..string* %13
	%135 = getelementptr inbounds %..string, %..string* %13, i64 0, i32 0
	store i8* %131, i8** %135
	%136 = getelementptr inbounds %..string, %..string* %13, i64 0, i32 1
	store i64 %132, i64* %136
	%137 = load %..string, %..string* %13, align 8
	%138 = call {i32, i64} @runtime.string_decode_rune(%..string %137)
	%139 = extractvalue {i32, i64} %138, 1
	%140 = add i64 %128, %139
	store i64 %140, i64* %12
	%141 = extractvalue {i32, i64} %138, 0
	store i32 %141, i32* %11
	; IfStmt
	%142 = load i32, i32* %11, align 4
	%143 = icmp eq i32 %142, 95
	%144 = zext i1 %143 to i8
	%145 = trunc i8 %144 to i1
	br i1 %145, label %if.then-24, label %if.done-25

if.then-24:
	; continue
	br label %for.string.loop-22

if.done-25:
	; v
	%146 = load i32, i32* %11, align 4
	%147 = call i64 @strconv._digit_value(i32 %146, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%148 = bitcast i64 %147 to i64
	store i64 %148, i64* %14
	; IfStmt
	%149 = load i64, i64* %14, align 8
	%150 = load i64, i64* %4, align 8
	%151 = icmp sge i64 %149, %150
	%152 = zext i1 %151 to i8
	%153 = trunc i8 %152 to i1
	br i1 %153, label %if.then-26, label %if.done-27

if.then-26:
	; break
	br label %for.string.done-28

if.done-27:
	; AssignStmt
	%154 = load i64, i64* %4, align 8
	%155 = load i64, i64* %10, align 8
	%156 = mul i64 %155, %154
	store i64 %156, i64* %10
	; AssignStmt
	%157 = load i64, i64* %14, align 8
	%158 = load i64, i64* %10, align 8
	%159 = add i64 %158, %157
	store i64 %159, i64* %10
	br label %for.string.loop-22

for.string.done-28:
	; IfStmt
	%160 = load i8, i8* %1, align 1
	%161 = trunc i8 %160 to i1
	br i1 %161, label %if.then-29, label %if.done-30

if.then-29:
	; ReturnStmt
	%162 = load i64, i64* %10, align 8
	%163 = sub i64 0, %162
	ret i64 %163

if.done-30:
	; ReturnStmt
	%164 = load i64, i64* %10, align 8
	ret i64 %164
}

define i64 @strconv.parse_u64(%..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i8, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..string, align 16
	%5 = alloca %..string, align 16
	%6 = alloca %..string, align 16
	%7 = alloca %..string, align 16
	%8 = alloca %..string, align 16
	%9 = alloca i64, align 16
	%10 = alloca i32, align 16
	%11 = alloca i64, align 16
	%12 = alloca %..string, align 16
	%13 = alloca i64, align 16
	store %..string %s, %..string* %0
	; neg
	store i8 0, i8* %1
	; IfStmt
	%14 = load %..string, %..string* %0, align 8
	%15 = extractvalue %..string %14, 1
	%16 = icmp sgt i64 %15, 1
	%17 = zext i1 %16 to i8
	%18 = trunc i8 %17 to i1
	br i1 %18, label %cmp.and-1, label %if.done-3

cmp.and-1:
	; IndexExpr
	%19 = load %..string, %..string* %0, align 8
	%20 = extractvalue %..string %19, 0
	%21 = extractvalue %..string %19, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1aa, i64 0, i32 0), i64 61}, i64 79, i64 21, i64 0, i64 %21)
	%22 = getelementptr inbounds i8, i8* %20, i64 0
	%23 = load i8, i8* %22, align 1
	%24 = icmp eq i8 %23, 43
	%25 = zext i1 %24 to i8
	%26 = trunc i8 %25 to i1
	br i1 %26, label %if.then-2, label %if.done-3

if.then-2:
	; AssignStmt
	; SliceExpr
	%27 = load %..string, %..string* %0, align 8
	%28 = extractvalue %..string %27, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1ab, i64 0, i32 0), i64 61}, i64 80, i64 8, i64 1, i64 %28, i64 %28)
	%29 = extractvalue %..string %27, 0
	%30 = getelementptr inbounds i8, i8* %29, i64 1
	%31 = sub i64 %28, 1
	%32 = bitcast %..string* %2 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	%34 = getelementptr inbounds %..string, %..string* %2, i64 0, i32 0
	store i8* %30, i8** %34
	%35 = getelementptr inbounds %..string, %..string* %2, i64 0, i32 1
	store i64 %31, i64* %35
	%36 = load %..string, %..string* %2, align 8
	store %..string %36, %..string* %0
	br label %if.done-3

if.done-3:
	; base
	store i64 10, i64* %3
	; IfStmt
	%37 = load %..string, %..string* %0, align 8
	%38 = extractvalue %..string %37, 1
	%39 = icmp sgt i64 %38, 2
	%40 = zext i1 %39 to i8
	%41 = trunc i8 %40 to i1
	br i1 %41, label %cmp.and-4, label %if.done-17

cmp.and-4:
	; IndexExpr
	%42 = load %..string, %..string* %0, align 8
	%43 = extractvalue %..string %42, 0
	%44 = extractvalue %..string %42, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1ac, i64 0, i32 0), i64 61}, i64 85, i64 21, i64 0, i64 %44)
	%45 = getelementptr inbounds i8, i8* %43, i64 0
	%46 = load i8, i8* %45, align 1
	%47 = icmp eq i8 %46, 48
	%48 = zext i1 %47 to i8
	%49 = trunc i8 %48 to i1
	br i1 %49, label %if.then-5, label %if.done-17

if.then-5:
	; SwitchStmt
	; IndexExpr
	%50 = load %..string, %..string* %0, align 8
	%51 = extractvalue %..string %50, 0
	%52 = extractvalue %..string %50, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1ad, i64 0, i32 0), i64 61}, i64 86, i64 12, i64 1, i64 %52)
	%53 = getelementptr inbounds i8, i8* %51, i64 1
	%54 = load i8, i8* %53, align 1
	%55 = icmp eq i8 %54, 98
	br i1 %55, label %switch.case.body-7, label %switch.case.next-6

switch.case.next-6:
	%56 = icmp eq i8 %54, 111
	br i1 %56, label %switch.fall.body-9, label %switch.case.next-8

switch.case.body-7:
	; AssignStmt
	store i64 2, i64* %3
	; AssignStmt
	; SliceExpr
	%57 = load %..string, %..string* %0, align 8
	%58 = extractvalue %..string %57, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1ae, i64 0, i32 0), i64 61}, i64 87, i64 30, i64 2, i64 %58, i64 %58)
	%59 = extractvalue %..string %57, 0
	%60 = getelementptr inbounds i8, i8* %59, i64 2
	%61 = sub i64 %58, 2
	%62 = bitcast %..string* %4 to %..rawptr
	%63 = call %..rawptr @mem.zero(%..rawptr %62, i64 16) noinline
	store %..string zeroinitializer, %..string* %4
	%64 = getelementptr inbounds %..string, %..string* %4, i64 0, i32 0
	store i8* %60, i8** %64
	%65 = getelementptr inbounds %..string, %..string* %4, i64 0, i32 1
	store i64 %61, i64* %65
	%66 = load %..string, %..string* %4, align 8
	store %..string %66, %..string* %0
	br label %switch.done-16

switch.case.next-8:
	%67 = icmp eq i8 %54, 100
	br i1 %67, label %switch.fall.body-11, label %switch.case.next-10

switch.fall.body-9:
	; AssignStmt
	store i64 8, i64* %3
	; AssignStmt
	; SliceExpr
	%68 = load %..string, %..string* %0, align 8
	%69 = extractvalue %..string %68, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1af, i64 0, i32 0), i64 61}, i64 88, i64 30, i64 2, i64 %69, i64 %69)
	%70 = extractvalue %..string %68, 0
	%71 = getelementptr inbounds i8, i8* %70, i64 2
	%72 = sub i64 %69, 2
	%73 = bitcast %..string* %5 to %..rawptr
	%74 = call %..rawptr @mem.zero(%..rawptr %73, i64 16) noinline
	store %..string zeroinitializer, %..string* %5
	%75 = getelementptr inbounds %..string, %..string* %5, i64 0, i32 0
	store i8* %71, i8** %75
	%76 = getelementptr inbounds %..string, %..string* %5, i64 0, i32 1
	store i64 %72, i64* %76
	%77 = load %..string, %..string* %5, align 8
	store %..string %77, %..string* %0
	br label %switch.done-16

switch.case.next-10:
	%78 = icmp eq i8 %54, 122
	br i1 %78, label %switch.fall.body-13, label %switch.case.next-12

switch.fall.body-11:
	; AssignStmt
	store i64 10, i64* %3
	; AssignStmt
	; SliceExpr
	%79 = load %..string, %..string* %0, align 8
	%80 = extractvalue %..string %79, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1b0, i64 0, i32 0), i64 61}, i64 89, i64 30, i64 2, i64 %80, i64 %80)
	%81 = extractvalue %..string %79, 0
	%82 = getelementptr inbounds i8, i8* %81, i64 2
	%83 = sub i64 %80, 2
	%84 = bitcast %..string* %6 to %..rawptr
	%85 = call %..rawptr @mem.zero(%..rawptr %84, i64 16) noinline
	store %..string zeroinitializer, %..string* %6
	%86 = getelementptr inbounds %..string, %..string* %6, i64 0, i32 0
	store i8* %82, i8** %86
	%87 = getelementptr inbounds %..string, %..string* %6, i64 0, i32 1
	store i64 %83, i64* %87
	%88 = load %..string, %..string* %6, align 8
	store %..string %88, %..string* %0
	br label %switch.done-16

switch.case.next-12:
	%89 = icmp eq i8 %54, 120
	br i1 %89, label %switch.fall.body-15, label %switch.case.next-14

switch.fall.body-13:
	; AssignStmt
	store i64 12, i64* %3
	; AssignStmt
	; SliceExpr
	%90 = load %..string, %..string* %0, align 8
	%91 = extractvalue %..string %90, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1b1, i64 0, i32 0), i64 61}, i64 90, i64 30, i64 2, i64 %91, i64 %91)
	%92 = extractvalue %..string %90, 0
	%93 = getelementptr inbounds i8, i8* %92, i64 2
	%94 = sub i64 %91, 2
	%95 = bitcast %..string* %7 to %..rawptr
	%96 = call %..rawptr @mem.zero(%..rawptr %95, i64 16) noinline
	store %..string zeroinitializer, %..string* %7
	%97 = getelementptr inbounds %..string, %..string* %7, i64 0, i32 0
	store i8* %93, i8** %97
	%98 = getelementptr inbounds %..string, %..string* %7, i64 0, i32 1
	store i64 %94, i64* %98
	%99 = load %..string, %..string* %7, align 8
	store %..string %99, %..string* %0
	br label %switch.done-16

switch.case.next-14:
	br label %switch.done-16

switch.fall.body-15:
	; AssignStmt
	store i64 16, i64* %3
	; AssignStmt
	; SliceExpr
	%100 = load %..string, %..string* %0, align 8
	%101 = extractvalue %..string %100, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1b2, i64 0, i32 0), i64 61}, i64 91, i64 30, i64 2, i64 %101, i64 %101)
	%102 = extractvalue %..string %100, 0
	%103 = getelementptr inbounds i8, i8* %102, i64 2
	%104 = sub i64 %101, 2
	%105 = bitcast %..string* %8 to %..rawptr
	%106 = call %..rawptr @mem.zero(%..rawptr %105, i64 16) noinline
	store %..string zeroinitializer, %..string* %8
	%107 = getelementptr inbounds %..string, %..string* %8, i64 0, i32 0
	store i8* %103, i8** %107
	%108 = getelementptr inbounds %..string, %..string* %8, i64 0, i32 1
	store i64 %104, i64* %108
	%109 = load %..string, %..string* %8, align 8
	store %..string %109, %..string* %0
	br label %switch.done-16

switch.done-16:
	br label %if.done-17

if.done-17:
	; value
	%110 = bitcast i64* %9 to %..rawptr
	%111 = call %..rawptr @mem.zero(%..rawptr %110, i64 8) noinline
	store i64 zeroinitializer, i64* %9
	; RangeStmt
	; r
	%112 = bitcast i32* %10 to %..rawptr
	%113 = call %..rawptr @mem.zero(%..rawptr %112, i64 4) noinline
	store i32 zeroinitializer, i32* %10
	%114 = load %..string, %..string* %0, align 8
	%115 = extractvalue %..string %114, 1
	%116 = bitcast i64* %11 to %..rawptr
	%117 = call %..rawptr @mem.zero(%..rawptr %116, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	store i64 0, i64* %11
	br label %for.string.loop-18

for.string.loop-18:
	%118 = load i64, i64* %11, align 8
	%119 = icmp slt i64 %118, %115
	br i1 %119, label %for.string.body-19, label %for.string.done-24

for.string.body-19:
	%120 = extractvalue %..string %114, 0
	%121 = getelementptr inbounds i8, i8* %120, i64 %118
	%122 = sub i64 %115, %118
	%123 = bitcast %..string* %12 to %..rawptr
	%124 = call %..rawptr @mem.zero(%..rawptr %123, i64 16) noinline
	store %..string zeroinitializer, %..string* %12
	%125 = getelementptr inbounds %..string, %..string* %12, i64 0, i32 0
	store i8* %121, i8** %125
	%126 = getelementptr inbounds %..string, %..string* %12, i64 0, i32 1
	store i64 %122, i64* %126
	%127 = load %..string, %..string* %12, align 8
	%128 = call {i32, i64} @runtime.string_decode_rune(%..string %127)
	%129 = extractvalue {i32, i64} %128, 1
	%130 = add i64 %118, %129
	store i64 %130, i64* %11
	%131 = extractvalue {i32, i64} %128, 0
	store i32 %131, i32* %10
	; IfStmt
	%132 = load i32, i32* %10, align 4
	%133 = icmp eq i32 %132, 95
	%134 = zext i1 %133 to i8
	%135 = trunc i8 %134 to i1
	br i1 %135, label %if.then-20, label %if.done-21

if.then-20:
	; continue
	br label %for.string.loop-18

if.done-21:
	; v
	%136 = load i32, i32* %10, align 4
	%137 = call i64 @strconv._digit_value(i32 %136, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%138 = bitcast i64 %137 to i64
	store i64 %138, i64* %13
	; IfStmt
	%139 = load i64, i64* %13, align 8
	%140 = load i64, i64* %3, align 8
	%141 = icmp uge i64 %139, %140
	%142 = zext i1 %141 to i8
	%143 = trunc i8 %142 to i1
	br i1 %143, label %if.then-22, label %if.done-23

if.then-22:
	; break
	br label %for.string.done-24

if.done-23:
	; AssignStmt
	%144 = load i64, i64* %3, align 8
	%145 = load i64, i64* %9, align 8
	%146 = mul i64 %145, %144
	store i64 %146, i64* %9
	; AssignStmt
	%147 = load i64, i64* %13, align 8
	%148 = load i64, i64* %9, align 8
	%149 = add i64 %148, %147
	store i64 %149, i64* %9
	br label %for.string.loop-18

for.string.done-24:
	; IfStmt
	%150 = load i8, i8* %1, align 1
	%151 = trunc i8 %150 to i1
	br i1 %151, label %if.then-25, label %if.done-26

if.then-25:
	; ReturnStmt
	%152 = load i64, i64* %9, align 8
	%153 = sub i64 0, %152
	ret i64 %153

if.done-26:
	; ReturnStmt
	%154 = load i64, i64* %9, align 8
	ret i64 %154
}

define double @strconv.parse_f64(%..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca double, align 16
	%3 = alloca double, align 16
	%4 = alloca i32, align 16
	%5 = alloca i64, align 16
	%6 = alloca double, align 16
	%7 = alloca i32, align 16
	%8 = alloca i64, align 16
	%9 = alloca i8, align 16
	%10 = alloca double, align 16
	%11 = alloca i32, align 16
	%12 = alloca i32, align 16
	%13 = alloca i32, align 16
	store %..string %s, %..string* %0
	; IfStmt
	%14 = load %..string, %..string* %0, align 8
	%15 = call i8 @runtime.string_eq(%..string %14, %..string zeroinitializer)
	%16 = trunc i8 %15 to i1
	br i1 %16, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret double 0x0000000000000000

if.done-2:
	; i
	store i64 0, i64* %1
	; sign
	store double 0x3ff0000000000000, double* %2
	; SwitchStmt
	; IndexExpr
	%17 = load %..string, %..string* %0, align 8
	%18 = extractvalue %..string %17, 0
	%19 = extractvalue %..string %17, 1
	%20 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1b3, i64 0, i32 0), i64 61}, i64 129, i64 11, i64 %20, i64 %19)
	%21 = getelementptr inbounds i8, i8* %18, i64 %20
	%22 = load i8, i8* %21, align 1
	%23 = icmp eq i8 %22, 45
	br i1 %23, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%24 = icmp eq i8 %22, 43
	br i1 %24, label %switch.fall.body-6, label %switch.case.next-5

switch.case.body-4:
	; AssignStmt
	%25 = load i64, i64* %1, align 8
	%26 = add i64 %25, 1
	store i64 %26, i64* %1
	; AssignStmt
	store double 0xbff0000000000000, double* %2
	br label %switch.done-7

switch.case.next-5:
	br label %switch.done-7

switch.fall.body-6:
	; AssignStmt
	%27 = load i64, i64* %1, align 8
	%28 = add i64 %27, 1
	store i64 %28, i64* %1
	br label %switch.done-7

switch.done-7:
	; value
	store double 0x0000000000000000, double* %3
	; ForStmt
	br label %for.loop-8

for.loop-8:
	%29 = load i64, i64* %1, align 8
	%30 = load %..string, %..string* %0, align 8
	%31 = extractvalue %..string %30, 1
	%32 = icmp slt i64 %29, %31
	%33 = zext i1 %32 to i8
	%34 = trunc i8 %33 to i1
	br i1 %34, label %for.body-9, label %for.done-15

for.body-9:
	; r
	; IndexExpr
	%35 = load %..string, %..string* %0, align 8
	%36 = extractvalue %..string %35, 0
	%37 = extractvalue %..string %35, 1
	%38 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1b4, i64 0, i32 0), i64 61}, i64 136, i64 15, i64 %38, i64 %37)
	%39 = getelementptr inbounds i8, i8* %36, i64 %38
	%40 = load i8, i8* %39, align 1
	%41 = zext i8 %40 to i32
	store i32 %41, i32* %4
	; IfStmt
	%42 = load i32, i32* %4, align 4
	%43 = icmp eq i32 %42, 95
	%44 = zext i1 %43 to i8
	%45 = trunc i8 %44 to i1
	br i1 %45, label %if.then-10, label %if.done-11

if.then-10:
	; continue
	br label %for.post-14

if.done-11:
	; v
	%46 = load i32, i32* %4, align 4
	%47 = call i64 @strconv._digit_value(i32 %46, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %47, i64* %5
	; IfStmt
	%48 = load i64, i64* %5, align 8
	%49 = icmp sge i64 %48, 10
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-12, label %if.done-13

if.then-12:
	; break
	br label %for.done-15

if.done-13:
	; AssignStmt
	%52 = load double, double* %3, align 8
	%53 = fmul double %52, 0x4024000000000000
	store double %53, double* %3
	; AssignStmt
	%54 = load i64, i64* %5, align 8
	%55 = sitofp i64 %54 to double
	%56 = load double, double* %3, align 8
	%57 = fadd double %56, %55
	store double %57, double* %3
	br label %for.post-14

for.post-14:
	; AssignStmt
	%58 = load i64, i64* %1, align 8
	%59 = add i64 %58, 1
	store i64 %59, i64* %1
	br label %for.loop-8

for.done-15:
	; IfStmt
	%60 = load i64, i64* %1, align 8
	%61 = load %..string, %..string* %0, align 8
	%62 = extractvalue %..string %61, 1
	%63 = icmp slt i64 %60, %62
	%64 = zext i1 %63 to i8
	%65 = trunc i8 %64 to i1
	br i1 %65, label %cmp.and-16, label %if.done-26

cmp.and-16:
	; IndexExpr
	%66 = load %..string, %..string* %0, align 8
	%67 = extractvalue %..string %66, 0
	%68 = extractvalue %..string %66, 1
	%69 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1b5, i64 0, i32 0), i64 61}, i64 145, i64 21, i64 %69, i64 %68)
	%70 = getelementptr inbounds i8, i8* %67, i64 %69
	%71 = load i8, i8* %70, align 1
	%72 = icmp eq i8 %71, 46
	%73 = zext i1 %72 to i8
	%74 = trunc i8 %73 to i1
	br i1 %74, label %if.then-17, label %if.done-26

if.then-17:
	; pow10
	store double 0x4024000000000000, double* %6
	; AssignStmt
	%75 = load i64, i64* %1, align 8
	%76 = add i64 %75, 1
	store i64 %76, i64* %1
	; ForStmt
	br label %for.loop-18

for.loop-18:
	%77 = load i64, i64* %1, align 8
	%78 = load %..string, %..string* %0, align 8
	%79 = extractvalue %..string %78, 1
	%80 = icmp slt i64 %77, %79
	%81 = zext i1 %80 to i8
	%82 = trunc i8 %81 to i1
	br i1 %82, label %for.body-19, label %for.done-25

for.body-19:
	; r
	; IndexExpr
	%83 = load %..string, %..string* %0, align 8
	%84 = extractvalue %..string %83, 0
	%85 = extractvalue %..string %83, 1
	%86 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1b6, i64 0, i32 0), i64 61}, i64 150, i64 16, i64 %86, i64 %85)
	%87 = getelementptr inbounds i8, i8* %84, i64 %86
	%88 = load i8, i8* %87, align 1
	%89 = zext i8 %88 to i32
	store i32 %89, i32* %7
	; IfStmt
	%90 = load i32, i32* %7, align 4
	%91 = icmp eq i32 %90, 95
	%92 = zext i1 %91 to i8
	%93 = trunc i8 %92 to i1
	br i1 %93, label %if.then-20, label %if.done-21

if.then-20:
	; continue
	br label %for.post-24

if.done-21:
	; v
	%94 = load i32, i32* %7, align 4
	%95 = call i64 @strconv._digit_value(i32 %94, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %95, i64* %8
	; IfStmt
	%96 = load i64, i64* %8, align 8
	%97 = icmp sge i64 %96, 10
	%98 = zext i1 %97 to i8
	%99 = trunc i8 %98 to i1
	br i1 %99, label %if.then-22, label %if.done-23

if.then-22:
	; break
	br label %for.done-25

if.done-23:
	; AssignStmt
	%100 = load i64, i64* %8, align 8
	%101 = sitofp i64 %100 to double
	%102 = load double, double* %6, align 8
	%103 = fdiv double %101, %102
	%104 = load double, double* %3, align 8
	%105 = fadd double %104, %103
	store double %105, double* %3
	; AssignStmt
	%106 = load double, double* %6, align 8
	%107 = fmul double %106, 0x4024000000000000
	store double %107, double* %6
	br label %for.post-24

for.post-24:
	; AssignStmt
	%108 = load i64, i64* %1, align 8
	%109 = add i64 %108, 1
	store i64 %109, i64* %1
	br label %for.loop-18

for.done-25:
	br label %if.done-26

if.done-26:
	; frac
	store i8 0, i8* %9
	; scale
	store double 0x3ff0000000000000, double* %10
	; IfStmt
	%110 = load i64, i64* %1, align 8
	%111 = load %..string, %..string* %0, align 8
	%112 = extractvalue %..string %111, 1
	%113 = icmp slt i64 %110, %112
	%114 = zext i1 %113 to i8
	%115 = trunc i8 %114 to i1
	br i1 %115, label %cmp.and-27, label %if.done-56

cmp.and-27:
	; IndexExpr
	%116 = load %..string, %..string* %0, align 8
	%117 = extractvalue %..string %116, 0
	%118 = extractvalue %..string %116, 1
	%119 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1b7, i64 0, i32 0), i64 61}, i64 163, i64 22, i64 %119, i64 %118)
	%120 = getelementptr inbounds i8, i8* %117, i64 %119
	%121 = load i8, i8* %120, align 1
	%122 = icmp eq i8 %121, 101
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-29, label %cmp.or-28

cmp.or-28:
	; IndexExpr
	%125 = load %..string, %..string* %0, align 8
	%126 = extractvalue %..string %125, 0
	%127 = extractvalue %..string %125, 1
	%128 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1b8, i64 0, i32 0), i64 61}, i64 163, i64 37, i64 %128, i64 %127)
	%129 = getelementptr inbounds i8, i8* %126, i64 %128
	%130 = load i8, i8* %129, align 1
	%131 = icmp eq i8 %130, 69
	%132 = zext i1 %131 to i8
	%133 = trunc i8 %132 to i1
	br i1 %133, label %if.then-29, label %if.done-56

if.then-29:
	; AssignStmt
	%134 = load i64, i64* %1, align 8
	%135 = add i64 %134, 1
	store i64 %135, i64* %1
	; IfStmt
	%136 = load i64, i64* %1, align 8
	%137 = load %..string, %..string* %0, align 8
	%138 = extractvalue %..string %137, 1
	%139 = icmp slt i64 %136, %138
	%140 = zext i1 %139 to i8
	%141 = trunc i8 %140 to i1
	br i1 %141, label %if.then-30, label %if.done-55

if.then-30:
	; SwitchStmt
	; IndexExpr
	%142 = load %..string, %..string* %0, align 8
	%143 = extractvalue %..string %142, 0
	%144 = extractvalue %..string %142, 1
	%145 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1b9, i64 0, i32 0), i64 61}, i64 167, i64 13, i64 %145, i64 %144)
	%146 = getelementptr inbounds i8, i8* %143, i64 %145
	%147 = load i8, i8* %146, align 1
	%148 = icmp eq i8 %147, 45
	br i1 %148, label %switch.case.body-32, label %switch.case.next-31

switch.case.next-31:
	%149 = icmp eq i8 %147, 43
	br i1 %149, label %switch.fall.body-34, label %switch.case.next-33

switch.case.body-32:
	; AssignStmt
	%150 = load i64, i64* %1, align 8
	%151 = add i64 %150, 1
	store i64 %151, i64* %1
	; AssignStmt
	store i8 1, i8* %9
	br label %switch.done-35

switch.case.next-33:
	br label %switch.done-35

switch.fall.body-34:
	; AssignStmt
	%152 = load i64, i64* %1, align 8
	%153 = add i64 %152, 1
	store i64 %153, i64* %1
	br label %switch.done-35

switch.done-35:
	; exp
	store i32 0, i32* %11
	; ForStmt
	br label %for.loop-36

for.loop-36:
	%154 = load i64, i64* %1, align 8
	%155 = load %..string, %..string* %0, align 8
	%156 = extractvalue %..string %155, 1
	%157 = icmp slt i64 %154, %156
	%158 = zext i1 %157 to i8
	%159 = trunc i8 %158 to i1
	br i1 %159, label %for.body-37, label %for.done-43

for.body-37:
	; r
	; IndexExpr
	%160 = load %..string, %..string* %0, align 8
	%161 = extractvalue %..string %160, 0
	%162 = extractvalue %..string %160, 1
	%163 = load i64, i64* %1, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1ba, i64 0, i32 0), i64 61}, i64 174, i64 17, i64 %163, i64 %162)
	%164 = getelementptr inbounds i8, i8* %161, i64 %163
	%165 = load i8, i8* %164, align 1
	%166 = zext i8 %165 to i32
	store i32 %166, i32* %12
	; IfStmt
	%167 = load i32, i32* %12, align 4
	%168 = icmp eq i32 %167, 95
	%169 = zext i1 %168 to i8
	%170 = trunc i8 %169 to i1
	br i1 %170, label %if.then-38, label %if.done-39

if.then-38:
	; continue
	br label %for.post-42

if.done-39:
	; d
	%171 = load i32, i32* %12, align 4
	%172 = call i64 @strconv._digit_value(i32 %171, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%173 = trunc i64 %172 to i32
	store i32 %173, i32* %13
	; IfStmt
	%174 = load i32, i32* %13, align 4
	%175 = icmp uge i32 %174, 10
	%176 = zext i1 %175 to i8
	%177 = trunc i8 %176 to i1
	br i1 %177, label %if.then-40, label %if.done-41

if.then-40:
	; break
	br label %for.done-43

if.done-41:
	; AssignStmt
	%178 = load i32, i32* %11, align 4
	%179 = mul i32 %178, 10
	%180 = load i32, i32* %13, align 4
	%181 = add i32 %179, %180
	store i32 %181, i32* %11
	br label %for.post-42

for.post-42:
	; AssignStmt
	%182 = load i64, i64* %1, align 8
	%183 = add i64 %182, 1
	store i64 %183, i64* %1
	br label %for.loop-36

for.done-43:
	; IfStmt
	%184 = load i32, i32* %11, align 4
	%185 = icmp ugt i32 %184, 308
	%186 = zext i1 %185 to i8
	%187 = trunc i8 %186 to i1
	br i1 %187, label %if.then-44, label %if.done-45

if.then-44:
	; AssignStmt
	store i32 308, i32* %11
	br label %if.done-45

if.done-45:
	; ForStmt
	br label %for.loop-46

for.loop-46:
	%188 = load i32, i32* %11, align 4
	%189 = icmp uge i32 %188, 50
	%190 = zext i1 %189 to i8
	%191 = trunc i8 %190 to i1
	br i1 %191, label %for.body-47, label %for.done-48

for.body-47:
	; AssignStmt
	%192 = load double, double* %10, align 8
	%193 = fmul double %192, 0x4a511b0ec57e649a
	store double %193, double* %10
	; AssignStmt
	%194 = load i32, i32* %11, align 4
	%195 = sub i32 %194, 50
	store i32 %195, i32* %11
	br label %for.loop-46

for.done-48:
	; ForStmt
	br label %for.loop-49

for.loop-49:
	%196 = load i32, i32* %11, align 4
	%197 = icmp uge i32 %196, 8
	%198 = zext i1 %197 to i8
	%199 = trunc i8 %198 to i1
	br i1 %199, label %for.body-50, label %for.done-51

for.body-50:
	; AssignStmt
	%200 = load double, double* %10, align 8
	%201 = fmul double %200, 0x4197d78400000000
	store double %201, double* %10
	; AssignStmt
	%202 = load i32, i32* %11, align 4
	%203 = sub i32 %202, 8
	store i32 %203, i32* %11
	br label %for.loop-49

for.done-51:
	; ForStmt
	br label %for.loop-52

for.loop-52:
	%204 = load i32, i32* %11, align 4
	%205 = icmp ugt i32 %204, 0
	%206 = zext i1 %205 to i8
	%207 = trunc i8 %206 to i1
	br i1 %207, label %for.body-53, label %for.done-54

for.body-53:
	; AssignStmt
	%208 = load double, double* %10, align 8
	%209 = fmul double %208, 0x4024000000000000
	store double %209, double* %10
	; AssignStmt
	%210 = load i32, i32* %11, align 4
	%211 = sub i32 %210, 1
	store i32 %211, i32* %11
	br label %for.loop-52

for.done-54:
	br label %if.done-55

if.done-55:
	br label %if.done-56

if.done-56:
	; IfStmt
	%212 = load i8, i8* %9, align 1
	%213 = trunc i8 %212 to i1
	br i1 %213, label %if.then-57, label %if.done-58

if.then-57:
	; ReturnStmt
	%214 = load double, double* %2, align 8
	%215 = load double, double* %3, align 8
	%216 = load double, double* %10, align 8
	%217 = fdiv double %215, %216
	%218 = fmul double %214, %217
	ret double %218

if.done-58:
	; ReturnStmt
	%219 = load double, double* %2, align 8
	%220 = load double, double* %3, align 8
	%221 = load double, double* %10, align 8
	%222 = fmul double %220, %221
	%223 = fmul double %219, %222
	ret double %223
}

define %..string @strconv.append_float({i8*, i64}* %buf, double %f, i8 %fmt, i64 %prec, i64 %bit_size, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca double, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca {i8*, i64}, align 16
	%5 = alloca %..string, align 16
	%6 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	store double %f, double* %0
	store i8 %fmt, i8* %1
	store i64 %prec, i64* %2
	store i64 %bit_size, i64* %3
	; ReturnStmt
	%7 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%8 = load double, double* %0, align 8
	%9 = load i8, i8* %1, align 1
	%10 = load i64, i64* %2, align 8
	%11 = load i64, i64* %3, align 8
	%12 = bitcast {i8*, i64}* %4 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %4
	store {i8*, i64} %7, {i8*, i64}* %4
	%14 = call {i8*, i64} @strconv.generic_ftoa({i8*, i64}* %4, double %8, i8 %9, i64 %10, i64 %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%15 = extractvalue {i8*, i64} %14, 0
	%16 = extractvalue {i8*, i64} %14, 1
	%17 = bitcast %..string* %5 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 16) noinline
	store %..string zeroinitializer, %..string* %5
	%19 = getelementptr inbounds %..string, %..string* %5, i64 0, i32 0
	store i8* %15, i8** %19
	%20 = getelementptr inbounds %..string, %..string* %5, i64 0, i32 1
	store i64 %16, i64* %20
	%21 = load %..string, %..string* %5, align 8
	ret %..string %21
}

define {i8*, i64} @strconv.generic_ftoa({i8*, i64}* %buf, double %val, i8 %fmt, i64 %prec, i64 %bit_size, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca double, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca %strconv.FloatInfo*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca i8, align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	%10 = alloca %..string, align 16
	%11 = alloca i64, align 16
	%12 = alloca i8*, align 16
	%13 = alloca {i8*, i64}, align 16
	%14 = alloca {i8*, i64}, align 16
	%15 = alloca {i8*, i64}, align 16
	%16 = alloca {i8*, i64}, align 16
	%17 = alloca %decimal.Decimal, align 16
	%18 = alloca %decimal.Decimal*, align 16
	%19 = alloca %strconv.DecimalSlice, align 16
	%20 = alloca i8, align 16
	%21 = alloca %strconv.DecimalSlice, align 16
	%22 = alloca {i8*, i64}, align 16
	%23 = alloca %strconv.DecimalSlice, align 16
	%24 = alloca {i8*, i64}, align 16
	%25 = alloca {i8*, i64}, align 16
	%26 = alloca %strconv.DecimalSlice, align 16
	%27 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	store double %val, double* %0
	store i8 %fmt, i8* %1
	store i64 %prec, i64* %2
	store i64 %bit_size, i64* %3
	; bits
	%28 = bitcast i64* %4 to %..rawptr
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	; flt
	%30 = bitcast %strconv.FloatInfo** %5 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 8) noinline
	store %strconv.FloatInfo* zeroinitializer, %strconv.FloatInfo** %5
	; SwitchStmt
	%32 = load i64, i64* %3, align 8
	%33 = icmp eq i64 %32, 32
	br i1 %33, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%34 = icmp eq i64 %32, 64
	br i1 %34, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	; AssignStmt
	%35 = load double, double* %0, align 8
	%36 = fptrunc double %35 to float
	%37 = bitcast float %36 to i32
	%38 = zext i32 %37 to i64
	store i64 %38, i64* %4
	; AssignStmt
	store %strconv.FloatInfo* @strconv._f32_info, %strconv.FloatInfo** %5
	br label %switch.done-5

switch.case.next-3:
	%39 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1bb, i64 0, i32 0), i64 61}, i64 246, i64 3, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$1bc, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %6
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$1bd, i64 0, i32 0), i64 25}, %runtime.Source_Code_Location* %6) noreturn
	br label %switch.done-5

switch.fall.body-4:
	; AssignStmt
	%41 = load double, double* %0, align 8
	%42 = bitcast double %41 to i64
	store i64 %42, i64* %4
	; AssignStmt
	store %strconv.FloatInfo* @strconv._f64_info, %strconv.FloatInfo** %5
	br label %switch.done-5

switch.done-5:
	; neg
	%43 = load i64, i64* %4, align 8
	; SelectorExpr
	%44 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%45 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %44, i64 0
	%46 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %45, i64 0, i32 1
	%47 = load i64, i64* %46, align 8
	; SelectorExpr
	%48 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%49 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %48, i64 0
	%50 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %49, i64 0, i32 0
	%51 = load i64, i64* %50, align 8
	%52 = add i64 %47, %51
	%53 = bitcast i64 %52 to i64
	%54 = lshr i64 %43, %53
	%55 = icmp ne i64 %54, 0
	%56 = zext i1 %55 to i8
	store i8 %56, i8* %7
	; exp
	%57 = load i64, i64* %4, align 8
	; SelectorExpr
	%58 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%59 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %58, i64 0
	%60 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %59, i64 0, i32 0
	%61 = load i64, i64* %60, align 8
	%62 = bitcast i64 %61 to i64
	%63 = lshr i64 %57, %62
	%64 = bitcast i64 %63 to i64
	; SelectorExpr
	%65 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%66 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %65, i64 0
	%67 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %66, i64 0, i32 1
	%68 = load i64, i64* %67, align 8
	%69 = bitcast i64 %68 to i64
	%70 = shl i64 1, %69
	%71 = sub i64 %70, 1
	%72 = and i64 %64, %71
	store i64 %72, i64* %8
	; mant
	%73 = load i64, i64* %4, align 8
	; SelectorExpr
	%74 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%75 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %74, i64 0
	%76 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %75, i64 0, i32 0
	%77 = load i64, i64* %76, align 8
	%78 = bitcast i64 %77 to i64
	%79 = shl i64 1, %78
	%80 = sub i64 %79, 1
	%81 = and i64 %73, %80
	store i64 %81, i64* %9
	; SwitchStmt
	%82 = load i64, i64* %8, align 8
	; SelectorExpr
	%83 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%84 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %83, i64 0
	%85 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %84, i64 0, i32 1
	%86 = load i64, i64* %85, align 8
	%87 = bitcast i64 %86 to i64
	%88 = shl i64 1, %87
	%89 = sub i64 %88, 1
	%90 = icmp eq i64 %82, %89
	br i1 %90, label %switch.case.body-7, label %switch.case.next-6

switch.case.next-6:
	%91 = icmp eq i64 %82, 0
	br i1 %91, label %switch.fall.body-15, label %switch.case.next-14

switch.case.body-7:
	; s
	%92 = bitcast %..string* %10 to %..rawptr
	%93 = call %..rawptr @mem.zero(%..rawptr %92, i64 16) noinline
	store %..string zeroinitializer, %..string* %10
	; IfStmt
	%94 = load i64, i64* %9, align 8
	%95 = icmp ne i64 %94, 0
	%96 = zext i1 %95 to i8
	%97 = trunc i8 %96 to i1
	br i1 %97, label %if.then-8, label %if.else-9

if.then-8:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$1be, i64 0, i32 0), i64 3}, %..string* %10
	br label %if.done-13

if.else-9:
	; IfStmt
	%98 = load i8, i8* %7, align 1
	%99 = trunc i8 %98 to i1
	br i1 %99, label %if.then-10, label %if.else-11

if.then-10:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$1bf, i64 0, i32 0), i64 4}, %..string* %10
	br label %if.done-12

if.else-11:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$1c0, i64 0, i32 0), i64 4}, %..string* %10
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; n
	%100 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%101 = load %..string, %..string* %10, align 8
	%102 = extractvalue %..string %101, 0
	%103 = bitcast i8** %12 to %..rawptr
	%104 = call %..rawptr @mem.zero(%..rawptr %103, i64 8) noinline
	store i8* zeroinitializer, i8** %12
	store i8* %102, i8** %12
	%105 = extractvalue %..string %101, 1
	%106 = sub i64 %105, 0
	%107 = load i8*, i8** %12, align 8
	%108 = getelementptr inbounds i8, i8* %107, i64 0
	%109 = bitcast {i8*, i64}* %13 to %..rawptr
	%110 = call %..rawptr @mem.zero(%..rawptr %109, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %13
	%111 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %13, i64 0, i32 0
	store i8* %108, i8** %111
	%112 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %13, i64 0, i32 1
	store i64 %106, i64* %112
	%113 = load {i8*, i64}, {i8*, i64}* %13, align 8
	%114 = bitcast {i8*, i64}* %14 to %..rawptr
	%115 = call %..rawptr @mem.zero(%..rawptr %114, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %14
	store {i8*, i64} %100, {i8*, i64}* %14
	%116 = bitcast {i8*, i64}* %15 to %..rawptr
	%117 = call %..rawptr @mem.zero(%..rawptr %116, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %15
	store {i8*, i64} %113, {i8*, i64}* %15
	%118 = call i64 @runtime.copy-19008({i8*, i64}* %14, {i8*, i64}* %15)
	store i64 %118, i64* %11
	; ReturnStmt
	; SliceExpr
	%119 = load i64, i64* %11, align 8
	%120 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%121 = extractvalue {i8*, i64} %120, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1c1, i64 0, i32 0), i64 61}, i64 264, i64 13, i64 0, i64 %119, i64 %121)
	%122 = extractvalue {i8*, i64} %120, 0
	%123 = getelementptr inbounds i8, i8* %122, i64 0
	%124 = sub i64 %119, 0
	%125 = bitcast {i8*, i64}* %16 to %..rawptr
	%126 = call %..rawptr @mem.zero(%..rawptr %125, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %16
	%127 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i64 0, i32 0
	store i8* %123, i8** %127
	%128 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i64 0, i32 1
	store i64 %124, i64* %128
	%129 = load {i8*, i64}, {i8*, i64}* %16, align 8
	ret {i8*, i64} %129

switch.case.next-14:
	; AssignStmt
	; SelectorExpr
	%130 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%131 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %130, i64 0
	%132 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %131, i64 0, i32 0
	%133 = load i64, i64* %132, align 8
	%134 = bitcast i64 %133 to i64
	%135 = shl i64 1, %134
	%136 = load i64, i64* %9, align 8
	%137 = or i64 %136, %135
	store i64 %137, i64* %9
	br label %switch.done-16

switch.fall.body-15:
	; AssignStmt
	%138 = load i64, i64* %8, align 8
	%139 = add i64 %138, 1
	store i64 %139, i64* %8
	br label %switch.done-16

switch.done-16:
	; AssignStmt
	; SelectorExpr
	%140 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%141 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %140, i64 0
	%142 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %141, i64 0, i32 2
	%143 = load i64, i64* %142, align 8
	%144 = load i64, i64* %8, align 8
	%145 = add i64 %144, %143
	store i64 %145, i64* %8
	; d_
	%146 = bitcast %decimal.Decimal* %17 to %..rawptr
	%147 = call %..rawptr @mem.zero(%..rawptr %146, i64 408) noinline
	store %decimal.Decimal zeroinitializer, %decimal.Decimal* %17
	; d
	store %decimal.Decimal* %17, %decimal.Decimal** %18
	%148 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%149 = load i64, i64* %9, align 8
	call void @decimal.assign(%decimal.Decimal* %148, i64 %149, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%150 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%151 = load i64, i64* %8, align 8
	; SelectorExpr
	%152 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	%153 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %152, i64 0
	%154 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %153, i64 0, i32 0
	%155 = load i64, i64* %154, align 8
	%156 = bitcast i64 %155 to i64
	%157 = sub i64 %151, %156
	call void @decimal.shift(%decimal.Decimal* %150, i64 %157, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; digs
	%158 = bitcast %strconv.DecimalSlice* %19 to %..rawptr
	%159 = call %..rawptr @mem.zero(%..rawptr %158, i64 40) noinline
	store %strconv.DecimalSlice zeroinitializer, %strconv.DecimalSlice* %19
	; shortest
	%160 = load i64, i64* %2, align 8
	%161 = icmp slt i64 %160, 0
	%162 = zext i1 %161 to i8
	store i8 %162, i8* %20
	; IfStmt
	%163 = load i8, i8* %20, align 1
	%164 = trunc i8 %163 to i1
	br i1 %164, label %if.then-17, label %if.else-28

if.then-17:
	%165 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%166 = load i64, i64* %9, align 8
	%167 = load i64, i64* %8, align 8
	%168 = load %strconv.FloatInfo*, %strconv.FloatInfo** %5, align 8
	call void @strconv.round_shortest(%decimal.Decimal* %165, i64 %166, i64 %167, %strconv.FloatInfo* %168, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	; CompoundLit
	%169 = bitcast %strconv.DecimalSlice* %21 to %..rawptr
	%170 = call %..rawptr @mem.zero(%..rawptr %169, i64 40) noinline
	store %strconv.DecimalSlice zeroinitializer, %strconv.DecimalSlice* %21
	store %strconv.DecimalSlice {{i8*, i64} zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i8 zeroinitializer}, %strconv.DecimalSlice* %21
	; SliceExpr
	; SelectorExpr
	%171 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%172 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %171, i64 0
	%173 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %172, i64 0, i32 0
	%174 = load [384 x i8], [384 x i8]* %173, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1c2, i64 0, i32 0), i64 61}, i64 283, i64 40, i64 0, i64 384, i64 384)
	%175 = getelementptr inbounds [384 x i8], [384 x i8]* %173, i64 0, i32 0
	%176 = getelementptr inbounds i8, i8* %175, i64 0
	%177 = sub i64 384, 0
	%178 = bitcast {i8*, i64}* %22 to %..rawptr
	%179 = call %..rawptr @mem.zero(%..rawptr %178, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %22
	%180 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %22, i64 0, i32 0
	store i8* %176, i8** %180
	%181 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %22, i64 0, i32 1
	store i64 %177, i64* %181
	%182 = load {i8*, i64}, {i8*, i64}* %22, align 8
	%183 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %21, i64 0, i32 0
	store {i8*, i64} %182, {i8*, i64}* %183
	; SelectorExpr
	%184 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%185 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %184, i64 0
	%186 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %185, i64 0, i32 1
	%187 = load i64, i64* %186, align 8
	%188 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %21, i64 0, i32 1
	store i64 %187, i64* %188
	; SelectorExpr
	%189 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%190 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %189, i64 0
	%191 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %190, i64 0, i32 2
	%192 = load i64, i64* %191, align 8
	%193 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %21, i64 0, i32 2
	store i64 %192, i64* %193
	%194 = load %strconv.DecimalSlice, %strconv.DecimalSlice* %21, align 8
	store %strconv.DecimalSlice %194, %strconv.DecimalSlice* %19
	; SwitchStmt
	%195 = load i8, i8* %1, align 1
	%196 = icmp eq i8 %195, 101
	br i1 %196, label %switch.case.body-20, label %switch.case.next-18

switch.case.next-18:
	%197 = icmp eq i8 %195, 69
	br i1 %197, label %switch.case.body-20, label %switch.case.next-19

switch.case.next-19:
	%198 = icmp eq i8 %195, 102
	br i1 %198, label %switch.fall.body-23, label %switch.case.next-21

switch.case.body-20:
	; AssignStmt
	; SelectorExpr
	%199 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %19, i64 0, i32 1
	%200 = load i64, i64* %199, align 8
	%201 = sub i64 %200, 1
	store i64 %201, i64* %2
	br label %switch.done-27

switch.case.next-21:
	%202 = icmp eq i8 %195, 70
	br i1 %202, label %switch.fall.body-23, label %switch.case.next-22

switch.case.next-22:
	%203 = icmp eq i8 %195, 103
	br i1 %203, label %switch.fall.body-26, label %switch.case.next-24

switch.fall.body-23:
	; AssignStmt
	; max
	; SelectorExpr
	%204 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %19, i64 0, i32 1
	%205 = load i64, i64* %204, align 8
	; SelectorExpr
	%206 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %19, i64 0, i32 2
	%207 = load i64, i64* %206, align 8
	%208 = sub i64 %205, %207
	%209 = icmp sgt i64 %208, 0
	%210 = select i1 %209, i64 %208, i64 0
	store i64 %210, i64* %2
	br label %switch.done-27

switch.case.next-24:
	%211 = icmp eq i8 %195, 71
	br i1 %211, label %switch.fall.body-26, label %switch.case.next-25

switch.case.next-25:
	br label %switch.done-27

switch.fall.body-26:
	; AssignStmt
	; SelectorExpr
	%212 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %19, i64 0, i32 1
	%213 = load i64, i64* %212, align 8
	store i64 %213, i64* %2
	br label %switch.done-27

switch.done-27:
	br label %if.done-41

if.else-28:
	; SwitchStmt
	%214 = load i8, i8* %1, align 1
	%215 = icmp eq i8 %214, 101
	br i1 %215, label %switch.case.body-31, label %switch.case.next-29

switch.case.next-29:
	%216 = icmp eq i8 %214, 69
	br i1 %216, label %switch.case.body-31, label %switch.case.next-30

switch.case.next-30:
	%217 = icmp eq i8 %214, 102
	br i1 %217, label %switch.fall.body-34, label %switch.case.next-32

switch.case.body-31:
	%218 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%219 = load i64, i64* %2, align 8
	%220 = add i64 %219, 1
	call void @decimal.round(%decimal.Decimal* %218, i64 %220, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-40

switch.case.next-32:
	%221 = icmp eq i8 %214, 70
	br i1 %221, label %switch.fall.body-34, label %switch.case.next-33

switch.case.next-33:
	%222 = icmp eq i8 %214, 103
	br i1 %222, label %switch.fall.body-37, label %switch.case.next-35

switch.fall.body-34:
	%223 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	; SelectorExpr
	%224 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%225 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %224, i64 0
	%226 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %225, i64 0, i32 2
	%227 = load i64, i64* %226, align 8
	%228 = load i64, i64* %2, align 8
	%229 = add i64 %227, %228
	call void @decimal.round(%decimal.Decimal* %223, i64 %229, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-40

switch.case.next-35:
	%230 = icmp eq i8 %214, 71
	br i1 %230, label %switch.fall.body-37, label %switch.case.next-36

switch.case.next-36:
	br label %switch.done-40

switch.fall.body-37:
	; IfStmt
	%231 = load i64, i64* %2, align 8
	%232 = icmp eq i64 %231, 0
	%233 = zext i1 %232 to i8
	%234 = trunc i8 %233 to i1
	br i1 %234, label %if.then-38, label %if.done-39

if.then-38:
	; AssignStmt
	store i64 1, i64* %2
	br label %if.done-39

if.done-39:
	%235 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%236 = load i64, i64* %2, align 8
	call void @decimal.round(%decimal.Decimal* %235, i64 %236, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-40

switch.done-40:
	; AssignStmt
	; CompoundLit
	%237 = bitcast %strconv.DecimalSlice* %23 to %..rawptr
	%238 = call %..rawptr @mem.zero(%..rawptr %237, i64 40) noinline
	store %strconv.DecimalSlice zeroinitializer, %strconv.DecimalSlice* %23
	store %strconv.DecimalSlice {{i8*, i64} zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i8 zeroinitializer}, %strconv.DecimalSlice* %23
	; SliceExpr
	; SelectorExpr
	%239 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%240 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %239, i64 0
	%241 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %240, i64 0, i32 0
	%242 = load [384 x i8], [384 x i8]* %241, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1c3, i64 0, i32 0), i64 61}, i64 300, i64 40, i64 0, i64 384, i64 384)
	%243 = getelementptr inbounds [384 x i8], [384 x i8]* %241, i64 0, i32 0
	%244 = getelementptr inbounds i8, i8* %243, i64 0
	%245 = sub i64 384, 0
	%246 = bitcast {i8*, i64}* %24 to %..rawptr
	%247 = call %..rawptr @mem.zero(%..rawptr %246, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %24
	%248 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %24, i64 0, i32 0
	store i8* %244, i8** %248
	%249 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %24, i64 0, i32 1
	store i64 %245, i64* %249
	%250 = load {i8*, i64}, {i8*, i64}* %24, align 8
	%251 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %23, i64 0, i32 0
	store {i8*, i64} %250, {i8*, i64}* %251
	; SelectorExpr
	%252 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%253 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %252, i64 0
	%254 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %253, i64 0, i32 1
	%255 = load i64, i64* %254, align 8
	%256 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %23, i64 0, i32 1
	store i64 %255, i64* %256
	; SelectorExpr
	%257 = load %decimal.Decimal*, %decimal.Decimal** %18, align 8
	%258 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %257, i64 0
	%259 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %258, i64 0, i32 2
	%260 = load i64, i64* %259, align 8
	%261 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %23, i64 0, i32 2
	store i64 %260, i64* %261
	%262 = load %strconv.DecimalSlice, %strconv.DecimalSlice* %23, align 8
	store %strconv.DecimalSlice %262, %strconv.DecimalSlice* %19
	br label %if.done-41

if.done-41:
	; ReturnStmt
	%263 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%264 = load i8, i8* %20, align 1
	%265 = load i8, i8* %7, align 1
	%266 = load %strconv.DecimalSlice, %strconv.DecimalSlice* %19, align 8
	%267 = load i64, i64* %2, align 8
	%268 = load i8, i8* %1, align 1
	%269 = bitcast {i8*, i64}* %25 to %..rawptr
	%270 = call %..rawptr @mem.zero(%..rawptr %269, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %25
	store {i8*, i64} %263, {i8*, i64}* %25
	%271 = trunc i8 %264 to i1
	%272 = trunc i8 %265 to i1
	%273 = bitcast %strconv.DecimalSlice* %26 to %..rawptr
	%274 = call %..rawptr @mem.zero(%..rawptr %273, i64 40) noinline
	store %strconv.DecimalSlice zeroinitializer, %strconv.DecimalSlice* %26
	store %strconv.DecimalSlice %266, %strconv.DecimalSlice* %26
	%275 = call {i8*, i64} @strconv.format_digits({i8*, i64}* %25, i1 %271, i1 %272, %strconv.DecimalSlice* %26, i64 %267, i8 %268, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i8*, i64} %275
}

define {i8*, i64} @strconv.format_digits({i8*, i64}* %buf, i1 %shortest, i1 %neg, %strconv.DecimalSlice* %digs, i64 %prec, i8 %fmt, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i8, align 16
	%4 = alloca %strconv.format_digits.Buffer-249, align 16
	%5 = alloca %strconv.format_digits.Buffer-249, align 16
	%6 = alloca {i8*, i64}, align 16
	%7 = alloca [1 x i8], align 16
	%8 = alloca {i8*, i64}, align 16
	%9 = alloca i64, align 16
	%10 = alloca {i8*, i64}, align 16
	%11 = alloca {i8*, i64}, align 16
	%12 = alloca {i8*, i64}, align 16
	%13 = alloca [1 x i8], align 16
	%14 = alloca {i8*, i64}, align 16
	%15 = alloca {i8*, i64}, align 16
	%16 = alloca [1 x i8], align 16
	%17 = alloca {i8*, i64}, align 16
	%18 = alloca {i8*, i64}, align 16
	%19 = alloca [1 x i8], align 16
	%20 = alloca {i8*, i64}, align 16
	%21 = alloca i64, align 16
	%22 = alloca i64, align 16
	%23 = alloca i64, align 16
	%24 = alloca i8, align 16
	%25 = alloca i64, align 16
	%26 = alloca {i8*, i64}, align 16
	%27 = alloca [1 x i8], align 16
	%28 = alloca {i8*, i64}, align 16
	%29 = alloca %strconv.format_digits.Buffer-249, align 16
	%30 = alloca %runtime.Source_Code_Location, align 16
	%31 = alloca %strconv.format_digits.Buffer-249, align 16
	%32 = alloca %runtime.Source_Code_Location, align 16
	%33 = alloca %strconv.format_digits.Buffer-249, align 16
	%34 = alloca {i8*, i64}, align 16
	%35 = alloca [2 x i8], align 16
	%36 = alloca {i8*, i64}, align 16
	%37 = alloca %strconv.format_digits.Buffer-249, align 16
	%38 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%39 = zext i1 %shortest to i8
	store i8 %39, i8* %0
	%40 = zext i1 %neg to i8
	store i8 %40, i8* %1
	%41 = load %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, align 8
	store i64 %prec, i64* %2
	store i8 %fmt, i8* %3
	; b
	; CompoundLit
	%42 = bitcast %strconv.format_digits.Buffer-249* %5 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 24) noinline
	store %strconv.format_digits.Buffer-249 zeroinitializer, %strconv.format_digits.Buffer-249* %5
	store %strconv.format_digits.Buffer-249 {{i8*, i64} zeroinitializer, i64 zeroinitializer}, %strconv.format_digits.Buffer-249* %5
	%44 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%45 = getelementptr inbounds %strconv.format_digits.Buffer-249, %strconv.format_digits.Buffer-249* %5, i64 0, i32 0
	store {i8*, i64} %44, {i8*, i64}* %45
	%46 = load %strconv.format_digits.Buffer-249, %strconv.format_digits.Buffer-249* %5, align 8
	store %strconv.format_digits.Buffer-249 %46, %strconv.format_digits.Buffer-249* %4
	; SwitchStmt
	%47 = load i8, i8* %3, align 1
	%48 = icmp eq i8 %47, 102
	br i1 %48, label %switch.case.body-3, label %switch.case.next-1

switch.case.next-1:
	%49 = icmp eq i8 %47, 70
	br i1 %49, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%50 = icmp eq i8 %47, 101
	br i1 %50, label %switch.fall.body-23, label %switch.case.next-21

switch.case.body-3:
	; TernaryExpr
	%51 = load i8, i8* %1, align 1
	%52 = trunc i8 %51 to i1
	br i1 %52, label %if.then-4, label %if.else-5

if.then-4:
	br label %if.done-6

if.else-5:
	br label %if.done-6

if.done-6:
	%53 = phi i32 [ 45, %if.then-4 ], [ 43, %if.else-5 ]
	%54 = trunc i32 %53 to i8
	; variadic call argument generation
	%55 = bitcast {i8*, i64}* %6 to %..rawptr
	%56 = call %..rawptr @mem.zero(%..rawptr %55, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	%57 = bitcast [1 x i8]* %7 to %..rawptr
	%58 = call %..rawptr @mem.zero(%..rawptr %57, i64 1) noinline
	store [1 x i8] zeroinitializer, [1 x i8]* %7
	%59 = getelementptr inbounds [1 x i8], [1 x i8]* %7, i64 0, i32 0
	store i8 %54, i8* %59
	%60 = getelementptr inbounds [1 x i8], [1 x i8]* %7, i64 0, i32 0
	%61 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %6, i64 0, i32 0
	store i8* %60, i8** %61
	%62 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %6, i64 0, i32 1
	store i64 1, i64* %62
	%63 = load {i8*, i64}, {i8*, i64}* %6, align 8
	%64 = bitcast {i8*, i64}* %8 to %..rawptr
	%65 = call %..rawptr @mem.zero(%..rawptr %64, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %8
	store {i8*, i64} %63, {i8*, i64}* %8
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-249* %4, {i8*, i64}* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%66 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 2
	%67 = load i64, i64* %66, align 8
	%68 = icmp sgt i64 %67, 0
	%69 = zext i1 %68 to i8
	%70 = trunc i8 %69 to i1
	br i1 %70, label %if.then-7, label %if.else-11

if.then-7:
	; m
	; min
	; SelectorExpr
	%71 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 1
	%72 = load i64, i64* %71, align 8
	; SelectorExpr
	%73 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 2
	%74 = load i64, i64* %73, align 8
	%75 = icmp slt i64 %72, %74
	%76 = select i1 %75, i64 %72, i64 %74
	store i64 %76, i64* %9
	; SliceExpr
	%77 = load i64, i64* %9, align 8
	; SelectorExpr
	%78 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 0
	%79 = load {i8*, i64}, {i8*, i64}* %78, align 8
	%80 = extractvalue {i8*, i64} %79, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1c4, i64 0, i32 0), i64 61}, i64 327, i64 31, i64 0, i64 %77, i64 %80)
	%81 = extractvalue {i8*, i64} %79, 0
	%82 = getelementptr inbounds i8, i8* %81, i64 0
	%83 = sub i64 %77, 0
	%84 = bitcast {i8*, i64}* %10 to %..rawptr
	%85 = call %..rawptr @mem.zero(%..rawptr %84, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %10
	%86 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %10, i64 0, i32 0
	store i8* %82, i8** %86
	%87 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %10, i64 0, i32 1
	store i64 %83, i64* %87
	%88 = load {i8*, i64}, {i8*, i64}* %10, align 8
	%89 = bitcast {i8*, i64}* %11 to %..rawptr
	%90 = call %..rawptr @mem.zero(%..rawptr %89, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %11
	store {i8*, i64} %88, {i8*, i64}* %11
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-249* %4, {i8*, i64}* %11, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ForStmt
	br label %for.loop-8

for.loop-8:
	%91 = load i64, i64* %9, align 8
	; SelectorExpr
	%92 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 2
	%93 = load i64, i64* %92, align 8
	%94 = icmp slt i64 %91, %93
	%95 = zext i1 %94 to i8
	%96 = trunc i8 %95 to i1
	br i1 %96, label %for.body-9, label %for.done-10

for.body-9:
	; variadic call argument generation
	%97 = bitcast {i8*, i64}* %12 to %..rawptr
	%98 = call %..rawptr @mem.zero(%..rawptr %97, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %12
	%99 = bitcast [1 x i8]* %13 to %..rawptr
	%100 = call %..rawptr @mem.zero(%..rawptr %99, i64 1) noinline
	store [1 x i8] zeroinitializer, [1 x i8]* %13
	%101 = getelementptr inbounds [1 x i8], [1 x i8]* %13, i64 0, i32 0
	store i8 48, i8* %101
	%102 = getelementptr inbounds [1 x i8], [1 x i8]* %13, i64 0, i32 0
	%103 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %12, i64 0, i32 0
	store i8* %102, i8** %103
	%104 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %12, i64 0, i32 1
	store i64 1, i64* %104
	%105 = load {i8*, i64}, {i8*, i64}* %12, align 8
	%106 = bitcast {i8*, i64}* %14 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %14
	store {i8*, i64} %105, {i8*, i64}* %14
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-249* %4, {i8*, i64}* %14, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	%108 = load i64, i64* %9, align 8
	%109 = add i64 %108, 1
	store i64 %109, i64* %9
	br label %for.loop-8

for.done-10:
	br label %if.done-12

if.else-11:
	; variadic call argument generation
	%110 = bitcast {i8*, i64}* %15 to %..rawptr
	%111 = call %..rawptr @mem.zero(%..rawptr %110, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %15
	%112 = bitcast [1 x i8]* %16 to %..rawptr
	%113 = call %..rawptr @mem.zero(%..rawptr %112, i64 1) noinline
	store [1 x i8] zeroinitializer, [1 x i8]* %16
	%114 = getelementptr inbounds [1 x i8], [1 x i8]* %16, i64 0, i32 0
	store i8 48, i8* %114
	%115 = getelementptr inbounds [1 x i8], [1 x i8]* %16, i64 0, i32 0
	%116 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %15, i64 0, i32 0
	store i8* %115, i8** %116
	%117 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %15, i64 0, i32 1
	store i64 1, i64* %117
	%118 = load {i8*, i64}, {i8*, i64}* %15, align 8
	%119 = bitcast {i8*, i64}* %17 to %..rawptr
	%120 = call %..rawptr @mem.zero(%..rawptr %119, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %17
	store {i8*, i64} %118, {i8*, i64}* %17
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-249* %4, {i8*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-12

if.done-12:
	; IfStmt
	%121 = load i64, i64* %2, align 8
	%122 = icmp sgt i64 %121, 0
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-13, label %if.done-20

if.then-13:
	; variadic call argument generation
	%125 = bitcast {i8*, i64}* %18 to %..rawptr
	%126 = call %..rawptr @mem.zero(%..rawptr %125, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %18
	%127 = bitcast [1 x i8]* %19 to %..rawptr
	%128 = call %..rawptr @mem.zero(%..rawptr %127, i64 1) noinline
	store [1 x i8] zeroinitializer, [1 x i8]* %19
	%129 = getelementptr inbounds [1 x i8], [1 x i8]* %19, i64 0, i32 0
	store i8 46, i8* %129
	%130 = getelementptr inbounds [1 x i8], [1 x i8]* %19, i64 0, i32 0
	%131 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %18, i64 0, i32 0
	store i8* %130, i8** %131
	%132 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %18, i64 0, i32 1
	store i64 1, i64* %132
	%133 = load {i8*, i64}, {i8*, i64}* %18, align 8
	%134 = bitcast {i8*, i64}* %20 to %..rawptr
	%135 = call %..rawptr @mem.zero(%..rawptr %134, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %20
	store {i8*, i64} %133, {i8*, i64}* %20
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-249* %4, {i8*, i64}* %20, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; RangeStmt
	; i
	%136 = bitcast i64* %21 to %..rawptr
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 8) noinline
	store i64 zeroinitializer, i64* %21
	%138 = bitcast i64* %22 to %..rawptr
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 8) noinline
	store i64 zeroinitializer, i64* %22
	store i64 0, i64* %22
	%140 = bitcast i64* %23 to %..rawptr
	%141 = call %..rawptr @mem.zero(%..rawptr %140, i64 8) noinline
	store i64 zeroinitializer, i64* %23
	store i64 0, i64* %23
	br label %for.interval.loop-14

for.interval.loop-14:
	%142 = load i64, i64* %2, align 8
	%143 = sub i64 %142, 1
	%144 = load i64, i64* %22, align 8
	%145 = icmp sle i64 %144, %143
	br i1 %145, label %for.interval.body-15, label %for.interval.done-19

for.interval.body-15:
	%146 = load i64, i64* %22, align 8
	%147 = load i64, i64* %23, align 8
	%148 = load i64, i64* %22, align 8
	%149 = add i64 %148, 1
	store i64 %149, i64* %22
	%150 = load i64, i64* %23, align 8
	%151 = add i64 %150, 1
	store i64 %151, i64* %23
	store i64 %146, i64* %21
	; c
	store i8 48, i8* %24
	; IfStmt
	; j
	; SelectorExpr
	%152 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 2
	%153 = load i64, i64* %152, align 8
	%154 = load i64, i64* %21, align 8
	%155 = add i64 %153, %154
	store i64 %155, i64* %25
	%156 = load i64, i64* %25, align 8
	%157 = icmp sle i64 0, %156
	%158 = zext i1 %157 to i8
	%159 = trunc i8 %158 to i1
	br i1 %159, label %cmp.and-16, label %if.done-18

cmp.and-16:
	%160 = load i64, i64* %25, align 8
	; SelectorExpr
	%161 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 1
	%162 = load i64, i64* %161, align 8
	%163 = icmp slt i64 %160, %162
	%164 = zext i1 %163 to i8
	%165 = trunc i8 %164 to i1
	br i1 %165, label %if.then-17, label %if.done-18

if.then-17:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%166 = getelementptr inbounds %strconv.DecimalSlice, %strconv.DecimalSlice* %digs, i64 0, i32 0
	%167 = load {i8*, i64}, {i8*, i64}* %166, align 8
	%168 = extractvalue {i8*, i64} %167, 0
	%169 = load i64, i64* %25, align 8
	%170 = extractvalue {i8*, i64} %167, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1c5, i64 0, i32 0), i64 61}, i64 342, i64 22, i64 %169, i64 %170)
	%171 = getelementptr inbounds i8, i8* %168, i64 %169
	%172 = load i8, i8* %171, align 1
	store i8 %172, i8* %24
	br label %if.done-18

if.done-18:
	%173 = load i8, i8* %24, align 1
	; variadic call argument generation
	%174 = bitcast {i8*, i64}* %26 to %..rawptr
	%175 = call %..rawptr @mem.zero(%..rawptr %174, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %26
	%176 = bitcast [1 x i8]* %27 to %..rawptr
	%177 = call %..rawptr @mem.zero(%..rawptr %176, i64 1) noinline
	store [1 x i8] zeroinitializer, [1 x i8]* %27
	%178 = getelementptr inbounds [1 x i8], [1 x i8]* %27, i64 0, i32 0
	store i8 %173, i8* %178
	%179 = getelementptr inbounds [1 x i8], [1 x i8]* %27, i64 0, i32 0
	%180 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %26, i64 0, i32 0
	store i8* %179, i8** %180
	%181 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %26, i64 0, i32 1
	store i64 1, i64* %181
	%182 = load {i8*, i64}, {i8*, i64}* %26, align 8
	%183 = bitcast {i8*, i64}* %28 to %..rawptr
	%184 = call %..rawptr @mem.zero(%..rawptr %183, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %28
	store {i8*, i64} %182, {i8*, i64}* %28
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-249* %4, {i8*, i64}* %28, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-14

for.interval.done-19:
	br label %if.done-20

if.done-20:
	; ReturnStmt
	%185 = load %strconv.format_digits.Buffer-249, %strconv.format_digits.Buffer-249* %4, align 8
	%186 = bitcast %strconv.format_digits.Buffer-249* %29 to %..rawptr
	%187 = call %..rawptr @mem.zero(%..rawptr %186, i64 24) noinline
	store %strconv.format_digits.Buffer-249 zeroinitializer, %strconv.format_digits.Buffer-249* %29
	store %strconv.format_digits.Buffer-249 %185, %strconv.format_digits.Buffer-249* %29
	%188 = call {i8*, i64} @strconv.format_digits.to_bytes-0(%strconv.format_digits.Buffer-249* %29, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i8*, i64} %188

switch.case.next-21:
	%189 = icmp eq i8 %47, 69
	br i1 %189, label %switch.fall.body-23, label %switch.case.next-22

switch.case.next-22:
	%190 = icmp eq i8 %47, 103
	br i1 %190, label %switch.fall.body-26, label %switch.case.next-24

switch.fall.body-23:
	%191 = bitcast %runtime.Source_Code_Location* %30 to %..rawptr
	%192 = call %..rawptr @mem.zero(%..rawptr %191, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %30
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1c6, i64 0, i32 0), i64 61}, i64 350, i64 3, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$1c7, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %30
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([49 x i8], [49 x i8]* @str$1c8, i64 0, i32 0), i64 48}, %runtime.Source_Code_Location* %30) noreturn
	; ReturnStmt
	%193 = load %strconv.format_digits.Buffer-249, %strconv.format_digits.Buffer-249* %4, align 8
	%194 = bitcast %strconv.format_digits.Buffer-249* %31 to %..rawptr
	%195 = call %..rawptr @mem.zero(%..rawptr %194, i64 24) noinline
	store %strconv.format_digits.Buffer-249 zeroinitializer, %strconv.format_digits.Buffer-249* %31
	store %strconv.format_digits.Buffer-249 %193, %strconv.format_digits.Buffer-249* %31
	%196 = call {i8*, i64} @strconv.format_digits.to_bytes-0(%strconv.format_digits.Buffer-249* %31, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i8*, i64} %196

switch.case.next-24:
	%197 = icmp eq i8 %47, 71
	br i1 %197, label %switch.fall.body-26, label %switch.case.next-25

switch.case.next-25:
	%198 = load i8, i8* %3, align 1
	; variadic call argument generation
	%199 = bitcast {i8*, i64}* %34 to %..rawptr
	%200 = call %..rawptr @mem.zero(%..rawptr %199, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %34
	%201 = bitcast [2 x i8]* %35 to %..rawptr
	%202 = call %..rawptr @mem.zero(%..rawptr %201, i64 2) noinline
	store [2 x i8] zeroinitializer, [2 x i8]* %35
	%203 = getelementptr inbounds [2 x i8], [2 x i8]* %35, i64 0, i32 0
	store i8 37, i8* %203
	%204 = getelementptr inbounds [2 x i8], [2 x i8]* %35, i64 0, i32 1
	store i8 %198, i8* %204
	%205 = getelementptr inbounds [2 x i8], [2 x i8]* %35, i64 0, i32 0
	%206 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %34, i64 0, i32 0
	store i8* %205, i8** %206
	%207 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %34, i64 0, i32 1
	store i64 2, i64* %207
	%208 = load {i8*, i64}, {i8*, i64}* %34, align 8
	%209 = bitcast {i8*, i64}* %36 to %..rawptr
	%210 = call %..rawptr @mem.zero(%..rawptr %209, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %36
	store {i8*, i64} %208, {i8*, i64}* %36
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-249* %4, {i8*, i64}* %36, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%211 = load %strconv.format_digits.Buffer-249, %strconv.format_digits.Buffer-249* %4, align 8
	%212 = bitcast %strconv.format_digits.Buffer-249* %37 to %..rawptr
	%213 = call %..rawptr @mem.zero(%..rawptr %212, i64 24) noinline
	store %strconv.format_digits.Buffer-249 zeroinitializer, %strconv.format_digits.Buffer-249* %37
	store %strconv.format_digits.Buffer-249 %211, %strconv.format_digits.Buffer-249* %37
	%214 = call {i8*, i64} @strconv.format_digits.to_bytes-0(%strconv.format_digits.Buffer-249* %37, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i8*, i64} %214

switch.fall.body-26:
	%215 = bitcast %runtime.Source_Code_Location* %32 to %..rawptr
	%216 = call %..rawptr @mem.zero(%..rawptr %215, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %32
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1c9, i64 0, i32 0), i64 61}, i64 354, i64 3, %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$1ca, i64 0, i32 0), i64 13}}, %runtime.Source_Code_Location* %32
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([49 x i8], [49 x i8]* @str$1cb, i64 0, i32 0), i64 48}, %runtime.Source_Code_Location* %32) noreturn
	; ReturnStmt
	%217 = load %strconv.format_digits.Buffer-249, %strconv.format_digits.Buffer-249* %4, align 8
	%218 = bitcast %strconv.format_digits.Buffer-249* %33 to %..rawptr
	%219 = call %..rawptr @mem.zero(%..rawptr %218, i64 24) noinline
	store %strconv.format_digits.Buffer-249 zeroinitializer, %strconv.format_digits.Buffer-249* %33
	store %strconv.format_digits.Buffer-249 %217, %strconv.format_digits.Buffer-249* %33
	%220 = call {i8*, i64} @strconv.format_digits.to_bytes-0(%strconv.format_digits.Buffer-249* %33, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i8*, i64} %220
}

define {i8*, i64} @strconv.format_digits.to_bytes-0(%strconv.format_digits.Buffer-249* %b, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64}, align 16
	%1 = load %strconv.format_digits.Buffer-249, %strconv.format_digits.Buffer-249* %b, align 8
	; ReturnStmt
	; SliceExpr
	; SelectorExpr
	%2 = getelementptr inbounds %strconv.format_digits.Buffer-249, %strconv.format_digits.Buffer-249* %b, i64 0, i32 1
	%3 = load i64, i64* %2, align 8
	; SelectorExpr
	%4 = getelementptr inbounds %strconv.format_digits.Buffer-249, %strconv.format_digits.Buffer-249* %b, i64 0, i32 0
	%5 = load {i8*, i64}, {i8*, i64}* %4, align 8
	%6 = extractvalue {i8*, i64} %5, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1cc, i64 0, i32 0), i64 61}, i64 313, i64 53, i64 0, i64 %3, i64 %6)
	%7 = extractvalue {i8*, i64} %5, 0
	%8 = getelementptr inbounds i8, i8* %7, i64 0
	%9 = sub i64 %3, 0
	%10 = bitcast {i8*, i64}* %0 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %0
	%12 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %0, i64 0, i32 0
	store i8* %8, i8** %12
	%13 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %0, i64 0, i32 1
	store i64 %9, i64* %13
	%14 = load {i8*, i64}, {i8*, i64}* %0, align 8
	ret {i8*, i64} %14
}

define void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-249* %buf, {i8*, i64}* %bytes, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %strconv.format_digits.Buffer-249*, align 16
	%1 = alloca {i8*, i64}, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca {i8*, i64}, align 16
	store %strconv.format_digits.Buffer-249* %buf, %strconv.format_digits.Buffer-249** %0
	%4 = load {i8*, i64}, {i8*, i64}* %bytes, align 8
	; AssignStmt
	; SelectorExpr
	%5 = load %strconv.format_digits.Buffer-249*, %strconv.format_digits.Buffer-249** %0, align 8
	%6 = getelementptr inbounds %strconv.format_digits.Buffer-249, %strconv.format_digits.Buffer-249* %5, i64 0
	%7 = getelementptr inbounds %strconv.format_digits.Buffer-249, %strconv.format_digits.Buffer-249* %6, i64 0, i32 1
	; SliceExpr
	; SelectorExpr
	%8 = load %strconv.format_digits.Buffer-249*, %strconv.format_digits.Buffer-249** %0, align 8
	%9 = getelementptr inbounds %strconv.format_digits.Buffer-249, %strconv.format_digits.Buffer-249* %8, i64 0
	%10 = getelementptr inbounds %strconv.format_digits.Buffer-249, %strconv.format_digits.Buffer-249* %9, i64 0, i32 1
	%11 = load i64, i64* %10, align 8
	; SelectorExpr
	%12 = load %strconv.format_digits.Buffer-249*, %strconv.format_digits.Buffer-249** %0, align 8
	%13 = getelementptr inbounds %strconv.format_digits.Buffer-249, %strconv.format_digits.Buffer-249* %12, i64 0
	%14 = getelementptr inbounds %strconv.format_digits.Buffer-249, %strconv.format_digits.Buffer-249* %13, i64 0, i32 0
	%15 = load {i8*, i64}, {i8*, i64}* %14, align 8
	%16 = extractvalue {i8*, i64} %15, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1cd, i64 0, i32 0), i64 61}, i64 315, i64 22, i64 %11, i64 %16, i64 %16)
	%17 = extractvalue {i8*, i64} %15, 0
	%18 = getelementptr inbounds i8, i8* %17, i64 %11
	%19 = sub i64 %16, %11
	%20 = bitcast {i8*, i64}* %1 to %..rawptr
	%21 = call %..rawptr @mem.zero(%..rawptr %20, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %1
	%22 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1, i64 0, i32 0
	store i8* %18, i8** %22
	%23 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1, i64 0, i32 1
	store i64 %19, i64* %23
	%24 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%25 = load {i8*, i64}, {i8*, i64}* %bytes, align 8
	%26 = bitcast {i8*, i64}* %2 to %..rawptr
	%27 = call %..rawptr @mem.zero(%..rawptr %26, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %2
	store {i8*, i64} %24, {i8*, i64}* %2
	%28 = bitcast {i8*, i64}* %3 to %..rawptr
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %3
	store {i8*, i64} %25, {i8*, i64}* %3
	%30 = call i64 @runtime.copy-19008({i8*, i64}* %2, {i8*, i64}* %3)
	%31 = load i64, i64* %7, align 8
	%32 = add i64 %31, %30
	store i64 %32, i64* %7
	ret void
}

define void @strconv.round_shortest(%decimal.Decimal* %d, i64 %mant, i64 %exp, %strconv.FloatInfo* %flt, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %strconv.FloatInfo*, align 16
	%4 = alloca i64, align 16
	%5 = alloca %decimal.Decimal, align 16
	%6 = alloca %decimal.Decimal*, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca %decimal.Decimal, align 16
	%10 = alloca %decimal.Decimal*, align 16
	%11 = alloca i8, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca i8, align 16
	%17 = alloca i8, align 16
	%18 = alloca i8, align 16
	%19 = alloca i8, align 16
	store %decimal.Decimal* %d, %decimal.Decimal** %0
	store i64 %mant, i64* %1
	store i64 %exp, i64* %2
	store %strconv.FloatInfo* %flt, %strconv.FloatInfo** %3
	; IfStmt
	%20 = load i64, i64* %1, align 8
	%21 = icmp eq i64 %20, 0
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; SelectorExpr
	%24 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%25 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %24, i64 0
	%26 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %25, i64 0, i32 1
	store i64 0, i64* %26
	; ReturnStmt
	ret void

if.done-2:
	; minexp
	; SelectorExpr
	%27 = load %strconv.FloatInfo*, %strconv.FloatInfo** %3, align 8
	%28 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %27, i64 0
	%29 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %28, i64 0, i32 2
	%30 = load i64, i64* %29, align 8
	%31 = add i64 %30, 1
	store i64 %31, i64* %4
	; IfStmt
	%32 = load i64, i64* %2, align 8
	%33 = load i64, i64* %4, align 8
	%34 = icmp sgt i64 %32, %33
	%35 = zext i1 %34 to i8
	%36 = trunc i8 %35 to i1
	br i1 %36, label %cmp.and-3, label %if.done-5

cmp.and-3:
	; SelectorExpr
	%37 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%38 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %37, i64 0
	%39 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %38, i64 0, i32 2
	%40 = load i64, i64* %39, align 8
	; SelectorExpr
	%41 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%42 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %41, i64 0
	%43 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %42, i64 0, i32 1
	%44 = load i64, i64* %43, align 8
	%45 = sub i64 %40, %44
	%46 = mul i64 332, %45
	%47 = load i64, i64* %2, align 8
	; SelectorExpr
	%48 = load %strconv.FloatInfo*, %strconv.FloatInfo** %3, align 8
	%49 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %48, i64 0
	%50 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %49, i64 0, i32 0
	%51 = load i64, i64* %50, align 8
	%52 = bitcast i64 %51 to i64
	%53 = sub i64 %47, %52
	%54 = mul i64 100, %53
	%55 = icmp sge i64 %46, %54
	%56 = zext i1 %55 to i8
	%57 = trunc i8 %56 to i1
	br i1 %57, label %if.then-4, label %if.done-5

if.then-4:
	; ReturnStmt
	ret void

if.done-5:
	; upper_
	%58 = bitcast %decimal.Decimal* %5 to %..rawptr
	%59 = call %..rawptr @mem.zero(%..rawptr %58, i64 408) noinline
	store %decimal.Decimal zeroinitializer, %decimal.Decimal* %5
	; upper
	store %decimal.Decimal* %5, %decimal.Decimal** %6
	%60 = load %decimal.Decimal*, %decimal.Decimal** %6, align 8
	%61 = load i64, i64* %1, align 8
	%62 = mul i64 2, %61
	%63 = sub i64 %62, 1
	call void @decimal.assign(%decimal.Decimal* %60, i64 %63, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%64 = load %decimal.Decimal*, %decimal.Decimal** %6, align 8
	%65 = load i64, i64* %2, align 8
	; SelectorExpr
	%66 = load %strconv.FloatInfo*, %strconv.FloatInfo** %3, align 8
	%67 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %66, i64 0
	%68 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %67, i64 0, i32 0
	%69 = load i64, i64* %68, align 8
	%70 = bitcast i64 %69 to i64
	%71 = sub i64 %65, %70
	%72 = sub i64 %71, 1
	call void @decimal.shift(%decimal.Decimal* %64, i64 %72, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; mantlo
	%73 = bitcast i64* %7 to %..rawptr
	%74 = call %..rawptr @mem.zero(%..rawptr %73, i64 8) noinline
	store i64 zeroinitializer, i64* %7
	; explo
	%75 = bitcast i64* %8 to %..rawptr
	%76 = call %..rawptr @mem.zero(%..rawptr %75, i64 8) noinline
	store i64 zeroinitializer, i64* %8
	; IfStmt
	%77 = load i64, i64* %1, align 8
	; SelectorExpr
	%78 = load %strconv.FloatInfo*, %strconv.FloatInfo** %3, align 8
	%79 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %78, i64 0
	%80 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %79, i64 0, i32 0
	%81 = load i64, i64* %80, align 8
	%82 = bitcast i64 %81 to i64
	%83 = shl i64 1, %82
	%84 = bitcast i64 %83 to i64
	%85 = icmp ugt i64 %77, %84
	%86 = zext i1 %85 to i8
	%87 = trunc i8 %86 to i1
	br i1 %87, label %if.then-7, label %cmp.or-6

cmp.or-6:
	%88 = load i64, i64* %2, align 8
	%89 = load i64, i64* %4, align 8
	%90 = icmp eq i64 %88, %89
	%91 = zext i1 %90 to i8
	%92 = trunc i8 %91 to i1
	br i1 %92, label %if.then-7, label %if.else-8

if.then-7:
	; AssignStmt
	%93 = load i64, i64* %1, align 8
	%94 = sub i64 %93, 1
	store i64 %94, i64* %7
	; AssignStmt
	%95 = load i64, i64* %2, align 8
	store i64 %95, i64* %8
	br label %if.done-9

if.else-8:
	; AssignStmt
	%96 = load i64, i64* %1, align 8
	%97 = mul i64 2, %96
	%98 = sub i64 %97, 1
	store i64 %98, i64* %7
	; AssignStmt
	%99 = load i64, i64* %2, align 8
	%100 = sub i64 %99, 1
	store i64 %100, i64* %8
	br label %if.done-9

if.done-9:
	; lower_
	%101 = bitcast %decimal.Decimal* %9 to %..rawptr
	%102 = call %..rawptr @mem.zero(%..rawptr %101, i64 408) noinline
	store %decimal.Decimal zeroinitializer, %decimal.Decimal* %9
	; lower
	store %decimal.Decimal* %9, %decimal.Decimal** %10
	%103 = load %decimal.Decimal*, %decimal.Decimal** %10, align 8
	%104 = load i64, i64* %7, align 8
	%105 = mul i64 2, %104
	%106 = add i64 %105, 1
	call void @decimal.assign(%decimal.Decimal* %103, i64 %106, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%107 = load %decimal.Decimal*, %decimal.Decimal** %10, align 8
	%108 = load i64, i64* %8, align 8
	; SelectorExpr
	%109 = load %strconv.FloatInfo*, %strconv.FloatInfo** %3, align 8
	%110 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %109, i64 0
	%111 = getelementptr inbounds %strconv.FloatInfo, %strconv.FloatInfo* %110, i64 0, i32 0
	%112 = load i64, i64* %111, align 8
	%113 = bitcast i64 %112 to i64
	%114 = sub i64 %108, %113
	%115 = sub i64 %114, 1
	call void @decimal.shift(%decimal.Decimal* %107, i64 %115, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; inclusive
	%116 = load i64, i64* %1, align 8
	%117 = urem i64 %116, 2
	%118 = icmp eq i64 %117, 0
	%119 = zext i1 %118 to i8
	store i8 %119, i8* %11
	; RangeStmt
	; i
	%120 = bitcast i64* %12 to %..rawptr
	%121 = call %..rawptr @mem.zero(%..rawptr %120, i64 8) noinline
	store i64 zeroinitializer, i64* %12
	%122 = bitcast i64* %13 to %..rawptr
	%123 = call %..rawptr @mem.zero(%..rawptr %122, i64 8) noinline
	store i64 zeroinitializer, i64* %13
	store i64 0, i64* %13
	%124 = bitcast i64* %14 to %..rawptr
	%125 = call %..rawptr @mem.zero(%..rawptr %124, i64 8) noinline
	store i64 zeroinitializer, i64* %14
	store i64 0, i64* %14
	br label %for.interval.loop-10

for.interval.loop-10:
	; SelectorExpr
	%126 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%127 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %126, i64 0
	%128 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %127, i64 0, i32 1
	%129 = load i64, i64* %128, align 8
	%130 = sub i64 %129, 1
	%131 = load i64, i64* %13, align 8
	%132 = icmp sle i64 %131, %130
	br i1 %132, label %for.interval.body-11, label %for.interval.done-34

for.interval.body-11:
	%133 = load i64, i64* %13, align 8
	%134 = load i64, i64* %14, align 8
	%135 = load i64, i64* %13, align 8
	%136 = add i64 %135, 1
	store i64 %136, i64* %13
	%137 = load i64, i64* %14, align 8
	%138 = add i64 %137, 1
	store i64 %138, i64* %14
	store i64 %133, i64* %12
	; l
	store i8 48, i8* %15
	; IfStmt
	%139 = load i64, i64* %12, align 8
	; SelectorExpr
	%140 = load %decimal.Decimal*, %decimal.Decimal** %10, align 8
	%141 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %140, i64 0
	%142 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %141, i64 0, i32 1
	%143 = load i64, i64* %142, align 8
	%144 = icmp slt i64 %139, %143
	%145 = zext i1 %144 to i8
	%146 = trunc i8 %145 to i1
	br i1 %146, label %if.then-12, label %if.done-13

if.then-12:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%147 = load %decimal.Decimal*, %decimal.Decimal** %10, align 8
	%148 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %147, i64 0
	%149 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %148, i64 0, i32 0
	%150 = load i64, i64* %12, align 8
	%151 = trunc i64 %150 to i32
	%152 = getelementptr inbounds [384 x i8], [384 x i8]* %149, i64 0, i32 %151
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1ce, i64 0, i32 0), i64 61}, i64 405, i64 21, i64 %150, i64 384)
	%153 = load i8, i8* %152, align 1
	store i8 %153, i8* %15
	br label %if.done-13

if.done-13:
	; m
	; IndexExpr
	; SelectorExpr
	%154 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%155 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %154, i64 0
	%156 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %155, i64 0, i32 0
	%157 = load i64, i64* %12, align 8
	%158 = trunc i64 %157 to i32
	%159 = getelementptr inbounds [384 x i8], [384 x i8]* %156, i64 0, i32 %158
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1cf, i64 0, i32 0), i64 61}, i64 407, i64 17, i64 %157, i64 384)
	%160 = load i8, i8* %159, align 1
	store i8 %160, i8* %16
	; u
	store i8 48, i8* %17
	; IfStmt
	%161 = load i64, i64* %12, align 8
	; SelectorExpr
	%162 = load %decimal.Decimal*, %decimal.Decimal** %6, align 8
	%163 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %162, i64 0
	%164 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %163, i64 0, i32 1
	%165 = load i64, i64* %164, align 8
	%166 = icmp slt i64 %161, %165
	%167 = zext i1 %166 to i8
	%168 = trunc i8 %167 to i1
	br i1 %168, label %if.then-14, label %if.done-15

if.then-14:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%169 = load %decimal.Decimal*, %decimal.Decimal** %6, align 8
	%170 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %169, i64 0
	%171 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %170, i64 0, i32 0
	%172 = load i64, i64* %12, align 8
	%173 = trunc i64 %172 to i32
	%174 = getelementptr inbounds [384 x i8], [384 x i8]* %171, i64 0, i32 %173
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1d0, i64 0, i32 0), i64 61}, i64 410, i64 21, i64 %172, i64 384)
	%175 = load i8, i8* %174, align 1
	store i8 %175, i8* %17
	br label %if.done-15

if.done-15:
	; ok_round_down
	%176 = load i8, i8* %15, align 1
	%177 = load i8, i8* %16, align 1
	%178 = icmp ne i8 %176, %177
	%179 = zext i1 %178 to i8
	%180 = load i8, i8* %15, align 1
	%181 = load i8, i8* %16, align 1
	%182 = icmp ne i8 %180, %181
	%183 = zext i1 %182 to i8
	%184 = trunc i8 %183 to i1
	br i1 %184, label %logical.cmp.done-19, label %logical.cmp.rhs-16

logical.cmp.rhs-16:
	%185 = load i8, i8* %11, align 1
	%186 = load i8, i8* %11, align 1
	%187 = trunc i8 %186 to i1
	br i1 %187, label %logical.cmp.rhs-17, label %logical.cmp.done-18

logical.cmp.rhs-17:
	%188 = load i64, i64* %12, align 8
	%189 = add i64 %188, 1
	; SelectorExpr
	%190 = load %decimal.Decimal*, %decimal.Decimal** %10, align 8
	%191 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %190, i64 0
	%192 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %191, i64 0, i32 1
	%193 = load i64, i64* %192, align 8
	%194 = icmp eq i64 %189, %193
	%195 = zext i1 %194 to i8
	br label %logical.cmp.done-18

logical.cmp.done-18:
	%196 = phi i8 [ 0, %logical.cmp.rhs-16 ], [ %195, %logical.cmp.rhs-17 ]
	br label %logical.cmp.done-19

logical.cmp.done-19:
	%197 = phi i8 [ 1, %if.done-15 ], [ %196, %logical.cmp.done-18 ]
	store i8 %197, i8* %18
	; ok_round_up
	%198 = load i8, i8* %16, align 1
	%199 = load i8, i8* %17, align 1
	%200 = icmp ne i8 %198, %199
	%201 = zext i1 %200 to i8
	%202 = load i8, i8* %16, align 1
	%203 = load i8, i8* %17, align 1
	%204 = icmp ne i8 %202, %203
	%205 = zext i1 %204 to i8
	%206 = trunc i8 %205 to i1
	br i1 %206, label %logical.cmp.rhs-20, label %logical.cmp.done-26

logical.cmp.rhs-20:
	%207 = load i8, i8* %11, align 1
	%208 = load i8, i8* %11, align 1
	%209 = trunc i8 %208 to i1
	br i1 %209, label %logical.cmp.done-22, label %logical.cmp.rhs-21

logical.cmp.rhs-21:
	%210 = load i8, i8* %16, align 1
	%211 = add i8 %210, 1
	%212 = load i8, i8* %17, align 1
	%213 = icmp ult i8 %211, %212
	%214 = zext i1 %213 to i8
	br label %logical.cmp.done-22

logical.cmp.done-22:
	%215 = phi i8 [ 1, %logical.cmp.rhs-20 ], [ %214, %logical.cmp.rhs-21 ]
	%216 = load i8, i8* %11, align 1
	%217 = trunc i8 %216 to i1
	br i1 %217, label %logical.cmp.done-25, label %cmp.or-23

cmp.or-23:
	%218 = load i8, i8* %16, align 1
	%219 = add i8 %218, 1
	%220 = load i8, i8* %17, align 1
	%221 = icmp ult i8 %219, %220
	%222 = zext i1 %221 to i8
	%223 = trunc i8 %222 to i1
	br i1 %223, label %logical.cmp.done-25, label %logical.cmp.rhs-24

logical.cmp.rhs-24:
	%224 = load i64, i64* %12, align 8
	%225 = add i64 %224, 1
	; SelectorExpr
	%226 = load %decimal.Decimal*, %decimal.Decimal** %6, align 8
	%227 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %226, i64 0
	%228 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %227, i64 0, i32 1
	%229 = load i64, i64* %228, align 8
	%230 = icmp slt i64 %225, %229
	%231 = zext i1 %230 to i8
	br label %logical.cmp.done-25

logical.cmp.done-25:
	%232 = phi i8 [ 1, %logical.cmp.done-22 ], [ 1, %cmp.or-23 ], [ %231, %logical.cmp.rhs-24 ]
	br label %logical.cmp.done-26

logical.cmp.done-26:
	%233 = phi i8 [ 0, %logical.cmp.done-19 ], [ %232, %logical.cmp.done-25 ]
	store i8 %233, i8* %19
	; IfStmt
	%234 = load i8, i8* %18, align 1
	%235 = trunc i8 %234 to i1
	br i1 %235, label %cmp.and-27, label %if.done-29

cmp.and-27:
	%236 = load i8, i8* %19, align 1
	%237 = trunc i8 %236 to i1
	br i1 %237, label %if.then-28, label %if.done-29

if.then-28:
	%238 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%239 = load i64, i64* %12, align 8
	%240 = add i64 %239, 1
	call void @decimal.round(%decimal.Decimal* %238, i64 %240, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-29:
	; IfStmt
	%241 = load i8, i8* %18, align 1
	%242 = trunc i8 %241 to i1
	br i1 %242, label %if.then-30, label %if.done-31

if.then-30:
	%243 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%244 = load i64, i64* %12, align 8
	%245 = add i64 %244, 1
	call void @decimal.round_down(%decimal.Decimal* %243, i64 %245, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-31:
	; IfStmt
	%246 = load i8, i8* %19, align 1
	%247 = trunc i8 %246 to i1
	br i1 %247, label %if.then-32, label %if.done-33

if.then-32:
	%248 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%249 = load i64, i64* %12, align 8
	%250 = add i64 %249, 1
	call void @decimal.round_up(%decimal.Decimal* %248, i64 %250, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	ret void

if.done-33:
	br label %for.interval.loop-10

for.interval.done-34:
	ret void
}

define {i64, i8} @strconv.is_integer_negative(i64 %u, i1 %is_signed, i64 %bit_size, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i8, align 16
	%5 = alloca i8, align 16
	%6 = alloca i16, align 16
	%7 = alloca i32, align 16
	%8 = alloca i64, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca {i64, i8}, align 16
	store i64 %u, i64* %0
	%11 = zext i1 %is_signed to i8
	store i8 %11, i8* %1
	store i64 %bit_size, i64* %2
	%12 = bitcast i64* %3 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	%14 = bitcast i8* %4 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 1) noinline
	store i8 zeroinitializer, i8* %4
	; IfStmt
	%16 = load i8, i8* %1, align 1
	%17 = trunc i8 %16 to i1
	br i1 %17, label %if.then-1, label %if.done-11

if.then-1:
	; SwitchStmt
	%18 = load i64, i64* %2, align 8
	%19 = icmp eq i64 %18, 8
	br i1 %19, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%20 = icmp eq i64 %18, 16
	br i1 %20, label %switch.fall.body-5, label %switch.case.next-4

switch.case.body-3:
	; i
	%21 = load i64, i64* %0, align 8
	%22 = trunc i64 %21 to i8
	store i8 %22, i8* %5
	; AssignStmt
	%23 = load i8, i8* %5, align 1
	%24 = icmp slt i8 %23, 0
	%25 = zext i1 %24 to i8
	store i8 %25, i8* %4
	; AssignStmt
	%26 = load i8, i8* %5, align 1
	; abs
	%27 = icmp slt i8 %26, 0
	%28 = sub i8 0, %26
	%29 = select i1 %27, i8 %28, i8 %26
	%30 = sext i8 %29 to i64
	store i64 %30, i64* %0
	br label %switch.done-10

switch.case.next-4:
	%31 = icmp eq i64 %18, 32
	br i1 %31, label %switch.fall.body-7, label %switch.case.next-6

switch.fall.body-5:
	; i
	%32 = load i64, i64* %0, align 8
	%33 = trunc i64 %32 to i16
	store i16 %33, i16* %6
	; AssignStmt
	%34 = load i16, i16* %6, align 2
	%35 = icmp slt i16 %34, 0
	%36 = zext i1 %35 to i8
	store i8 %36, i8* %4
	; AssignStmt
	%37 = load i16, i16* %6, align 2
	; abs
	%38 = icmp slt i16 %37, 0
	%39 = sub i16 0, %37
	%40 = select i1 %38, i16 %39, i16 %37
	%41 = sext i16 %40 to i64
	store i64 %41, i64* %0
	br label %switch.done-10

switch.case.next-6:
	%42 = icmp eq i64 %18, 64
	br i1 %42, label %switch.fall.body-9, label %switch.case.next-8

switch.fall.body-7:
	; i
	%43 = load i64, i64* %0, align 8
	%44 = trunc i64 %43 to i32
	store i32 %44, i32* %7
	; AssignStmt
	%45 = load i32, i32* %7, align 4
	%46 = icmp slt i32 %45, 0
	%47 = zext i1 %46 to i8
	store i8 %47, i8* %4
	; AssignStmt
	%48 = load i32, i32* %7, align 4
	; abs
	%49 = icmp slt i32 %48, 0
	%50 = sub i32 0, %48
	%51 = select i1 %49, i32 %50, i32 %48
	%52 = sext i32 %51 to i64
	store i64 %52, i64* %0
	br label %switch.done-10

switch.case.next-8:
	%53 = bitcast %runtime.Source_Code_Location* %9 to %..rawptr
	%54 = call %..rawptr @mem.zero(%..rawptr %53, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %9
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1d1, i64 0, i32 0), i64 61}, i64 456, i64 4, %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$1d2, i64 0, i32 0), i64 19}}, %runtime.Source_Code_Location* %9
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([42 x i8], [42 x i8]* @str$1d3, i64 0, i32 0), i64 41}, %runtime.Source_Code_Location* %9) noreturn
	br label %switch.done-10

switch.fall.body-9:
	; i
	%55 = load i64, i64* %0, align 8
	%56 = bitcast i64 %55 to i64
	store i64 %56, i64* %8
	; AssignStmt
	%57 = load i64, i64* %8, align 8
	%58 = icmp slt i64 %57, 0
	%59 = zext i1 %58 to i8
	store i8 %59, i8* %4
	; AssignStmt
	%60 = load i64, i64* %8, align 8
	; abs
	%61 = icmp slt i64 %60, 0
	%62 = sub i64 0, %60
	%63 = select i1 %61, i64 %62, i64 %60
	%64 = bitcast i64 %63 to i64
	store i64 %64, i64* %0
	br label %switch.done-10

switch.done-10:
	br label %if.done-11

if.done-11:
	; ReturnStmt
	%65 = load i64, i64* %0, align 8
	%66 = load i8, i8* %4, align 1
	%67 = bitcast {i64, i8}* %10 to %..rawptr
	%68 = call %..rawptr @mem.zero(%..rawptr %67, i64 16) noinline
	store {i64, i8} zeroinitializer, {i64, i8}* %10
	%69 = getelementptr inbounds {i64, i8}, {i64, i8}* %10, i64 0, i32 0
	store i64 %65, i64* %69
	%70 = getelementptr inbounds {i64, i8}, {i64, i8}* %10, i64 0, i32 1
	store i8 %66, i8* %70
	%71 = load {i64, i8}, {i64, i8}* %10, align 8
	ret {i64, i8} %71
}

define %..string @strconv.append_bits({i8*, i64}* %buf, i64 %u, i64 %base, i1 %is_signed, i64 %bit_size, %..string %digits, i8 %flags, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..string, align 16
	%5 = alloca i8, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca i8, align 16
	%8 = alloca [129 x i8], align 16
	%9 = alloca i64, align 16
	%10 = alloca i64, align 16
	%11 = alloca i8, align 16
	%12 = alloca {i8*, i64}, align 16
	%13 = alloca {i8*, i64}, align 16
	%14 = alloca {i8*, i64}, align 16
	%15 = alloca {i8*, i64}, align 16
	%16 = alloca {i8*, i64}, align 16
	%17 = alloca %..string, align 16
	%18 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	store i64 %u, i64* %0
	store i64 %base, i64* %1
	%19 = zext i1 %is_signed to i8
	store i8 %19, i8* %2
	store i64 %bit_size, i64* %3
	store %..string %digits, %..string* %4
	store i8 %flags, i8* %5
	; IfStmt
	%20 = load i64, i64* %1, align 8
	%21 = icmp slt i64 %20, 2
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%24 = load i64, i64* %1, align 8
	%25 = icmp sgt i64 %24, 32
	%26 = zext i1 %25 to i8
	%27 = trunc i8 %26 to i1
	br i1 %27, label %if.then-2, label %if.done-3

if.then-2:
	%28 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1d4, i64 0, i32 0), i64 61}, i64 464, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$1d5, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %6
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([44 x i8], [44 x i8]* @str$1d6, i64 0, i32 0), i64 43}, %runtime.Source_Code_Location* %6) noreturn
	br label %if.done-3

if.done-3:
	; neg
	%30 = bitcast i8* %7 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 1) noinline
	store i8 zeroinitializer, i8* %7
	; a
	%32 = bitcast [129 x i8]* %8 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 129) noinline
	store [129 x i8] zeroinitializer, [129 x i8]* %8
	; i
	store i64 129, i64* %9
	; AssignStmt
	%34 = load i64, i64* %0, align 8
	%35 = load i8, i8* %2, align 1
	%36 = load i64, i64* %3, align 8
	%37 = trunc i8 %35 to i1
	%38 = call {i64, i8} @strconv.is_integer_negative(i64 %34, i1 %37, i64 %36, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%39 = extractvalue {i64, i8} %38, 0
	%40 = extractvalue {i64, i8} %38, 1
	store i64 %39, i64* %0
	store i8 %40, i8* %7
	; b
	%41 = load i64, i64* %1, align 8
	%42 = bitcast i64 %41 to i64
	store i64 %42, i64* %10
	; ForStmt
	br label %for.loop-4

for.loop-4:
	%43 = load i64, i64* %0, align 8
	%44 = load i64, i64* %10, align 8
	%45 = icmp uge i64 %43, %44
	%46 = zext i1 %45 to i8
	%47 = trunc i8 %46 to i1
	br i1 %47, label %for.body-5, label %for.done-6

for.body-5:
	; AssignStmt
	%48 = load i64, i64* %9, align 8
	%49 = sub i64 %48, 1
	store i64 %49, i64* %9
	; AssignStmt
	; IndexExpr
	%50 = load i64, i64* %9, align 8
	%51 = trunc i64 %50 to i32
	%52 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %51
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1d7, i64 0, i32 0), i64 61}, i64 473, i64 11, i64 %50, i64 129)
	; IndexExpr
	%53 = load %..string, %..string* %4, align 8
	%54 = extractvalue %..string %53, 0
	%55 = extractvalue %..string %53, 1
	%56 = load i64, i64* %0, align 8
	%57 = load i64, i64* %10, align 8
	%58 = urem i64 %56, %57
	%59 = bitcast i64 %58 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1d8, i64 0, i32 0), i64 61}, i64 473, i64 23, i64 %59, i64 %55)
	%60 = getelementptr inbounds i8, i8* %54, i64 %59
	%61 = load i8, i8* %60, align 1
	store i8 %61, i8* %52
	; AssignStmt
	%62 = load i64, i64* %10, align 8
	%63 = load i64, i64* %0, align 8
	%64 = udiv i64 %63, %62
	store i64 %64, i64* %0
	br label %for.loop-4

for.done-6:
	; AssignStmt
	%65 = load i64, i64* %9, align 8
	%66 = sub i64 %65, 1
	store i64 %66, i64* %9
	; AssignStmt
	; IndexExpr
	%67 = load i64, i64* %9, align 8
	%68 = trunc i64 %67 to i32
	%69 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %68
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1d9, i64 0, i32 0), i64 61}, i64 476, i64 10, i64 %67, i64 129)
	; IndexExpr
	%70 = load %..string, %..string* %4, align 8
	%71 = extractvalue %..string %70, 0
	%72 = extractvalue %..string %70, 1
	%73 = load i64, i64* %0, align 8
	%74 = load i64, i64* %10, align 8
	%75 = urem i64 %73, %74
	%76 = bitcast i64 %75 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1da, i64 0, i32 0), i64 61}, i64 476, i64 22, i64 %76, i64 %72)
	%77 = getelementptr inbounds i8, i8* %71, i64 %76
	%78 = load i8, i8* %77, align 1
	store i8 %78, i8* %69
	; IfStmt
	%79 = load i8, i8* %5, align 1
	; bit_set in
	%80 = sub i8 0, 0
	%81 = shl i8 1, %80
	%82 = bitcast i8 %79 to i8
	%83 = and i8 %82, %81
	%84 = icmp ne i8 %83, 0
	%85 = zext i1 %84 to i8
	%86 = trunc i8 %85 to i1
	br i1 %86, label %if.then-7, label %if.done-21

if.then-7:
	; ok
	store i8 1, i8* %11
	; SwitchStmt
	%87 = load i64, i64* %1, align 8
	%88 = icmp eq i64 %87, 2
	br i1 %88, label %switch.case.body-9, label %switch.case.next-8

switch.case.next-8:
	%89 = icmp eq i64 %87, 8
	br i1 %89, label %switch.fall.body-11, label %switch.case.next-10

switch.case.body-9:
	; AssignStmt
	%90 = load i64, i64* %9, align 8
	%91 = sub i64 %90, 1
	store i64 %91, i64* %9
	; AssignStmt
	; IndexExpr
	%92 = load i64, i64* %9, align 8
	%93 = trunc i64 %92 to i32
	%94 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %93
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1db, i64 0, i32 0), i64 61}, i64 481, i64 20, i64 %92, i64 129)
	store i8 98, i8* %94
	br label %switch.done-18

switch.case.next-10:
	%95 = icmp eq i64 %87, 10
	br i1 %95, label %switch.fall.body-13, label %switch.case.next-12

switch.fall.body-11:
	; AssignStmt
	%96 = load i64, i64* %9, align 8
	%97 = sub i64 %96, 1
	store i64 %97, i64* %9
	; AssignStmt
	; IndexExpr
	%98 = load i64, i64* %9, align 8
	%99 = trunc i64 %98 to i32
	%100 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %99
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1dc, i64 0, i32 0), i64 61}, i64 482, i64 20, i64 %98, i64 129)
	store i8 111, i8* %100
	br label %switch.done-18

switch.case.next-12:
	%101 = icmp eq i64 %87, 12
	br i1 %101, label %switch.fall.body-15, label %switch.case.next-14

switch.fall.body-13:
	; AssignStmt
	%102 = load i64, i64* %9, align 8
	%103 = sub i64 %102, 1
	store i64 %103, i64* %9
	; AssignStmt
	; IndexExpr
	%104 = load i64, i64* %9, align 8
	%105 = trunc i64 %104 to i32
	%106 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %105
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1dd, i64 0, i32 0), i64 61}, i64 483, i64 20, i64 %104, i64 129)
	store i8 100, i8* %106
	br label %switch.done-18

switch.case.next-14:
	%107 = icmp eq i64 %87, 16
	br i1 %107, label %switch.fall.body-17, label %switch.case.next-16

switch.fall.body-15:
	; AssignStmt
	%108 = load i64, i64* %9, align 8
	%109 = sub i64 %108, 1
	store i64 %109, i64* %9
	; AssignStmt
	; IndexExpr
	%110 = load i64, i64* %9, align 8
	%111 = trunc i64 %110 to i32
	%112 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %111
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1de, i64 0, i32 0), i64 61}, i64 484, i64 20, i64 %110, i64 129)
	store i8 122, i8* %112
	br label %switch.done-18

switch.case.next-16:
	; AssignStmt
	store i8 0, i8* %11
	br label %switch.done-18

switch.fall.body-17:
	; AssignStmt
	%113 = load i64, i64* %9, align 8
	%114 = sub i64 %113, 1
	store i64 %114, i64* %9
	; AssignStmt
	; IndexExpr
	%115 = load i64, i64* %9, align 8
	%116 = trunc i64 %115 to i32
	%117 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %116
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1df, i64 0, i32 0), i64 61}, i64 485, i64 20, i64 %115, i64 129)
	store i8 120, i8* %117
	br label %switch.done-18

switch.done-18:
	; IfStmt
	%118 = load i8, i8* %11, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %if.then-19, label %if.done-20

if.then-19:
	; AssignStmt
	%120 = load i64, i64* %9, align 8
	%121 = sub i64 %120, 1
	store i64 %121, i64* %9
	; AssignStmt
	; IndexExpr
	%122 = load i64, i64* %9, align 8
	%123 = trunc i64 %122 to i32
	%124 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %123
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1e0, i64 0, i32 0), i64 61}, i64 489, i64 12, i64 %122, i64 129)
	store i8 48, i8* %124
	br label %if.done-20

if.done-20:
	br label %if.done-21

if.done-21:
	; SwitchStmt
	%125 = load i8, i8* %7, align 1
	%126 = icmp eq i8 1, %125
	br i1 %126, label %switch.case.body-23, label %switch.case.next-22

switch.case.next-22:
	%127 = load i8, i8* %5, align 1
	; bit_set in
	%128 = sub i8 1, 0
	%129 = shl i8 1, %128
	%130 = bitcast i8 %127 to i8
	%131 = and i8 %130, %129
	%132 = icmp ne i8 %131, 0
	%133 = zext i1 %132 to i8
	%134 = icmp eq i8 1, %133
	br i1 %134, label %switch.fall.body-25, label %switch.case.next-24

switch.case.body-23:
	; AssignStmt
	%135 = load i64, i64* %9, align 8
	%136 = sub i64 %135, 1
	store i64 %136, i64* %9
	; AssignStmt
	; IndexExpr
	%137 = load i64, i64* %9, align 8
	%138 = trunc i64 %137 to i32
	%139 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %138
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1e1, i64 0, i32 0), i64 61}, i64 495, i64 11, i64 %137, i64 129)
	store i8 45, i8* %139
	br label %switch.done-28

switch.case.next-24:
	%140 = load i8, i8* %5, align 1
	; bit_set in
	%141 = sub i8 2, 0
	%142 = shl i8 1, %141
	%143 = bitcast i8 %140 to i8
	%144 = and i8 %143, %142
	%145 = icmp ne i8 %144, 0
	%146 = zext i1 %145 to i8
	%147 = icmp eq i8 1, %146
	br i1 %147, label %switch.fall.body-27, label %switch.case.next-26

switch.fall.body-25:
	; AssignStmt
	%148 = load i64, i64* %9, align 8
	%149 = sub i64 %148, 1
	store i64 %149, i64* %9
	; AssignStmt
	; IndexExpr
	%150 = load i64, i64* %9, align 8
	%151 = trunc i64 %150 to i32
	%152 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %151
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1e2, i64 0, i32 0), i64 61}, i64 497, i64 11, i64 %150, i64 129)
	store i8 43, i8* %152
	br label %switch.done-28

switch.case.next-26:
	br label %switch.done-28

switch.fall.body-27:
	; AssignStmt
	%153 = load i64, i64* %9, align 8
	%154 = sub i64 %153, 1
	store i64 %154, i64* %9
	; AssignStmt
	; IndexExpr
	%155 = load i64, i64* %9, align 8
	%156 = trunc i64 %155 to i32
	%157 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 %156
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1e3, i64 0, i32 0), i64 61}, i64 499, i64 11, i64 %155, i64 129)
	store i8 32, i8* %157
	br label %switch.done-28

switch.done-28:
	; out
	; SliceExpr
	%158 = load i64, i64* %9, align 8
	%159 = load [129 x i8], [129 x i8]* %8, align 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1e4, i64 0, i32 0), i64 61}, i64 502, i64 10, i64 %158, i64 129, i64 129)
	%160 = getelementptr inbounds [129 x i8], [129 x i8]* %8, i64 0, i32 0
	%161 = getelementptr inbounds i8, i8* %160, i64 %158
	%162 = sub i64 129, %158
	%163 = bitcast {i8*, i64}* %13 to %..rawptr
	%164 = call %..rawptr @mem.zero(%..rawptr %163, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %13
	%165 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %13, i64 0, i32 0
	store i8* %161, i8** %165
	%166 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %13, i64 0, i32 1
	store i64 %162, i64* %166
	%167 = load {i8*, i64}, {i8*, i64}* %13, align 8
	store {i8*, i64} %167, {i8*, i64}* %12
	%168 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%169 = load {i8*, i64}, {i8*, i64}* %12, align 8
	%170 = bitcast {i8*, i64}* %14 to %..rawptr
	%171 = call %..rawptr @mem.zero(%..rawptr %170, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %14
	store {i8*, i64} %168, {i8*, i64}* %14
	%172 = bitcast {i8*, i64}* %15 to %..rawptr
	%173 = call %..rawptr @mem.zero(%..rawptr %172, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %15
	store {i8*, i64} %169, {i8*, i64}* %15
	%174 = call i64 @runtime.copy-19008({i8*, i64}* %14, {i8*, i64}* %15)
	; ReturnStmt
	; SliceExpr
	%175 = load {i8*, i64}, {i8*, i64}* %12, align 8
	%176 = extractvalue {i8*, i64} %175, 1
	%177 = load {i8*, i64}, {i8*, i64}* %buf, align 8
	%178 = extractvalue {i8*, i64} %177, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1e5, i64 0, i32 0), i64 61}, i64 504, i64 19, i64 0, i64 %176, i64 %178)
	%179 = extractvalue {i8*, i64} %177, 0
	%180 = getelementptr inbounds i8, i8* %179, i64 0
	%181 = sub i64 %176, 0
	%182 = bitcast {i8*, i64}* %16 to %..rawptr
	%183 = call %..rawptr @mem.zero(%..rawptr %182, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %16
	%184 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i64 0, i32 0
	store i8* %180, i8** %184
	%185 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i64 0, i32 1
	store i64 %181, i64* %185
	%186 = load {i8*, i64}, {i8*, i64}* %16, align 8
	%187 = extractvalue {i8*, i64} %186, 0
	%188 = extractvalue {i8*, i64} %186, 1
	%189 = bitcast %..string* %17 to %..rawptr
	%190 = call %..rawptr @mem.zero(%..rawptr %189, i64 16) noinline
	store %..string zeroinitializer, %..string* %17
	%191 = getelementptr inbounds %..string, %..string* %17, i64 0, i32 0
	store i8* %187, i8** %191
	%192 = getelementptr inbounds %..string, %..string* %17, i64 0, i32 1
	store i64 %188, i64* %192
	%193 = load %..string, %..string* %17, align 8
	ret %..string %193
}

define %..string @strings.new_string(%..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca {i8*, i64}, align 16
	%2 = alloca %mem.Allocator, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i8*, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca {i8*, i64}, align 16
	%7 = alloca {i8*, i64}, align 16
	%8 = alloca {i8*, i64}, align 16
	%9 = alloca %..string, align 16
	store %..string %s, %..string* %0
	; c
	%10 = load %..string, %..string* %0, align 8
	%11 = extractvalue %..string %10, 1
	%12 = add i64 %11, 1
	; SelectorExpr
	%13 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%14 = load %mem.Allocator, %mem.Allocator* %13, align 8
	%15 = bitcast %mem.Allocator* %2 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %2
	store %mem.Allocator %14, %mem.Allocator* %2
	%17 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1e6, i64 0, i32 0), i64 61}, i64 6, i64 7, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$1e7, i64 0, i32 0), i64 10}}, %runtime.Source_Code_Location* %3
	%19 = call {i8*, i64} @mem.make_slice-14294(i64 %12, %mem.Allocator* %2, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64} %19, {i8*, i64}* %1
	%20 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%21 = load %..string, %..string* %0, align 8
	%22 = extractvalue %..string %21, 0
	%23 = bitcast i8** %4 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 8) noinline
	store i8* zeroinitializer, i8** %4
	store i8* %22, i8** %4
	%25 = extractvalue %..string %21, 1
	%26 = sub i64 %25, 0
	%27 = load i8*, i8** %4, align 8
	%28 = getelementptr inbounds i8, i8* %27, i64 0
	%29 = bitcast {i8*, i64}* %5 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	%31 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 0
	store i8* %28, i8** %31
	%32 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 1
	store i64 %26, i64* %32
	%33 = load {i8*, i64}, {i8*, i64}* %5, align 8
	%34 = bitcast {i8*, i64}* %6 to %..rawptr
	%35 = call %..rawptr @mem.zero(%..rawptr %34, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	store {i8*, i64} %20, {i8*, i64}* %6
	%36 = bitcast {i8*, i64}* %7 to %..rawptr
	%37 = call %..rawptr @mem.zero(%..rawptr %36, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %7
	store {i8*, i64} %33, {i8*, i64}* %7
	%38 = call i64 @runtime.copy-19008({i8*, i64}* %6, {i8*, i64}* %7)
	; AssignStmt
	; IndexExpr
	%39 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%40 = extractvalue {i8*, i64} %39, 0
	%41 = load %..string, %..string* %0, align 8
	%42 = extractvalue %..string %41, 1
	%43 = extractvalue {i8*, i64} %39, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1e8, i64 0, i32 0), i64 61}, i64 8, i64 4, i64 %42, i64 %43)
	%44 = getelementptr inbounds i8, i8* %40, i64 %42
	store i8 0, i8* %44
	; ReturnStmt
	; SliceExpr
	%45 = load %..string, %..string* %0, align 8
	%46 = extractvalue %..string %45, 1
	%47 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%48 = extractvalue {i8*, i64} %47, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1e9, i64 0, i32 0), i64 61}, i64 9, i64 17, i64 0, i64 %46, i64 %48)
	%49 = extractvalue {i8*, i64} %47, 0
	%50 = getelementptr inbounds i8, i8* %49, i64 0
	%51 = sub i64 %46, 0
	%52 = bitcast {i8*, i64}* %8 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %8
	%54 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %8, i64 0, i32 0
	store i8* %50, i8** %54
	%55 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %8, i64 0, i32 1
	store i64 %51, i64* %55
	%56 = load {i8*, i64}, {i8*, i64}* %8, align 8
	%57 = extractvalue {i8*, i64} %56, 0
	%58 = extractvalue {i8*, i64} %56, 1
	%59 = bitcast %..string* %9 to %..rawptr
	%60 = call %..rawptr @mem.zero(%..rawptr %59, i64 16) noinline
	store %..string zeroinitializer, %..string* %9
	%61 = getelementptr inbounds %..string, %..string* %9, i64 0, i32 0
	store i8* %57, i8** %61
	%62 = getelementptr inbounds %..string, %..string* %9, i64 0, i32 1
	store i64 %58, i64* %62
	%63 = load %..string, %..string* %9, align 8
	ret %..string %63
}

define i8* @strings.new_cstring(%..string %s, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca {i8*, i64}, align 16
	%2 = alloca %mem.Allocator, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i8*, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca {i8*, i64}, align 16
	%7 = alloca {i8*, i64}, align 16
	store %..string %s, %..string* %0
	; c
	%8 = load %..string, %..string* %0, align 8
	%9 = extractvalue %..string %8, 1
	%10 = add i64 %9, 1
	; SelectorExpr
	%11 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%12 = load %mem.Allocator, %mem.Allocator* %11, align 8
	%13 = bitcast %mem.Allocator* %2 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %2
	store %mem.Allocator %12, %mem.Allocator* %2
	%15 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1ea, i64 0, i32 0), i64 61}, i64 13, i64 7, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$1eb, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %3
	%17 = call {i8*, i64} @mem.make_slice-14294(i64 %10, %mem.Allocator* %2, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store {i8*, i64} %17, {i8*, i64}* %1
	%18 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%19 = load %..string, %..string* %0, align 8
	%20 = extractvalue %..string %19, 0
	%21 = bitcast i8** %4 to %..rawptr
	%22 = call %..rawptr @mem.zero(%..rawptr %21, i64 8) noinline
	store i8* zeroinitializer, i8** %4
	store i8* %20, i8** %4
	%23 = extractvalue %..string %19, 1
	%24 = sub i64 %23, 0
	%25 = load i8*, i8** %4, align 8
	%26 = getelementptr inbounds i8, i8* %25, i64 0
	%27 = bitcast {i8*, i64}* %5 to %..rawptr
	%28 = call %..rawptr @mem.zero(%..rawptr %27, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	%29 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 0
	store i8* %26, i8** %29
	%30 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 1
	store i64 %24, i64* %30
	%31 = load {i8*, i64}, {i8*, i64}* %5, align 8
	%32 = bitcast {i8*, i64}* %6 to %..rawptr
	%33 = call %..rawptr @mem.zero(%..rawptr %32, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	store {i8*, i64} %18, {i8*, i64}* %6
	%34 = bitcast {i8*, i64}* %7 to %..rawptr
	%35 = call %..rawptr @mem.zero(%..rawptr %34, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %7
	store {i8*, i64} %31, {i8*, i64}* %7
	%36 = call i64 @runtime.copy-19008({i8*, i64}* %6, {i8*, i64}* %7)
	; AssignStmt
	; IndexExpr
	%37 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%38 = extractvalue {i8*, i64} %37, 0
	%39 = load %..string, %..string* %0, align 8
	%40 = extractvalue %..string %39, 1
	%41 = extractvalue {i8*, i64} %37, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1ec, i64 0, i32 0), i64 61}, i64 15, i64 4, i64 %40, i64 %41)
	%42 = getelementptr inbounds i8, i8* %38, i64 %40
	store i8 0, i8* %42
	; ReturnStmt
	; IndexExpr
	%43 = load {i8*, i64}, {i8*, i64}* %1, align 8
	%44 = extractvalue {i8*, i64} %43, 0
	%45 = extractvalue {i8*, i64} %43, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1ed, i64 0, i32 0), i64 61}, i64 16, i64 20, i64 0, i64 %45)
	%46 = getelementptr inbounds i8, i8* %44, i64 0
	%47 = bitcast i8* %46 to i8*
	ret i8* %47
}

define void @decimal.trim(%decimal.Decimal* %a, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	; ForStmt
	br label %for.loop-1

for.loop-1:
	; SelectorExpr
	%1 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%2 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %1, i64 0
	%3 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %2, i64 0, i32 1
	%4 = load i64, i64* %3, align 8
	%5 = icmp sgt i64 %4, 0
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %cmp.and-2, label %for.done-4

cmp.and-2:
	; IndexExpr
	; SelectorExpr
	%8 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%9 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %8, i64 0
	%10 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %9, i64 0, i32 0
	; SelectorExpr
	%11 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%12 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %11, i64 0
	%13 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %12, i64 0, i32 1
	%14 = load i64, i64* %13, align 8
	%15 = sub i64 %14, 1
	%16 = trunc i64 %15 to i32
	%17 = getelementptr inbounds [384 x i8], [384 x i8]* %10, i64 0, i32 %16
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1ee, i64 0, i32 0), i64 61}, i64 50, i64 32, i64 %15, i64 384)
	%18 = load i8, i8* %17, align 1
	%19 = icmp eq i8 %18, 48
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %for.body-3, label %for.done-4

for.body-3:
	; AssignStmt
	; SelectorExpr
	%22 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%23 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %22, i64 0
	%24 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %23, i64 0, i32 1
	%25 = load i64, i64* %24, align 8
	%26 = sub i64 %25, 1
	store i64 %26, i64* %24
	br label %for.loop-1

for.done-4:
	; IfStmt
	; SelectorExpr
	%27 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%28 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %27, i64 0
	%29 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %28, i64 0, i32 1
	%30 = load i64, i64* %29, align 8
	%31 = icmp eq i64 %30, 0
	%32 = zext i1 %31 to i8
	%33 = trunc i8 %32 to i1
	br i1 %33, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%34 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%35 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %34, i64 0
	%36 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %35, i64 0, i32 2
	store i64 0, i64* %36
	br label %if.done-6

if.done-6:
	ret void
}

define void @decimal.assign(%decimal.Decimal* %a, i64 %i, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca [64 x i8], align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %i, i64* %1
	; buf
	%5 = bitcast [64 x i8]* %2 to %..rawptr
	%6 = call %..rawptr @mem.zero(%..rawptr %5, i64 64) noinline
	store [64 x i8] zeroinitializer, [64 x i8]* %2
	; n
	store i64 0, i64* %3
	; ForStmt
	br label %for.loop-1

for.loop-1:
	%7 = load i64, i64* %1, align 8
	%8 = icmp ugt i64 %7, 0
	%9 = zext i1 %8 to i8
	%10 = trunc i8 %9 to i1
	br i1 %10, label %for.body-2, label %for.done-3

for.body-2:
	; j
	%11 = load i64, i64* %1, align 8
	%12 = udiv i64 %11, 10
	store i64 %12, i64* %4
	; AssignStmt
	%13 = load i64, i64* %4, align 8
	%14 = mul i64 10, %13
	%15 = load i64, i64* %1, align 8
	%16 = sub i64 %15, %14
	store i64 %16, i64* %1
	; AssignStmt
	; IndexExpr
	%17 = load i64, i64* %3, align 8
	%18 = trunc i64 %17 to i32
	%19 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i32 %18
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1ef, i64 0, i32 0), i64 61}, i64 65, i64 7, i64 %17, i64 64)
	%20 = load i64, i64* %1, align 8
	%21 = add i64 48, %20
	%22 = trunc i64 %21 to i8
	store i8 %22, i8* %19
	; AssignStmt
	%23 = load i64, i64* %3, align 8
	%24 = add i64 %23, 1
	store i64 %24, i64* %3
	; AssignStmt
	%25 = load i64, i64* %4, align 8
	store i64 %25, i64* %1
	br label %for.loop-1

for.done-3:
	; AssignStmt
	; SelectorExpr
	%26 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%27 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %26, i64 0
	%28 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %27, i64 0, i32 1
	store i64 0, i64* %28
	; ForStmt
	; AssignStmt
	%29 = load i64, i64* %3, align 8
	%30 = sub i64 %29, 1
	store i64 %30, i64* %3
	br label %for.loop-4

for.loop-4:
	%31 = load i64, i64* %3, align 8
	%32 = icmp sge i64 %31, 0
	%33 = zext i1 %32 to i8
	%34 = trunc i8 %33 to i1
	br i1 %34, label %for.body-5, label %for.done-6

for.body-5:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%35 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%36 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %35, i64 0
	%37 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %36, i64 0, i32 0
	; SelectorExpr
	%38 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%39 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %38, i64 0
	%40 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %39, i64 0, i32 1
	%41 = load i64, i64* %40, align 8
	%42 = trunc i64 %41 to i32
	%43 = getelementptr inbounds [384 x i8], [384 x i8]* %37, i64 0, i32 %42
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1f0, i64 0, i32 0), i64 61}, i64 72, i64 14, i64 %41, i64 384)
	; IndexExpr
	%44 = load i64, i64* %3, align 8
	%45 = trunc i64 %44 to i32
	%46 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i32 %45
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1f1, i64 0, i32 0), i64 61}, i64 72, i64 27, i64 %44, i64 64)
	%47 = load i8, i8* %46, align 1
	store i8 %47, i8* %43
	; AssignStmt
	; SelectorExpr
	%48 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%49 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %48, i64 0
	%50 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %49, i64 0, i32 1
	%51 = load i64, i64* %50, align 8
	%52 = add i64 %51, 1
	store i64 %52, i64* %50
	; AssignStmt
	%53 = load i64, i64* %3, align 8
	%54 = sub i64 %53, 1
	store i64 %54, i64* %3
	br label %for.loop-4

for.done-6:
	; AssignStmt
	; SelectorExpr
	%55 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%56 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %55, i64 0
	%57 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %56, i64 0, i32 2
	; SelectorExpr
	%58 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%59 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %58, i64 0
	%60 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %59, i64 0, i32 1
	%61 = load i64, i64* %60, align 8
	store i64 %61, i64* %57
	%62 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.trim(%decimal.Decimal* %62, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @decimal.shift_right(%decimal.Decimal* %a, i64 %k, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %k, i64* %1
	; r
	store i64 0, i64* %2
	; w
	store i64 0, i64* %3
	; n
	%10 = bitcast i64* %4 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 8) noinline
	store i64 zeroinitializer, i64* %4
	; ForStmt
	br label %for.loop-1

for.loop-1:
	%12 = load i64, i64* %4, align 8
	%13 = load i64, i64* %1, align 8
	%14 = lshr i64 %12, %13
	%15 = icmp eq i64 %14, 0
	%16 = zext i1 %15 to i8
	%17 = trunc i8 %16 to i1
	br i1 %17, label %for.body-2, label %for.done-10

for.body-2:
	; IfStmt
	%18 = load i64, i64* %2, align 8
	; SelectorExpr
	%19 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%20 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %19, i64 0
	%21 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %20, i64 0, i32 1
	%22 = load i64, i64* %21, align 8
	%23 = icmp sge i64 %18, %22
	%24 = zext i1 %23 to i8
	%25 = trunc i8 %24 to i1
	br i1 %25, label %if.then-3, label %if.done-9

if.then-3:
	; IfStmt
	%26 = load i64, i64* %4, align 8
	%27 = icmp eq i64 %26, 0
	%28 = zext i1 %27 to i8
	%29 = trunc i8 %28 to i1
	br i1 %29, label %if.then-4, label %if.done-5

if.then-4:
	; AssignStmt
	; SelectorExpr
	%30 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%31 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %30, i64 0
	%32 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %31, i64 0, i32 1
	store i64 0, i64* %32
	; ReturnStmt
	ret void

if.done-5:
	; ForStmt
	br label %for.loop-6

for.loop-6:
	%33 = load i64, i64* %4, align 8
	%34 = load i64, i64* %1, align 8
	%35 = lshr i64 %33, %34
	%36 = icmp eq i64 %35, 0
	%37 = zext i1 %36 to i8
	%38 = trunc i8 %37 to i1
	br i1 %38, label %for.body-7, label %for.done-8

for.body-7:
	; AssignStmt
	%39 = load i64, i64* %4, align 8
	%40 = mul i64 %39, 10
	store i64 %40, i64* %4
	; AssignStmt
	%41 = load i64, i64* %2, align 8
	%42 = add i64 %41, 1
	store i64 %42, i64* %2
	br label %for.loop-6

for.done-8:
	; break
	br label %for.done-10

if.done-9:
	; c
	; IndexExpr
	; SelectorExpr
	%43 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%44 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %43, i64 0
	%45 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %44, i64 0, i32 0
	%46 = load i64, i64* %2, align 8
	%47 = trunc i64 %46 to i32
	%48 = getelementptr inbounds [384 x i8], [384 x i8]* %45, i64 0, i32 %47
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1f2, i64 0, i32 0), i64 61}, i64 99, i64 22, i64 %46, i64 384)
	%49 = load i8, i8* %48, align 1
	%50 = zext i8 %49 to i64
	store i64 %50, i64* %5
	; AssignStmt
	%51 = load i64, i64* %4, align 8
	%52 = mul i64 %51, 10
	%53 = load i64, i64* %5, align 8
	%54 = add i64 %52, %53
	%55 = sub i64 %54, 48
	store i64 %55, i64* %4
	; AssignStmt
	%56 = load i64, i64* %2, align 8
	%57 = add i64 %56, 1
	store i64 %57, i64* %2
	br label %for.loop-1

for.done-10:
	; AssignStmt
	; SelectorExpr
	%58 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%59 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %58, i64 0
	%60 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %59, i64 0, i32 2
	%61 = load i64, i64* %2, align 8
	%62 = sub i64 %61, 1
	%63 = load i64, i64* %60, align 8
	%64 = sub i64 %63, %62
	store i64 %64, i64* %60
	; mask
	%65 = load i64, i64* %1, align 8
	%66 = shl i64 1, %65
	%67 = bitcast i64 %66 to i64
	%68 = sub i64 %67, 1
	%69 = bitcast i64 %68 to i64
	store i64 %69, i64* %6
	; ForStmt
	br label %for.loop-11

for.loop-11:
	%70 = load i64, i64* %2, align 8
	; SelectorExpr
	%71 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%72 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %71, i64 0
	%73 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %72, i64 0, i32 1
	%74 = load i64, i64* %73, align 8
	%75 = icmp slt i64 %70, %74
	%76 = zext i1 %75 to i8
	%77 = trunc i8 %76 to i1
	br i1 %77, label %for.body-12, label %for.done-13

for.body-12:
	; c
	; IndexExpr
	; SelectorExpr
	%78 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%79 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %78, i64 0
	%80 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %79, i64 0, i32 0
	%81 = load i64, i64* %2, align 8
	%82 = trunc i64 %81 to i32
	%83 = getelementptr inbounds [384 x i8], [384 x i8]* %80, i64 0, i32 %82
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1f3, i64 0, i32 0), i64 61}, i64 107, i64 22, i64 %81, i64 384)
	%84 = load i8, i8* %83, align 1
	%85 = zext i8 %84 to i64
	store i64 %85, i64* %7
	; dig
	%86 = load i64, i64* %4, align 8
	%87 = load i64, i64* %1, align 8
	%88 = lshr i64 %86, %87
	store i64 %88, i64* %8
	; AssignStmt
	%89 = load i64, i64* %6, align 8
	%90 = load i64, i64* %4, align 8
	%91 = and i64 %90, %89
	store i64 %91, i64* %4
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%92 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%93 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %92, i64 0
	%94 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %93, i64 0, i32 0
	%95 = load i64, i64* %3, align 8
	%96 = trunc i64 %95 to i32
	%97 = getelementptr inbounds [384 x i8], [384 x i8]* %94, i64 0, i32 %96
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1f4, i64 0, i32 0), i64 61}, i64 110, i64 12, i64 %95, i64 384)
	%98 = load i64, i64* %8, align 8
	%99 = add i64 48, %98
	%100 = trunc i64 %99 to i8
	store i8 %100, i8* %97
	; AssignStmt
	%101 = load i64, i64* %3, align 8
	%102 = add i64 %101, 1
	store i64 %102, i64* %3
	; AssignStmt
	%103 = load i64, i64* %4, align 8
	%104 = mul i64 %103, 10
	%105 = load i64, i64* %7, align 8
	%106 = add i64 %104, %105
	%107 = sub i64 %106, 48
	store i64 %107, i64* %4
	; AssignStmt
	%108 = load i64, i64* %2, align 8
	%109 = add i64 %108, 1
	store i64 %109, i64* %2
	br label %for.loop-11

for.done-13:
	; ForStmt
	br label %for.loop-14

for.loop-14:
	%110 = load i64, i64* %4, align 8
	%111 = icmp ugt i64 %110, 0
	%112 = zext i1 %111 to i8
	%113 = trunc i8 %112 to i1
	br i1 %113, label %for.body-15, label %for.done-21

for.body-15:
	; dig
	%114 = load i64, i64* %4, align 8
	%115 = load i64, i64* %1, align 8
	%116 = lshr i64 %114, %115
	store i64 %116, i64* %9
	; AssignStmt
	%117 = load i64, i64* %6, align 8
	%118 = load i64, i64* %4, align 8
	%119 = and i64 %118, %117
	store i64 %119, i64* %4
	; IfStmt
	%120 = load i64, i64* %3, align 8
	%121 = icmp slt i64 %120, 384
	%122 = zext i1 %121 to i8
	%123 = trunc i8 %122 to i1
	br i1 %123, label %if.then-16, label %if.else-17

if.then-16:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%124 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%125 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %124, i64 0
	%126 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %125, i64 0, i32 0
	%127 = load i64, i64* %3, align 8
	%128 = trunc i64 %127 to i32
	%129 = getelementptr inbounds [384 x i8], [384 x i8]* %126, i64 0, i32 %128
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1f5, i64 0, i32 0), i64 61}, i64 119, i64 13, i64 %127, i64 384)
	%130 = load i64, i64* %9, align 8
	%131 = add i64 48, %130
	%132 = trunc i64 %131 to i8
	store i8 %132, i8* %129
	; AssignStmt
	%133 = load i64, i64* %3, align 8
	%134 = add i64 %133, 1
	store i64 %134, i64* %3
	br label %if.done-20

if.else-17:
	; IfStmt
	%135 = load i64, i64* %9, align 8
	%136 = icmp ugt i64 %135, 0
	%137 = zext i1 %136 to i8
	%138 = trunc i8 %137 to i1
	br i1 %138, label %if.then-18, label %if.done-19

if.then-18:
	; AssignStmt
	; SelectorExpr
	%139 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%140 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %139, i64 0
	%141 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %140, i64 0, i32 4
	store i8 1, i8* %141
	br label %if.done-19

if.done-19:
	br label %if.done-20

if.done-20:
	; AssignStmt
	%142 = load i64, i64* %4, align 8
	%143 = mul i64 %142, 10
	store i64 %143, i64* %4
	br label %for.loop-14

for.done-21:
	; AssignStmt
	; SelectorExpr
	%144 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%145 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %144, i64 0
	%146 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %145, i64 0, i32 1
	%147 = load i64, i64* %3, align 8
	store i64 %147, i64* %146
	%148 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.trim(%decimal.Decimal* %148, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @decimal.shift_left(%decimal.Decimal* %a, i64 %k, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %k, i64* %1
	; delta
	%10 = load i64, i64* %1, align 8
	%11 = udiv i64 %10, 4
	%12 = bitcast i64 %11 to i64
	store i64 %12, i64* %2
	; r
	; SelectorExpr
	%13 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%14 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %13, i64 0
	%15 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %14, i64 0, i32 1
	%16 = load i64, i64* %15, align 8
	store i64 %16, i64* %3
	; w
	; SelectorExpr
	%17 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%18 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %17, i64 0
	%19 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %18, i64 0, i32 1
	%20 = load i64, i64* %19, align 8
	%21 = load i64, i64* %2, align 8
	%22 = add i64 %20, %21
	store i64 %22, i64* %4
	; n
	%23 = bitcast i64* %5 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 8) noinline
	store i64 zeroinitializer, i64* %5
	; ForStmt
	; AssignStmt
	%25 = load i64, i64* %3, align 8
	%26 = sub i64 %25, 1
	store i64 %26, i64* %3
	br label %for.loop-1

for.loop-1:
	%27 = load i64, i64* %3, align 8
	%28 = icmp sge i64 %27, 0
	%29 = zext i1 %28 to i8
	%30 = trunc i8 %29 to i1
	br i1 %30, label %for.body-2, label %for.done-8

for.body-2:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%31 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%32 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %31, i64 0
	%33 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %32, i64 0, i32 0
	%34 = load i64, i64* %3, align 8
	%35 = trunc i64 %34 to i32
	%36 = getelementptr inbounds [384 x i8], [384 x i8]* %33, i64 0, i32 %35
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1f6, i64 0, i32 0), i64 61}, i64 140, i64 23, i64 %34, i64 384)
	%37 = load i8, i8* %36, align 1
	%38 = zext i8 %37 to i64
	%39 = sub i64 %38, 48
	%40 = load i64, i64* %1, align 8
	%41 = shl i64 %39, %40
	%42 = load i64, i64* %5, align 8
	%43 = add i64 %42, %41
	store i64 %43, i64* %5
	; quo
	%44 = load i64, i64* %5, align 8
	%45 = udiv i64 %44, 10
	store i64 %45, i64* %6
	; rem
	%46 = load i64, i64* %5, align 8
	%47 = load i64, i64* %6, align 8
	%48 = mul i64 10, %47
	%49 = sub i64 %46, %48
	store i64 %49, i64* %7
	; AssignStmt
	%50 = load i64, i64* %4, align 8
	%51 = sub i64 %50, 1
	store i64 %51, i64* %4
	; IfStmt
	%52 = load i64, i64* %4, align 8
	%53 = icmp slt i64 %52, 384
	%54 = zext i1 %53 to i8
	%55 = trunc i8 %54 to i1
	br i1 %55, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%56 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%57 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %56, i64 0
	%58 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %57, i64 0, i32 0
	%59 = load i64, i64* %4, align 8
	%60 = trunc i64 %59 to i32
	%61 = getelementptr inbounds [384 x i8], [384 x i8]* %58, i64 0, i32 %60
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1f7, i64 0, i32 0), i64 61}, i64 145, i64 13, i64 %59, i64 384)
	%62 = load i64, i64* %7, align 8
	%63 = add i64 48, %62
	%64 = trunc i64 %63 to i8
	store i8 %64, i8* %61
	br label %if.done-7

if.else-4:
	; IfStmt
	%65 = load i64, i64* %7, align 8
	%66 = icmp ne i64 %65, 0
	%67 = zext i1 %66 to i8
	%68 = trunc i8 %67 to i1
	br i1 %68, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%69 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%70 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %69, i64 0
	%71 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %70, i64 0, i32 4
	store i8 1, i8* %71
	br label %if.done-6

if.done-6:
	br label %if.done-7

if.done-7:
	; AssignStmt
	%72 = load i64, i64* %6, align 8
	store i64 %72, i64* %5
	; AssignStmt
	%73 = load i64, i64* %3, align 8
	%74 = sub i64 %73, 1
	store i64 %74, i64* %3
	br label %for.loop-1

for.done-8:
	; ForStmt
	br label %for.loop-9

for.loop-9:
	%75 = load i64, i64* %5, align 8
	%76 = icmp ugt i64 %75, 0
	%77 = zext i1 %76 to i8
	%78 = trunc i8 %77 to i1
	br i1 %78, label %for.body-10, label %for.done-17

for.body-10:
	; quo
	%79 = load i64, i64* %5, align 8
	%80 = udiv i64 %79, 10
	store i64 %80, i64* %8
	; rem
	%81 = load i64, i64* %5, align 8
	%82 = load i64, i64* %8, align 8
	%83 = mul i64 10, %82
	%84 = sub i64 %81, %83
	store i64 %84, i64* %9
	; AssignStmt
	%85 = load i64, i64* %4, align 8
	%86 = sub i64 %85, 1
	store i64 %86, i64* %4
	; IfStmt
	%87 = load i64, i64* %4, align 8
	%88 = icmp sle i64 0, %87
	%89 = zext i1 %88 to i8
	%90 = trunc i8 %89 to i1
	br i1 %90, label %cmp.and-11, label %if.else-13

cmp.and-11:
	%91 = load i64, i64* %4, align 8
	%92 = icmp slt i64 %91, 384
	%93 = zext i1 %92 to i8
	%94 = trunc i8 %93 to i1
	br i1 %94, label %if.then-12, label %if.else-13

if.then-12:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%95 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%96 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %95, i64 0
	%97 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %96, i64 0, i32 0
	%98 = load i64, i64* %4, align 8
	%99 = trunc i64 %98 to i32
	%100 = getelementptr inbounds [384 x i8], [384 x i8]* %97, i64 0, i32 %99
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1f8, i64 0, i32 0), i64 61}, i64 157, i64 13, i64 %98, i64 384)
	%101 = load i64, i64* %9, align 8
	%102 = add i64 48, %101
	%103 = trunc i64 %102 to i8
	store i8 %103, i8* %100
	br label %if.done-16

if.else-13:
	; IfStmt
	%104 = load i64, i64* %9, align 8
	%105 = icmp ne i64 %104, 0
	%106 = zext i1 %105 to i8
	%107 = trunc i8 %106 to i1
	br i1 %107, label %if.then-14, label %if.done-15

if.then-14:
	; AssignStmt
	; SelectorExpr
	%108 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%109 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %108, i64 0
	%110 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %109, i64 0, i32 4
	store i8 1, i8* %110
	br label %if.done-15

if.done-15:
	br label %if.done-16

if.done-16:
	; AssignStmt
	%111 = load i64, i64* %8, align 8
	store i64 %111, i64* %5
	br label %for.loop-9

for.done-17:
	; AssignStmt
	; SelectorExpr
	%112 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%113 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %112, i64 0
	%114 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %113, i64 0, i32 1
	%115 = load i64, i64* %2, align 8
	%116 = load i64, i64* %114, align 8
	%117 = add i64 %116, %115
	store i64 %117, i64* %114
	; AssignStmt
	; SelectorExpr
	%118 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%119 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %118, i64 0
	%120 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %119, i64 0, i32 1
	; min
	; SelectorExpr
	%121 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%122 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %121, i64 0
	%123 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %122, i64 0, i32 1
	%124 = load i64, i64* %123, align 8
	%125 = icmp slt i64 %124, 384
	%126 = select i1 %125, i64 %124, i64 384
	store i64 %126, i64* %120
	; AssignStmt
	; SelectorExpr
	%127 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%128 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %127, i64 0
	%129 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %128, i64 0, i32 2
	%130 = load i64, i64* %2, align 8
	%131 = load i64, i64* %129, align 8
	%132 = add i64 %131, %130
	store i64 %132, i64* %129
	%133 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.trim(%decimal.Decimal* %133, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @decimal.shift(%decimal.Decimal* %a, i64 %k, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %k, i64* %1
	; SwitchStmt
	; SelectorExpr
	%2 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%3 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %2, i64 0
	%4 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %3, i64 0, i32 1
	%5 = load i64, i64* %4, align 8
	%6 = icmp eq i64 %5, 0
	%7 = zext i1 %6 to i8
	%8 = icmp eq i8 1, %7
	br i1 %8, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%9 = load i64, i64* %1, align 8
	%10 = icmp sgt i64 %9, 0
	%11 = zext i1 %10 to i8
	%12 = icmp eq i8 1, %11
	br i1 %12, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	br label %switch.done-13

switch.case.next-3:
	%13 = load i64, i64* %1, align 8
	%14 = icmp slt i64 %13, 0
	%15 = zext i1 %14 to i8
	%16 = icmp eq i8 1, %15
	br i1 %16, label %switch.fall.body-9, label %switch.case.next-8

switch.fall.body-4:
	; ForStmt
	br label %for.loop-5

for.loop-5:
	%17 = load i64, i64* %1, align 8
	%18 = icmp sgt i64 %17, 60
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %for.body-6, label %for.done-7

for.body-6:
	%21 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.shift_left(%decimal.Decimal* %21, i64 60, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	%22 = load i64, i64* %1, align 8
	%23 = sub i64 %22, 60
	store i64 %23, i64* %1
	br label %for.loop-5

for.done-7:
	%24 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%25 = load i64, i64* %1, align 8
	%26 = bitcast i64 %25 to i64
	call void @decimal.shift_left(%decimal.Decimal* %24, i64 %26, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-13

switch.case.next-8:
	br label %switch.done-13

switch.fall.body-9:
	; ForStmt
	br label %for.loop-10

for.loop-10:
	%27 = load i64, i64* %1, align 8
	%28 = icmp slt i64 %27, -60
	%29 = zext i1 %28 to i8
	%30 = trunc i8 %29 to i1
	br i1 %30, label %for.body-11, label %for.done-12

for.body-11:
	%31 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.shift_right(%decimal.Decimal* %31, i64 60, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	%32 = load i64, i64* %1, align 8
	%33 = add i64 %32, 60
	store i64 %33, i64* %1
	br label %for.loop-10

for.done-12:
	%34 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%35 = load i64, i64* %1, align 8
	%36 = sub i64 0, %35
	%37 = bitcast i64 %36 to i64
	call void @decimal.shift_right(%decimal.Decimal* %34, i64 %37, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %switch.done-13

switch.done-13:
	ret void
}

define i8 @decimal.can_round_up(%decimal.Decimal* %a, i64 %nd, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %nd, i64* %1
	; IfStmt
	%2 = load i64, i64* %1, align 8
	%3 = icmp slt i64 %2, 0
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%6 = load i64, i64* %1, align 8
	; SelectorExpr
	%7 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%8 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %7, i64 0
	%9 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %8, i64 0, i32 1
	%10 = load i64, i64* %9, align 8
	%11 = icmp sge i64 %6, %10
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret i8 0

if.done-3:
	; IfStmt
	; IndexExpr
	; SelectorExpr
	%14 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%15 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %14, i64 0
	%16 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %15, i64 0, i32 0
	%17 = load i64, i64* %1, align 8
	%18 = trunc i64 %17 to i32
	%19 = getelementptr inbounds [384 x i8], [384 x i8]* %16, i64 0, i32 %18
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1f9, i64 0, i32 0), i64 61}, i64 196, i64 14, i64 %17, i64 384)
	%20 = load i8, i8* %19, align 1
	%21 = icmp eq i8 %20, 53
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %cmp.and-4, label %if.done-10

cmp.and-4:
	%24 = load i64, i64* %1, align 8
	%25 = add i64 %24, 1
	; SelectorExpr
	%26 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%27 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %26, i64 0
	%28 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %27, i64 0, i32 1
	%29 = load i64, i64* %28, align 8
	%30 = icmp eq i64 %25, %29
	%31 = zext i1 %30 to i8
	%32 = trunc i8 %31 to i1
	br i1 %32, label %if.then-5, label %if.done-10

if.then-5:
	; IfStmt
	; SelectorExpr
	%33 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%34 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %33, i64 0
	%35 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %34, i64 0, i32 4
	%36 = load i8, i8* %35, align 1
	%37 = trunc i8 %36 to i1
	br i1 %37, label %if.then-6, label %if.done-7

if.then-6:
	; ReturnStmt
	ret i8 1

if.done-7:
	; ReturnStmt
	%38 = load i64, i64* %1, align 8
	%39 = icmp sgt i64 %38, 0
	%40 = zext i1 %39 to i8
	%41 = load i64, i64* %1, align 8
	%42 = icmp sgt i64 %41, 0
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	br i1 %44, label %logical.cmp.rhs-8, label %logical.cmp.done-9

logical.cmp.rhs-8:
	; IndexExpr
	; SelectorExpr
	%45 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%46 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %45, i64 0
	%47 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %46, i64 0, i32 0
	%48 = load i64, i64* %1, align 8
	%49 = sub i64 %48, 1
	%50 = trunc i64 %49 to i32
	%51 = getelementptr inbounds [384 x i8], [384 x i8]* %47, i64 0, i32 %50
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1fa, i64 0, i32 0), i64 61}, i64 198, i64 30, i64 %49, i64 384)
	%52 = load i8, i8* %51, align 1
	%53 = sub i8 %52, 48
	%54 = urem i8 %53, 2
	%55 = icmp ne i8 %54, 0
	%56 = zext i1 %55 to i8
	br label %logical.cmp.done-9

logical.cmp.done-9:
	%57 = phi i8 [ 0, %if.done-7 ], [ %56, %logical.cmp.rhs-8 ]
	ret i8 %57

if.done-10:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%58 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%59 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %58, i64 0
	%60 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %59, i64 0, i32 0
	%61 = load i64, i64* %1, align 8
	%62 = trunc i64 %61 to i32
	%63 = getelementptr inbounds [384 x i8], [384 x i8]* %60, i64 0, i32 %62
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1fb, i64 0, i32 0), i64 61}, i64 201, i64 18, i64 %61, i64 384)
	%64 = load i8, i8* %63, align 1
	%65 = icmp uge i8 %64, 53
	%66 = zext i1 %65 to i8
	ret i8 %66
}

define void @decimal.round(%decimal.Decimal* %a, i64 %nd, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %nd, i64* %1
	; IfStmt
	%2 = load i64, i64* %1, align 8
	%3 = icmp slt i64 %2, 0
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%6 = load i64, i64* %1, align 8
	; SelectorExpr
	%7 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%8 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %7, i64 0
	%9 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %8, i64 0, i32 1
	%10 = load i64, i64* %9, align 8
	%11 = icmp sge i64 %6, %10
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	; IfStmt
	%14 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%15 = load i64, i64* %1, align 8
	%16 = call i8 @decimal.can_round_up(%decimal.Decimal* %14, i64 %15, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%17 = trunc i8 %16 to i1
	br i1 %17, label %if.then-4, label %if.else-5

if.then-4:
	%18 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%19 = load i64, i64* %1, align 8
	call void @decimal.round_up(%decimal.Decimal* %18, i64 %19, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-6

if.else-5:
	%20 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%21 = load i64, i64* %1, align 8
	call void @decimal.round_down(%decimal.Decimal* %20, i64 %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-6

if.done-6:
	ret void
}

define void @decimal.round_up(%decimal.Decimal* %a, i64 %nd, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i8, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %nd, i64* %1
	; IfStmt
	%4 = load i64, i64* %1, align 8
	%5 = icmp slt i64 %4, 0
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%8 = load i64, i64* %1, align 8
	; SelectorExpr
	%9 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%10 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %9, i64 0
	%11 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %10, i64 0, i32 1
	%12 = load i64, i64* %11, align 8
	%13 = icmp sge i64 %8, %12
	%14 = zext i1 %13 to i8
	%15 = trunc i8 %14 to i1
	br i1 %15, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	; ForStmt
	; i
	%16 = load i64, i64* %1, align 8
	%17 = sub i64 %16, 1
	store i64 %17, i64* %2
	br label %for.loop-4

for.loop-4:
	%18 = load i64, i64* %2, align 8
	%19 = icmp sge i64 %18, 0
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %for.body-5, label %for.done-8

for.body-5:
	; IfStmt
	; c
	; IndexExpr
	; SelectorExpr
	%22 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%23 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %22, i64 0
	%24 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %23, i64 0, i32 0
	%25 = load i64, i64* %2, align 8
	%26 = trunc i64 %25 to i32
	%27 = getelementptr inbounds [384 x i8], [384 x i8]* %24, i64 0, i32 %26
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1fc, i64 0, i32 0), i64 61}, i64 217, i64 20, i64 %25, i64 384)
	%28 = load i8, i8* %27, align 1
	store i8 %28, i8* %3
	%29 = load i8, i8* %3, align 1
	%30 = icmp ult i8 %29, 57
	%31 = zext i1 %30 to i8
	%32 = trunc i8 %31 to i1
	br i1 %32, label %if.then-6, label %if.done-7

if.then-6:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%33 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%34 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %33, i64 0
	%35 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %34, i64 0, i32 0
	%36 = load i64, i64* %2, align 8
	%37 = trunc i64 %36 to i32
	%38 = getelementptr inbounds [384 x i8], [384 x i8]* %35, i64 0, i32 %37
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([62 x i8], [62 x i8]* @str$1fd, i64 0, i32 0), i64 61}, i64 218, i64 13, i64 %36, i64 384)
	%39 = load i8, i8* %38, align 1
	%40 = add i8 %39, 1
	store i8 %40, i8* %38
	; AssignStmt
	; SelectorExpr
	%41 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%42 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %41, i64 0
	%43 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %42, i64 0, i32 1
	%44 = load i64, i64* %2, align 8
	%45 = add i64 %44, 1
	store i64 %45, i64* %43
	; ReturnStmt
	ret void

if.done-7:
	; AssignStmt
	%46 = load i64, i64* %2, align 8
	%47 = sub i64 %46, 1
	store i64 %47, i64* %2
	br label %for.loop-4

for.done-8:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%48 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%49 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %48, i64 0
	%50 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %49, i64 0, i32 0
	%51 = getelementptr inbounds [384 x i8], [384 x i8]* %50, i64 0, i32 0
	store i8 49, i8* %51
	; AssignStmt
	; SelectorExpr
	%52 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%53 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %52, i64 0
	%54 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %53, i64 0, i32 1
	store i64 1, i64* %54
	; AssignStmt
	; SelectorExpr
	%55 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%56 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %55, i64 0
	%57 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %56, i64 0, i32 2
	%58 = load i64, i64* %57, align 8
	%59 = add i64 %58, 1
	store i64 %59, i64* %57
	ret void
}

define void @decimal.round_down(%decimal.Decimal* %a, i64 %nd, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	store %decimal.Decimal* %a, %decimal.Decimal** %0
	store i64 %nd, i64* %1
	; IfStmt
	%2 = load i64, i64* %1, align 8
	%3 = icmp slt i64 %2, 0
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%6 = load i64, i64* %1, align 8
	; SelectorExpr
	%7 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%8 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %7, i64 0
	%9 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %8, i64 0, i32 1
	%10 = load i64, i64* %9, align 8
	%11 = icmp sge i64 %6, %10
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	; AssignStmt
	; SelectorExpr
	%14 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%15 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %14, i64 0
	%16 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %15, i64 0, i32 1
	%17 = load i64, i64* %1, align 8
	store i64 %17, i64* %16
	%18 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.trim(%decimal.Decimal* %18, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define {%lexer.Token, i8} @lexer.get_next_token(%lexer.Lexer* %lexer, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %lexer.Lexer*, align 16
	%1 = alloca {%lexer.Token, i8}, align 16
	%2 = alloca i8, align 16
	%3 = alloca {%lexer.Token, i8}, align 16
	%4 = alloca %lexer.Token, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i32, align 16
	%8 = alloca %..string, align 16
	%9 = alloca %..any, align 16
	%10 = alloca {%..any*, i64}, align 16
	%11 = alloca [1 x %..any], align 16
	%12 = alloca {%..any*, i64}, align 16
	%13 = alloca %runtime.Source_Code_Location, align 16
	%14 = alloca {%lexer.Token, i8}, align 16
	%15 = alloca i64, align 16
	%16 = alloca i8, align 16
	%17 = alloca %..string, align 16
	%18 = alloca %..any, align 16
	%19 = alloca {%..any*, i64}, align 16
	%20 = alloca [1 x %..any], align 16
	%21 = alloca {%..any*, i64}, align 16
	%22 = alloca %runtime.Source_Code_Location, align 16
	%23 = alloca {%lexer.Token, i8}, align 16
	%24 = alloca %..string, align 16
	%25 = alloca %..string, align 16
	%26 = alloca %lexer.Token, align 16
	%27 = alloca %lexer.Token_String, align 16
	%28 = alloca {[0 x <8 x i8>], [32 x i8], i8}, align 16
	%29 = alloca %lexer.Token, align 16
	%30 = alloca %..string, align 16
	%31 = alloca %lexer.Token_Symbol, align 16
	%32 = alloca {[0 x <8 x i8>], [32 x i8], i8}, align 16
	%33 = alloca i64, align 16
	%34 = alloca %..string, align 16
	%35 = alloca %..string, align 16
	%36 = alloca %lexer.Token, align 16
	%37 = alloca %lexer.Token_Identifier, align 16
	%38 = alloca {[0 x <8 x i8>], [32 x i8], i8}, align 16
	%39 = alloca i64, align 16
	%40 = alloca i8, align 16
	%41 = alloca %runtime.Source_Code_Location, align 16
	%42 = alloca %..string, align 16
	%43 = alloca %..string, align 16
	%44 = alloca i64, align 16
	%45 = alloca i64, align 16
	%46 = alloca double, align 16
	%47 = alloca %lexer.Token, align 16
	%48 = alloca %lexer.Token_Number, align 16
	%49 = alloca {[0 x <8 x i8>], [32 x i8], i8}, align 16
	%50 = alloca %..string, align 16
	%51 = alloca %..any, align 16
	%52 = alloca %..any, align 16
	%53 = alloca i32, align 16
	%54 = alloca %..string, align 16
	%55 = alloca %..any, align 16
	%56 = alloca %..any, align 16
	%57 = alloca %..string, align 16
	%58 = alloca %..any, align 16
	%59 = alloca %..any, align 16
	%60 = alloca {%..any*, i64}, align 16
	%61 = alloca [6 x %..any], align 16
	%62 = alloca {%..any*, i64}, align 16
	%63 = alloca %runtime.Source_Code_Location, align 16
	%64 = alloca %runtime.Source_Code_Location, align 16
	%65 = alloca {%lexer.Token, i8}, align 16
	store %lexer.Lexer* %lexer, %lexer.Lexer** %0
	%66 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%67 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%68 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %67, i64 0
	%69 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%72 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %71, i64 0
	%73 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %72, i64 0, i32 0
	%74 = load %..string, %..string* %73, align 8
	%75 = extractvalue %..string %74, 1
	%76 = icmp sge i64 %70, %75
	%77 = zext i1 %76 to i8
	%78 = trunc i8 %77 to i1
	br i1 %78, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%79 = bitcast {%lexer.Token, i8}* %1 to %..rawptr
	%80 = call %..rawptr @mem.zero(%..rawptr %79, i64 64) noinline
	store {%lexer.Token, i8} zeroinitializer, {%lexer.Token, i8}* %1
	%81 = getelementptr inbounds {%lexer.Token, i8}, {%lexer.Token, i8}* %1, i64 0, i32 0
	store %lexer.Token zeroinitializer, %lexer.Token* %81
	%82 = getelementptr inbounds {%lexer.Token, i8}, {%lexer.Token, i8}* %1, i64 0, i32 1
	store i8 0, i8* %82
	%83 = load {%lexer.Token, i8}, {%lexer.Token, i8}* %1, align 8
	ret {%lexer.Token, i8} %83

if.done-2:
	; had_whitespace_before_token
	store i8 0, i8* %2
	; ForStmt
	br label %for.loop-3

for.loop-3:
	; IndexExpr
	%84 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%85 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %84, i64 0
	%86 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %85, i64 0, i32 0
	%87 = load %..string, %..string* %86, align 8
	%88 = extractvalue %..string %87, 0
	%89 = extractvalue %..string %87, 1
	%90 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%91 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %90, i64 0
	%92 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %91, i64 0, i32 1
	%93 = load i64, i64* %92, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$1fe, i64 0, i32 0), i64 68}, i64 83, i64 32, i64 %93, i64 %89)
	%94 = getelementptr inbounds i8, i8* %88, i64 %93
	%95 = load i8, i8* %94, align 1
	%96 = call i8 @lexer._is_whitespace(i8 %95, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%97 = trunc i8 %96 to i1
	br i1 %97, label %for.body-4, label %for.done-7

for.body-4:
	; AssignStmt
	store i8 1, i8* %2
	; IfStmt
	%98 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%99 = call i8 @lexer._inc(%lexer.Lexer* %98, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%100 = trunc i8 %99 to i1
	br i1 %100, label %if.done-6, label %if.then-5

if.then-5:
	; ReturnStmt
	%101 = bitcast {%lexer.Token, i8}* %3 to %..rawptr
	%102 = call %..rawptr @mem.zero(%..rawptr %101, i64 64) noinline
	store {%lexer.Token, i8} zeroinitializer, {%lexer.Token, i8}* %3
	%103 = getelementptr inbounds {%lexer.Token, i8}, {%lexer.Token, i8}* %3, i64 0, i32 0
	store %lexer.Token zeroinitializer, %lexer.Token* %103
	%104 = getelementptr inbounds {%lexer.Token, i8}, {%lexer.Token, i8}* %3, i64 0, i32 1
	store i8 0, i8* %104
	%105 = load {%lexer.Token, i8}, {%lexer.Token, i8}* %3, align 8
	ret {%lexer.Token, i8} %105

if.done-6:
	br label %for.loop-3

for.done-7:
	; token
	%106 = bitcast %lexer.Token* %4 to %..rawptr
	%107 = call %..rawptr @mem.zero(%..rawptr %106, i64 56) noinline
	store %lexer.Token zeroinitializer, %lexer.Token* %4
	; token_start_char
	%108 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%109 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %108, i64 0
	%110 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %109, i64 0, i32 2
	%111 = load i64, i64* %110, align 8
	store i64 %111, i64* %5
	; token_start_line
	%112 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%113 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %112, i64 0
	%114 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %113, i64 0, i32 3
	%115 = load i64, i64* %114, align 8
	store i64 %115, i64* %6
	; r
	; IndexExpr
	%116 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%117 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %116, i64 0
	%118 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %117, i64 0, i32 0
	%119 = load %..string, %..string* %118, align 8
	%120 = extractvalue %..string %119, 0
	%121 = extractvalue %..string %119, 1
	%122 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%123 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %122, i64 0
	%124 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %123, i64 0, i32 1
	%125 = load i64, i64* %124, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$1ff, i64 0, i32 0), i64 68}, i64 92, i64 29, i64 %125, i64 %121)
	%126 = getelementptr inbounds i8, i8* %120, i64 %125
	%127 = load i8, i8* %126, align 1
	%128 = zext i8 %127 to i32
	store i32 %128, i32* %7
	; SwitchStmt
	%129 = load i32, i32* %7, align 4
	%130 = icmp eq i32 %129, 34
	br i1 %130, label %switch.case.body-9, label %switch.case.next-8

switch.case.next-8:
	%131 = icmp sle i32 33, %129
	%132 = icmp sle i32 %129, 47
	%133 = zext i1 %131 to i8
	%134 = zext i1 %132 to i8
	%135 = and i8 %133, %134
	%136 = trunc i8 %135 to i1
	br i1 %136, label %switch.fall.body-22, label %switch.case.next-18

switch.case.body-9:
	; IfStmt
	%137 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%138 = call i8 @lexer._inc(%lexer.Lexer* %137, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%139 = trunc i8 %138 to i1
	br i1 %139, label %if.done-11, label %if.then-10

if.then-10:
	; SelectorExpr
	%140 = bitcast %..string* %8 to %..rawptr
	%141 = call %..rawptr @mem.zero(%..rawptr %140, i64 16) noinline
	store %..string zeroinitializer, %..string* %8
	store %..string {i8* getelementptr inbounds ([31 x i8], [31 x i8]* @str$200, i64 0, i32 0), i64 30}, %..string* %8
	%142 = load %..string, %..string* %8, align 8
	%143 = bitcast %..any* %9 to %..rawptr
	%144 = call %..rawptr @mem.zero(%..rawptr %143, i64 16) noinline
	store %..any zeroinitializer, %..any* %9
	%145 = bitcast %..string* %8 to %..rawptr
	%146 = getelementptr inbounds %..any, %..any* %9, i64 0, i32 0
	store %..rawptr %145, %..rawptr* %146
	%147 = getelementptr inbounds %..any, %..any* %9, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %147
	%148 = load %..any, %..any* %9, align 8
	; variadic call argument generation
	%149 = bitcast {%..any*, i64}* %10 to %..rawptr
	%150 = call %..rawptr @mem.zero(%..rawptr %149, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %10
	%151 = bitcast [1 x %..any]* %11 to %..rawptr
	%152 = call %..rawptr @mem.zero(%..rawptr %151, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %11
	%153 = getelementptr inbounds [1 x %..any], [1 x %..any]* %11, i64 0, i32 0
	store %..any %148, %..any* %153
	%154 = getelementptr inbounds [1 x %..any], [1 x %..any]* %11, i64 0, i32 0
	%155 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %10, i64 0, i32 0
	store %..any* %154, %..any** %155
	%156 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %10, i64 0, i32 1
	store i64 1, i64* %156
	%157 = load {%..any*, i64}, {%..any*, i64}* %10, align 8
	%158 = bitcast {%..any*, i64}* %12 to %..rawptr
	%159 = call %..rawptr @mem.zero(%..rawptr %158, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %12
	store {%..any*, i64} %157, {%..any*, i64}* %12
	%160 = call %..string @fmt.tprint({%..any*, i64}* %12, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%161 = bitcast %runtime.Source_Code_Location* %13 to %..rawptr
	%162 = call %..rawptr @mem.zero(%..rawptr %161, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %13
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$201, i64 0, i32 0), i64 68}, i64 96, i64 5, %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$202, i64 0, i32 0), i64 14}}, %runtime.Source_Code_Location* %13
	call void @runtime.panic(%..string %160, %runtime.Source_Code_Location* %13) noreturn
	; ReturnStmt
	%163 = bitcast {%lexer.Token, i8}* %14 to %..rawptr
	%164 = call %..rawptr @mem.zero(%..rawptr %163, i64 64) noinline
	store {%lexer.Token, i8} zeroinitializer, {%lexer.Token, i8}* %14
	%165 = getelementptr inbounds {%lexer.Token, i8}, {%lexer.Token, i8}* %14, i64 0, i32 0
	store %lexer.Token zeroinitializer, %lexer.Token* %165
	%166 = getelementptr inbounds {%lexer.Token, i8}, {%lexer.Token, i8}* %14, i64 0, i32 1
	store i8 0, i8* %166
	%167 = load {%lexer.Token, i8}, {%lexer.Token, i8}* %14, align 8
	ret {%lexer.Token, i8} %167

if.done-11:
	; start
	%168 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%169 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %168, i64 0
	%170 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %169, i64 0, i32 1
	%171 = load i64, i64* %170, align 8
	store i64 %171, i64* %15
	; escaped
	store i8 0, i8* %16
	; ForStmt
	br label %for.loop-12

for.loop-12:
	; IndexExpr
	%172 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%173 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %172, i64 0
	%174 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %173, i64 0, i32 0
	%175 = load %..string, %..string* %174, align 8
	%176 = extractvalue %..string %175, 0
	%177 = extractvalue %..string %175, 1
	%178 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%179 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %178, i64 0
	%180 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %179, i64 0, i32 1
	%181 = load i64, i64* %180, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$203, i64 0, i32 0), i64 68}, i64 101, i64 19, i64 %181, i64 %177)
	%182 = getelementptr inbounds i8, i8* %176, i64 %181
	%183 = load i8, i8* %182, align 1
	%184 = icmp ne i8 %183, 34
	%185 = zext i1 %184 to i8
	%186 = trunc i8 %185 to i1
	br i1 %186, label %for.body-14, label %cmp.or-13

cmp.or-13:
	%187 = load i8, i8* %16, align 1
	%188 = trunc i8 %187 to i1
	br i1 %188, label %for.body-14, label %for.done-17

for.body-14:
	; AssignStmt
	; IndexExpr
	%189 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%190 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %189, i64 0
	%191 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %190, i64 0, i32 0
	%192 = load %..string, %..string* %191, align 8
	%193 = extractvalue %..string %192, 0
	%194 = extractvalue %..string %192, 1
	%195 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%196 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %195, i64 0
	%197 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %196, i64 0, i32 1
	%198 = load i64, i64* %197, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$204, i64 0, i32 0), i64 68}, i64 102, i64 26, i64 %198, i64 %194)
	%199 = getelementptr inbounds i8, i8* %193, i64 %198
	%200 = load i8, i8* %199, align 1
	%201 = icmp eq i8 %200, 92
	%202 = zext i1 %201 to i8
	store i8 %202, i8* %16
	; IfStmt
	%203 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%204 = call i8 @lexer._inc(%lexer.Lexer* %203, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%205 = trunc i8 %204 to i1
	br i1 %205, label %if.done-16, label %if.then-15

if.then-15:
	; SelectorExpr
	%206 = bitcast %..string* %17 to %..rawptr
	%207 = call %..rawptr @mem.zero(%..rawptr %206, i64 16) noinline
	store %..string zeroinitializer, %..string* %17
	store %..string {i8* getelementptr inbounds ([31 x i8], [31 x i8]* @str$205, i64 0, i32 0), i64 30}, %..string* %17
	%208 = load %..string, %..string* %17, align 8
	%209 = bitcast %..any* %18 to %..rawptr
	%210 = call %..rawptr @mem.zero(%..rawptr %209, i64 16) noinline
	store %..any zeroinitializer, %..any* %18
	%211 = bitcast %..string* %17 to %..rawptr
	%212 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 0
	store %..rawptr %211, %..rawptr* %212
	%213 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %213
	%214 = load %..any, %..any* %18, align 8
	; variadic call argument generation
	%215 = bitcast {%..any*, i64}* %19 to %..rawptr
	%216 = call %..rawptr @mem.zero(%..rawptr %215, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %19
	%217 = bitcast [1 x %..any]* %20 to %..rawptr
	%218 = call %..rawptr @mem.zero(%..rawptr %217, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %20
	%219 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	store %..any %214, %..any* %219
	%220 = getelementptr inbounds [1 x %..any], [1 x %..any]* %20, i64 0, i32 0
	%221 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 0
	store %..any* %220, %..any** %221
	%222 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %19, i64 0, i32 1
	store i64 1, i64* %222
	%223 = load {%..any*, i64}, {%..any*, i64}* %19, align 8
	%224 = bitcast {%..any*, i64}* %21 to %..rawptr
	%225 = call %..rawptr @mem.zero(%..rawptr %224, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %21
	store {%..any*, i64} %223, {%..any*, i64}* %21
	%226 = call %..string @fmt.tprint({%..any*, i64}* %21, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%227 = bitcast %runtime.Source_Code_Location* %22 to %..rawptr
	%228 = call %..rawptr @mem.zero(%..rawptr %227, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %22
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$206, i64 0, i32 0), i64 68}, i64 105, i64 6, %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$207, i64 0, i32 0), i64 14}}, %runtime.Source_Code_Location* %22
	call void @runtime.panic(%..string %226, %runtime.Source_Code_Location* %22) noreturn
	; ReturnStmt
	%229 = bitcast {%lexer.Token, i8}* %23 to %..rawptr
	%230 = call %..rawptr @mem.zero(%..rawptr %229, i64 64) noinline
	store {%lexer.Token, i8} zeroinitializer, {%lexer.Token, i8}* %23
	%231 = getelementptr inbounds {%lexer.Token, i8}, {%lexer.Token, i8}* %23, i64 0, i32 0
	store %lexer.Token zeroinitializer, %lexer.Token* %231
	%232 = getelementptr inbounds {%lexer.Token, i8}, {%lexer.Token, i8}* %23, i64 0, i32 1
	store i8 0, i8* %232
	%233 = load {%lexer.Token, i8}, {%lexer.Token, i8}* %23, align 8
	ret {%lexer.Token, i8} %233

if.done-16:
	br label %for.loop-12

for.done-17:
	; token_text
	; SliceExpr
	%234 = load i64, i64* %15, align 8
	%235 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%236 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %235, i64 0
	%237 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %236, i64 0, i32 1
	%238 = load i64, i64* %237, align 8
	%239 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%240 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %239, i64 0
	%241 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %240, i64 0, i32 0
	%242 = load %..string, %..string* %241, align 8
	%243 = extractvalue %..string %242, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$208, i64 0, i32 0), i64 68}, i64 110, i64 28, i64 %234, i64 %238, i64 %243)
	%244 = extractvalue %..string %242, 0
	%245 = getelementptr inbounds i8, i8* %244, i64 %234
	%246 = sub i64 %238, %234
	%247 = bitcast %..string* %25 to %..rawptr
	%248 = call %..rawptr @mem.zero(%..rawptr %247, i64 16) noinline
	store %..string zeroinitializer, %..string* %25
	%249 = getelementptr inbounds %..string, %..string* %25, i64 0, i32 0
	store i8* %245, i8** %249
	%250 = getelementptr inbounds %..string, %..string* %25, i64 0, i32 1
	store i64 %246, i64* %250
	%251 = load %..string, %..string* %25, align 8
	store %..string %251, %..string* %24
	; AssignStmt
	; CompoundLit
	%252 = bitcast %lexer.Token* %26 to %..rawptr
	%253 = call %..rawptr @mem.zero(%..rawptr %252, i64 56) noinline
	store %lexer.Token zeroinitializer, %lexer.Token* %26
	store %lexer.Token {%..string zeroinitializer, {[0 x <8 x i8>], [32 x i8], i8} zeroinitializer}, %lexer.Token* %26
	%254 = load %..string, %..string* %24, align 8
	%255 = getelementptr inbounds %lexer.Token, %lexer.Token* %26, i64 0, i32 0
	store %..string %254, %..string* %255
	; CompoundLit
	%256 = bitcast %lexer.Token_String* %27 to %..rawptr
	%257 = call %..rawptr @mem.zero(%..rawptr %256, i64 16) noinline
	store %lexer.Token_String zeroinitializer, %lexer.Token_String* %27
	store %lexer.Token_String {%..string zeroinitializer}, %lexer.Token_String* %27
	%258 = load %..string, %..string* %24, align 8
	%259 = getelementptr inbounds %lexer.Token_String, %lexer.Token_String* %27, i64 0, i32 0
	store %..string %258, %..string* %259
	%260 = load %lexer.Token_String, %lexer.Token_String* %27, align 8
	; union - child to parent
	%261 = bitcast {[0 x <8 x i8>], [32 x i8], i8}* %28 to %..rawptr
	%262 = call %..rawptr @mem.zero(%..rawptr %261, i64 40) noinline
	store {[0 x <8 x i8>], [32 x i8], i8} zeroinitializer, {[0 x <8 x i8>], [32 x i8], i8}* %28
	%263 = bitcast {[0 x <8 x i8>], [32 x i8], i8}* %28 to %lexer.Token_String*
	store %lexer.Token_String %260, %lexer.Token_String* %263
	%264 = getelementptr inbounds {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %28, i64 0, i32 2 ; UnionTagPtr
	store i8 3, i8* %264
	%265 = load {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %28, align 8
	%266 = getelementptr inbounds %lexer.Token, %lexer.Token* %26, i64 0, i32 1
	store {[0 x <8 x i8>], [32 x i8], i8} %265, {[0 x <8 x i8>], [32 x i8], i8}* %266
	%267 = load %lexer.Token, %lexer.Token* %26, align 8
	store %lexer.Token %267, %lexer.Token* %4
	br label %switch.done-50

switch.case.next-18:
	%268 = icmp sle i32 58, %129
	%269 = icmp sle i32 %129, 64
	%270 = zext i1 %268 to i8
	%271 = zext i1 %269 to i8
	%272 = and i8 %270, %271
	%273 = trunc i8 %272 to i1
	br i1 %273, label %switch.fall.body-22, label %switch.case.next-19

switch.case.next-19:
	%274 = icmp sle i32 91, %129
	%275 = icmp sle i32 %129, 96
	%276 = zext i1 %274 to i8
	%277 = zext i1 %275 to i8
	%278 = and i8 %276, %277
	%279 = trunc i8 %278 to i1
	br i1 %279, label %switch.fall.body-22, label %switch.case.next-20

switch.case.next-20:
	%280 = icmp sle i32 123, %129
	%281 = icmp sle i32 %129, 126
	%282 = zext i1 %280 to i8
	%283 = zext i1 %281 to i8
	%284 = and i8 %282, %283
	%285 = trunc i8 %284 to i1
	br i1 %285, label %switch.fall.body-22, label %switch.case.next-21

switch.case.next-21:
	%286 = icmp sle i32 65, %129
	%287 = icmp sle i32 %129, 90
	%288 = zext i1 %286 to i8
	%289 = zext i1 %287 to i8
	%290 = and i8 %288, %289
	%291 = trunc i8 %290 to i1
	br i1 %291, label %switch.fall.body-26, label %switch.case.next-23

switch.fall.body-22:
	; AssignStmt
	; CompoundLit
	%292 = bitcast %lexer.Token* %29 to %..rawptr
	%293 = call %..rawptr @mem.zero(%..rawptr %292, i64 56) noinline
	store %lexer.Token zeroinitializer, %lexer.Token* %29
	store %lexer.Token {%..string zeroinitializer, {[0 x <8 x i8>], [32 x i8], i8} zeroinitializer}, %lexer.Token* %29
	; SliceExpr
	%294 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%295 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %294, i64 0
	%296 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %295, i64 0, i32 1
	%297 = load i64, i64* %296, align 8
	%298 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%299 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %298, i64 0
	%300 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %299, i64 0, i32 1
	%301 = load i64, i64* %300, align 8
	%302 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%303 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %302, i64 0
	%304 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %303, i64 0, i32 0
	%305 = load %..string, %..string* %304, align 8
	%306 = extractvalue %..string %305, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$209, i64 0, i32 0), i64 68}, i64 115, i64 28, i64 %297, i64 %301, i64 %306)
	%307 = extractvalue %..string %305, 0
	%308 = getelementptr inbounds i8, i8* %307, i64 %297
	%309 = sub i64 %301, %297
	%310 = bitcast %..string* %30 to %..rawptr
	%311 = call %..rawptr @mem.zero(%..rawptr %310, i64 16) noinline
	store %..string zeroinitializer, %..string* %30
	%312 = getelementptr inbounds %..string, %..string* %30, i64 0, i32 0
	store i8* %308, i8** %312
	%313 = getelementptr inbounds %..string, %..string* %30, i64 0, i32 1
	store i64 %309, i64* %313
	%314 = load %..string, %..string* %30, align 8
	%315 = getelementptr inbounds %lexer.Token, %lexer.Token* %29, i64 0, i32 0
	store %..string %314, %..string* %315
	; CompoundLit
	%316 = bitcast %lexer.Token_Symbol* %31 to %..rawptr
	%317 = call %..rawptr @mem.zero(%..rawptr %316, i64 4) noinline
	store %lexer.Token_Symbol zeroinitializer, %lexer.Token_Symbol* %31
	store %lexer.Token_Symbol {i32 zeroinitializer}, %lexer.Token_Symbol* %31
	%318 = load i32, i32* %7, align 4
	%319 = getelementptr inbounds %lexer.Token_Symbol, %lexer.Token_Symbol* %31, i64 0, i32 0
	store i32 %318, i32* %319
	%320 = load %lexer.Token_Symbol, %lexer.Token_Symbol* %31, align 4
	; union - child to parent
	%321 = bitcast {[0 x <8 x i8>], [32 x i8], i8}* %32 to %..rawptr
	%322 = call %..rawptr @mem.zero(%..rawptr %321, i64 40) noinline
	store {[0 x <8 x i8>], [32 x i8], i8} zeroinitializer, {[0 x <8 x i8>], [32 x i8], i8}* %32
	%323 = bitcast {[0 x <8 x i8>], [32 x i8], i8}* %32 to %lexer.Token_Symbol*
	store %lexer.Token_Symbol %320, %lexer.Token_Symbol* %323
	%324 = getelementptr inbounds {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %32, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %324
	%325 = load {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %32, align 8
	%326 = getelementptr inbounds %lexer.Token, %lexer.Token* %29, i64 0, i32 1
	store {[0 x <8 x i8>], [32 x i8], i8} %325, {[0 x <8 x i8>], [32 x i8], i8}* %326
	%327 = load %lexer.Token, %lexer.Token* %29, align 8
	store %lexer.Token %327, %lexer.Token* %4
	br label %switch.done-50

switch.case.next-23:
	%328 = icmp sle i32 97, %129
	%329 = icmp sle i32 %129, 122
	%330 = zext i1 %328 to i8
	%331 = zext i1 %329 to i8
	%332 = and i8 %330, %331
	%333 = trunc i8 %332 to i1
	br i1 %333, label %switch.fall.body-26, label %switch.case.next-24

switch.case.next-24:
	%334 = icmp eq i32 %129, 95
	br i1 %334, label %switch.fall.body-26, label %switch.case.next-25

switch.case.next-25:
	%335 = icmp sle i32 48, %129
	%336 = icmp sle i32 %129, 57
	%337 = zext i1 %335 to i8
	%338 = zext i1 %336 to i8
	%339 = and i8 %337, %338
	%340 = trunc i8 %339 to i1
	br i1 %340, label %switch.fall.body-38, label %switch.case.next-36

switch.fall.body-26:
	; start
	%341 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%342 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %341, i64 0
	%343 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %342, i64 0, i32 1
	%344 = load i64, i64* %343, align 8
	store i64 %344, i64* %33
	; ForStmt
	br label %for.body-27

for.body-27:
	; SwitchStmt
	; IndexExpr
	%345 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%346 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %345, i64 0
	%347 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %346, i64 0, i32 0
	%348 = load %..string, %..string* %347, align 8
	%349 = extractvalue %..string %348, 0
	%350 = extractvalue %..string %348, 1
	%351 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%352 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %351, i64 0
	%353 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %352, i64 0, i32 1
	%354 = load i64, i64* %353, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$20a, i64 0, i32 0), i64 68}, i64 122, i64 23, i64 %354, i64 %350)
	%355 = getelementptr inbounds i8, i8* %349, i64 %354
	%356 = load i8, i8* %355, align 1
	%357 = icmp ule i8 65, %356
	%358 = icmp ule i8 %356, 90
	%359 = zext i1 %357 to i8
	%360 = zext i1 %358 to i8
	%361 = and i8 %359, %360
	%362 = trunc i8 %361 to i1
	br i1 %362, label %switch.case.body-32, label %switch.case.next-28

switch.case.next-28:
	%363 = icmp ule i8 97, %356
	%364 = icmp ule i8 %356, 122
	%365 = zext i1 %363 to i8
	%366 = zext i1 %364 to i8
	%367 = and i8 %365, %366
	%368 = trunc i8 %367 to i1
	br i1 %368, label %switch.case.body-32, label %switch.case.next-29

switch.case.next-29:
	%369 = icmp ule i8 48, %356
	%370 = icmp ule i8 %356, 57
	%371 = zext i1 %369 to i8
	%372 = zext i1 %370 to i8
	%373 = and i8 %371, %372
	%374 = trunc i8 %373 to i1
	br i1 %374, label %switch.case.body-32, label %switch.case.next-30

switch.case.next-30:
	%375 = icmp eq i8 %356, 95
	br i1 %375, label %switch.case.body-32, label %switch.case.next-31

switch.case.next-31:
	; break
	br label %for.done-35

switch.case.body-32:
	; IfStmt
	%376 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%377 = call i8 @lexer._inc(%lexer.Lexer* %376, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%378 = trunc i8 %377 to i1
	br i1 %378, label %if.done-34, label %if.then-33

if.then-33:
	; break
	br label %for.done-35

if.done-34:
	br label %for.body-27

for.done-35:
	; token_text
	; SliceExpr
	%379 = load i64, i64* %33, align 8
	%380 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%381 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %380, i64 0
	%382 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %381, i64 0, i32 1
	%383 = load i64, i64* %382, align 8
	%384 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%385 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %384, i64 0
	%386 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %385, i64 0, i32 0
	%387 = load %..string, %..string* %386, align 8
	%388 = extractvalue %..string %387, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$20b, i64 0, i32 0), i64 68}, i64 133, i64 28, i64 %379, i64 %383, i64 %388)
	%389 = extractvalue %..string %387, 0
	%390 = getelementptr inbounds i8, i8* %389, i64 %379
	%391 = sub i64 %383, %379
	%392 = bitcast %..string* %35 to %..rawptr
	%393 = call %..rawptr @mem.zero(%..rawptr %392, i64 16) noinline
	store %..string zeroinitializer, %..string* %35
	%394 = getelementptr inbounds %..string, %..string* %35, i64 0, i32 0
	store i8* %390, i8** %394
	%395 = getelementptr inbounds %..string, %..string* %35, i64 0, i32 1
	store i64 %391, i64* %395
	%396 = load %..string, %..string* %35, align 8
	store %..string %396, %..string* %34
	%397 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	call void @lexer._dec(%lexer.Lexer* %397, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	; CompoundLit
	%398 = bitcast %lexer.Token* %36 to %..rawptr
	%399 = call %..rawptr @mem.zero(%..rawptr %398, i64 56) noinline
	store %lexer.Token zeroinitializer, %lexer.Token* %36
	store %lexer.Token {%..string zeroinitializer, {[0 x <8 x i8>], [32 x i8], i8} zeroinitializer}, %lexer.Token* %36
	%400 = load %..string, %..string* %34, align 8
	%401 = getelementptr inbounds %lexer.Token, %lexer.Token* %36, i64 0, i32 0
	store %..string %400, %..string* %401
	; CompoundLit
	%402 = bitcast %lexer.Token_Identifier* %37 to %..rawptr
	%403 = call %..rawptr @mem.zero(%..rawptr %402, i64 16) noinline
	store %lexer.Token_Identifier zeroinitializer, %lexer.Token_Identifier* %37
	store %lexer.Token_Identifier {%..string zeroinitializer}, %lexer.Token_Identifier* %37
	%404 = load %..string, %..string* %34, align 8
	%405 = getelementptr inbounds %lexer.Token_Identifier, %lexer.Token_Identifier* %37, i64 0, i32 0
	store %..string %404, %..string* %405
	%406 = load %lexer.Token_Identifier, %lexer.Token_Identifier* %37, align 8
	; union - child to parent
	%407 = bitcast {[0 x <8 x i8>], [32 x i8], i8}* %38 to %..rawptr
	%408 = call %..rawptr @mem.zero(%..rawptr %407, i64 40) noinline
	store {[0 x <8 x i8>], [32 x i8], i8} zeroinitializer, {[0 x <8 x i8>], [32 x i8], i8}* %38
	%409 = bitcast {[0 x <8 x i8>], [32 x i8], i8}* %38 to %lexer.Token_Identifier*
	store %lexer.Token_Identifier %406, %lexer.Token_Identifier* %409
	%410 = getelementptr inbounds {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %38, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %410
	%411 = load {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %38, align 8
	%412 = getelementptr inbounds %lexer.Token, %lexer.Token* %36, i64 0, i32 1
	store {[0 x <8 x i8>], [32 x i8], i8} %411, {[0 x <8 x i8>], [32 x i8], i8}* %412
	%413 = load %lexer.Token, %lexer.Token* %36, align 8
	store %lexer.Token %413, %lexer.Token* %4
	br label %switch.done-50

switch.case.next-36:
	%414 = icmp eq i32 %129, 46
	br i1 %414, label %switch.fall.body-38, label %switch.case.next-37

switch.case.next-37:
	; SelectorExpr
	; IndexExpr
	%415 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%416 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %415, i64 0
	%417 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %416, i64 0, i32 0
	%418 = load %..string, %..string* %417, align 8
	%419 = extractvalue %..string %418, 0
	%420 = extractvalue %..string %418, 1
	%421 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%422 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %421, i64 0
	%423 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %422, i64 0, i32 1
	%424 = load i64, i64* %423, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$20c, i64 0, i32 0), i64 68}, i64 183, i64 55, i64 %424, i64 %420)
	%425 = getelementptr inbounds i8, i8* %419, i64 %424
	%426 = load i8, i8* %425, align 1
	%427 = zext i8 %426 to i32
	%428 = load i64, i64* %6, align 8
	%429 = load i64, i64* %5, align 8
	%430 = bitcast %..string* %50 to %..rawptr
	%431 = call %..rawptr @mem.zero(%..rawptr %430, i64 16) noinline
	store %..string zeroinitializer, %..string* %50
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$20d, i64 0, i32 0), i64 14}, %..string* %50
	%432 = load %..string, %..string* %50, align 8
	%433 = bitcast %..any* %51 to %..rawptr
	%434 = call %..rawptr @mem.zero(%..rawptr %433, i64 16) noinline
	store %..any zeroinitializer, %..any* %51
	%435 = bitcast %..string* %50 to %..rawptr
	%436 = getelementptr inbounds %..any, %..any* %51, i64 0, i32 0
	store %..rawptr %435, %..rawptr* %436
	%437 = getelementptr inbounds %..any, %..any* %51, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %437
	%438 = load %..any, %..any* %51, align 8
	%439 = bitcast %..any* %52 to %..rawptr
	%440 = call %..rawptr @mem.zero(%..rawptr %439, i64 16) noinline
	store %..any zeroinitializer, %..any* %52
	%441 = bitcast i32* %53 to %..rawptr
	%442 = call %..rawptr @mem.zero(%..rawptr %441, i64 4) noinline
	store i32 zeroinitializer, i32* %53
	store i32 %427, i32* %53
	%443 = bitcast i32* %53 to %..rawptr
	%444 = getelementptr inbounds %..any, %..any* %52, i64 0, i32 0
	store %..rawptr %443, %..rawptr* %444
	%445 = getelementptr inbounds %..any, %..any* %52, i64 0, i32 1
	store %..typeid 4755801206503243833, %..typeid* %445
	%446 = load %..any, %..any* %52, align 8
	%447 = bitcast %..string* %54 to %..rawptr
	%448 = call %..rawptr @mem.zero(%..rawptr %447, i64 16) noinline
	store %..string zeroinitializer, %..string* %54
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$20e, i64 0, i32 0), i64 7}, %..string* %54
	%449 = load %..string, %..string* %54, align 8
	%450 = bitcast %..any* %55 to %..rawptr
	%451 = call %..rawptr @mem.zero(%..rawptr %450, i64 16) noinline
	store %..any zeroinitializer, %..any* %55
	%452 = bitcast %..string* %54 to %..rawptr
	%453 = getelementptr inbounds %..any, %..any* %55, i64 0, i32 0
	store %..rawptr %452, %..rawptr* %453
	%454 = getelementptr inbounds %..any, %..any* %55, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %454
	%455 = load %..any, %..any* %55, align 8
	%456 = bitcast %..any* %56 to %..rawptr
	%457 = call %..rawptr @mem.zero(%..rawptr %456, i64 16) noinline
	store %..any zeroinitializer, %..any* %56
	%458 = bitcast i64* %6 to %..rawptr
	%459 = getelementptr inbounds %..any, %..any* %56, i64 0, i32 0
	store %..rawptr %458, %..rawptr* %459
	%460 = getelementptr inbounds %..any, %..any* %56, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %460
	%461 = load %..any, %..any* %56, align 8
	%462 = bitcast %..string* %57 to %..rawptr
	%463 = call %..rawptr @mem.zero(%..rawptr %462, i64 16) noinline
	store %..string zeroinitializer, %..string* %57
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$20f, i64 0, i32 0), i64 6}, %..string* %57
	%464 = load %..string, %..string* %57, align 8
	%465 = bitcast %..any* %58 to %..rawptr
	%466 = call %..rawptr @mem.zero(%..rawptr %465, i64 16) noinline
	store %..any zeroinitializer, %..any* %58
	%467 = bitcast %..string* %57 to %..rawptr
	%468 = getelementptr inbounds %..any, %..any* %58, i64 0, i32 0
	store %..rawptr %467, %..rawptr* %468
	%469 = getelementptr inbounds %..any, %..any* %58, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %469
	%470 = load %..any, %..any* %58, align 8
	%471 = bitcast %..any* %59 to %..rawptr
	%472 = call %..rawptr @mem.zero(%..rawptr %471, i64 16) noinline
	store %..any zeroinitializer, %..any* %59
	%473 = bitcast i64* %5 to %..rawptr
	%474 = getelementptr inbounds %..any, %..any* %59, i64 0, i32 0
	store %..rawptr %473, %..rawptr* %474
	%475 = getelementptr inbounds %..any, %..any* %59, i64 0, i32 1
	store %..typeid 4683743612465315846, %..typeid* %475
	%476 = load %..any, %..any* %59, align 8
	; variadic call argument generation
	%477 = bitcast {%..any*, i64}* %60 to %..rawptr
	%478 = call %..rawptr @mem.zero(%..rawptr %477, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %60
	%479 = bitcast [6 x %..any]* %61 to %..rawptr
	%480 = call %..rawptr @mem.zero(%..rawptr %479, i64 96) noinline
	store [6 x %..any] zeroinitializer, [6 x %..any]* %61
	%481 = getelementptr inbounds [6 x %..any], [6 x %..any]* %61, i64 0, i32 0
	store %..any %438, %..any* %481
	%482 = getelementptr inbounds [6 x %..any], [6 x %..any]* %61, i64 0, i32 1
	store %..any %446, %..any* %482
	%483 = getelementptr inbounds [6 x %..any], [6 x %..any]* %61, i64 0, i32 2
	store %..any %455, %..any* %483
	%484 = getelementptr inbounds [6 x %..any], [6 x %..any]* %61, i64 0, i32 3
	store %..any %461, %..any* %484
	%485 = getelementptr inbounds [6 x %..any], [6 x %..any]* %61, i64 0, i32 4
	store %..any %470, %..any* %485
	%486 = getelementptr inbounds [6 x %..any], [6 x %..any]* %61, i64 0, i32 5
	store %..any %476, %..any* %486
	%487 = getelementptr inbounds [6 x %..any], [6 x %..any]* %61, i64 0, i32 0
	%488 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %60, i64 0, i32 0
	store %..any* %487, %..any** %488
	%489 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %60, i64 0, i32 1
	store i64 6, i64* %489
	%490 = load {%..any*, i64}, {%..any*, i64}* %60, align 8
	%491 = bitcast {%..any*, i64}* %62 to %..rawptr
	%492 = call %..rawptr @mem.zero(%..rawptr %491, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %62
	store {%..any*, i64} %490, {%..any*, i64}* %62
	%493 = call i64 @fmt.println({%..any*, i64}* %62, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%494 = bitcast %runtime.Source_Code_Location* %63 to %..rawptr
	%495 = call %..rawptr @mem.zero(%..rawptr %494, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %63
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$210, i64 0, i32 0), i64 68}, i64 184, i64 4, %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$211, i64 0, i32 0), i64 14}}, %runtime.Source_Code_Location* %63
	%496 = call i8 @runtime.assert(i1 false, %..string zeroinitializer, %runtime.Source_Code_Location* %63)
	br label %switch.done-50

switch.fall.body-38:
	; start
	%497 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%498 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %497, i64 0
	%499 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %498, i64 0, i32 1
	%500 = load i64, i64* %499, align 8
	store i64 %500, i64* %39
	; found_a_dot
	store i8 0, i8* %40
	; ForStmt
	br label %for.body-39

for.body-39:
	; SwitchStmt
	; IndexExpr
	%501 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%502 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %501, i64 0
	%503 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %502, i64 0, i32 0
	%504 = load %..string, %..string* %503, align 8
	%505 = extractvalue %..string %504, 0
	%506 = extractvalue %..string %504, 1
	%507 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%508 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %507, i64 0
	%509 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %508, i64 0, i32 1
	%510 = load i64, i64* %509, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$212, i64 0, i32 0), i64 68}, i64 144, i64 23, i64 %510, i64 %506)
	%511 = getelementptr inbounds i8, i8* %505, i64 %510
	%512 = load i8, i8* %511, align 1
	%513 = icmp eq i8 %512, 46
	br i1 %513, label %switch.case.body-41, label %switch.case.next-40

switch.case.next-40:
	%514 = icmp ule i8 48, %512
	%515 = icmp ule i8 %512, 57
	%516 = zext i1 %514 to i8
	%517 = zext i1 %515 to i8
	%518 = and i8 %516, %517
	%519 = trunc i8 %518 to i1
	br i1 %519, label %switch.fall.body-43, label %switch.case.next-42

switch.case.body-41:
	%520 = load i8, i8* %40, align 1
	%521 = icmp eq i8 %520, 0
	%522 = zext i1 %521 to i8
	%523 = trunc i8 %522 to i1
	%524 = bitcast %runtime.Source_Code_Location* %41 to %..rawptr
	%525 = call %..rawptr @mem.zero(%..rawptr %524, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %41
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$213, i64 0, i32 0), i64 68}, i64 146, i64 7, %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$214, i64 0, i32 0), i64 14}}, %runtime.Source_Code_Location* %41
	%526 = call i8 @runtime.assert(i1 %523, %..string zeroinitializer, %runtime.Source_Code_Location* %41)
	; AssignStmt
	store i8 1, i8* %40
	; fallthrough
	br label %switch.fall.body-43

switch.case.next-42:
	; break
	br label %for.done-46

switch.fall.body-43:
	; IfStmt
	%527 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%528 = call i8 @lexer._inc(%lexer.Lexer* %527, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%529 = trunc i8 %528 to i1
	br i1 %529, label %if.done-45, label %if.then-44

if.then-44:
	; break
	br label %for.done-46

if.done-45:
	br label %for.body-39

for.done-46:
	; token_text
	; SliceExpr
	%530 = load i64, i64* %39, align 8
	%531 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%532 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %531, i64 0
	%533 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %532, i64 0, i32 1
	%534 = load i64, i64* %533, align 8
	%535 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%536 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %535, i64 0
	%537 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %536, i64 0, i32 0
	%538 = load %..string, %..string* %537, align 8
	%539 = extractvalue %..string %538, 1
	call void @runtime.slice_expr_error(%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$215, i64 0, i32 0), i64 68}, i64 162, i64 28, i64 %530, i64 %534, i64 %539)
	%540 = extractvalue %..string %538, 0
	%541 = getelementptr inbounds i8, i8* %540, i64 %530
	%542 = sub i64 %534, %530
	%543 = bitcast %..string* %43 to %..rawptr
	%544 = call %..rawptr @mem.zero(%..rawptr %543, i64 16) noinline
	store %..string zeroinitializer, %..string* %43
	%545 = getelementptr inbounds %..string, %..string* %43, i64 0, i32 0
	store i8* %541, i8** %545
	%546 = getelementptr inbounds %..string, %..string* %43, i64 0, i32 1
	store i64 %542, i64* %546
	%547 = load %..string, %..string* %43, align 8
	store %..string %547, %..string* %42
	; int_val
	%548 = bitcast i64* %44 to %..rawptr
	%549 = call %..rawptr @mem.zero(%..rawptr %548, i64 8) noinline
	store i64 zeroinitializer, i64* %44
	; unsigned_int_val
	%550 = bitcast i64* %45 to %..rawptr
	%551 = call %..rawptr @mem.zero(%..rawptr %550, i64 8) noinline
	store i64 zeroinitializer, i64* %45
	; float_val
	%552 = bitcast double* %46 to %..rawptr
	%553 = call %..rawptr @mem.zero(%..rawptr %552, i64 8) noinline
	store double zeroinitializer, double* %46
	; IfStmt
	%554 = load i8, i8* %40, align 1
	%555 = trunc i8 %554 to i1
	br i1 %555, label %if.then-47, label %if.else-48

if.then-47:
	; AssignStmt
	; SelectorExpr
	%556 = load %..string, %..string* %42, align 8
	%557 = call double @strconv.parse_f64(%..string %556, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store double %557, double* %46
	; AssignStmt
	%558 = load double, double* %46, align 8
	%559 = fptosi double %558 to i64
	store i64 %559, i64* %44
	; AssignStmt
	%560 = load double, double* %46, align 8
	%561 = fptoui double %560 to i64
	store i64 %561, i64* %45
	br label %if.done-49

if.else-48:
	; AssignStmt
	; SelectorExpr
	%562 = load %..string, %..string* %42, align 8
	%563 = call i64 @strconv.parse_u64(%..string %562, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %563, i64* %45
	; AssignStmt
	; SelectorExpr
	%564 = load %..string, %..string* %42, align 8
	%565 = call i64 @strconv.parse_i64(%..string %564, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store i64 %565, i64* %44
	; AssignStmt
	%566 = load i64, i64* %44, align 8
	%567 = sitofp i64 %566 to double
	store double %567, double* %46
	br label %if.done-49

if.done-49:
	%568 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	call void @lexer._dec(%lexer.Lexer* %568, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	; CompoundLit
	%569 = bitcast %lexer.Token* %47 to %..rawptr
	%570 = call %..rawptr @mem.zero(%..rawptr %569, i64 56) noinline
	store %lexer.Token zeroinitializer, %lexer.Token* %47
	store %lexer.Token {%..string zeroinitializer, {[0 x <8 x i8>], [32 x i8], i8} zeroinitializer}, %lexer.Token* %47
	%571 = load %..string, %..string* %42, align 8
	%572 = getelementptr inbounds %lexer.Token, %lexer.Token* %47, i64 0, i32 0
	store %..string %571, %..string* %572
	; CompoundLit
	%573 = bitcast %lexer.Token_Number* %48 to %..rawptr
	%574 = call %..rawptr @mem.zero(%..rawptr %573, i64 32) noinline
	store %lexer.Token_Number zeroinitializer, %lexer.Token_Number* %48
	store %lexer.Token_Number {i64 zeroinitializer, i64 zeroinitializer, double zeroinitializer, i8 zeroinitializer}, %lexer.Token_Number* %48
	%575 = load i64, i64* %44, align 8
	%576 = getelementptr inbounds %lexer.Token_Number, %lexer.Token_Number* %48, i64 0, i32 0
	store i64 %575, i64* %576
	%577 = load i64, i64* %45, align 8
	%578 = getelementptr inbounds %lexer.Token_Number, %lexer.Token_Number* %48, i64 0, i32 1
	store i64 %577, i64* %578
	%579 = load double, double* %46, align 8
	%580 = getelementptr inbounds %lexer.Token_Number, %lexer.Token_Number* %48, i64 0, i32 2
	store double %579, double* %580
	%581 = load i8, i8* %40, align 1
	%582 = getelementptr inbounds %lexer.Token_Number, %lexer.Token_Number* %48, i64 0, i32 3
	store i8 %581, i8* %582
	%583 = load %lexer.Token_Number, %lexer.Token_Number* %48, align 8
	; union - child to parent
	%584 = bitcast {[0 x <8 x i8>], [32 x i8], i8}* %49 to %..rawptr
	%585 = call %..rawptr @mem.zero(%..rawptr %584, i64 40) noinline
	store {[0 x <8 x i8>], [32 x i8], i8} zeroinitializer, {[0 x <8 x i8>], [32 x i8], i8}* %49
	%586 = bitcast {[0 x <8 x i8>], [32 x i8], i8}* %49 to %lexer.Token_Number*
	store %lexer.Token_Number %583, %lexer.Token_Number* %586
	%587 = getelementptr inbounds {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %49, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %587
	%588 = load {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %49, align 8
	%589 = getelementptr inbounds %lexer.Token, %lexer.Token* %47, i64 0, i32 1
	store {[0 x <8 x i8>], [32 x i8], i8} %588, {[0 x <8 x i8>], [32 x i8], i8}* %589
	%590 = load %lexer.Token, %lexer.Token* %47, align 8
	store %lexer.Token %590, %lexer.Token* %4
	br label %switch.done-50

switch.done-50:
	%591 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%592 = call i8 @lexer._inc(%lexer.Lexer* %591, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%593 = getelementptr inbounds %lexer.Token, %lexer.Token* %4, i64 0, i32 1
	%594 = load {[0 x <8 x i8>], [32 x i8], i8}, {[0 x <8 x i8>], [32 x i8], i8}* %593, align 8
	%595 = extractvalue {[0 x <8 x i8>], [32 x i8], i8} %594, 2 ; UnionTagValue
	%596 = icmp ne i8 %595, 0
	%597 = zext i1 %596 to i8
	%598 = trunc i8 %597 to i1
	%599 = bitcast %runtime.Source_Code_Location* %64 to %..rawptr
	%600 = call %..rawptr @mem.zero(%..rawptr %599, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %64
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$216, i64 0, i32 0), i64 68}, i64 190, i64 2, %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$217, i64 0, i32 0), i64 14}}, %runtime.Source_Code_Location* %64
	%601 = call i8 @runtime.assert(i1 %598, %..string zeroinitializer, %runtime.Source_Code_Location* %64)
	; ReturnStmt
	%602 = load %lexer.Token, %lexer.Token* %4, align 8
	%603 = bitcast {%lexer.Token, i8}* %65 to %..rawptr
	%604 = call %..rawptr @mem.zero(%..rawptr %603, i64 64) noinline
	store {%lexer.Token, i8} zeroinitializer, {%lexer.Token, i8}* %65
	%605 = getelementptr inbounds {%lexer.Token, i8}, {%lexer.Token, i8}* %65, i64 0, i32 0
	store %lexer.Token %602, %lexer.Token* %605
	%606 = getelementptr inbounds {%lexer.Token, i8}, {%lexer.Token, i8}* %65, i64 0, i32 1
	store i8 1, i8* %606
	%607 = load {%lexer.Token, i8}, {%lexer.Token, i8}* %65, align 8
	ret {%lexer.Token, i8} %607
}

define i8 @lexer._is_whitespace(i8 %r, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i8, align 16
	store i8 %r, i8* %0
	; SwitchStmt
	%1 = load i8, i8* %0, align 1
	%2 = zext i8 %1 to i32
	%3 = icmp eq i32 %2, 32
	br i1 %3, label %switch.case.body-5, label %switch.case.next-1

switch.case.next-1:
	%4 = icmp eq i32 %2, 10
	br i1 %4, label %switch.case.body-5, label %switch.case.next-2

switch.case.next-2:
	%5 = icmp eq i32 %2, 13
	br i1 %5, label %switch.case.body-5, label %switch.case.next-3

switch.case.next-3:
	%6 = icmp eq i32 %2, 9
	br i1 %6, label %switch.case.body-5, label %switch.case.next-4

switch.case.next-4:
	; ReturnStmt
	ret i8 0

switch.case.body-5:
	; ReturnStmt
	ret i8 1
}

define void @lexer._dec(%lexer.Lexer* %lexer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %lexer.Lexer*, align 16
	store %lexer.Lexer* %lexer, %lexer.Lexer** %0
	; AssignStmt
	%1 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%2 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %1, i64 0
	%3 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %2, i64 0, i32 1
	%4 = load i64, i64* %3, align 8
	%5 = sub i64 %4, 1
	store i64 %5, i64* %3
	; AssignStmt
	%6 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%7 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %6, i64 0
	%8 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %7, i64 0, i32 2
	%9 = load i64, i64* %8, align 8
	%10 = sub i64 %9, 1
	store i64 %10, i64* %8
	ret void
}

define i8 @lexer._inc(%lexer.Lexer* %lexer, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %lexer.Lexer*, align 16
	%1 = alloca i8, align 16
	store %lexer.Lexer* %lexer, %lexer.Lexer** %0
	; r
	; IndexExpr
	%2 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%3 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %2, i64 0
	%4 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %3, i64 0, i32 0
	%5 = load %..string, %..string* %4, align 8
	%6 = extractvalue %..string %5, 0
	%7 = extractvalue %..string %5, 1
	%8 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%9 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %8, i64 0
	%10 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %9, i64 0, i32 1
	%11 = load i64, i64* %10, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([69 x i8], [69 x i8]* @str$218, i64 0, i32 0), i64 68}, i64 209, i64 18, i64 %11, i64 %7)
	%12 = getelementptr inbounds i8, i8* %6, i64 %11
	%13 = load i8, i8* %12, align 1
	store i8 %13, i8* %1
	; AssignStmt
	%14 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%15 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %14, i64 0
	%16 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %15, i64 0, i32 1
	%17 = load i64, i64* %16, align 8
	%18 = add i64 %17, 1
	store i64 %18, i64* %16
	; IfStmt
	%19 = load i8, i8* %1, align 1
	%20 = icmp eq i8 %19, 10
	%21 = zext i1 %20 to i8
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.else-2

if.then-1:
	; AssignStmt
	%23 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%24 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %23, i64 0
	%25 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %24, i64 0, i32 2
	store i64 1, i64* %25
	; AssignStmt
	%26 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%27 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %26, i64 0
	%28 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %27, i64 0, i32 3
	%29 = load i64, i64* %28, align 8
	%30 = add i64 %29, 1
	store i64 %30, i64* %28
	br label %if.done-6

if.else-2:
	; IfStmt
	%31 = load i8, i8* %1, align 1
	%32 = icmp eq i8 %31, 9
	%33 = zext i1 %32 to i8
	%34 = trunc i8 %33 to i1
	br i1 %34, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	%35 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%36 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %35, i64 0
	%37 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %36, i64 0, i32 2
	%38 = load i64, i64* %37, align 8
	%39 = add i64 %38, 4
	store i64 %39, i64* %37
	br label %if.done-5

if.else-4:
	; AssignStmt
	%40 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%41 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %40, i64 0
	%42 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %41, i64 0, i32 2
	%43 = load i64, i64* %42, align 8
	%44 = add i64 %43, 1
	store i64 %44, i64* %42
	br label %if.done-5

if.done-5:
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%45 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%46 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %45, i64 0
	%47 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %46, i64 0, i32 1
	%48 = load i64, i64* %47, align 8
	%49 = load %lexer.Lexer*, %lexer.Lexer** %0, align 8
	%50 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %49, i64 0
	%51 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %50, i64 0, i32 0
	%52 = load %..string, %..string* %51, align 8
	%53 = extractvalue %..string %52, 1
	%54 = icmp slt i64 %48, %53
	%55 = zext i1 %54 to i8
	ret i8 %55
}

define i8 @types.is_rune(%runtime.Type_Info* %info, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca {%runtime.Type_Info_Rune, i8}, align 16
	store %runtime.Type_Info* %info, %runtime.Type_Info** %0
	; IfStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%5 = icmp eq %runtime.Type_Info* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ok
	; SelectorExpr
	; SelectorExpr
	%8 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%9 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %8)
	%10 = bitcast %runtime.Type_Info** %2 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %2
	store %runtime.Type_Info* %9, %runtime.Type_Info** %2
	%12 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%13 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %12, i64 0
	%14 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %13, i64 0, i32 3
	%15 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, align 8
	; cast - union_cast
	%16 = bitcast {%runtime.Type_Info_Rune, i8}* %3 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 1) noinline
	store {%runtime.Type_Info_Rune, i8} zeroinitializer, {%runtime.Type_Info_Rune, i8}* %3
	%18 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, i64 0, i32 2 ; UnionTagPtr
	%19 = load i8, i8* %18, align 1
	%20 = icmp eq i8 %19, 3
	br i1 %20, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%21 = getelementptr inbounds {%runtime.Type_Info_Rune, i8}, {%runtime.Type_Info_Rune, i8}* %3, i64 0, i32 0
	%22 = getelementptr inbounds {%runtime.Type_Info_Rune, i8}, {%runtime.Type_Info_Rune, i8}* %3, i64 0, i32 1
	%23 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %14 to %runtime.Type_Info_Rune*
	%24 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %23, align 1
	store %runtime.Type_Info_Rune %24, %runtime.Type_Info_Rune* %21
	store i8 1, i8* %22
	br label %union_cast.end-4

union_cast.end-4:
	%25 = load {%runtime.Type_Info_Rune, i8}, {%runtime.Type_Info_Rune, i8}* %3, align 1
	%26 = extractvalue {%runtime.Type_Info_Rune, i8} %25, 0
	%27 = extractvalue {%runtime.Type_Info_Rune, i8} %25, 1
	store i8 %27, i8* %1
	; ReturnStmt
	%28 = load i8, i8* %1, align 1
	ret i8 %28
}

define i8 @types.is_any(%runtime.Type_Info* %info, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca {%runtime.Type_Info_Any, i8}, align 16
	store %runtime.Type_Info* %info, %runtime.Type_Info** %0
	; IfStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%5 = icmp eq %runtime.Type_Info* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ok
	; SelectorExpr
	; SelectorExpr
	%8 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%9 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %8)
	%10 = bitcast %runtime.Type_Info** %2 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %2
	store %runtime.Type_Info* %9, %runtime.Type_Info** %2
	%12 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%13 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %12, i64 0
	%14 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %13, i64 0, i32 3
	%15 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, align 8
	; cast - union_cast
	%16 = bitcast {%runtime.Type_Info_Any, i8}* %3 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 1) noinline
	store {%runtime.Type_Info_Any, i8} zeroinitializer, {%runtime.Type_Info_Any, i8}* %3
	%18 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, i64 0, i32 2 ; UnionTagPtr
	%19 = load i8, i8* %18, align 1
	%20 = icmp eq i8 %19, 8
	br i1 %20, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%21 = getelementptr inbounds {%runtime.Type_Info_Any, i8}, {%runtime.Type_Info_Any, i8}* %3, i64 0, i32 0
	%22 = getelementptr inbounds {%runtime.Type_Info_Any, i8}, {%runtime.Type_Info_Any, i8}* %3, i64 0, i32 1
	%23 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %14 to %runtime.Type_Info_Any*
	%24 = load %runtime.Type_Info_Any, %runtime.Type_Info_Any* %23, align 1
	store %runtime.Type_Info_Any %24, %runtime.Type_Info_Any* %21
	store i8 1, i8* %22
	br label %union_cast.end-4

union_cast.end-4:
	%25 = load {%runtime.Type_Info_Any, i8}, {%runtime.Type_Info_Any, i8}* %3, align 1
	%26 = extractvalue {%runtime.Type_Info_Any, i8} %25, 0
	%27 = extractvalue {%runtime.Type_Info_Any, i8} %25, 1
	store i8 %27, i8* %1
	; ReturnStmt
	%28 = load i8, i8* %1, align 1
	ret i8 %28
}

define i8 @types.is_string(%runtime.Type_Info* %info, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca {%runtime.Type_Info_String, i8}, align 16
	store %runtime.Type_Info* %info, %runtime.Type_Info** %0
	; IfStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%5 = icmp eq %runtime.Type_Info* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ok
	; SelectorExpr
	; SelectorExpr
	%8 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%9 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %8)
	%10 = bitcast %runtime.Type_Info** %2 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %2
	store %runtime.Type_Info* %9, %runtime.Type_Info** %2
	%12 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%13 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %12, i64 0
	%14 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %13, i64 0, i32 3
	%15 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, align 8
	; cast - union_cast
	%16 = bitcast {%runtime.Type_Info_String, i8}* %3 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 2) noinline
	store {%runtime.Type_Info_String, i8} zeroinitializer, {%runtime.Type_Info_String, i8}* %3
	%18 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, i64 0, i32 2 ; UnionTagPtr
	%19 = load i8, i8* %18, align 1
	%20 = icmp eq i8 %19, 6
	br i1 %20, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%21 = getelementptr inbounds {%runtime.Type_Info_String, i8}, {%runtime.Type_Info_String, i8}* %3, i64 0, i32 0
	%22 = getelementptr inbounds {%runtime.Type_Info_String, i8}, {%runtime.Type_Info_String, i8}* %3, i64 0, i32 1
	%23 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %14 to %runtime.Type_Info_String*
	%24 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %23, align 1
	store %runtime.Type_Info_String %24, %runtime.Type_Info_String* %21
	store i8 1, i8* %22
	br label %union_cast.end-4

union_cast.end-4:
	%25 = load {%runtime.Type_Info_String, i8}, {%runtime.Type_Info_String, i8}* %3, align 1
	%26 = extractvalue {%runtime.Type_Info_String, i8} %25, 0
	%27 = extractvalue {%runtime.Type_Info_String, i8} %25, 1
	store i8 %27, i8* %1
	; ReturnStmt
	%28 = load i8, i8* %1, align 1
	ret i8 %28
}

define i8 @types.is_enum(%runtime.Type_Info* %info, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca {%runtime.Type_Info_Enum, i8}, align 16
	store %runtime.Type_Info* %info, %runtime.Type_Info** %0
	; IfStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%5 = icmp eq %runtime.Type_Info* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ok
	; SelectorExpr
	; SelectorExpr
	%8 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%9 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %8)
	%10 = bitcast %runtime.Type_Info** %2 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 8) noinline
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %2
	store %runtime.Type_Info* %9, %runtime.Type_Info** %2
	%12 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%13 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %12, i64 0
	%14 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %13, i64 0, i32 3
	%15 = load {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, align 8
	; cast - union_cast
	%16 = bitcast {%runtime.Type_Info_Enum, i8}* %3 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 48) noinline
	store {%runtime.Type_Info_Enum, i8} zeroinitializer, {%runtime.Type_Info_Enum, i8}* %3
	%18 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, i64 0, i32 2 ; UnionTagPtr
	%19 = load i8, i8* %18, align 1
	%20 = icmp eq i8 %19, 18
	br i1 %20, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%21 = getelementptr inbounds {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %3, i64 0, i32 0
	%22 = getelementptr inbounds {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %3, i64 0, i32 1
	%23 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %14 to %runtime.Type_Info_Enum*
	%24 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %23, align 8
	store %runtime.Type_Info_Enum %24, %runtime.Type_Info_Enum* %21
	store i8 1, i8* %22
	br label %union_cast.end-4

union_cast.end-4:
	%25 = load {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %3, align 8
	%26 = extractvalue {%runtime.Type_Info_Enum, i8} %25, 0
	%27 = extractvalue {%runtime.Type_Info_Enum, i8} %25, 1
	store i8 %27, i8* %1
	; ReturnStmt
	%28 = load i8, i8* %1, align 1
	ret i8 %28
}

define void @prebuild.main() #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..any, align 16
	%2 = alloca {%..any*, i64}, align 16
	%3 = alloca [1 x %..any], align 16
	%4 = alloca %runtime.Context, align 16
	%5 = bitcast %runtime.Context* %4 to %..rawptr
	%6 = call %..rawptr @mem.zero(%..rawptr %5, i64 104) noinline
	store %runtime.Context zeroinitializer, %runtime.Context* %4
	%7 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %7, %runtime.Context* %4
	call void @runtime.__init_context(%runtime.Context* %4)
	%8 = alloca {%..any*, i64}, align 16
	%9 = alloca {i8*, i64}, align 16
	%10 = alloca i8, align 16
	%11 = alloca %..string, align 16
	%12 = alloca %..any, align 16
	%13 = alloca %..string, align 16
	%14 = alloca %..any, align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca [2 x %..any], align 16
	%17 = alloca {%..any*, i64}, align 16
	%18 = alloca %runtime.Source_Code_Location, align 16
	%19 = alloca {%prebuild.main.Component_Definition-250*, i64}, align 16
	%20 = alloca %..string, align 16
	%21 = alloca %prebuild.main.Component_Definition-250, align 16
	%22 = alloca i64, align 16
	%23 = alloca i64, align 16
	%24 = alloca {%prebuild.Parameter*, i64}, align 16
	%25 = alloca [2 x %prebuild.Parameter], align 16
	%26 = alloca {%prebuild.Parameter*, i64}, align 16
	%27 = alloca %prebuild.main.Component_Definition-250, align 16
	%28 = alloca i64, align 16
	%29 = alloca i64, align 16
	%30 = alloca %..string, align 16
	%31 = alloca %..any, align 16
	%32 = alloca %..any, align 16
	%33 = alloca %..string, align 16
	%34 = alloca %..any, align 16
	%35 = alloca {%..any*, i64}, align 16
	%36 = alloca [3 x %..any], align 16
	%37 = alloca {%..any*, i64}, align 16
	%38 = alloca %..string, align 16
	%39 = alloca %..any, align 16
	%40 = alloca %..any, align 16
	%41 = alloca %..string, align 16
	%42 = alloca %..any, align 16
	%43 = alloca {%..any*, i64}, align 16
	%44 = alloca [3 x %..any], align 16
	%45 = alloca {%..any*, i64}, align 16
	%46 = alloca %..string, align 16
	%47 = alloca %..any, align 16
	%48 = alloca %..any, align 16
	%49 = alloca %..string, align 16
	%50 = alloca %..any, align 16
	%51 = alloca %..any, align 16
	%52 = alloca %..string, align 16
	%53 = alloca %..any, align 16
	%54 = alloca {%..any*, i64}, align 16
	%55 = alloca [5 x %..any], align 16
	%56 = alloca {%..any*, i64}, align 16
	%57 = alloca %..any, align 16
	%58 = alloca %..string, align 16
	%59 = alloca %..any, align 16
	%60 = alloca {%..any*, i64}, align 16
	%61 = alloca [2 x %..any], align 16
	%62 = alloca {%..any*, i64}, align 16
	%63 = alloca %..string, align 16
	%64 = alloca %..any, align 16
	%65 = alloca {%..any*, i64}, align 16
	%66 = alloca [1 x %..any], align 16
	%67 = alloca {%..any*, i64}, align 16
	%68 = alloca {%prebuild.Parameter*, i64}, align 16
	%69 = alloca [2 x %prebuild.Parameter], align 16
	%70 = alloca {%prebuild.Parameter*, i64}, align 16
	%71 = alloca %prebuild.main.Component_Definition-250, align 16
	%72 = alloca i64, align 16
	%73 = alloca i64, align 16
	%74 = alloca %..string, align 16
	%75 = alloca %..any, align 16
	%76 = alloca %..any, align 16
	%77 = alloca %..string, align 16
	%78 = alloca %..any, align 16
	%79 = alloca {%..any*, i64}, align 16
	%80 = alloca [3 x %..any], align 16
	%81 = alloca {%..any*, i64}, align 16
	%82 = alloca %..string, align 16
	%83 = alloca %..any, align 16
	%84 = alloca %..any, align 16
	%85 = alloca %..string, align 16
	%86 = alloca %..any, align 16
	%87 = alloca {%..any*, i64}, align 16
	%88 = alloca [3 x %..any], align 16
	%89 = alloca {%..any*, i64}, align 16
	%90 = alloca %..string, align 16
	%91 = alloca %..any, align 16
	%92 = alloca %..any, align 16
	%93 = alloca %..string, align 16
	%94 = alloca %..any, align 16
	%95 = alloca {%..any*, i64}, align 16
	%96 = alloca [3 x %..any], align 16
	%97 = alloca {%..any*, i64}, align 16
	%98 = alloca {%prebuild.Parameter*, i64}, align 16
	%99 = alloca [1 x %prebuild.Parameter], align 16
	%100 = alloca {%prebuild.Parameter*, i64}, align 16
	%101 = alloca %prebuild.main.Component_Definition-250, align 16
	%102 = alloca i64, align 16
	%103 = alloca i64, align 16
	%104 = alloca %..string, align 16
	%105 = alloca %..any, align 16
	%106 = alloca %..any, align 16
	%107 = alloca %..string, align 16
	%108 = alloca %..any, align 16
	%109 = alloca {%..any*, i64}, align 16
	%110 = alloca [3 x %..any], align 16
	%111 = alloca {%..any*, i64}, align 16
	%112 = alloca %..string, align 16
	%113 = alloca %..any, align 16
	%114 = alloca %..any, align 16
	%115 = alloca %..string, align 16
	%116 = alloca %..any, align 16
	%117 = alloca {%..any*, i64}, align 16
	%118 = alloca [3 x %..any], align 16
	%119 = alloca {%..any*, i64}, align 16
	%120 = alloca %..string, align 16
	%121 = alloca %..any, align 16
	%122 = alloca %..any, align 16
	%123 = alloca %..string, align 16
	%124 = alloca %..any, align 16
	%125 = alloca {%..any*, i64}, align 16
	%126 = alloca [3 x %..any], align 16
	%127 = alloca {%..any*, i64}, align 16
	%128 = alloca {%prebuild.Parameter*, i64}, align 16
	%129 = alloca {%prebuild.Parameter*, i64}, align 16
	%130 = alloca %prebuild.main.Component_Definition-250, align 16
	%131 = alloca i64, align 16
	%132 = alloca i64, align 16
	%133 = alloca %..string, align 16
	%134 = alloca %..any, align 16
	%135 = alloca %..any, align 16
	%136 = alloca %..string, align 16
	%137 = alloca %..any, align 16
	%138 = alloca {%..any*, i64}, align 16
	%139 = alloca [3 x %..any], align 16
	%140 = alloca {%..any*, i64}, align 16
	%141 = alloca %..string, align 16
	%142 = alloca %..any, align 16
	%143 = alloca %..any, align 16
	%144 = alloca %..string, align 16
	%145 = alloca %..any, align 16
	%146 = alloca %..any, align 16
	%147 = alloca %..string, align 16
	%148 = alloca %..any, align 16
	%149 = alloca {%..any*, i64}, align 16
	%150 = alloca [5 x %..any], align 16
	%151 = alloca {%..any*, i64}, align 16
	%152 = alloca {%prebuild.Parameter*, i64}, align 16
	%153 = alloca {%prebuild.Parameter*, i64}, align 16
	%154 = alloca %prebuild.main.Component_Definition-250, align 16
	%155 = alloca i64, align 16
	%156 = alloca i64, align 16
	%157 = alloca %..string, align 16
	%158 = alloca %..any, align 16
	%159 = alloca %..any, align 16
	%160 = alloca %..string, align 16
	%161 = alloca %..any, align 16
	%162 = alloca {%..any*, i64}, align 16
	%163 = alloca [3 x %..any], align 16
	%164 = alloca {%..any*, i64}, align 16
	%165 = alloca %..string, align 16
	%166 = alloca %..any, align 16
	%167 = alloca %..any, align 16
	%168 = alloca %..string, align 16
	%169 = alloca %..any, align 16
	%170 = alloca %..any, align 16
	%171 = alloca %..string, align 16
	%172 = alloca %..any, align 16
	%173 = alloca {%..any*, i64}, align 16
	%174 = alloca [5 x %..any], align 16
	%175 = alloca {%..any*, i64}, align 16
	%176 = alloca {%prebuild.Parameter*, i64}, align 16
	%177 = alloca {%prebuild.Parameter*, i64}, align 16
	%178 = alloca %prebuild.main.Component_Definition-250, align 16
	%179 = alloca i64, align 16
	%180 = alloca i64, align 16
	%181 = alloca %..string, align 16
	%182 = alloca %..any, align 16
	%183 = alloca %..any, align 16
	%184 = alloca %..string, align 16
	%185 = alloca %..any, align 16
	%186 = alloca {%..any*, i64}, align 16
	%187 = alloca [3 x %..any], align 16
	%188 = alloca {%..any*, i64}, align 16
	%189 = alloca %..string, align 16
	%190 = alloca %..any, align 16
	%191 = alloca %..any, align 16
	%192 = alloca %..string, align 16
	%193 = alloca %..any, align 16
	%194 = alloca %..any, align 16
	%195 = alloca %..string, align 16
	%196 = alloca %..any, align 16
	%197 = alloca {%..any*, i64}, align 16
	%198 = alloca [5 x %..any], align 16
	%199 = alloca {%..any*, i64}, align 16
	%200 = alloca {i8*, i64}, align 16
	%201 = alloca %mem.Allocator, align 16
	%202 = alloca %runtime.Source_Code_Location, align 16
	%203 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%204 = alloca i8*, align 16
	%205 = alloca {i8*, i64}, align 16
	%206 = alloca {i8*, i64}, align 16
	%207 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%208 = alloca %runtime.Source_Code_Location, align 16
	%209 = bitcast %..string* %0 to %..rawptr
	%210 = call %..rawptr @mem.zero(%..rawptr %209, i64 16) noinline
	store %..string zeroinitializer, %..string* %0
	store %..string {i8* getelementptr inbounds ([40 x i8], [40 x i8]* @str$219, i64 0, i32 0), i64 39}, %..string* %0
	%211 = load %..string, %..string* %0, align 8
	%212 = bitcast %..any* %1 to %..rawptr
	%213 = call %..rawptr @mem.zero(%..rawptr %212, i64 16) noinline
	store %..any zeroinitializer, %..any* %1
	%214 = bitcast %..string* %0 to %..rawptr
	%215 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	store %..rawptr %214, %..rawptr* %215
	%216 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %216
	%217 = load %..any, %..any* %1, align 8
	; variadic call argument generation
	%218 = bitcast {%..any*, i64}* %2 to %..rawptr
	%219 = call %..rawptr @mem.zero(%..rawptr %218, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %2
	%220 = bitcast [1 x %..any]* %3 to %..rawptr
	%221 = call %..rawptr @mem.zero(%..rawptr %220, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %3
	%222 = getelementptr inbounds [1 x %..any], [1 x %..any]* %3, i64 0, i32 0
	store %..any %217, %..any* %222
	%223 = getelementptr inbounds [1 x %..any], [1 x %..any]* %3, i64 0, i32 0
	%224 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %2, i64 0, i32 0
	store %..any* %223, %..any** %224
	%225 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %2, i64 0, i32 1
	store i64 1, i64* %225
	%226 = load {%..any*, i64}, {%..any*, i64}* %2, align 8
	%227 = bitcast {%..any*, i64}* %8 to %..rawptr
	%228 = call %..rawptr @mem.zero(%..rawptr %227, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %8
	store {%..any*, i64} %226, {%..any*, i64}* %8
	%229 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* @prebuild.generated_code, {%..any*, i64}* %8, %runtime.Context* noalias nonnull nocapture inreg %4)
	; component_types_data
	; ok
	; SelectorExpr
	%230 = call {{i8*, i64}, i8} @os.read_entire_file(%..string {i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$21a, i64 0, i32 0), i64 27}, %runtime.Context* noalias nonnull nocapture inreg %4)
	%231 = extractvalue {{i8*, i64}, i8} %230, 0
	%232 = extractvalue {{i8*, i64}, i8} %230, 1
	store {i8*, i64} %231, {i8*, i64}* %9
	store i8 %232, i8* %10
	%233 = load i8, i8* %10, align 1
	%234 = bitcast %..string* %11 to %..rawptr
	%235 = call %..rawptr @mem.zero(%..rawptr %234, i64 16) noinline
	store %..string zeroinitializer, %..string* %11
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$21b, i64 0, i32 0), i64 14}, %..string* %11
	%236 = load %..string, %..string* %11, align 8
	%237 = bitcast %..any* %12 to %..rawptr
	%238 = call %..rawptr @mem.zero(%..rawptr %237, i64 16) noinline
	store %..any zeroinitializer, %..any* %12
	%239 = bitcast %..string* %11 to %..rawptr
	%240 = getelementptr inbounds %..any, %..any* %12, i64 0, i32 0
	store %..rawptr %239, %..rawptr* %240
	%241 = getelementptr inbounds %..any, %..any* %12, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %241
	%242 = load %..any, %..any* %12, align 8
	%243 = bitcast %..string* %13 to %..rawptr
	%244 = call %..rawptr @mem.zero(%..rawptr %243, i64 16) noinline
	store %..string zeroinitializer, %..string* %13
	store %..string {i8* getelementptr inbounds ([28 x i8], [28 x i8]* @str$21c, i64 0, i32 0), i64 27}, %..string* %13
	%245 = load %..string, %..string* %13, align 8
	%246 = bitcast %..any* %14 to %..rawptr
	%247 = call %..rawptr @mem.zero(%..rawptr %246, i64 16) noinline
	store %..any zeroinitializer, %..any* %14
	%248 = bitcast %..string* %13 to %..rawptr
	%249 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 0
	store %..rawptr %248, %..rawptr* %249
	%250 = getelementptr inbounds %..any, %..any* %14, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %250
	%251 = load %..any, %..any* %14, align 8
	; variadic call argument generation
	%252 = bitcast {%..any*, i64}* %15 to %..rawptr
	%253 = call %..rawptr @mem.zero(%..rawptr %252, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	%254 = bitcast [2 x %..any]* %16 to %..rawptr
	%255 = call %..rawptr @mem.zero(%..rawptr %254, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %16
	%256 = getelementptr inbounds [2 x %..any], [2 x %..any]* %16, i64 0, i32 0
	store %..any %242, %..any* %256
	%257 = getelementptr inbounds [2 x %..any], [2 x %..any]* %16, i64 0, i32 1
	store %..any %251, %..any* %257
	%258 = getelementptr inbounds [2 x %..any], [2 x %..any]* %16, i64 0, i32 0
	%259 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 0
	store %..any* %258, %..any** %259
	%260 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %15, i64 0, i32 1
	store i64 2, i64* %260
	%261 = load {%..any*, i64}, {%..any*, i64}* %15, align 8
	%262 = bitcast {%..any*, i64}* %17 to %..rawptr
	%263 = call %..rawptr @mem.zero(%..rawptr %262, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %17
	store {%..any*, i64} %261, {%..any*, i64}* %17
	%264 = call %..string @fmt.tprint({%..any*, i64}* %17, %runtime.Context* noalias nonnull nocapture inreg %4)
	%265 = trunc i8 %233 to i1
	%266 = bitcast %runtime.Source_Code_Location* %18 to %..rawptr
	%267 = call %..rawptr @mem.zero(%..rawptr %266, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %18
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([74 x i8], [74 x i8]* @str$21d, i64 0, i32 0), i64 73}, i64 39, i64 3, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$21e, i64 0, i32 0), i64 4}}, %runtime.Source_Code_Location* %18
	%268 = call i8 @runtime.assert(i1 %265, %..string %264, %runtime.Source_Code_Location* %18)
	; DeferStmt
	; components
	; SelectorExpr
	%269 = load {i8*, i64}, {i8*, i64}* %9, align 8
	%270 = extractvalue {i8*, i64} %269, 0
	%271 = extractvalue {i8*, i64} %269, 1
	%272 = bitcast %..string* %20 to %..rawptr
	%273 = call %..rawptr @mem.zero(%..rawptr %272, i64 16) noinline
	store %..string zeroinitializer, %..string* %20
	%274 = getelementptr inbounds %..string, %..string* %20, i64 0, i32 0
	store i8* %270, i8** %274
	%275 = getelementptr inbounds %..string, %..string* %20, i64 0, i32 1
	store i64 %271, i64* %275
	%276 = load %..string, %..string* %20, align 8
	%277 = call {%prebuild.main.Component_Definition-250*, i64} @wbml.deserialize-20347(%..string %276, %runtime.Context* noalias nonnull nocapture inreg %4)
	store {%prebuild.main.Component_Definition-250*, i64} %277, {%prebuild.main.Component_Definition-250*, i64}* %19
	call void @prebuild.union_begin(%..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$21f, i64 0, i32 0), i64 14}, %runtime.Context* noalias nonnull nocapture inreg %4)
	; DeferStmt
	; RangeStmt
	; c
	%278 = bitcast %prebuild.main.Component_Definition-250* %21 to %..rawptr
	%279 = call %..rawptr @mem.zero(%..rawptr %278, i64 96) noinline
	store %prebuild.main.Component_Definition-250 zeroinitializer, %prebuild.main.Component_Definition-250* %21
	%280 = load {%prebuild.main.Component_Definition-250*, i64}, {%prebuild.main.Component_Definition-250*, i64}* %19, align 8
	%281 = bitcast i64* %22 to %..rawptr
	%282 = call %..rawptr @mem.zero(%..rawptr %281, i64 8) noinline
	store i64 zeroinitializer, i64* %22
	%283 = extractvalue {%prebuild.main.Component_Definition-250*, i64} %280, 1
	store i64 %283, i64* %22
	%284 = bitcast i64* %23 to %..rawptr
	%285 = call %..rawptr @mem.zero(%..rawptr %284, i64 8) noinline
	store i64 zeroinitializer, i64* %23
	store i64 -1, i64* %23
	br label %for.index.loop-1

for.index.loop-1:
	%286 = load i64, i64* %23, align 8
	%287 = add i64 %286, 1
	store i64 %287, i64* %23
	%288 = load i64, i64* %22, align 8
	%289 = icmp slt i64 %287, %288
	br i1 %289, label %for.index.body-2, label %for.index.done-3

for.index.body-2:
	%290 = load i64, i64* %23, align 8
	%291 = extractvalue {%prebuild.main.Component_Definition-250*, i64} %280, 0
	%292 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %291, i64 %290
	%293 = load %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %292, align 8
	store %prebuild.main.Component_Definition-250 %293, %prebuild.main.Component_Definition-250* %21
	; SelectorExpr
	%294 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %21, i64 0, i32 0
	%295 = load %..string, %..string* %294, align 8
	call void @prebuild.union_field(%..string %295, %runtime.Context* noalias nonnull nocapture inreg %4)
	br label %for.index.loop-1

for.index.done-3:
	; defer
	call void @prebuild.union_end(%runtime.Context* noalias nonnull nocapture inreg %4)
	; variadic call argument generation
	%296 = bitcast {%prebuild.Parameter*, i64}* %24 to %..rawptr
	%297 = call %..rawptr @mem.zero(%..rawptr %296, i64 16) noinline
	store {%prebuild.Parameter*, i64} zeroinitializer, {%prebuild.Parameter*, i64}* %24
	%298 = bitcast [2 x %prebuild.Parameter]* %25 to %..rawptr
	%299 = call %..rawptr @mem.zero(%..rawptr %298, i64 64) noinline
	store [2 x %prebuild.Parameter] zeroinitializer, [2 x %prebuild.Parameter]* %25
	%300 = getelementptr inbounds [2 x %prebuild.Parameter], [2 x %prebuild.Parameter]* %25, i64 0, i32 0
	store %prebuild.Parameter {%..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$220, i64 0, i32 0), i64 6}, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$221, i64 0, i32 0), i64 6}}, %prebuild.Parameter* %300
	%301 = getelementptr inbounds [2 x %prebuild.Parameter], [2 x %prebuild.Parameter]* %25, i64 0, i32 1
	store %prebuild.Parameter {%..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$222, i64 0, i32 0), i64 5}, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$223, i64 0, i32 0), i64 6}}, %prebuild.Parameter* %301
	%302 = getelementptr inbounds [2 x %prebuild.Parameter], [2 x %prebuild.Parameter]* %25, i64 0, i32 0
	%303 = getelementptr inbounds {%prebuild.Parameter*, i64}, {%prebuild.Parameter*, i64}* %24, i64 0, i32 0
	store %prebuild.Parameter* %302, %prebuild.Parameter** %303
	%304 = getelementptr inbounds {%prebuild.Parameter*, i64}, {%prebuild.Parameter*, i64}* %24, i64 0, i32 1
	store i64 2, i64* %304
	%305 = load {%prebuild.Parameter*, i64}, {%prebuild.Parameter*, i64}* %24, align 8
	%306 = bitcast {%prebuild.Parameter*, i64}* %26 to %..rawptr
	%307 = call %..rawptr @mem.zero(%..rawptr %306, i64 16) noinline
	store {%prebuild.Parameter*, i64} zeroinitializer, {%prebuild.Parameter*, i64}* %26
	store {%prebuild.Parameter*, i64} %305, {%prebuild.Parameter*, i64}* %26
	call void @prebuild.procedure_begin(%..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$224, i64 0, i32 0), i64 13}, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$225, i64 0, i32 0), i64 5}, {%prebuild.Parameter*, i64}* %26, %runtime.Context* noalias nonnull nocapture inreg %4)
	; DeferStmt
	; RangeStmt
	; c
	%308 = bitcast %prebuild.main.Component_Definition-250* %27 to %..rawptr
	%309 = call %..rawptr @mem.zero(%..rawptr %308, i64 96) noinline
	store %prebuild.main.Component_Definition-250 zeroinitializer, %prebuild.main.Component_Definition-250* %27
	%310 = load {%prebuild.main.Component_Definition-250*, i64}, {%prebuild.main.Component_Definition-250*, i64}* %19, align 8
	%311 = bitcast i64* %28 to %..rawptr
	%312 = call %..rawptr @mem.zero(%..rawptr %311, i64 8) noinline
	store i64 zeroinitializer, i64* %28
	%313 = extractvalue {%prebuild.main.Component_Definition-250*, i64} %310, 1
	store i64 %313, i64* %28
	%314 = bitcast i64* %29 to %..rawptr
	%315 = call %..rawptr @mem.zero(%..rawptr %314, i64 8) noinline
	store i64 zeroinitializer, i64* %29
	store i64 -1, i64* %29
	br label %for.index.loop-4

for.index.loop-4:
	%316 = load i64, i64* %29, align 8
	%317 = add i64 %316, 1
	store i64 %317, i64* %29
	%318 = load i64, i64* %28, align 8
	%319 = icmp slt i64 %317, %318
	br i1 %319, label %for.index.body-5, label %for.index.done-8

for.index.body-5:
	%320 = load i64, i64* %29, align 8
	%321 = extractvalue {%prebuild.main.Component_Definition-250*, i64} %310, 0
	%322 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %321, i64 %320
	%323 = load %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %322, align 8
	store %prebuild.main.Component_Definition-250 %323, %prebuild.main.Component_Definition-250* %27
	; SelectorExpr
	%324 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %27, i64 0, i32 0
	%325 = load %..string, %..string* %324, align 8
	%326 = bitcast %..string* %30 to %..rawptr
	%327 = call %..rawptr @mem.zero(%..rawptr %326, i64 16) noinline
	store %..string zeroinitializer, %..string* %30
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$226, i64 0, i32 0), i64 13}, %..string* %30
	%328 = load %..string, %..string* %30, align 8
	%329 = bitcast %..any* %31 to %..rawptr
	%330 = call %..rawptr @mem.zero(%..rawptr %329, i64 16) noinline
	store %..any zeroinitializer, %..any* %31
	%331 = bitcast %..string* %30 to %..rawptr
	%332 = getelementptr inbounds %..any, %..any* %31, i64 0, i32 0
	store %..rawptr %331, %..rawptr* %332
	%333 = getelementptr inbounds %..any, %..any* %31, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %333
	%334 = load %..any, %..any* %31, align 8
	%335 = bitcast %..any* %32 to %..rawptr
	%336 = call %..rawptr @mem.zero(%..rawptr %335, i64 16) noinline
	store %..any zeroinitializer, %..any* %32
	%337 = bitcast %..string* %324 to %..rawptr
	%338 = getelementptr inbounds %..any, %..any* %32, i64 0, i32 0
	store %..rawptr %337, %..rawptr* %338
	%339 = getelementptr inbounds %..any, %..any* %32, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %339
	%340 = load %..any, %..any* %32, align 8
	%341 = bitcast %..string* %33 to %..rawptr
	%342 = call %..rawptr @mem.zero(%..rawptr %341, i64 16) noinline
	store %..string zeroinitializer, %..string* %33
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$227, i64 0, i32 0), i64 2}, %..string* %33
	%343 = load %..string, %..string* %33, align 8
	%344 = bitcast %..any* %34 to %..rawptr
	%345 = call %..rawptr @mem.zero(%..rawptr %344, i64 16) noinline
	store %..any zeroinitializer, %..any* %34
	%346 = bitcast %..string* %33 to %..rawptr
	%347 = getelementptr inbounds %..any, %..any* %34, i64 0, i32 0
	store %..rawptr %346, %..rawptr* %347
	%348 = getelementptr inbounds %..any, %..any* %34, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %348
	%349 = load %..any, %..any* %34, align 8
	; variadic call argument generation
	%350 = bitcast {%..any*, i64}* %35 to %..rawptr
	%351 = call %..rawptr @mem.zero(%..rawptr %350, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %35
	%352 = bitcast [3 x %..any]* %36 to %..rawptr
	%353 = call %..rawptr @mem.zero(%..rawptr %352, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %36
	%354 = getelementptr inbounds [3 x %..any], [3 x %..any]* %36, i64 0, i32 0
	store %..any %334, %..any* %354
	%355 = getelementptr inbounds [3 x %..any], [3 x %..any]* %36, i64 0, i32 1
	store %..any %340, %..any* %355
	%356 = getelementptr inbounds [3 x %..any], [3 x %..any]* %36, i64 0, i32 2
	store %..any %349, %..any* %356
	%357 = getelementptr inbounds [3 x %..any], [3 x %..any]* %36, i64 0, i32 0
	%358 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %35, i64 0, i32 0
	store %..any* %357, %..any** %358
	%359 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %35, i64 0, i32 1
	store i64 3, i64* %359
	%360 = load {%..any*, i64}, {%..any*, i64}* %35, align 8
	%361 = bitcast {%..any*, i64}* %37 to %..rawptr
	%362 = call %..rawptr @mem.zero(%..rawptr %361, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %37
	store {%..any*, i64} %360, {%..any*, i64}* %37
	%363 = call %..string @fmt.tprint({%..any*, i64}* %37, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %363, %runtime.Context* noalias nonnull nocapture inreg %4)
	; DeferStmt
	; AssignStmt
	%364 = load i64, i64* @prebuild.indent_level, align 8
	%365 = add i64 %364, 1
	store i64 %365, i64* @prebuild.indent_level
	; DeferStmt
	call void @prebuild.procedure_line(%..string {i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$228, i64 0, i32 0), i64 29}, %runtime.Context* noalias nonnull nocapture inreg %4)
	; SelectorExpr
	%366 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %27, i64 0, i32 1
	%367 = load %..string, %..string* %366, align 8
	%368 = bitcast %..string* %38 to %..rawptr
	%369 = call %..rawptr @mem.zero(%..rawptr %368, i64 16) noinline
	store %..string zeroinitializer, %..string* %38
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$229, i64 0, i32 0), i64 8}, %..string* %38
	%370 = load %..string, %..string* %38, align 8
	%371 = bitcast %..any* %39 to %..rawptr
	%372 = call %..rawptr @mem.zero(%..rawptr %371, i64 16) noinline
	store %..any zeroinitializer, %..any* %39
	%373 = bitcast %..string* %38 to %..rawptr
	%374 = getelementptr inbounds %..any, %..any* %39, i64 0, i32 0
	store %..rawptr %373, %..rawptr* %374
	%375 = getelementptr inbounds %..any, %..any* %39, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %375
	%376 = load %..any, %..any* %39, align 8
	%377 = bitcast %..any* %40 to %..rawptr
	%378 = call %..rawptr @mem.zero(%..rawptr %377, i64 16) noinline
	store %..any zeroinitializer, %..any* %40
	%379 = bitcast %..string* %366 to %..rawptr
	%380 = getelementptr inbounds %..any, %..any* %40, i64 0, i32 0
	store %..rawptr %379, %..rawptr* %380
	%381 = getelementptr inbounds %..any, %..any* %40, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %381
	%382 = load %..any, %..any* %40, align 8
	%383 = bitcast %..string* %41 to %..rawptr
	%384 = call %..rawptr @mem.zero(%..rawptr %383, i64 16) noinline
	store %..string zeroinitializer, %..string* %41
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$22a, i64 0, i32 0), i64 6}, %..string* %41
	%385 = load %..string, %..string* %41, align 8
	%386 = bitcast %..any* %42 to %..rawptr
	%387 = call %..rawptr @mem.zero(%..rawptr %386, i64 16) noinline
	store %..any zeroinitializer, %..any* %42
	%388 = bitcast %..string* %41 to %..rawptr
	%389 = getelementptr inbounds %..any, %..any* %42, i64 0, i32 0
	store %..rawptr %388, %..rawptr* %389
	%390 = getelementptr inbounds %..any, %..any* %42, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %390
	%391 = load %..any, %..any* %42, align 8
	; variadic call argument generation
	%392 = bitcast {%..any*, i64}* %43 to %..rawptr
	%393 = call %..rawptr @mem.zero(%..rawptr %392, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %43
	%394 = bitcast [3 x %..any]* %44 to %..rawptr
	%395 = call %..rawptr @mem.zero(%..rawptr %394, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %44
	%396 = getelementptr inbounds [3 x %..any], [3 x %..any]* %44, i64 0, i32 0
	store %..any %376, %..any* %396
	%397 = getelementptr inbounds [3 x %..any], [3 x %..any]* %44, i64 0, i32 1
	store %..any %382, %..any* %397
	%398 = getelementptr inbounds [3 x %..any], [3 x %..any]* %44, i64 0, i32 2
	store %..any %391, %..any* %398
	%399 = getelementptr inbounds [3 x %..any], [3 x %..any]* %44, i64 0, i32 0
	%400 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %43, i64 0, i32 0
	store %..any* %399, %..any** %400
	%401 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %43, i64 0, i32 1
	store i64 3, i64* %401
	%402 = load {%..any*, i64}, {%..any*, i64}* %43, align 8
	%403 = bitcast {%..any*, i64}* %45 to %..rawptr
	%404 = call %..rawptr @mem.zero(%..rawptr %403, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %45
	store {%..any*, i64} %402, {%..any*, i64}* %45
	%405 = call %..string @fmt.tprint({%..any*, i64}* %45, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %405, %runtime.Context* noalias nonnull nocapture inreg %4)
	; SelectorExpr
	%406 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %27, i64 0, i32 1
	%407 = load %..string, %..string* %406, align 8
	; SelectorExpr
	%408 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %27, i64 0, i32 1
	%409 = load %..string, %..string* %408, align 8
	%410 = bitcast %..string* %46 to %..rawptr
	%411 = call %..rawptr @mem.zero(%..rawptr %410, i64 16) noinline
	store %..string zeroinitializer, %..string* %46
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$22b, i64 0, i32 0), i64 6}, %..string* %46
	%412 = load %..string, %..string* %46, align 8
	%413 = bitcast %..any* %47 to %..rawptr
	%414 = call %..rawptr @mem.zero(%..rawptr %413, i64 16) noinline
	store %..any zeroinitializer, %..any* %47
	%415 = bitcast %..string* %46 to %..rawptr
	%416 = getelementptr inbounds %..any, %..any* %47, i64 0, i32 0
	store %..rawptr %415, %..rawptr* %416
	%417 = getelementptr inbounds %..any, %..any* %47, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %417
	%418 = load %..any, %..any* %47, align 8
	%419 = bitcast %..any* %48 to %..rawptr
	%420 = call %..rawptr @mem.zero(%..rawptr %419, i64 16) noinline
	store %..any zeroinitializer, %..any* %48
	%421 = bitcast %..string* %406 to %..rawptr
	%422 = getelementptr inbounds %..any, %..any* %48, i64 0, i32 0
	store %..rawptr %421, %..rawptr* %422
	%423 = getelementptr inbounds %..any, %..any* %48, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %423
	%424 = load %..any, %..any* %48, align 8
	%425 = bitcast %..string* %49 to %..rawptr
	%426 = call %..rawptr @mem.zero(%..rawptr %425, i64 16) noinline
	store %..string zeroinitializer, %..string* %49
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$22c, i64 0, i32 0), i64 5}, %..string* %49
	%427 = load %..string, %..string* %49, align 8
	%428 = bitcast %..any* %50 to %..rawptr
	%429 = call %..rawptr @mem.zero(%..rawptr %428, i64 16) noinline
	store %..any zeroinitializer, %..any* %50
	%430 = bitcast %..string* %49 to %..rawptr
	%431 = getelementptr inbounds %..any, %..any* %50, i64 0, i32 0
	store %..rawptr %430, %..rawptr* %431
	%432 = getelementptr inbounds %..any, %..any* %50, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %432
	%433 = load %..any, %..any* %50, align 8
	%434 = bitcast %..any* %51 to %..rawptr
	%435 = call %..rawptr @mem.zero(%..rawptr %434, i64 16) noinline
	store %..any zeroinitializer, %..any* %51
	%436 = bitcast %..string* %408 to %..rawptr
	%437 = getelementptr inbounds %..any, %..any* %51, i64 0, i32 0
	store %..rawptr %436, %..rawptr* %437
	%438 = getelementptr inbounds %..any, %..any* %51, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %438
	%439 = load %..any, %..any* %51, align 8
	%440 = bitcast %..string* %52 to %..rawptr
	%441 = call %..rawptr @mem.zero(%..rawptr %440, i64 16) noinline
	store %..string zeroinitializer, %..string* %52
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$22d, i64 0, i32 0), i64 5}, %..string* %52
	%442 = load %..string, %..string* %52, align 8
	%443 = bitcast %..any* %53 to %..rawptr
	%444 = call %..rawptr @mem.zero(%..rawptr %443, i64 16) noinline
	store %..any zeroinitializer, %..any* %53
	%445 = bitcast %..string* %52 to %..rawptr
	%446 = getelementptr inbounds %..any, %..any* %53, i64 0, i32 0
	store %..rawptr %445, %..rawptr* %446
	%447 = getelementptr inbounds %..any, %..any* %53, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %447
	%448 = load %..any, %..any* %53, align 8
	; variadic call argument generation
	%449 = bitcast {%..any*, i64}* %54 to %..rawptr
	%450 = call %..rawptr @mem.zero(%..rawptr %449, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %54
	%451 = bitcast [5 x %..any]* %55 to %..rawptr
	%452 = call %..rawptr @mem.zero(%..rawptr %451, i64 80) noinline
	store [5 x %..any] zeroinitializer, [5 x %..any]* %55
	%453 = getelementptr inbounds [5 x %..any], [5 x %..any]* %55, i64 0, i32 0
	store %..any %418, %..any* %453
	%454 = getelementptr inbounds [5 x %..any], [5 x %..any]* %55, i64 0, i32 1
	store %..any %424, %..any* %454
	%455 = getelementptr inbounds [5 x %..any], [5 x %..any]* %55, i64 0, i32 2
	store %..any %433, %..any* %455
	%456 = getelementptr inbounds [5 x %..any], [5 x %..any]* %55, i64 0, i32 3
	store %..any %439, %..any* %456
	%457 = getelementptr inbounds [5 x %..any], [5 x %..any]* %55, i64 0, i32 4
	store %..any %448, %..any* %457
	%458 = getelementptr inbounds [5 x %..any], [5 x %..any]* %55, i64 0, i32 0
	%459 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %54, i64 0, i32 0
	store %..any* %458, %..any** %459
	%460 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %54, i64 0, i32 1
	store i64 5, i64* %460
	%461 = load {%..any*, i64}, {%..any*, i64}* %54, align 8
	%462 = bitcast {%..any*, i64}* %56 to %..rawptr
	%463 = call %..rawptr @mem.zero(%..rawptr %462, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %56
	store {%..any*, i64} %461, {%..any*, i64}* %56
	%464 = call %..string @fmt.tprint({%..any*, i64}* %56, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %464, %runtime.Context* noalias nonnull nocapture inreg %4)
	; IfStmt
	; SelectorExpr
	%465 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %27, i64 0, i32 2
	%466 = load %..string, %..string* %465, align 8
	%467 = call i8 @runtime.string_ne(%..string %466, %..string zeroinitializer)
	%468 = trunc i8 %467 to i1
	br i1 %468, label %if.then-6, label %if.done-7

if.then-6:
	; SelectorExpr
	%469 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %27, i64 0, i32 2
	%470 = load %..string, %..string* %469, align 8
	%471 = bitcast %..any* %57 to %..rawptr
	%472 = call %..rawptr @mem.zero(%..rawptr %471, i64 16) noinline
	store %..any zeroinitializer, %..any* %57
	%473 = bitcast %..string* %469 to %..rawptr
	%474 = getelementptr inbounds %..any, %..any* %57, i64 0, i32 0
	store %..rawptr %473, %..rawptr* %474
	%475 = getelementptr inbounds %..any, %..any* %57, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %475
	%476 = load %..any, %..any* %57, align 8
	%477 = bitcast %..string* %58 to %..rawptr
	%478 = call %..rawptr @mem.zero(%..rawptr %477, i64 16) noinline
	store %..string zeroinitializer, %..string* %58
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$22e, i64 0, i32 0), i64 4}, %..string* %58
	%479 = load %..string, %..string* %58, align 8
	%480 = bitcast %..any* %59 to %..rawptr
	%481 = call %..rawptr @mem.zero(%..rawptr %480, i64 16) noinline
	store %..any zeroinitializer, %..any* %59
	%482 = bitcast %..string* %58 to %..rawptr
	%483 = getelementptr inbounds %..any, %..any* %59, i64 0, i32 0
	store %..rawptr %482, %..rawptr* %483
	%484 = getelementptr inbounds %..any, %..any* %59, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %484
	%485 = load %..any, %..any* %59, align 8
	; variadic call argument generation
	%486 = bitcast {%..any*, i64}* %60 to %..rawptr
	%487 = call %..rawptr @mem.zero(%..rawptr %486, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %60
	%488 = bitcast [2 x %..any]* %61 to %..rawptr
	%489 = call %..rawptr @mem.zero(%..rawptr %488, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %61
	%490 = getelementptr inbounds [2 x %..any], [2 x %..any]* %61, i64 0, i32 0
	store %..any %476, %..any* %490
	%491 = getelementptr inbounds [2 x %..any], [2 x %..any]* %61, i64 0, i32 1
	store %..any %485, %..any* %491
	%492 = getelementptr inbounds [2 x %..any], [2 x %..any]* %61, i64 0, i32 0
	%493 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %60, i64 0, i32 0
	store %..any* %492, %..any** %493
	%494 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %60, i64 0, i32 1
	store i64 2, i64* %494
	%495 = load {%..any*, i64}, {%..any*, i64}* %60, align 8
	%496 = bitcast {%..any*, i64}* %62 to %..rawptr
	%497 = call %..rawptr @mem.zero(%..rawptr %496, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %62
	store {%..any*, i64} %495, {%..any*, i64}* %62
	%498 = call %..string @fmt.tprint({%..any*, i64}* %62, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %498, %runtime.Context* noalias nonnull nocapture inreg %4)
	br label %if.done-7

if.done-7:
	%499 = bitcast %..string* %63 to %..rawptr
	%500 = call %..rawptr @mem.zero(%..rawptr %499, i64 16) noinline
	store %..string zeroinitializer, %..string* %63
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$22f, i64 0, i32 0), i64 9}, %..string* %63
	%501 = load %..string, %..string* %63, align 8
	%502 = bitcast %..any* %64 to %..rawptr
	%503 = call %..rawptr @mem.zero(%..rawptr %502, i64 16) noinline
	store %..any zeroinitializer, %..any* %64
	%504 = bitcast %..string* %63 to %..rawptr
	%505 = getelementptr inbounds %..any, %..any* %64, i64 0, i32 0
	store %..rawptr %504, %..rawptr* %505
	%506 = getelementptr inbounds %..any, %..any* %64, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %506
	%507 = load %..any, %..any* %64, align 8
	; variadic call argument generation
	%508 = bitcast {%..any*, i64}* %65 to %..rawptr
	%509 = call %..rawptr @mem.zero(%..rawptr %508, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %65
	%510 = bitcast [1 x %..any]* %66 to %..rawptr
	%511 = call %..rawptr @mem.zero(%..rawptr %510, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %66
	%512 = getelementptr inbounds [1 x %..any], [1 x %..any]* %66, i64 0, i32 0
	store %..any %507, %..any* %512
	%513 = getelementptr inbounds [1 x %..any], [1 x %..any]* %66, i64 0, i32 0
	%514 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %65, i64 0, i32 0
	store %..any* %513, %..any** %514
	%515 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %65, i64 0, i32 1
	store i64 1, i64* %515
	%516 = load {%..any*, i64}, {%..any*, i64}* %65, align 8
	%517 = bitcast {%..any*, i64}* %67 to %..rawptr
	%518 = call %..rawptr @mem.zero(%..rawptr %517, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %67
	store {%..any*, i64} %516, {%..any*, i64}* %67
	%519 = call %..string @fmt.tprint({%..any*, i64}* %67, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %519, %runtime.Context* noalias nonnull nocapture inreg %4)
	; defer
	; AssignStmt
	%520 = load i64, i64* @prebuild.indent_level, align 8
	%521 = sub i64 %520, 1
	store i64 %521, i64* @prebuild.indent_level
	; defer
	call void @prebuild.procedure_line(%..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$230, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %4)
	br label %for.index.loop-4

for.index.done-8:
	call void @prebuild.procedure_line(%..string {i8* getelementptr inbounds ([169 x i8], [169 x i8]* @str$231, i64 0, i32 0), i64 168}, %runtime.Context* noalias nonnull nocapture inreg %4)
	; defer
	call void @prebuild.procedure_end(%runtime.Context* noalias nonnull nocapture inreg %4)
	; variadic call argument generation
	%522 = bitcast {%prebuild.Parameter*, i64}* %68 to %..rawptr
	%523 = call %..rawptr @mem.zero(%..rawptr %522, i64 16) noinline
	store {%prebuild.Parameter*, i64} zeroinitializer, {%prebuild.Parameter*, i64}* %68
	%524 = bitcast [2 x %prebuild.Parameter]* %69 to %..rawptr
	%525 = call %..rawptr @mem.zero(%..rawptr %524, i64 64) noinline
	store [2 x %prebuild.Parameter] zeroinitializer, [2 x %prebuild.Parameter]* %69
	%526 = getelementptr inbounds [2 x %prebuild.Parameter], [2 x %prebuild.Parameter]* %69, i64 0, i32 0
	store %prebuild.Parameter {%..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$232, i64 0, i32 0), i64 6}, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$233, i64 0, i32 0), i64 6}}, %prebuild.Parameter* %526
	%527 = getelementptr inbounds [2 x %prebuild.Parameter], [2 x %prebuild.Parameter]* %69, i64 0, i32 1
	store %prebuild.Parameter {%..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$234, i64 0, i32 0), i64 5}, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$235, i64 0, i32 0), i64 6}}, %prebuild.Parameter* %527
	%528 = getelementptr inbounds [2 x %prebuild.Parameter], [2 x %prebuild.Parameter]* %69, i64 0, i32 0
	%529 = getelementptr inbounds {%prebuild.Parameter*, i64}, {%prebuild.Parameter*, i64}* %68, i64 0, i32 0
	store %prebuild.Parameter* %528, %prebuild.Parameter** %529
	%530 = getelementptr inbounds {%prebuild.Parameter*, i64}, {%prebuild.Parameter*, i64}* %68, i64 0, i32 1
	store i64 2, i64* %530
	%531 = load {%prebuild.Parameter*, i64}, {%prebuild.Parameter*, i64}* %68, align 8
	%532 = bitcast {%prebuild.Parameter*, i64}* %70 to %..rawptr
	%533 = call %..rawptr @mem.zero(%..rawptr %532, i64 16) noinline
	store {%prebuild.Parameter*, i64} zeroinitializer, {%prebuild.Parameter*, i64}* %70
	store {%prebuild.Parameter*, i64} %531, {%prebuild.Parameter*, i64}* %70
	call void @prebuild.procedure_begin(%..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$236, i64 0, i32 0), i64 13}, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$237, i64 0, i32 0), i64 5}, {%prebuild.Parameter*, i64}* %70, %runtime.Context* noalias nonnull nocapture inreg %4)
	; DeferStmt
	; RangeStmt
	; c
	%534 = bitcast %prebuild.main.Component_Definition-250* %71 to %..rawptr
	%535 = call %..rawptr @mem.zero(%..rawptr %534, i64 96) noinline
	store %prebuild.main.Component_Definition-250 zeroinitializer, %prebuild.main.Component_Definition-250* %71
	%536 = load {%prebuild.main.Component_Definition-250*, i64}, {%prebuild.main.Component_Definition-250*, i64}* %19, align 8
	%537 = bitcast i64* %72 to %..rawptr
	%538 = call %..rawptr @mem.zero(%..rawptr %537, i64 8) noinline
	store i64 zeroinitializer, i64* %72
	%539 = extractvalue {%prebuild.main.Component_Definition-250*, i64} %536, 1
	store i64 %539, i64* %72
	%540 = bitcast i64* %73 to %..rawptr
	%541 = call %..rawptr @mem.zero(%..rawptr %540, i64 8) noinline
	store i64 zeroinitializer, i64* %73
	store i64 -1, i64* %73
	br label %for.index.loop-9

for.index.loop-9:
	%542 = load i64, i64* %73, align 8
	%543 = add i64 %542, 1
	store i64 %543, i64* %73
	%544 = load i64, i64* %72, align 8
	%545 = icmp slt i64 %543, %544
	br i1 %545, label %for.index.body-10, label %for.index.done-11

for.index.body-10:
	%546 = load i64, i64* %73, align 8
	%547 = extractvalue {%prebuild.main.Component_Definition-250*, i64} %536, 0
	%548 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %547, i64 %546
	%549 = load %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %548, align 8
	store %prebuild.main.Component_Definition-250 %549, %prebuild.main.Component_Definition-250* %71
	; SelectorExpr
	%550 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %71, i64 0, i32 0
	%551 = load %..string, %..string* %550, align 8
	%552 = bitcast %..string* %74 to %..rawptr
	%553 = call %..rawptr @mem.zero(%..rawptr %552, i64 16) noinline
	store %..string zeroinitializer, %..string* %74
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$238, i64 0, i32 0), i64 13}, %..string* %74
	%554 = load %..string, %..string* %74, align 8
	%555 = bitcast %..any* %75 to %..rawptr
	%556 = call %..rawptr @mem.zero(%..rawptr %555, i64 16) noinline
	store %..any zeroinitializer, %..any* %75
	%557 = bitcast %..string* %74 to %..rawptr
	%558 = getelementptr inbounds %..any, %..any* %75, i64 0, i32 0
	store %..rawptr %557, %..rawptr* %558
	%559 = getelementptr inbounds %..any, %..any* %75, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %559
	%560 = load %..any, %..any* %75, align 8
	%561 = bitcast %..any* %76 to %..rawptr
	%562 = call %..rawptr @mem.zero(%..rawptr %561, i64 16) noinline
	store %..any zeroinitializer, %..any* %76
	%563 = bitcast %..string* %550 to %..rawptr
	%564 = getelementptr inbounds %..any, %..any* %76, i64 0, i32 0
	store %..rawptr %563, %..rawptr* %564
	%565 = getelementptr inbounds %..any, %..any* %76, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %565
	%566 = load %..any, %..any* %76, align 8
	%567 = bitcast %..string* %77 to %..rawptr
	%568 = call %..rawptr @mem.zero(%..rawptr %567, i64 16) noinline
	store %..string zeroinitializer, %..string* %77
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$239, i64 0, i32 0), i64 2}, %..string* %77
	%569 = load %..string, %..string* %77, align 8
	%570 = bitcast %..any* %78 to %..rawptr
	%571 = call %..rawptr @mem.zero(%..rawptr %570, i64 16) noinline
	store %..any zeroinitializer, %..any* %78
	%572 = bitcast %..string* %77 to %..rawptr
	%573 = getelementptr inbounds %..any, %..any* %78, i64 0, i32 0
	store %..rawptr %572, %..rawptr* %573
	%574 = getelementptr inbounds %..any, %..any* %78, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %574
	%575 = load %..any, %..any* %78, align 8
	; variadic call argument generation
	%576 = bitcast {%..any*, i64}* %79 to %..rawptr
	%577 = call %..rawptr @mem.zero(%..rawptr %576, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %79
	%578 = bitcast [3 x %..any]* %80 to %..rawptr
	%579 = call %..rawptr @mem.zero(%..rawptr %578, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %80
	%580 = getelementptr inbounds [3 x %..any], [3 x %..any]* %80, i64 0, i32 0
	store %..any %560, %..any* %580
	%581 = getelementptr inbounds [3 x %..any], [3 x %..any]* %80, i64 0, i32 1
	store %..any %566, %..any* %581
	%582 = getelementptr inbounds [3 x %..any], [3 x %..any]* %80, i64 0, i32 2
	store %..any %575, %..any* %582
	%583 = getelementptr inbounds [3 x %..any], [3 x %..any]* %80, i64 0, i32 0
	%584 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %79, i64 0, i32 0
	store %..any* %583, %..any** %584
	%585 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %79, i64 0, i32 1
	store i64 3, i64* %585
	%586 = load {%..any*, i64}, {%..any*, i64}* %79, align 8
	%587 = bitcast {%..any*, i64}* %81 to %..rawptr
	%588 = call %..rawptr @mem.zero(%..rawptr %587, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %81
	store {%..any*, i64} %586, {%..any*, i64}* %81
	%589 = call %..string @fmt.tprint({%..any*, i64}* %81, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %589, %runtime.Context* noalias nonnull nocapture inreg %4)
	; DeferStmt
	; AssignStmt
	%590 = load i64, i64* @prebuild.indent_level, align 8
	%591 = add i64 %590, 1
	store i64 %591, i64* @prebuild.indent_level
	; DeferStmt
	; SelectorExpr
	%592 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %71, i64 0, i32 1
	%593 = load %..string, %..string* %592, align 8
	%594 = bitcast %..string* %82 to %..rawptr
	%595 = call %..rawptr @mem.zero(%..rawptr %594, i64 16) noinline
	store %..string zeroinitializer, %..string* %82
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$23a, i64 0, i32 0), i64 12}, %..string* %82
	%596 = load %..string, %..string* %82, align 8
	%597 = bitcast %..any* %83 to %..rawptr
	%598 = call %..rawptr @mem.zero(%..rawptr %597, i64 16) noinline
	store %..any zeroinitializer, %..any* %83
	%599 = bitcast %..string* %82 to %..rawptr
	%600 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 0
	store %..rawptr %599, %..rawptr* %600
	%601 = getelementptr inbounds %..any, %..any* %83, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %601
	%602 = load %..any, %..any* %83, align 8
	%603 = bitcast %..any* %84 to %..rawptr
	%604 = call %..rawptr @mem.zero(%..rawptr %603, i64 16) noinline
	store %..any zeroinitializer, %..any* %84
	%605 = bitcast %..string* %592 to %..rawptr
	%606 = getelementptr inbounds %..any, %..any* %84, i64 0, i32 0
	store %..rawptr %605, %..rawptr* %606
	%607 = getelementptr inbounds %..any, %..any* %84, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %607
	%608 = load %..any, %..any* %84, align 8
	%609 = bitcast %..string* %85 to %..rawptr
	%610 = call %..rawptr @mem.zero(%..rawptr %609, i64 16) noinline
	store %..string zeroinitializer, %..string* %85
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$23b, i64 0, i32 0), i64 2}, %..string* %85
	%611 = load %..string, %..string* %85, align 8
	%612 = bitcast %..any* %86 to %..rawptr
	%613 = call %..rawptr @mem.zero(%..rawptr %612, i64 16) noinline
	store %..any zeroinitializer, %..any* %86
	%614 = bitcast %..string* %85 to %..rawptr
	%615 = getelementptr inbounds %..any, %..any* %86, i64 0, i32 0
	store %..rawptr %614, %..rawptr* %615
	%616 = getelementptr inbounds %..any, %..any* %86, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %616
	%617 = load %..any, %..any* %86, align 8
	; variadic call argument generation
	%618 = bitcast {%..any*, i64}* %87 to %..rawptr
	%619 = call %..rawptr @mem.zero(%..rawptr %618, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %87
	%620 = bitcast [3 x %..any]* %88 to %..rawptr
	%621 = call %..rawptr @mem.zero(%..rawptr %620, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %88
	%622 = getelementptr inbounds [3 x %..any], [3 x %..any]* %88, i64 0, i32 0
	store %..any %602, %..any* %622
	%623 = getelementptr inbounds [3 x %..any], [3 x %..any]* %88, i64 0, i32 1
	store %..any %608, %..any* %623
	%624 = getelementptr inbounds [3 x %..any], [3 x %..any]* %88, i64 0, i32 2
	store %..any %617, %..any* %624
	%625 = getelementptr inbounds [3 x %..any], [3 x %..any]* %88, i64 0, i32 0
	%626 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %87, i64 0, i32 0
	store %..any* %625, %..any** %626
	%627 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %87, i64 0, i32 1
	store i64 3, i64* %627
	%628 = load {%..any*, i64}, {%..any*, i64}* %87, align 8
	%629 = bitcast {%..any*, i64}* %89 to %..rawptr
	%630 = call %..rawptr @mem.zero(%..rawptr %629, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %89
	store {%..any*, i64} %628, {%..any*, i64}* %89
	%631 = call %..string @fmt.tprint({%..any*, i64}* %89, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %631, %runtime.Context* noalias nonnull nocapture inreg %4)
	; DeferStmt
	; AssignStmt
	%632 = load i64, i64* @prebuild.indent_level, align 8
	%633 = add i64 %632, 1
	store i64 %633, i64* @prebuild.indent_level
	; DeferStmt
	; SelectorExpr
	%634 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %71, i64 0, i32 1
	%635 = load %..string, %..string* %634, align 8
	%636 = bitcast %..string* %90 to %..rawptr
	%637 = call %..rawptr @mem.zero(%..rawptr %636, i64 16) noinline
	store %..string zeroinitializer, %..string* %90
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$23c, i64 0, i32 0), i64 6}, %..string* %90
	%638 = load %..string, %..string* %90, align 8
	%639 = bitcast %..any* %91 to %..rawptr
	%640 = call %..rawptr @mem.zero(%..rawptr %639, i64 16) noinline
	store %..any zeroinitializer, %..any* %91
	%641 = bitcast %..string* %90 to %..rawptr
	%642 = getelementptr inbounds %..any, %..any* %91, i64 0, i32 0
	store %..rawptr %641, %..rawptr* %642
	%643 = getelementptr inbounds %..any, %..any* %91, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %643
	%644 = load %..any, %..any* %91, align 8
	%645 = bitcast %..any* %92 to %..rawptr
	%646 = call %..rawptr @mem.zero(%..rawptr %645, i64 16) noinline
	store %..any zeroinitializer, %..any* %92
	%647 = bitcast %..string* %634 to %..rawptr
	%648 = getelementptr inbounds %..any, %..any* %92, i64 0, i32 0
	store %..rawptr %647, %..rawptr* %648
	%649 = getelementptr inbounds %..any, %..any* %92, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %649
	%650 = load %..any, %..any* %92, align 8
	%651 = bitcast %..string* %93 to %..rawptr
	%652 = call %..rawptr @mem.zero(%..rawptr %651, i64 16) noinline
	store %..string zeroinitializer, %..string* %93
	store %..string {i8* getelementptr inbounds ([40 x i8], [40 x i8]* @str$23d, i64 0, i32 0), i64 39}, %..string* %93
	%653 = load %..string, %..string* %93, align 8
	%654 = bitcast %..any* %94 to %..rawptr
	%655 = call %..rawptr @mem.zero(%..rawptr %654, i64 16) noinline
	store %..any zeroinitializer, %..any* %94
	%656 = bitcast %..string* %93 to %..rawptr
	%657 = getelementptr inbounds %..any, %..any* %94, i64 0, i32 0
	store %..rawptr %656, %..rawptr* %657
	%658 = getelementptr inbounds %..any, %..any* %94, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %658
	%659 = load %..any, %..any* %94, align 8
	; variadic call argument generation
	%660 = bitcast {%..any*, i64}* %95 to %..rawptr
	%661 = call %..rawptr @mem.zero(%..rawptr %660, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %95
	%662 = bitcast [3 x %..any]* %96 to %..rawptr
	%663 = call %..rawptr @mem.zero(%..rawptr %662, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %96
	%664 = getelementptr inbounds [3 x %..any], [3 x %..any]* %96, i64 0, i32 0
	store %..any %644, %..any* %664
	%665 = getelementptr inbounds [3 x %..any], [3 x %..any]* %96, i64 0, i32 1
	store %..any %650, %..any* %665
	%666 = getelementptr inbounds [3 x %..any], [3 x %..any]* %96, i64 0, i32 2
	store %..any %659, %..any* %666
	%667 = getelementptr inbounds [3 x %..any], [3 x %..any]* %96, i64 0, i32 0
	%668 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %95, i64 0, i32 0
	store %..any* %667, %..any** %668
	%669 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %95, i64 0, i32 1
	store i64 3, i64* %669
	%670 = load {%..any*, i64}, {%..any*, i64}* %95, align 8
	%671 = bitcast {%..any*, i64}* %97 to %..rawptr
	%672 = call %..rawptr @mem.zero(%..rawptr %671, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %97
	store {%..any*, i64} %670, {%..any*, i64}* %97
	%673 = call %..string @fmt.tprint({%..any*, i64}* %97, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %673, %runtime.Context* noalias nonnull nocapture inreg %4)
	; defer
	; AssignStmt
	%674 = load i64, i64* @prebuild.indent_level, align 8
	%675 = sub i64 %674, 1
	store i64 %675, i64* @prebuild.indent_level
	; defer
	call void @prebuild.procedure_line(%..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$23e, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %4)
	; defer
	; AssignStmt
	%676 = load i64, i64* @prebuild.indent_level, align 8
	%677 = sub i64 %676, 1
	store i64 %677, i64* @prebuild.indent_level
	; defer
	call void @prebuild.procedure_line(%..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$23f, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %4)
	br label %for.index.loop-9

for.index.done-11:
	call void @prebuild.procedure_line(%..string {i8* getelementptr inbounds ([169 x i8], [169 x i8]* @str$240, i64 0, i32 0), i64 168}, %runtime.Context* noalias nonnull nocapture inreg %4)
	; defer
	call void @prebuild.procedure_end(%runtime.Context* noalias nonnull nocapture inreg %4)
	; variadic call argument generation
	%678 = bitcast {%prebuild.Parameter*, i64}* %98 to %..rawptr
	%679 = call %..rawptr @mem.zero(%..rawptr %678, i64 16) noinline
	store {%prebuild.Parameter*, i64} zeroinitializer, {%prebuild.Parameter*, i64}* %98
	%680 = bitcast [1 x %prebuild.Parameter]* %99 to %..rawptr
	%681 = call %..rawptr @mem.zero(%..rawptr %680, i64 32) noinline
	store [1 x %prebuild.Parameter] zeroinitializer, [1 x %prebuild.Parameter]* %99
	%682 = getelementptr inbounds [1 x %prebuild.Parameter], [1 x %prebuild.Parameter]* %99, i64 0, i32 0
	store %prebuild.Parameter {%..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$241, i64 0, i32 0), i64 9}, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$242, i64 0, i32 0), i64 5}}, %prebuild.Parameter* %682
	%683 = getelementptr inbounds [1 x %prebuild.Parameter], [1 x %prebuild.Parameter]* %99, i64 0, i32 0
	%684 = getelementptr inbounds {%prebuild.Parameter*, i64}, {%prebuild.Parameter*, i64}* %98, i64 0, i32 0
	store %prebuild.Parameter* %683, %prebuild.Parameter** %684
	%685 = getelementptr inbounds {%prebuild.Parameter*, i64}, {%prebuild.Parameter*, i64}* %98, i64 0, i32 1
	store i64 1, i64* %685
	%686 = load {%prebuild.Parameter*, i64}, {%prebuild.Parameter*, i64}* %98, align 8
	%687 = bitcast {%prebuild.Parameter*, i64}* %100 to %..rawptr
	%688 = call %..rawptr @mem.zero(%..rawptr %687, i64 16) noinline
	store {%prebuild.Parameter*, i64} zeroinitializer, {%prebuild.Parameter*, i64}* %100
	store {%prebuild.Parameter*, i64} %686, {%prebuild.Parameter*, i64}* %100
	call void @prebuild.procedure_begin(%..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$243, i64 0, i32 0), i64 17}, %..string zeroinitializer, {%prebuild.Parameter*, i64}* %100, %runtime.Context* noalias nonnull nocapture inreg %4)
	; DeferStmt
	; RangeStmt
	; c
	%689 = bitcast %prebuild.main.Component_Definition-250* %101 to %..rawptr
	%690 = call %..rawptr @mem.zero(%..rawptr %689, i64 96) noinline
	store %prebuild.main.Component_Definition-250 zeroinitializer, %prebuild.main.Component_Definition-250* %101
	%691 = load {%prebuild.main.Component_Definition-250*, i64}, {%prebuild.main.Component_Definition-250*, i64}* %19, align 8
	%692 = bitcast i64* %102 to %..rawptr
	%693 = call %..rawptr @mem.zero(%..rawptr %692, i64 8) noinline
	store i64 zeroinitializer, i64* %102
	%694 = extractvalue {%prebuild.main.Component_Definition-250*, i64} %691, 1
	store i64 %694, i64* %102
	%695 = bitcast i64* %103 to %..rawptr
	%696 = call %..rawptr @mem.zero(%..rawptr %695, i64 8) noinline
	store i64 zeroinitializer, i64* %103
	store i64 -1, i64* %103
	br label %for.index.loop-12

for.index.loop-12:
	%697 = load i64, i64* %103, align 8
	%698 = add i64 %697, 1
	store i64 %698, i64* %103
	%699 = load i64, i64* %102, align 8
	%700 = icmp slt i64 %698, %699
	br i1 %700, label %for.index.body-13, label %for.index.done-16

for.index.body-13:
	%701 = load i64, i64* %103, align 8
	%702 = extractvalue {%prebuild.main.Component_Definition-250*, i64} %691, 0
	%703 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %702, i64 %701
	%704 = load %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %703, align 8
	store %prebuild.main.Component_Definition-250 %704, %prebuild.main.Component_Definition-250* %101
	; IfStmt
	; SelectorExpr
	%705 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %101, i64 0, i32 5
	%706 = load %..string, %..string* %705, align 8
	%707 = call i8 @runtime.string_eq(%..string %706, %..string zeroinitializer)
	%708 = trunc i8 %707 to i1
	br i1 %708, label %if.then-14, label %if.done-15

if.then-14:
	; continue
	br label %for.index.loop-12

if.done-15:
	; SelectorExpr
	%709 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %101, i64 0, i32 0
	%710 = load %..string, %..string* %709, align 8
	%711 = bitcast %..string* %104 to %..rawptr
	%712 = call %..rawptr @mem.zero(%..rawptr %711, i64 16) noinline
	store %..string zeroinitializer, %..string* %104
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$244, i64 0, i32 0), i64 13}, %..string* %104
	%713 = load %..string, %..string* %104, align 8
	%714 = bitcast %..any* %105 to %..rawptr
	%715 = call %..rawptr @mem.zero(%..rawptr %714, i64 16) noinline
	store %..any zeroinitializer, %..any* %105
	%716 = bitcast %..string* %104 to %..rawptr
	%717 = getelementptr inbounds %..any, %..any* %105, i64 0, i32 0
	store %..rawptr %716, %..rawptr* %717
	%718 = getelementptr inbounds %..any, %..any* %105, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %718
	%719 = load %..any, %..any* %105, align 8
	%720 = bitcast %..any* %106 to %..rawptr
	%721 = call %..rawptr @mem.zero(%..rawptr %720, i64 16) noinline
	store %..any zeroinitializer, %..any* %106
	%722 = bitcast %..string* %709 to %..rawptr
	%723 = getelementptr inbounds %..any, %..any* %106, i64 0, i32 0
	store %..rawptr %722, %..rawptr* %723
	%724 = getelementptr inbounds %..any, %..any* %106, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %724
	%725 = load %..any, %..any* %106, align 8
	%726 = bitcast %..string* %107 to %..rawptr
	%727 = call %..rawptr @mem.zero(%..rawptr %726, i64 16) noinline
	store %..string zeroinitializer, %..string* %107
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$245, i64 0, i32 0), i64 2}, %..string* %107
	%728 = load %..string, %..string* %107, align 8
	%729 = bitcast %..any* %108 to %..rawptr
	%730 = call %..rawptr @mem.zero(%..rawptr %729, i64 16) noinline
	store %..any zeroinitializer, %..any* %108
	%731 = bitcast %..string* %107 to %..rawptr
	%732 = getelementptr inbounds %..any, %..any* %108, i64 0, i32 0
	store %..rawptr %731, %..rawptr* %732
	%733 = getelementptr inbounds %..any, %..any* %108, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %733
	%734 = load %..any, %..any* %108, align 8
	; variadic call argument generation
	%735 = bitcast {%..any*, i64}* %109 to %..rawptr
	%736 = call %..rawptr @mem.zero(%..rawptr %735, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %109
	%737 = bitcast [3 x %..any]* %110 to %..rawptr
	%738 = call %..rawptr @mem.zero(%..rawptr %737, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %110
	%739 = getelementptr inbounds [3 x %..any], [3 x %..any]* %110, i64 0, i32 0
	store %..any %719, %..any* %739
	%740 = getelementptr inbounds [3 x %..any], [3 x %..any]* %110, i64 0, i32 1
	store %..any %725, %..any* %740
	%741 = getelementptr inbounds [3 x %..any], [3 x %..any]* %110, i64 0, i32 2
	store %..any %734, %..any* %741
	%742 = getelementptr inbounds [3 x %..any], [3 x %..any]* %110, i64 0, i32 0
	%743 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %109, i64 0, i32 0
	store %..any* %742, %..any** %743
	%744 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %109, i64 0, i32 1
	store i64 3, i64* %744
	%745 = load {%..any*, i64}, {%..any*, i64}* %109, align 8
	%746 = bitcast {%..any*, i64}* %111 to %..rawptr
	%747 = call %..rawptr @mem.zero(%..rawptr %746, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %111
	store {%..any*, i64} %745, {%..any*, i64}* %111
	%748 = call %..string @fmt.tprint({%..any*, i64}* %111, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %748, %runtime.Context* noalias nonnull nocapture inreg %4)
	; DeferStmt
	; AssignStmt
	%749 = load i64, i64* @prebuild.indent_level, align 8
	%750 = add i64 %749, 1
	store i64 %750, i64* @prebuild.indent_level
	; DeferStmt
	; SelectorExpr
	%751 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %101, i64 0, i32 1
	%752 = load %..string, %..string* %751, align 8
	%753 = bitcast %..string* %112 to %..rawptr
	%754 = call %..rawptr @mem.zero(%..rawptr %753, i64 16) noinline
	store %..string zeroinitializer, %..string* %112
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$246, i64 0, i32 0), i64 12}, %..string* %112
	%755 = load %..string, %..string* %112, align 8
	%756 = bitcast %..any* %113 to %..rawptr
	%757 = call %..rawptr @mem.zero(%..rawptr %756, i64 16) noinline
	store %..any zeroinitializer, %..any* %113
	%758 = bitcast %..string* %112 to %..rawptr
	%759 = getelementptr inbounds %..any, %..any* %113, i64 0, i32 0
	store %..rawptr %758, %..rawptr* %759
	%760 = getelementptr inbounds %..any, %..any* %113, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %760
	%761 = load %..any, %..any* %113, align 8
	%762 = bitcast %..any* %114 to %..rawptr
	%763 = call %..rawptr @mem.zero(%..rawptr %762, i64 16) noinline
	store %..any zeroinitializer, %..any* %114
	%764 = bitcast %..string* %751 to %..rawptr
	%765 = getelementptr inbounds %..any, %..any* %114, i64 0, i32 0
	store %..rawptr %764, %..rawptr* %765
	%766 = getelementptr inbounds %..any, %..any* %114, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %766
	%767 = load %..any, %..any* %114, align 8
	%768 = bitcast %..string* %115 to %..rawptr
	%769 = call %..rawptr @mem.zero(%..rawptr %768, i64 16) noinline
	store %..string zeroinitializer, %..string* %115
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$247, i64 0, i32 0), i64 2}, %..string* %115
	%770 = load %..string, %..string* %115, align 8
	%771 = bitcast %..any* %116 to %..rawptr
	%772 = call %..rawptr @mem.zero(%..rawptr %771, i64 16) noinline
	store %..any zeroinitializer, %..any* %116
	%773 = bitcast %..string* %115 to %..rawptr
	%774 = getelementptr inbounds %..any, %..any* %116, i64 0, i32 0
	store %..rawptr %773, %..rawptr* %774
	%775 = getelementptr inbounds %..any, %..any* %116, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %775
	%776 = load %..any, %..any* %116, align 8
	; variadic call argument generation
	%777 = bitcast {%..any*, i64}* %117 to %..rawptr
	%778 = call %..rawptr @mem.zero(%..rawptr %777, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %117
	%779 = bitcast [3 x %..any]* %118 to %..rawptr
	%780 = call %..rawptr @mem.zero(%..rawptr %779, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %118
	%781 = getelementptr inbounds [3 x %..any], [3 x %..any]* %118, i64 0, i32 0
	store %..any %761, %..any* %781
	%782 = getelementptr inbounds [3 x %..any], [3 x %..any]* %118, i64 0, i32 1
	store %..any %767, %..any* %782
	%783 = getelementptr inbounds [3 x %..any], [3 x %..any]* %118, i64 0, i32 2
	store %..any %776, %..any* %783
	%784 = getelementptr inbounds [3 x %..any], [3 x %..any]* %118, i64 0, i32 0
	%785 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %117, i64 0, i32 0
	store %..any* %784, %..any** %785
	%786 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %117, i64 0, i32 1
	store i64 3, i64* %786
	%787 = load {%..any*, i64}, {%..any*, i64}* %117, align 8
	%788 = bitcast {%..any*, i64}* %119 to %..rawptr
	%789 = call %..rawptr @mem.zero(%..rawptr %788, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %119
	store {%..any*, i64} %787, {%..any*, i64}* %119
	%790 = call %..string @fmt.tprint({%..any*, i64}* %119, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %790, %runtime.Context* noalias nonnull nocapture inreg %4)
	; DeferStmt
	; AssignStmt
	%791 = load i64, i64* @prebuild.indent_level, align 8
	%792 = add i64 %791, 1
	store i64 %792, i64* @prebuild.indent_level
	; DeferStmt
	; SelectorExpr
	%793 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %101, i64 0, i32 1
	%794 = load %..string, %..string* %793, align 8
	%795 = bitcast %..string* %120 to %..rawptr
	%796 = call %..rawptr @mem.zero(%..rawptr %795, i64 16) noinline
	store %..string zeroinitializer, %..string* %120
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$248, i64 0, i32 0), i64 6}, %..string* %120
	%797 = load %..string, %..string* %120, align 8
	%798 = bitcast %..any* %121 to %..rawptr
	%799 = call %..rawptr @mem.zero(%..rawptr %798, i64 16) noinline
	store %..any zeroinitializer, %..any* %121
	%800 = bitcast %..string* %120 to %..rawptr
	%801 = getelementptr inbounds %..any, %..any* %121, i64 0, i32 0
	store %..rawptr %800, %..rawptr* %801
	%802 = getelementptr inbounds %..any, %..any* %121, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %802
	%803 = load %..any, %..any* %121, align 8
	%804 = bitcast %..any* %122 to %..rawptr
	%805 = call %..rawptr @mem.zero(%..rawptr %804, i64 16) noinline
	store %..any zeroinitializer, %..any* %122
	%806 = bitcast %..string* %793 to %..rawptr
	%807 = getelementptr inbounds %..any, %..any* %122, i64 0, i32 0
	store %..rawptr %806, %..rawptr* %807
	%808 = getelementptr inbounds %..any, %..any* %122, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %808
	%809 = load %..any, %..any* %122, align 8
	%810 = bitcast %..string* %123 to %..rawptr
	%811 = call %..rawptr @mem.zero(%..rawptr %810, i64 16) noinline
	store %..string zeroinitializer, %..string* %123
	store %..string {i8* getelementptr inbounds ([40 x i8], [40 x i8]* @str$249, i64 0, i32 0), i64 39}, %..string* %123
	%812 = load %..string, %..string* %123, align 8
	%813 = bitcast %..any* %124 to %..rawptr
	%814 = call %..rawptr @mem.zero(%..rawptr %813, i64 16) noinline
	store %..any zeroinitializer, %..any* %124
	%815 = bitcast %..string* %123 to %..rawptr
	%816 = getelementptr inbounds %..any, %..any* %124, i64 0, i32 0
	store %..rawptr %815, %..rawptr* %816
	%817 = getelementptr inbounds %..any, %..any* %124, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %817
	%818 = load %..any, %..any* %124, align 8
	; variadic call argument generation
	%819 = bitcast {%..any*, i64}* %125 to %..rawptr
	%820 = call %..rawptr @mem.zero(%..rawptr %819, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %125
	%821 = bitcast [3 x %..any]* %126 to %..rawptr
	%822 = call %..rawptr @mem.zero(%..rawptr %821, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %126
	%823 = getelementptr inbounds [3 x %..any], [3 x %..any]* %126, i64 0, i32 0
	store %..any %803, %..any* %823
	%824 = getelementptr inbounds [3 x %..any], [3 x %..any]* %126, i64 0, i32 1
	store %..any %809, %..any* %824
	%825 = getelementptr inbounds [3 x %..any], [3 x %..any]* %126, i64 0, i32 2
	store %..any %818, %..any* %825
	%826 = getelementptr inbounds [3 x %..any], [3 x %..any]* %126, i64 0, i32 0
	%827 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %125, i64 0, i32 0
	store %..any* %826, %..any** %827
	%828 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %125, i64 0, i32 1
	store i64 3, i64* %828
	%829 = load {%..any*, i64}, {%..any*, i64}* %125, align 8
	%830 = bitcast {%..any*, i64}* %127 to %..rawptr
	%831 = call %..rawptr @mem.zero(%..rawptr %830, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %127
	store {%..any*, i64} %829, {%..any*, i64}* %127
	%832 = call %..string @fmt.tprint({%..any*, i64}* %127, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %832, %runtime.Context* noalias nonnull nocapture inreg %4)
	; defer
	; AssignStmt
	%833 = load i64, i64* @prebuild.indent_level, align 8
	%834 = sub i64 %833, 1
	store i64 %834, i64* @prebuild.indent_level
	; defer
	call void @prebuild.procedure_line(%..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$24a, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %4)
	; defer
	; AssignStmt
	%835 = load i64, i64* @prebuild.indent_level, align 8
	%836 = sub i64 %835, 1
	store i64 %836, i64* @prebuild.indent_level
	; defer
	call void @prebuild.procedure_line(%..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$24b, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %4)
	br label %for.index.loop-12

for.index.done-16:
	; defer
	call void @prebuild.procedure_end(%runtime.Context* noalias nonnull nocapture inreg %4)
	; variadic call argument generation
	%837 = bitcast {%prebuild.Parameter*, i64}* %128 to %..rawptr
	%838 = call %..rawptr @mem.zero(%..rawptr %837, i64 16) noinline
	store {%prebuild.Parameter*, i64} zeroinitializer, {%prebuild.Parameter*, i64}* %128
	%839 = load {%prebuild.Parameter*, i64}, {%prebuild.Parameter*, i64}* %128, align 8
	%840 = bitcast {%prebuild.Parameter*, i64}* %129 to %..rawptr
	%841 = call %..rawptr @mem.zero(%..rawptr %840, i64 16) noinline
	store {%prebuild.Parameter*, i64} zeroinitializer, {%prebuild.Parameter*, i64}* %129
	store {%prebuild.Parameter*, i64} %839, {%prebuild.Parameter*, i64}* %129
	call void @prebuild.procedure_begin(%..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$24c, i64 0, i32 0), i64 22}, %..string zeroinitializer, {%prebuild.Parameter*, i64}* %129, %runtime.Context* noalias nonnull nocapture inreg %4)
	; DeferStmt
	; RangeStmt
	; c
	%842 = bitcast %prebuild.main.Component_Definition-250* %130 to %..rawptr
	%843 = call %..rawptr @mem.zero(%..rawptr %842, i64 96) noinline
	store %prebuild.main.Component_Definition-250 zeroinitializer, %prebuild.main.Component_Definition-250* %130
	%844 = load {%prebuild.main.Component_Definition-250*, i64}, {%prebuild.main.Component_Definition-250*, i64}* %19, align 8
	%845 = bitcast i64* %131 to %..rawptr
	%846 = call %..rawptr @mem.zero(%..rawptr %845, i64 8) noinline
	store i64 zeroinitializer, i64* %131
	%847 = extractvalue {%prebuild.main.Component_Definition-250*, i64} %844, 1
	store i64 %847, i64* %131
	%848 = bitcast i64* %132 to %..rawptr
	%849 = call %..rawptr @mem.zero(%..rawptr %848, i64 8) noinline
	store i64 zeroinitializer, i64* %132
	store i64 -1, i64* %132
	br label %for.index.loop-17

for.index.loop-17:
	%850 = load i64, i64* %132, align 8
	%851 = add i64 %850, 1
	store i64 %851, i64* %132
	%852 = load i64, i64* %131, align 8
	%853 = icmp slt i64 %851, %852
	br i1 %853, label %for.index.body-18, label %for.index.done-21

for.index.body-18:
	%854 = load i64, i64* %132, align 8
	%855 = extractvalue {%prebuild.main.Component_Definition-250*, i64} %844, 0
	%856 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %855, i64 %854
	%857 = load %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %856, align 8
	store %prebuild.main.Component_Definition-250 %857, %prebuild.main.Component_Definition-250* %130
	; IfStmt
	; SelectorExpr
	%858 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %130, i64 0, i32 3
	%859 = load %..string, %..string* %858, align 8
	%860 = call i8 @runtime.string_eq(%..string %859, %..string zeroinitializer)
	%861 = trunc i8 %860 to i1
	br i1 %861, label %if.then-19, label %if.done-20

if.then-19:
	; continue
	br label %for.index.loop-17

if.done-20:
	; SelectorExpr
	%862 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %130, i64 0, i32 1
	%863 = load %..string, %..string* %862, align 8
	%864 = bitcast %..string* %133 to %..rawptr
	%865 = call %..rawptr @mem.zero(%..rawptr %864, i64 16) noinline
	store %..string zeroinitializer, %..string* %133
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$24d, i64 0, i32 0), i64 12}, %..string* %133
	%866 = load %..string, %..string* %133, align 8
	%867 = bitcast %..any* %134 to %..rawptr
	%868 = call %..rawptr @mem.zero(%..rawptr %867, i64 16) noinline
	store %..any zeroinitializer, %..any* %134
	%869 = bitcast %..string* %133 to %..rawptr
	%870 = getelementptr inbounds %..any, %..any* %134, i64 0, i32 0
	store %..rawptr %869, %..rawptr* %870
	%871 = getelementptr inbounds %..any, %..any* %134, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %871
	%872 = load %..any, %..any* %134, align 8
	%873 = bitcast %..any* %135 to %..rawptr
	%874 = call %..rawptr @mem.zero(%..rawptr %873, i64 16) noinline
	store %..any zeroinitializer, %..any* %135
	%875 = bitcast %..string* %862 to %..rawptr
	%876 = getelementptr inbounds %..any, %..any* %135, i64 0, i32 0
	store %..rawptr %875, %..rawptr* %876
	%877 = getelementptr inbounds %..any, %..any* %135, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %877
	%878 = load %..any, %..any* %135, align 8
	%879 = bitcast %..string* %136 to %..rawptr
	%880 = call %..rawptr @mem.zero(%..rawptr %879, i64 16) noinline
	store %..string zeroinitializer, %..string* %136
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$24e, i64 0, i32 0), i64 2}, %..string* %136
	%881 = load %..string, %..string* %136, align 8
	%882 = bitcast %..any* %137 to %..rawptr
	%883 = call %..rawptr @mem.zero(%..rawptr %882, i64 16) noinline
	store %..any zeroinitializer, %..any* %137
	%884 = bitcast %..string* %136 to %..rawptr
	%885 = getelementptr inbounds %..any, %..any* %137, i64 0, i32 0
	store %..rawptr %884, %..rawptr* %885
	%886 = getelementptr inbounds %..any, %..any* %137, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %886
	%887 = load %..any, %..any* %137, align 8
	; variadic call argument generation
	%888 = bitcast {%..any*, i64}* %138 to %..rawptr
	%889 = call %..rawptr @mem.zero(%..rawptr %888, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %138
	%890 = bitcast [3 x %..any]* %139 to %..rawptr
	%891 = call %..rawptr @mem.zero(%..rawptr %890, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %139
	%892 = getelementptr inbounds [3 x %..any], [3 x %..any]* %139, i64 0, i32 0
	store %..any %872, %..any* %892
	%893 = getelementptr inbounds [3 x %..any], [3 x %..any]* %139, i64 0, i32 1
	store %..any %878, %..any* %893
	%894 = getelementptr inbounds [3 x %..any], [3 x %..any]* %139, i64 0, i32 2
	store %..any %887, %..any* %894
	%895 = getelementptr inbounds [3 x %..any], [3 x %..any]* %139, i64 0, i32 0
	%896 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %138, i64 0, i32 0
	store %..any* %895, %..any** %896
	%897 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %138, i64 0, i32 1
	store i64 3, i64* %897
	%898 = load {%..any*, i64}, {%..any*, i64}* %138, align 8
	%899 = bitcast {%..any*, i64}* %140 to %..rawptr
	%900 = call %..rawptr @mem.zero(%..rawptr %899, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %140
	store {%..any*, i64} %898, {%..any*, i64}* %140
	%901 = call %..string @fmt.tprint({%..any*, i64}* %140, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %901, %runtime.Context* noalias nonnull nocapture inreg %4)
	; DeferStmt
	; AssignStmt
	%902 = load i64, i64* @prebuild.indent_level, align 8
	%903 = add i64 %902, 1
	store i64 %903, i64* @prebuild.indent_level
	; DeferStmt
	; SelectorExpr
	%904 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %130, i64 0, i32 1
	%905 = load %..string, %..string* %904, align 8
	; SelectorExpr
	%906 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %130, i64 0, i32 3
	%907 = load %..string, %..string* %906, align 8
	%908 = bitcast %..string* %141 to %..rawptr
	%909 = call %..rawptr @mem.zero(%..rawptr %908, i64 16) noinline
	store %..string zeroinitializer, %..string* %141
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$24f, i64 0, i32 0), i64 6}, %..string* %141
	%910 = load %..string, %..string* %141, align 8
	%911 = bitcast %..any* %142 to %..rawptr
	%912 = call %..rawptr @mem.zero(%..rawptr %911, i64 16) noinline
	store %..any zeroinitializer, %..any* %142
	%913 = bitcast %..string* %141 to %..rawptr
	%914 = getelementptr inbounds %..any, %..any* %142, i64 0, i32 0
	store %..rawptr %913, %..rawptr* %914
	%915 = getelementptr inbounds %..any, %..any* %142, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %915
	%916 = load %..any, %..any* %142, align 8
	%917 = bitcast %..any* %143 to %..rawptr
	%918 = call %..rawptr @mem.zero(%..rawptr %917, i64 16) noinline
	store %..any zeroinitializer, %..any* %143
	%919 = bitcast %..string* %904 to %..rawptr
	%920 = getelementptr inbounds %..any, %..any* %143, i64 0, i32 0
	store %..rawptr %919, %..rawptr* %920
	%921 = getelementptr inbounds %..any, %..any* %143, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %921
	%922 = load %..any, %..any* %143, align 8
	%923 = bitcast %..string* %144 to %..rawptr
	%924 = call %..rawptr @mem.zero(%..rawptr %923, i64 16) noinline
	store %..string zeroinitializer, %..string* %144
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$250, i64 0, i32 0), i64 5}, %..string* %144
	%925 = load %..string, %..string* %144, align 8
	%926 = bitcast %..any* %145 to %..rawptr
	%927 = call %..rawptr @mem.zero(%..rawptr %926, i64 16) noinline
	store %..any zeroinitializer, %..any* %145
	%928 = bitcast %..string* %144 to %..rawptr
	%929 = getelementptr inbounds %..any, %..any* %145, i64 0, i32 0
	store %..rawptr %928, %..rawptr* %929
	%930 = getelementptr inbounds %..any, %..any* %145, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %930
	%931 = load %..any, %..any* %145, align 8
	%932 = bitcast %..any* %146 to %..rawptr
	%933 = call %..rawptr @mem.zero(%..rawptr %932, i64 16) noinline
	store %..any zeroinitializer, %..any* %146
	%934 = bitcast %..string* %906 to %..rawptr
	%935 = getelementptr inbounds %..any, %..any* %146, i64 0, i32 0
	store %..rawptr %934, %..rawptr* %935
	%936 = getelementptr inbounds %..any, %..any* %146, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %936
	%937 = load %..any, %..any* %146, align 8
	%938 = bitcast %..string* %147 to %..rawptr
	%939 = call %..rawptr @mem.zero(%..rawptr %938, i64 16) noinline
	store %..string zeroinitializer, %..string* %147
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$251, i64 0, i32 0), i64 4}, %..string* %147
	%940 = load %..string, %..string* %147, align 8
	%941 = bitcast %..any* %148 to %..rawptr
	%942 = call %..rawptr @mem.zero(%..rawptr %941, i64 16) noinline
	store %..any zeroinitializer, %..any* %148
	%943 = bitcast %..string* %147 to %..rawptr
	%944 = getelementptr inbounds %..any, %..any* %148, i64 0, i32 0
	store %..rawptr %943, %..rawptr* %944
	%945 = getelementptr inbounds %..any, %..any* %148, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %945
	%946 = load %..any, %..any* %148, align 8
	; variadic call argument generation
	%947 = bitcast {%..any*, i64}* %149 to %..rawptr
	%948 = call %..rawptr @mem.zero(%..rawptr %947, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %149
	%949 = bitcast [5 x %..any]* %150 to %..rawptr
	%950 = call %..rawptr @mem.zero(%..rawptr %949, i64 80) noinline
	store [5 x %..any] zeroinitializer, [5 x %..any]* %150
	%951 = getelementptr inbounds [5 x %..any], [5 x %..any]* %150, i64 0, i32 0
	store %..any %916, %..any* %951
	%952 = getelementptr inbounds [5 x %..any], [5 x %..any]* %150, i64 0, i32 1
	store %..any %922, %..any* %952
	%953 = getelementptr inbounds [5 x %..any], [5 x %..any]* %150, i64 0, i32 2
	store %..any %931, %..any* %953
	%954 = getelementptr inbounds [5 x %..any], [5 x %..any]* %150, i64 0, i32 3
	store %..any %937, %..any* %954
	%955 = getelementptr inbounds [5 x %..any], [5 x %..any]* %150, i64 0, i32 4
	store %..any %946, %..any* %955
	%956 = getelementptr inbounds [5 x %..any], [5 x %..any]* %150, i64 0, i32 0
	%957 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %149, i64 0, i32 0
	store %..any* %956, %..any** %957
	%958 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %149, i64 0, i32 1
	store i64 5, i64* %958
	%959 = load {%..any*, i64}, {%..any*, i64}* %149, align 8
	%960 = bitcast {%..any*, i64}* %151 to %..rawptr
	%961 = call %..rawptr @mem.zero(%..rawptr %960, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %151
	store {%..any*, i64} %959, {%..any*, i64}* %151
	%962 = call %..string @fmt.tprint({%..any*, i64}* %151, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %962, %runtime.Context* noalias nonnull nocapture inreg %4)
	; defer
	; AssignStmt
	%963 = load i64, i64* @prebuild.indent_level, align 8
	%964 = sub i64 %963, 1
	store i64 %964, i64* @prebuild.indent_level
	; defer
	call void @prebuild.procedure_line(%..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$252, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %4)
	br label %for.index.loop-17

for.index.done-21:
	; defer
	call void @prebuild.procedure_end(%runtime.Context* noalias nonnull nocapture inreg %4)
	; variadic call argument generation
	%965 = bitcast {%prebuild.Parameter*, i64}* %152 to %..rawptr
	%966 = call %..rawptr @mem.zero(%..rawptr %965, i64 16) noinline
	store {%prebuild.Parameter*, i64} zeroinitializer, {%prebuild.Parameter*, i64}* %152
	%967 = load {%prebuild.Parameter*, i64}, {%prebuild.Parameter*, i64}* %152, align 8
	%968 = bitcast {%prebuild.Parameter*, i64}* %153 to %..rawptr
	%969 = call %..rawptr @mem.zero(%..rawptr %968, i64 16) noinline
	store {%prebuild.Parameter*, i64} zeroinitializer, {%prebuild.Parameter*, i64}* %153
	store {%prebuild.Parameter*, i64} %967, {%prebuild.Parameter*, i64}* %153
	call void @prebuild.procedure_begin(%..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$253, i64 0, i32 0), i64 22}, %..string zeroinitializer, {%prebuild.Parameter*, i64}* %153, %runtime.Context* noalias nonnull nocapture inreg %4)
	; DeferStmt
	; RangeStmt
	; c
	%970 = bitcast %prebuild.main.Component_Definition-250* %154 to %..rawptr
	%971 = call %..rawptr @mem.zero(%..rawptr %970, i64 96) noinline
	store %prebuild.main.Component_Definition-250 zeroinitializer, %prebuild.main.Component_Definition-250* %154
	%972 = load {%prebuild.main.Component_Definition-250*, i64}, {%prebuild.main.Component_Definition-250*, i64}* %19, align 8
	%973 = bitcast i64* %155 to %..rawptr
	%974 = call %..rawptr @mem.zero(%..rawptr %973, i64 8) noinline
	store i64 zeroinitializer, i64* %155
	%975 = extractvalue {%prebuild.main.Component_Definition-250*, i64} %972, 1
	store i64 %975, i64* %155
	%976 = bitcast i64* %156 to %..rawptr
	%977 = call %..rawptr @mem.zero(%..rawptr %976, i64 8) noinline
	store i64 zeroinitializer, i64* %156
	store i64 -1, i64* %156
	br label %for.index.loop-22

for.index.loop-22:
	%978 = load i64, i64* %156, align 8
	%979 = add i64 %978, 1
	store i64 %979, i64* %156
	%980 = load i64, i64* %155, align 8
	%981 = icmp slt i64 %979, %980
	br i1 %981, label %for.index.body-23, label %for.index.done-26

for.index.body-23:
	%982 = load i64, i64* %156, align 8
	%983 = extractvalue {%prebuild.main.Component_Definition-250*, i64} %972, 0
	%984 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %983, i64 %982
	%985 = load %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %984, align 8
	store %prebuild.main.Component_Definition-250 %985, %prebuild.main.Component_Definition-250* %154
	; IfStmt
	; SelectorExpr
	%986 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %154, i64 0, i32 4
	%987 = load %..string, %..string* %986, align 8
	%988 = call i8 @runtime.string_eq(%..string %987, %..string zeroinitializer)
	%989 = trunc i8 %988 to i1
	br i1 %989, label %if.then-24, label %if.done-25

if.then-24:
	; continue
	br label %for.index.loop-22

if.done-25:
	; SelectorExpr
	%990 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %154, i64 0, i32 1
	%991 = load %..string, %..string* %990, align 8
	%992 = bitcast %..string* %157 to %..rawptr
	%993 = call %..rawptr @mem.zero(%..rawptr %992, i64 16) noinline
	store %..string zeroinitializer, %..string* %157
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$254, i64 0, i32 0), i64 12}, %..string* %157
	%994 = load %..string, %..string* %157, align 8
	%995 = bitcast %..any* %158 to %..rawptr
	%996 = call %..rawptr @mem.zero(%..rawptr %995, i64 16) noinline
	store %..any zeroinitializer, %..any* %158
	%997 = bitcast %..string* %157 to %..rawptr
	%998 = getelementptr inbounds %..any, %..any* %158, i64 0, i32 0
	store %..rawptr %997, %..rawptr* %998
	%999 = getelementptr inbounds %..any, %..any* %158, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %999
	%1000 = load %..any, %..any* %158, align 8
	%1001 = bitcast %..any* %159 to %..rawptr
	%1002 = call %..rawptr @mem.zero(%..rawptr %1001, i64 16) noinline
	store %..any zeroinitializer, %..any* %159
	%1003 = bitcast %..string* %990 to %..rawptr
	%1004 = getelementptr inbounds %..any, %..any* %159, i64 0, i32 0
	store %..rawptr %1003, %..rawptr* %1004
	%1005 = getelementptr inbounds %..any, %..any* %159, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %1005
	%1006 = load %..any, %..any* %159, align 8
	%1007 = bitcast %..string* %160 to %..rawptr
	%1008 = call %..rawptr @mem.zero(%..rawptr %1007, i64 16) noinline
	store %..string zeroinitializer, %..string* %160
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$255, i64 0, i32 0), i64 2}, %..string* %160
	%1009 = load %..string, %..string* %160, align 8
	%1010 = bitcast %..any* %161 to %..rawptr
	%1011 = call %..rawptr @mem.zero(%..rawptr %1010, i64 16) noinline
	store %..any zeroinitializer, %..any* %161
	%1012 = bitcast %..string* %160 to %..rawptr
	%1013 = getelementptr inbounds %..any, %..any* %161, i64 0, i32 0
	store %..rawptr %1012, %..rawptr* %1013
	%1014 = getelementptr inbounds %..any, %..any* %161, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %1014
	%1015 = load %..any, %..any* %161, align 8
	; variadic call argument generation
	%1016 = bitcast {%..any*, i64}* %162 to %..rawptr
	%1017 = call %..rawptr @mem.zero(%..rawptr %1016, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %162
	%1018 = bitcast [3 x %..any]* %163 to %..rawptr
	%1019 = call %..rawptr @mem.zero(%..rawptr %1018, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %163
	%1020 = getelementptr inbounds [3 x %..any], [3 x %..any]* %163, i64 0, i32 0
	store %..any %1000, %..any* %1020
	%1021 = getelementptr inbounds [3 x %..any], [3 x %..any]* %163, i64 0, i32 1
	store %..any %1006, %..any* %1021
	%1022 = getelementptr inbounds [3 x %..any], [3 x %..any]* %163, i64 0, i32 2
	store %..any %1015, %..any* %1022
	%1023 = getelementptr inbounds [3 x %..any], [3 x %..any]* %163, i64 0, i32 0
	%1024 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %162, i64 0, i32 0
	store %..any* %1023, %..any** %1024
	%1025 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %162, i64 0, i32 1
	store i64 3, i64* %1025
	%1026 = load {%..any*, i64}, {%..any*, i64}* %162, align 8
	%1027 = bitcast {%..any*, i64}* %164 to %..rawptr
	%1028 = call %..rawptr @mem.zero(%..rawptr %1027, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %164
	store {%..any*, i64} %1026, {%..any*, i64}* %164
	%1029 = call %..string @fmt.tprint({%..any*, i64}* %164, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %1029, %runtime.Context* noalias nonnull nocapture inreg %4)
	; DeferStmt
	; AssignStmt
	%1030 = load i64, i64* @prebuild.indent_level, align 8
	%1031 = add i64 %1030, 1
	store i64 %1031, i64* @prebuild.indent_level
	; DeferStmt
	; SelectorExpr
	%1032 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %154, i64 0, i32 1
	%1033 = load %..string, %..string* %1032, align 8
	; SelectorExpr
	%1034 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %154, i64 0, i32 4
	%1035 = load %..string, %..string* %1034, align 8
	%1036 = bitcast %..string* %165 to %..rawptr
	%1037 = call %..rawptr @mem.zero(%..rawptr %1036, i64 16) noinline
	store %..string zeroinitializer, %..string* %165
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$256, i64 0, i32 0), i64 6}, %..string* %165
	%1038 = load %..string, %..string* %165, align 8
	%1039 = bitcast %..any* %166 to %..rawptr
	%1040 = call %..rawptr @mem.zero(%..rawptr %1039, i64 16) noinline
	store %..any zeroinitializer, %..any* %166
	%1041 = bitcast %..string* %165 to %..rawptr
	%1042 = getelementptr inbounds %..any, %..any* %166, i64 0, i32 0
	store %..rawptr %1041, %..rawptr* %1042
	%1043 = getelementptr inbounds %..any, %..any* %166, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %1043
	%1044 = load %..any, %..any* %166, align 8
	%1045 = bitcast %..any* %167 to %..rawptr
	%1046 = call %..rawptr @mem.zero(%..rawptr %1045, i64 16) noinline
	store %..any zeroinitializer, %..any* %167
	%1047 = bitcast %..string* %1032 to %..rawptr
	%1048 = getelementptr inbounds %..any, %..any* %167, i64 0, i32 0
	store %..rawptr %1047, %..rawptr* %1048
	%1049 = getelementptr inbounds %..any, %..any* %167, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %1049
	%1050 = load %..any, %..any* %167, align 8
	%1051 = bitcast %..string* %168 to %..rawptr
	%1052 = call %..rawptr @mem.zero(%..rawptr %1051, i64 16) noinline
	store %..string zeroinitializer, %..string* %168
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$257, i64 0, i32 0), i64 5}, %..string* %168
	%1053 = load %..string, %..string* %168, align 8
	%1054 = bitcast %..any* %169 to %..rawptr
	%1055 = call %..rawptr @mem.zero(%..rawptr %1054, i64 16) noinline
	store %..any zeroinitializer, %..any* %169
	%1056 = bitcast %..string* %168 to %..rawptr
	%1057 = getelementptr inbounds %..any, %..any* %169, i64 0, i32 0
	store %..rawptr %1056, %..rawptr* %1057
	%1058 = getelementptr inbounds %..any, %..any* %169, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %1058
	%1059 = load %..any, %..any* %169, align 8
	%1060 = bitcast %..any* %170 to %..rawptr
	%1061 = call %..rawptr @mem.zero(%..rawptr %1060, i64 16) noinline
	store %..any zeroinitializer, %..any* %170
	%1062 = bitcast %..string* %1034 to %..rawptr
	%1063 = getelementptr inbounds %..any, %..any* %170, i64 0, i32 0
	store %..rawptr %1062, %..rawptr* %1063
	%1064 = getelementptr inbounds %..any, %..any* %170, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %1064
	%1065 = load %..any, %..any* %170, align 8
	%1066 = bitcast %..string* %171 to %..rawptr
	%1067 = call %..rawptr @mem.zero(%..rawptr %1066, i64 16) noinline
	store %..string zeroinitializer, %..string* %171
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$258, i64 0, i32 0), i64 4}, %..string* %171
	%1068 = load %..string, %..string* %171, align 8
	%1069 = bitcast %..any* %172 to %..rawptr
	%1070 = call %..rawptr @mem.zero(%..rawptr %1069, i64 16) noinline
	store %..any zeroinitializer, %..any* %172
	%1071 = bitcast %..string* %171 to %..rawptr
	%1072 = getelementptr inbounds %..any, %..any* %172, i64 0, i32 0
	store %..rawptr %1071, %..rawptr* %1072
	%1073 = getelementptr inbounds %..any, %..any* %172, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %1073
	%1074 = load %..any, %..any* %172, align 8
	; variadic call argument generation
	%1075 = bitcast {%..any*, i64}* %173 to %..rawptr
	%1076 = call %..rawptr @mem.zero(%..rawptr %1075, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %173
	%1077 = bitcast [5 x %..any]* %174 to %..rawptr
	%1078 = call %..rawptr @mem.zero(%..rawptr %1077, i64 80) noinline
	store [5 x %..any] zeroinitializer, [5 x %..any]* %174
	%1079 = getelementptr inbounds [5 x %..any], [5 x %..any]* %174, i64 0, i32 0
	store %..any %1044, %..any* %1079
	%1080 = getelementptr inbounds [5 x %..any], [5 x %..any]* %174, i64 0, i32 1
	store %..any %1050, %..any* %1080
	%1081 = getelementptr inbounds [5 x %..any], [5 x %..any]* %174, i64 0, i32 2
	store %..any %1059, %..any* %1081
	%1082 = getelementptr inbounds [5 x %..any], [5 x %..any]* %174, i64 0, i32 3
	store %..any %1065, %..any* %1082
	%1083 = getelementptr inbounds [5 x %..any], [5 x %..any]* %174, i64 0, i32 4
	store %..any %1074, %..any* %1083
	%1084 = getelementptr inbounds [5 x %..any], [5 x %..any]* %174, i64 0, i32 0
	%1085 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %173, i64 0, i32 0
	store %..any* %1084, %..any** %1085
	%1086 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %173, i64 0, i32 1
	store i64 5, i64* %1086
	%1087 = load {%..any*, i64}, {%..any*, i64}* %173, align 8
	%1088 = bitcast {%..any*, i64}* %175 to %..rawptr
	%1089 = call %..rawptr @mem.zero(%..rawptr %1088, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %175
	store {%..any*, i64} %1087, {%..any*, i64}* %175
	%1090 = call %..string @fmt.tprint({%..any*, i64}* %175, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %1090, %runtime.Context* noalias nonnull nocapture inreg %4)
	; defer
	; AssignStmt
	%1091 = load i64, i64* @prebuild.indent_level, align 8
	%1092 = sub i64 %1091, 1
	store i64 %1092, i64* @prebuild.indent_level
	; defer
	call void @prebuild.procedure_line(%..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$259, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %4)
	br label %for.index.loop-22

for.index.done-26:
	; defer
	call void @prebuild.procedure_end(%runtime.Context* noalias nonnull nocapture inreg %4)
	; variadic call argument generation
	%1093 = bitcast {%prebuild.Parameter*, i64}* %176 to %..rawptr
	%1094 = call %..rawptr @mem.zero(%..rawptr %1093, i64 16) noinline
	store {%prebuild.Parameter*, i64} zeroinitializer, {%prebuild.Parameter*, i64}* %176
	%1095 = load {%prebuild.Parameter*, i64}, {%prebuild.Parameter*, i64}* %176, align 8
	%1096 = bitcast {%prebuild.Parameter*, i64}* %177 to %..rawptr
	%1097 = call %..rawptr @mem.zero(%..rawptr %1096, i64 16) noinline
	store {%prebuild.Parameter*, i64} zeroinitializer, {%prebuild.Parameter*, i64}* %177
	store {%prebuild.Parameter*, i64} %1095, {%prebuild.Parameter*, i64}* %177
	call void @prebuild.procedure_begin(%..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$25a, i64 0, i32 0), i64 23}, %..string zeroinitializer, {%prebuild.Parameter*, i64}* %177, %runtime.Context* noalias nonnull nocapture inreg %4)
	; DeferStmt
	; RangeStmt
	; c
	%1098 = bitcast %prebuild.main.Component_Definition-250* %178 to %..rawptr
	%1099 = call %..rawptr @mem.zero(%..rawptr %1098, i64 96) noinline
	store %prebuild.main.Component_Definition-250 zeroinitializer, %prebuild.main.Component_Definition-250* %178
	%1100 = load {%prebuild.main.Component_Definition-250*, i64}, {%prebuild.main.Component_Definition-250*, i64}* %19, align 8
	%1101 = bitcast i64* %179 to %..rawptr
	%1102 = call %..rawptr @mem.zero(%..rawptr %1101, i64 8) noinline
	store i64 zeroinitializer, i64* %179
	%1103 = extractvalue {%prebuild.main.Component_Definition-250*, i64} %1100, 1
	store i64 %1103, i64* %179
	%1104 = bitcast i64* %180 to %..rawptr
	%1105 = call %..rawptr @mem.zero(%..rawptr %1104, i64 8) noinline
	store i64 zeroinitializer, i64* %180
	store i64 -1, i64* %180
	br label %for.index.loop-27

for.index.loop-27:
	%1106 = load i64, i64* %180, align 8
	%1107 = add i64 %1106, 1
	store i64 %1107, i64* %180
	%1108 = load i64, i64* %179, align 8
	%1109 = icmp slt i64 %1107, %1108
	br i1 %1109, label %for.index.body-28, label %for.index.done-31

for.index.body-28:
	%1110 = load i64, i64* %180, align 8
	%1111 = extractvalue {%prebuild.main.Component_Definition-250*, i64} %1100, 0
	%1112 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %1111, i64 %1110
	%1113 = load %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %1112, align 8
	store %prebuild.main.Component_Definition-250 %1113, %prebuild.main.Component_Definition-250* %178
	; IfStmt
	; SelectorExpr
	%1114 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %178, i64 0, i32 5
	%1115 = load %..string, %..string* %1114, align 8
	%1116 = call i8 @runtime.string_eq(%..string %1115, %..string zeroinitializer)
	%1117 = trunc i8 %1116 to i1
	br i1 %1117, label %if.then-29, label %if.done-30

if.then-29:
	; continue
	br label %for.index.loop-27

if.done-30:
	; SelectorExpr
	%1118 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %178, i64 0, i32 1
	%1119 = load %..string, %..string* %1118, align 8
	%1120 = bitcast %..string* %181 to %..rawptr
	%1121 = call %..rawptr @mem.zero(%..rawptr %1120, i64 16) noinline
	store %..string zeroinitializer, %..string* %181
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$25b, i64 0, i32 0), i64 12}, %..string* %181
	%1122 = load %..string, %..string* %181, align 8
	%1123 = bitcast %..any* %182 to %..rawptr
	%1124 = call %..rawptr @mem.zero(%..rawptr %1123, i64 16) noinline
	store %..any zeroinitializer, %..any* %182
	%1125 = bitcast %..string* %181 to %..rawptr
	%1126 = getelementptr inbounds %..any, %..any* %182, i64 0, i32 0
	store %..rawptr %1125, %..rawptr* %1126
	%1127 = getelementptr inbounds %..any, %..any* %182, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %1127
	%1128 = load %..any, %..any* %182, align 8
	%1129 = bitcast %..any* %183 to %..rawptr
	%1130 = call %..rawptr @mem.zero(%..rawptr %1129, i64 16) noinline
	store %..any zeroinitializer, %..any* %183
	%1131 = bitcast %..string* %1118 to %..rawptr
	%1132 = getelementptr inbounds %..any, %..any* %183, i64 0, i32 0
	store %..rawptr %1131, %..rawptr* %1132
	%1133 = getelementptr inbounds %..any, %..any* %183, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %1133
	%1134 = load %..any, %..any* %183, align 8
	%1135 = bitcast %..string* %184 to %..rawptr
	%1136 = call %..rawptr @mem.zero(%..rawptr %1135, i64 16) noinline
	store %..string zeroinitializer, %..string* %184
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$25c, i64 0, i32 0), i64 2}, %..string* %184
	%1137 = load %..string, %..string* %184, align 8
	%1138 = bitcast %..any* %185 to %..rawptr
	%1139 = call %..rawptr @mem.zero(%..rawptr %1138, i64 16) noinline
	store %..any zeroinitializer, %..any* %185
	%1140 = bitcast %..string* %184 to %..rawptr
	%1141 = getelementptr inbounds %..any, %..any* %185, i64 0, i32 0
	store %..rawptr %1140, %..rawptr* %1141
	%1142 = getelementptr inbounds %..any, %..any* %185, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %1142
	%1143 = load %..any, %..any* %185, align 8
	; variadic call argument generation
	%1144 = bitcast {%..any*, i64}* %186 to %..rawptr
	%1145 = call %..rawptr @mem.zero(%..rawptr %1144, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %186
	%1146 = bitcast [3 x %..any]* %187 to %..rawptr
	%1147 = call %..rawptr @mem.zero(%..rawptr %1146, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %187
	%1148 = getelementptr inbounds [3 x %..any], [3 x %..any]* %187, i64 0, i32 0
	store %..any %1128, %..any* %1148
	%1149 = getelementptr inbounds [3 x %..any], [3 x %..any]* %187, i64 0, i32 1
	store %..any %1134, %..any* %1149
	%1150 = getelementptr inbounds [3 x %..any], [3 x %..any]* %187, i64 0, i32 2
	store %..any %1143, %..any* %1150
	%1151 = getelementptr inbounds [3 x %..any], [3 x %..any]* %187, i64 0, i32 0
	%1152 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %186, i64 0, i32 0
	store %..any* %1151, %..any** %1152
	%1153 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %186, i64 0, i32 1
	store i64 3, i64* %1153
	%1154 = load {%..any*, i64}, {%..any*, i64}* %186, align 8
	%1155 = bitcast {%..any*, i64}* %188 to %..rawptr
	%1156 = call %..rawptr @mem.zero(%..rawptr %1155, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %188
	store {%..any*, i64} %1154, {%..any*, i64}* %188
	%1157 = call %..string @fmt.tprint({%..any*, i64}* %188, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %1157, %runtime.Context* noalias nonnull nocapture inreg %4)
	; DeferStmt
	; AssignStmt
	%1158 = load i64, i64* @prebuild.indent_level, align 8
	%1159 = add i64 %1158, 1
	store i64 %1159, i64* @prebuild.indent_level
	; DeferStmt
	; SelectorExpr
	%1160 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %178, i64 0, i32 1
	%1161 = load %..string, %..string* %1160, align 8
	; SelectorExpr
	%1162 = getelementptr inbounds %prebuild.main.Component_Definition-250, %prebuild.main.Component_Definition-250* %178, i64 0, i32 5
	%1163 = load %..string, %..string* %1162, align 8
	%1164 = bitcast %..string* %189 to %..rawptr
	%1165 = call %..rawptr @mem.zero(%..rawptr %1164, i64 16) noinline
	store %..string zeroinitializer, %..string* %189
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$25d, i64 0, i32 0), i64 6}, %..string* %189
	%1166 = load %..string, %..string* %189, align 8
	%1167 = bitcast %..any* %190 to %..rawptr
	%1168 = call %..rawptr @mem.zero(%..rawptr %1167, i64 16) noinline
	store %..any zeroinitializer, %..any* %190
	%1169 = bitcast %..string* %189 to %..rawptr
	%1170 = getelementptr inbounds %..any, %..any* %190, i64 0, i32 0
	store %..rawptr %1169, %..rawptr* %1170
	%1171 = getelementptr inbounds %..any, %..any* %190, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %1171
	%1172 = load %..any, %..any* %190, align 8
	%1173 = bitcast %..any* %191 to %..rawptr
	%1174 = call %..rawptr @mem.zero(%..rawptr %1173, i64 16) noinline
	store %..any zeroinitializer, %..any* %191
	%1175 = bitcast %..string* %1160 to %..rawptr
	%1176 = getelementptr inbounds %..any, %..any* %191, i64 0, i32 0
	store %..rawptr %1175, %..rawptr* %1176
	%1177 = getelementptr inbounds %..any, %..any* %191, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %1177
	%1178 = load %..any, %..any* %191, align 8
	%1179 = bitcast %..string* %192 to %..rawptr
	%1180 = call %..rawptr @mem.zero(%..rawptr %1179, i64 16) noinline
	store %..string zeroinitializer, %..string* %192
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$25e, i64 0, i32 0), i64 5}, %..string* %192
	%1181 = load %..string, %..string* %192, align 8
	%1182 = bitcast %..any* %193 to %..rawptr
	%1183 = call %..rawptr @mem.zero(%..rawptr %1182, i64 16) noinline
	store %..any zeroinitializer, %..any* %193
	%1184 = bitcast %..string* %192 to %..rawptr
	%1185 = getelementptr inbounds %..any, %..any* %193, i64 0, i32 0
	store %..rawptr %1184, %..rawptr* %1185
	%1186 = getelementptr inbounds %..any, %..any* %193, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %1186
	%1187 = load %..any, %..any* %193, align 8
	%1188 = bitcast %..any* %194 to %..rawptr
	%1189 = call %..rawptr @mem.zero(%..rawptr %1188, i64 16) noinline
	store %..any zeroinitializer, %..any* %194
	%1190 = bitcast %..string* %1162 to %..rawptr
	%1191 = getelementptr inbounds %..any, %..any* %194, i64 0, i32 0
	store %..rawptr %1190, %..rawptr* %1191
	%1192 = getelementptr inbounds %..any, %..any* %194, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %1192
	%1193 = load %..any, %..any* %194, align 8
	%1194 = bitcast %..string* %195 to %..rawptr
	%1195 = call %..rawptr @mem.zero(%..rawptr %1194, i64 16) noinline
	store %..string zeroinitializer, %..string* %195
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$25f, i64 0, i32 0), i64 4}, %..string* %195
	%1196 = load %..string, %..string* %195, align 8
	%1197 = bitcast %..any* %196 to %..rawptr
	%1198 = call %..rawptr @mem.zero(%..rawptr %1197, i64 16) noinline
	store %..any zeroinitializer, %..any* %196
	%1199 = bitcast %..string* %195 to %..rawptr
	%1200 = getelementptr inbounds %..any, %..any* %196, i64 0, i32 0
	store %..rawptr %1199, %..rawptr* %1200
	%1201 = getelementptr inbounds %..any, %..any* %196, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %1201
	%1202 = load %..any, %..any* %196, align 8
	; variadic call argument generation
	%1203 = bitcast {%..any*, i64}* %197 to %..rawptr
	%1204 = call %..rawptr @mem.zero(%..rawptr %1203, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %197
	%1205 = bitcast [5 x %..any]* %198 to %..rawptr
	%1206 = call %..rawptr @mem.zero(%..rawptr %1205, i64 80) noinline
	store [5 x %..any] zeroinitializer, [5 x %..any]* %198
	%1207 = getelementptr inbounds [5 x %..any], [5 x %..any]* %198, i64 0, i32 0
	store %..any %1172, %..any* %1207
	%1208 = getelementptr inbounds [5 x %..any], [5 x %..any]* %198, i64 0, i32 1
	store %..any %1178, %..any* %1208
	%1209 = getelementptr inbounds [5 x %..any], [5 x %..any]* %198, i64 0, i32 2
	store %..any %1187, %..any* %1209
	%1210 = getelementptr inbounds [5 x %..any], [5 x %..any]* %198, i64 0, i32 3
	store %..any %1193, %..any* %1210
	%1211 = getelementptr inbounds [5 x %..any], [5 x %..any]* %198, i64 0, i32 4
	store %..any %1202, %..any* %1211
	%1212 = getelementptr inbounds [5 x %..any], [5 x %..any]* %198, i64 0, i32 0
	%1213 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %197, i64 0, i32 0
	store %..any* %1212, %..any** %1213
	%1214 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %197, i64 0, i32 1
	store i64 5, i64* %1214
	%1215 = load {%..any*, i64}, {%..any*, i64}* %197, align 8
	%1216 = bitcast {%..any*, i64}* %199 to %..rawptr
	%1217 = call %..rawptr @mem.zero(%..rawptr %1216, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %199
	store {%..any*, i64} %1215, {%..any*, i64}* %199
	%1218 = call %..string @fmt.tprint({%..any*, i64}* %199, %runtime.Context* noalias nonnull nocapture inreg %4)
	call void @prebuild.procedure_line(%..string %1218, %runtime.Context* noalias nonnull nocapture inreg %4)
	; defer
	; AssignStmt
	%1219 = load i64, i64* @prebuild.indent_level, align 8
	%1220 = sub i64 %1219, 1
	store i64 %1220, i64* @prebuild.indent_level
	; defer
	call void @prebuild.procedure_line(%..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$260, i64 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture inreg %4)
	br label %for.index.loop-27

for.index.done-31:
	; defer
	call void @prebuild.procedure_end(%runtime.Context* noalias nonnull nocapture inreg %4)
	; defer
	%1221 = load {i8*, i64}, {i8*, i64}* %9, align 8
	; SelectorExpr
	%1222 = getelementptr inbounds %runtime.Context, %runtime.Context* %4, i64 0, i32 0
	%1223 = load %mem.Allocator, %mem.Allocator* %1222, align 8
	%1224 = bitcast {i8*, i64}* %200 to %..rawptr
	%1225 = call %..rawptr @mem.zero(%..rawptr %1224, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %200
	store {i8*, i64} %1221, {i8*, i64}* %200
	%1226 = bitcast %mem.Allocator* %201 to %..rawptr
	%1227 = call %..rawptr @mem.zero(%..rawptr %1226, i64 16) noinline
	store %mem.Allocator zeroinitializer, %mem.Allocator* %201
	store %mem.Allocator %1223, %mem.Allocator* %201
	%1228 = bitcast %runtime.Source_Code_Location* %202 to %..rawptr
	%1229 = call %..rawptr @mem.zero(%..rawptr %1228, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %202
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([74 x i8], [74 x i8]* @str$261, i64 0, i32 0), i64 73}, i64 40, i64 9, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$262, i64 0, i32 0), i64 4}}, %runtime.Source_Code_Location* %202
	call void @mem.delete_slice-14814({i8*, i64}* %200, %mem.Allocator* %201, %runtime.Source_Code_Location* %202, %runtime.Context* noalias nonnull nocapture inreg %4)
	; SelectorExpr
	%1230 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* @prebuild.generated_code, align 8
	%1231 = bitcast {i8*, i64, i64, %mem.Allocator}* %203 to %..rawptr
	%1232 = call %..rawptr @mem.zero(%..rawptr %1231, i64 40) noinline
	store {i8*, i64, i64, %mem.Allocator} zeroinitializer, {i8*, i64, i64, %mem.Allocator}* %203
	store {i8*, i64, i64, %mem.Allocator} %1230, {i8*, i64, i64, %mem.Allocator}* %203
	%1233 = call %..string @fmt.to_string({i8*, i64, i64, %mem.Allocator}* %203, %runtime.Context* noalias nonnull nocapture inreg %4)
	%1234 = extractvalue %..string %1233, 0
	%1235 = bitcast i8** %204 to %..rawptr
	%1236 = call %..rawptr @mem.zero(%..rawptr %1235, i64 8) noinline
	store i8* zeroinitializer, i8** %204
	store i8* %1234, i8** %204
	%1237 = extractvalue %..string %1233, 1
	%1238 = sub i64 %1237, 0
	%1239 = load i8*, i8** %204, align 8
	%1240 = getelementptr inbounds i8, i8* %1239, i64 0
	%1241 = bitcast {i8*, i64}* %205 to %..rawptr
	%1242 = call %..rawptr @mem.zero(%..rawptr %1241, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %205
	%1243 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %205, i64 0, i32 0
	store i8* %1240, i8** %1243
	%1244 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %205, i64 0, i32 1
	store i64 %1238, i64* %1244
	%1245 = load {i8*, i64}, {i8*, i64}* %205, align 8
	%1246 = bitcast {i8*, i64}* %206 to %..rawptr
	%1247 = call %..rawptr @mem.zero(%..rawptr %1246, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %206
	store {i8*, i64} %1245, {i8*, i64}* %206
	%1248 = call i8 @os.write_entire_file(%..string {i8* getelementptr inbounds ([37 x i8], [37 x i8]* @str$263, i64 0, i32 0), i64 36}, {i8*, i64}* %206, i1 true, %runtime.Context* noalias nonnull nocapture inreg %4)
	%1249 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* @prebuild.generated_code, align 8
	%1250 = bitcast {i8*, i64, i64, %mem.Allocator}* %207 to %..rawptr
	%1251 = call %..rawptr @mem.zero(%..rawptr %1250, i64 40) noinline
	store {i8*, i64, i64, %mem.Allocator} zeroinitializer, {i8*, i64, i64, %mem.Allocator}* %207
	store {i8*, i64, i64, %mem.Allocator} %1249, {i8*, i64, i64, %mem.Allocator}* %207
	%1252 = bitcast %runtime.Source_Code_Location* %208 to %..rawptr
	%1253 = call %..rawptr @mem.zero(%..rawptr %1252, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %208
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([74 x i8], [74 x i8]* @str$264, i64 0, i32 0), i64 73}, i64 149, i64 2, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$265, i64 0, i32 0), i64 4}}, %runtime.Source_Code_Location* %208
	call void @mem.delete_dynamic_array-20363({i8*, i64, i64, %mem.Allocator}* %207, %runtime.Source_Code_Location* %208, %runtime.Context* noalias nonnull nocapture inreg %4)
	ret void
}

define void @prebuild.indent(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %..string, align 16
	%4 = alloca %..any, align 16
	%5 = alloca {%..any*, i64}, align 16
	%6 = alloca [1 x %..any], align 16
	%7 = alloca {%..any*, i64}, align 16
	; RangeStmt
	; i
	%8 = bitcast i64* %0 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 8) noinline
	store i64 zeroinitializer, i64* %0
	%10 = bitcast i64* %1 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 8) noinline
	store i64 zeroinitializer, i64* %1
	store i64 0, i64* %1
	%12 = bitcast i64* %2 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	store i64 0, i64* %2
	br label %for.interval.loop-1

for.interval.loop-1:
	%14 = load i64, i64* @prebuild.indent_level, align 8
	%15 = sub i64 %14, 1
	%16 = load i64, i64* %1, align 8
	%17 = icmp sle i64 %16, %15
	br i1 %17, label %for.interval.body-2, label %for.interval.done-3

for.interval.body-2:
	%18 = load i64, i64* %1, align 8
	%19 = load i64, i64* %2, align 8
	%20 = load i64, i64* %1, align 8
	%21 = add i64 %20, 1
	store i64 %21, i64* %1
	%22 = load i64, i64* %2, align 8
	%23 = add i64 %22, 1
	store i64 %23, i64* %2
	store i64 %18, i64* %0
	%24 = bitcast %..string* %3 to %..rawptr
	%25 = call %..rawptr @mem.zero(%..rawptr %24, i64 16) noinline
	store %..string zeroinitializer, %..string* %3
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$266, i64 0, i32 0), i64 1}, %..string* %3
	%26 = load %..string, %..string* %3, align 8
	%27 = bitcast %..any* %4 to %..rawptr
	%28 = call %..rawptr @mem.zero(%..rawptr %27, i64 16) noinline
	store %..any zeroinitializer, %..any* %4
	%29 = bitcast %..string* %3 to %..rawptr
	%30 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	store %..rawptr %29, %..rawptr* %30
	%31 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %31
	%32 = load %..any, %..any* %4, align 8
	; variadic call argument generation
	%33 = bitcast {%..any*, i64}* %5 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %5
	%35 = bitcast [1 x %..any]* %6 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %6
	%37 = getelementptr inbounds [1 x %..any], [1 x %..any]* %6, i64 0, i32 0
	store %..any %32, %..any* %37
	%38 = getelementptr inbounds [1 x %..any], [1 x %..any]* %6, i64 0, i32 0
	%39 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %5, i64 0, i32 0
	store %..any* %38, %..any** %39
	%40 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %5, i64 0, i32 1
	store i64 1, i64* %40
	%41 = load {%..any*, i64}, {%..any*, i64}* %5, align 8
	%42 = bitcast {%..any*, i64}* %7 to %..rawptr
	%43 = call %..rawptr @mem.zero(%..rawptr %42, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %7
	store {%..any*, i64} %41, {%..any*, i64}* %7
	%44 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* @prebuild.generated_code, {%..any*, i64}* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.interval.loop-1

for.interval.done-3:
	ret void
}

define void @prebuild.union_begin(%..string %struct_name, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..any, align 16
	%2 = alloca %..string, align 16
	%3 = alloca %..any, align 16
	%4 = alloca {%..any*, i64}, align 16
	%5 = alloca [2 x %..any], align 16
	%6 = alloca {%..any*, i64}, align 16
	store %..string %struct_name, %..string* %0
	call void @prebuild.indent(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load %..string, %..string* %0, align 8
	%8 = bitcast %..any* %1 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 16) noinline
	store %..any zeroinitializer, %..any* %1
	%10 = bitcast %..string* %0 to %..rawptr
	%11 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	store %..rawptr %10, %..rawptr* %11
	%12 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %12
	%13 = load %..any, %..any* %1, align 8
	%14 = bitcast %..string* %2 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$267, i64 0, i32 0), i64 12}, %..string* %2
	%16 = load %..string, %..string* %2, align 8
	%17 = bitcast %..any* %3 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 16) noinline
	store %..any zeroinitializer, %..any* %3
	%19 = bitcast %..string* %2 to %..rawptr
	%20 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	store %..rawptr %19, %..rawptr* %20
	%21 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %21
	%22 = load %..any, %..any* %3, align 8
	; variadic call argument generation
	%23 = bitcast {%..any*, i64}* %4 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %4
	%25 = bitcast [2 x %..any]* %5 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %5
	%27 = getelementptr inbounds [2 x %..any], [2 x %..any]* %5, i64 0, i32 0
	store %..any %13, %..any* %27
	%28 = getelementptr inbounds [2 x %..any], [2 x %..any]* %5, i64 0, i32 1
	store %..any %22, %..any* %28
	%29 = getelementptr inbounds [2 x %..any], [2 x %..any]* %5, i64 0, i32 0
	%30 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %4, i64 0, i32 0
	store %..any* %29, %..any** %30
	%31 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %4, i64 0, i32 1
	store i64 2, i64* %31
	%32 = load {%..any*, i64}, {%..any*, i64}* %4, align 8
	%33 = bitcast {%..any*, i64}* %6 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %6
	store {%..any*, i64} %32, {%..any*, i64}* %6
	%35 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* @prebuild.generated_code, {%..any*, i64}* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	%36 = load i64, i64* @prebuild.indent_level, align 8
	%37 = add i64 %36, 1
	store i64 %37, i64* @prebuild.indent_level
	ret void
}

define void @prebuild.union_field(%..string %field_name, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..any, align 16
	%2 = alloca %..string, align 16
	%3 = alloca %..any, align 16
	%4 = alloca {%..any*, i64}, align 16
	%5 = alloca [2 x %..any], align 16
	%6 = alloca {%..any*, i64}, align 16
	store %..string %field_name, %..string* %0
	call void @prebuild.indent(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load %..string, %..string* %0, align 8
	%8 = bitcast %..any* %1 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 16) noinline
	store %..any zeroinitializer, %..any* %1
	%10 = bitcast %..string* %0 to %..rawptr
	%11 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	store %..rawptr %10, %..rawptr* %11
	%12 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %12
	%13 = load %..any, %..any* %1, align 8
	%14 = bitcast %..string* %2 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$268, i64 0, i32 0), i64 2}, %..string* %2
	%16 = load %..string, %..string* %2, align 8
	%17 = bitcast %..any* %3 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 16) noinline
	store %..any zeroinitializer, %..any* %3
	%19 = bitcast %..string* %2 to %..rawptr
	%20 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	store %..rawptr %19, %..rawptr* %20
	%21 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %21
	%22 = load %..any, %..any* %3, align 8
	; variadic call argument generation
	%23 = bitcast {%..any*, i64}* %4 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %4
	%25 = bitcast [2 x %..any]* %5 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %5
	%27 = getelementptr inbounds [2 x %..any], [2 x %..any]* %5, i64 0, i32 0
	store %..any %13, %..any* %27
	%28 = getelementptr inbounds [2 x %..any], [2 x %..any]* %5, i64 0, i32 1
	store %..any %22, %..any* %28
	%29 = getelementptr inbounds [2 x %..any], [2 x %..any]* %5, i64 0, i32 0
	%30 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %4, i64 0, i32 0
	store %..any* %29, %..any** %30
	%31 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %4, i64 0, i32 1
	store i64 2, i64* %31
	%32 = load {%..any*, i64}, {%..any*, i64}* %4, align 8
	%33 = bitcast {%..any*, i64}* %6 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %6
	store {%..any*, i64} %32, {%..any*, i64}* %6
	%35 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* @prebuild.generated_code, {%..any*, i64}* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @prebuild.union_end(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..any, align 16
	%2 = alloca {%..any*, i64}, align 16
	%3 = alloca [1 x %..any], align 16
	%4 = alloca {%..any*, i64}, align 16
	; AssignStmt
	%5 = load i64, i64* @prebuild.indent_level, align 8
	%6 = sub i64 %5, 1
	store i64 %6, i64* @prebuild.indent_level
	call void @prebuild.indent(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = bitcast %..string* %0 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 16) noinline
	store %..string zeroinitializer, %..string* %0
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$269, i64 0, i32 0), i64 3}, %..string* %0
	%9 = load %..string, %..string* %0, align 8
	%10 = bitcast %..any* %1 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 16) noinline
	store %..any zeroinitializer, %..any* %1
	%12 = bitcast %..string* %0 to %..rawptr
	%13 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	store %..rawptr %12, %..rawptr* %13
	%14 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %14
	%15 = load %..any, %..any* %1, align 8
	; variadic call argument generation
	%16 = bitcast {%..any*, i64}* %2 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %2
	%18 = bitcast [1 x %..any]* %3 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %3
	%20 = getelementptr inbounds [1 x %..any], [1 x %..any]* %3, i64 0, i32 0
	store %..any %15, %..any* %20
	%21 = getelementptr inbounds [1 x %..any], [1 x %..any]* %3, i64 0, i32 0
	%22 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %2, i64 0, i32 0
	store %..any* %21, %..any** %22
	%23 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %2, i64 0, i32 1
	store i64 1, i64* %23
	%24 = load {%..any*, i64}, {%..any*, i64}* %2, align 8
	%25 = bitcast {%..any*, i64}* %4 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %4
	store {%..any*, i64} %24, {%..any*, i64}* %4
	%27 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* @prebuild.generated_code, {%..any*, i64}* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @prebuild.procedure_begin(%..string %name, %..string %return_type, {%prebuild.Parameter*, i64}* %params, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	%2 = alloca %..any, align 16
	%3 = alloca %..string, align 16
	%4 = alloca %..any, align 16
	%5 = alloca {%..any*, i64}, align 16
	%6 = alloca [2 x %..any], align 16
	%7 = alloca {%..any*, i64}, align 16
	%8 = alloca %..string, align 16
	%9 = alloca %prebuild.Parameter, align 16
	%10 = alloca i64, align 16
	%11 = alloca i64, align 16
	%12 = alloca %..any, align 16
	%13 = alloca {%..any*, i64}, align 16
	%14 = alloca [1 x %..any], align 16
	%15 = alloca {%..any*, i64}, align 16
	%16 = alloca %..any, align 16
	%17 = alloca %..string, align 16
	%18 = alloca %..any, align 16
	%19 = alloca %..any, align 16
	%20 = alloca {%..any*, i64}, align 16
	%21 = alloca [3 x %..any], align 16
	%22 = alloca {%..any*, i64}, align 16
	%23 = alloca %..string, align 16
	%24 = alloca %..any, align 16
	%25 = alloca {%..any*, i64}, align 16
	%26 = alloca [1 x %..any], align 16
	%27 = alloca {%..any*, i64}, align 16
	%28 = alloca %..string, align 16
	%29 = alloca %..any, align 16
	%30 = alloca %..any, align 16
	%31 = alloca %..string, align 16
	%32 = alloca %..any, align 16
	%33 = alloca {%..any*, i64}, align 16
	%34 = alloca [3 x %..any], align 16
	%35 = alloca {%..any*, i64}, align 16
	%36 = alloca %..string, align 16
	%37 = alloca %..any, align 16
	%38 = alloca {%..any*, i64}, align 16
	%39 = alloca [1 x %..any], align 16
	%40 = alloca {%..any*, i64}, align 16
	store %..string %name, %..string* %0
	store %..string %return_type, %..string* %1
	%41 = load {%prebuild.Parameter*, i64}, {%prebuild.Parameter*, i64}* %params, align 8
	call void @prebuild.indent(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%42 = load %..string, %..string* %0, align 8
	%43 = bitcast %..any* %2 to %..rawptr
	%44 = call %..rawptr @mem.zero(%..rawptr %43, i64 16) noinline
	store %..any zeroinitializer, %..any* %2
	%45 = bitcast %..string* %0 to %..rawptr
	%46 = getelementptr inbounds %..any, %..any* %2, i64 0, i32 0
	store %..rawptr %45, %..rawptr* %46
	%47 = getelementptr inbounds %..any, %..any* %2, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %47
	%48 = load %..any, %..any* %2, align 8
	%49 = bitcast %..string* %3 to %..rawptr
	%50 = call %..rawptr @mem.zero(%..rawptr %49, i64 16) noinline
	store %..string zeroinitializer, %..string* %3
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$26a, i64 0, i32 0), i64 9}, %..string* %3
	%51 = load %..string, %..string* %3, align 8
	%52 = bitcast %..any* %4 to %..rawptr
	%53 = call %..rawptr @mem.zero(%..rawptr %52, i64 16) noinline
	store %..any zeroinitializer, %..any* %4
	%54 = bitcast %..string* %3 to %..rawptr
	%55 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 0
	store %..rawptr %54, %..rawptr* %55
	%56 = getelementptr inbounds %..any, %..any* %4, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %56
	%57 = load %..any, %..any* %4, align 8
	; variadic call argument generation
	%58 = bitcast {%..any*, i64}* %5 to %..rawptr
	%59 = call %..rawptr @mem.zero(%..rawptr %58, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %5
	%60 = bitcast [2 x %..any]* %6 to %..rawptr
	%61 = call %..rawptr @mem.zero(%..rawptr %60, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %6
	%62 = getelementptr inbounds [2 x %..any], [2 x %..any]* %6, i64 0, i32 0
	store %..any %48, %..any* %62
	%63 = getelementptr inbounds [2 x %..any], [2 x %..any]* %6, i64 0, i32 1
	store %..any %57, %..any* %63
	%64 = getelementptr inbounds [2 x %..any], [2 x %..any]* %6, i64 0, i32 0
	%65 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %5, i64 0, i32 0
	store %..any* %64, %..any** %65
	%66 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %5, i64 0, i32 1
	store i64 2, i64* %66
	%67 = load {%..any*, i64}, {%..any*, i64}* %5, align 8
	%68 = bitcast {%..any*, i64}* %7 to %..rawptr
	%69 = call %..rawptr @mem.zero(%..rawptr %68, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %7
	store {%..any*, i64} %67, {%..any*, i64}* %7
	%70 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* @prebuild.generated_code, {%..any*, i64}* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; comma
	store %..string zeroinitializer, %..string* %8
	; RangeStmt
	; param
	%71 = bitcast %prebuild.Parameter* %9 to %..rawptr
	%72 = call %..rawptr @mem.zero(%..rawptr %71, i64 32) noinline
	store %prebuild.Parameter zeroinitializer, %prebuild.Parameter* %9
	%73 = load {%prebuild.Parameter*, i64}, {%prebuild.Parameter*, i64}* %params, align 8
	%74 = bitcast i64* %10 to %..rawptr
	%75 = call %..rawptr @mem.zero(%..rawptr %74, i64 8) noinline
	store i64 zeroinitializer, i64* %10
	%76 = extractvalue {%prebuild.Parameter*, i64} %73, 1
	store i64 %76, i64* %10
	%77 = bitcast i64* %11 to %..rawptr
	%78 = call %..rawptr @mem.zero(%..rawptr %77, i64 8) noinline
	store i64 zeroinitializer, i64* %11
	store i64 -1, i64* %11
	br label %for.index.loop-1

for.index.loop-1:
	%79 = load i64, i64* %11, align 8
	%80 = add i64 %79, 1
	store i64 %80, i64* %11
	%81 = load i64, i64* %10, align 8
	%82 = icmp slt i64 %80, %81
	br i1 %82, label %for.index.body-2, label %for.index.done-3

for.index.body-2:
	%83 = load i64, i64* %11, align 8
	%84 = extractvalue {%prebuild.Parameter*, i64} %73, 0
	%85 = getelementptr inbounds %prebuild.Parameter, %prebuild.Parameter* %84, i64 %83
	%86 = load %prebuild.Parameter, %prebuild.Parameter* %85, align 8
	store %prebuild.Parameter %86, %prebuild.Parameter* %9
	%87 = load %..string, %..string* %8, align 8
	%88 = bitcast %..any* %12 to %..rawptr
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 16) noinline
	store %..any zeroinitializer, %..any* %12
	%90 = bitcast %..string* %8 to %..rawptr
	%91 = getelementptr inbounds %..any, %..any* %12, i64 0, i32 0
	store %..rawptr %90, %..rawptr* %91
	%92 = getelementptr inbounds %..any, %..any* %12, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %92
	%93 = load %..any, %..any* %12, align 8
	; variadic call argument generation
	%94 = bitcast {%..any*, i64}* %13 to %..rawptr
	%95 = call %..rawptr @mem.zero(%..rawptr %94, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %13
	%96 = bitcast [1 x %..any]* %14 to %..rawptr
	%97 = call %..rawptr @mem.zero(%..rawptr %96, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %14
	%98 = getelementptr inbounds [1 x %..any], [1 x %..any]* %14, i64 0, i32 0
	store %..any %93, %..any* %98
	%99 = getelementptr inbounds [1 x %..any], [1 x %..any]* %14, i64 0, i32 0
	%100 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %13, i64 0, i32 0
	store %..any* %99, %..any** %100
	%101 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %13, i64 0, i32 1
	store i64 1, i64* %101
	%102 = load {%..any*, i64}, {%..any*, i64}* %13, align 8
	%103 = bitcast {%..any*, i64}* %15 to %..rawptr
	%104 = call %..rawptr @mem.zero(%..rawptr %103, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %15
	store {%..any*, i64} %102, {%..any*, i64}* %15
	%105 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* @prebuild.generated_code, {%..any*, i64}* %15, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$26b, i64 0, i32 0), i64 2}, %..string* %8
	; SelectorExpr
	%106 = getelementptr inbounds %prebuild.Parameter, %prebuild.Parameter* %9, i64 0, i32 0
	%107 = load %..string, %..string* %106, align 8
	; SelectorExpr
	%108 = getelementptr inbounds %prebuild.Parameter, %prebuild.Parameter* %9, i64 0, i32 1
	%109 = load %..string, %..string* %108, align 8
	%110 = bitcast %..any* %16 to %..rawptr
	%111 = call %..rawptr @mem.zero(%..rawptr %110, i64 16) noinline
	store %..any zeroinitializer, %..any* %16
	%112 = bitcast %..string* %106 to %..rawptr
	%113 = getelementptr inbounds %..any, %..any* %16, i64 0, i32 0
	store %..rawptr %112, %..rawptr* %113
	%114 = getelementptr inbounds %..any, %..any* %16, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %114
	%115 = load %..any, %..any* %16, align 8
	%116 = bitcast %..string* %17 to %..rawptr
	%117 = call %..rawptr @mem.zero(%..rawptr %116, i64 16) noinline
	store %..string zeroinitializer, %..string* %17
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$26c, i64 0, i32 0), i64 2}, %..string* %17
	%118 = load %..string, %..string* %17, align 8
	%119 = bitcast %..any* %18 to %..rawptr
	%120 = call %..rawptr @mem.zero(%..rawptr %119, i64 16) noinline
	store %..any zeroinitializer, %..any* %18
	%121 = bitcast %..string* %17 to %..rawptr
	%122 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 0
	store %..rawptr %121, %..rawptr* %122
	%123 = getelementptr inbounds %..any, %..any* %18, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %123
	%124 = load %..any, %..any* %18, align 8
	%125 = bitcast %..any* %19 to %..rawptr
	%126 = call %..rawptr @mem.zero(%..rawptr %125, i64 16) noinline
	store %..any zeroinitializer, %..any* %19
	%127 = bitcast %..string* %108 to %..rawptr
	%128 = getelementptr inbounds %..any, %..any* %19, i64 0, i32 0
	store %..rawptr %127, %..rawptr* %128
	%129 = getelementptr inbounds %..any, %..any* %19, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %129
	%130 = load %..any, %..any* %19, align 8
	; variadic call argument generation
	%131 = bitcast {%..any*, i64}* %20 to %..rawptr
	%132 = call %..rawptr @mem.zero(%..rawptr %131, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %20
	%133 = bitcast [3 x %..any]* %21 to %..rawptr
	%134 = call %..rawptr @mem.zero(%..rawptr %133, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %21
	%135 = getelementptr inbounds [3 x %..any], [3 x %..any]* %21, i64 0, i32 0
	store %..any %115, %..any* %135
	%136 = getelementptr inbounds [3 x %..any], [3 x %..any]* %21, i64 0, i32 1
	store %..any %124, %..any* %136
	%137 = getelementptr inbounds [3 x %..any], [3 x %..any]* %21, i64 0, i32 2
	store %..any %130, %..any* %137
	%138 = getelementptr inbounds [3 x %..any], [3 x %..any]* %21, i64 0, i32 0
	%139 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %20, i64 0, i32 0
	store %..any* %138, %..any** %139
	%140 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %20, i64 0, i32 1
	store i64 3, i64* %140
	%141 = load {%..any*, i64}, {%..any*, i64}* %20, align 8
	%142 = bitcast {%..any*, i64}* %22 to %..rawptr
	%143 = call %..rawptr @mem.zero(%..rawptr %142, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %22
	store {%..any*, i64} %141, {%..any*, i64}* %22
	%144 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* @prebuild.generated_code, {%..any*, i64}* %22, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-1

for.index.done-3:
	%145 = bitcast %..string* %23 to %..rawptr
	%146 = call %..rawptr @mem.zero(%..rawptr %145, i64 16) noinline
	store %..string zeroinitializer, %..string* %23
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$26d, i64 0, i32 0), i64 2}, %..string* %23
	%147 = load %..string, %..string* %23, align 8
	%148 = bitcast %..any* %24 to %..rawptr
	%149 = call %..rawptr @mem.zero(%..rawptr %148, i64 16) noinline
	store %..any zeroinitializer, %..any* %24
	%150 = bitcast %..string* %23 to %..rawptr
	%151 = getelementptr inbounds %..any, %..any* %24, i64 0, i32 0
	store %..rawptr %150, %..rawptr* %151
	%152 = getelementptr inbounds %..any, %..any* %24, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %152
	%153 = load %..any, %..any* %24, align 8
	; variadic call argument generation
	%154 = bitcast {%..any*, i64}* %25 to %..rawptr
	%155 = call %..rawptr @mem.zero(%..rawptr %154, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %25
	%156 = bitcast [1 x %..any]* %26 to %..rawptr
	%157 = call %..rawptr @mem.zero(%..rawptr %156, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %26
	%158 = getelementptr inbounds [1 x %..any], [1 x %..any]* %26, i64 0, i32 0
	store %..any %153, %..any* %158
	%159 = getelementptr inbounds [1 x %..any], [1 x %..any]* %26, i64 0, i32 0
	%160 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %25, i64 0, i32 0
	store %..any* %159, %..any** %160
	%161 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %25, i64 0, i32 1
	store i64 1, i64* %161
	%162 = load {%..any*, i64}, {%..any*, i64}* %25, align 8
	%163 = bitcast {%..any*, i64}* %27 to %..rawptr
	%164 = call %..rawptr @mem.zero(%..rawptr %163, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %27
	store {%..any*, i64} %162, {%..any*, i64}* %27
	%165 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* @prebuild.generated_code, {%..any*, i64}* %27, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; IfStmt
	%166 = load %..string, %..string* %1, align 8
	%167 = call i8 @runtime.string_ne(%..string %166, %..string zeroinitializer)
	%168 = trunc i8 %167 to i1
	br i1 %168, label %if.then-4, label %if.done-5

if.then-4:
	%169 = load %..string, %..string* %1, align 8
	%170 = bitcast %..string* %28 to %..rawptr
	%171 = call %..rawptr @mem.zero(%..rawptr %170, i64 16) noinline
	store %..string zeroinitializer, %..string* %28
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$26e, i64 0, i32 0), i64 3}, %..string* %28
	%172 = load %..string, %..string* %28, align 8
	%173 = bitcast %..any* %29 to %..rawptr
	%174 = call %..rawptr @mem.zero(%..rawptr %173, i64 16) noinline
	store %..any zeroinitializer, %..any* %29
	%175 = bitcast %..string* %28 to %..rawptr
	%176 = getelementptr inbounds %..any, %..any* %29, i64 0, i32 0
	store %..rawptr %175, %..rawptr* %176
	%177 = getelementptr inbounds %..any, %..any* %29, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %177
	%178 = load %..any, %..any* %29, align 8
	%179 = bitcast %..any* %30 to %..rawptr
	%180 = call %..rawptr @mem.zero(%..rawptr %179, i64 16) noinline
	store %..any zeroinitializer, %..any* %30
	%181 = bitcast %..string* %1 to %..rawptr
	%182 = getelementptr inbounds %..any, %..any* %30, i64 0, i32 0
	store %..rawptr %181, %..rawptr* %182
	%183 = getelementptr inbounds %..any, %..any* %30, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %183
	%184 = load %..any, %..any* %30, align 8
	%185 = bitcast %..string* %31 to %..rawptr
	%186 = call %..rawptr @mem.zero(%..rawptr %185, i64 16) noinline
	store %..string zeroinitializer, %..string* %31
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$26f, i64 0, i32 0), i64 1}, %..string* %31
	%187 = load %..string, %..string* %31, align 8
	%188 = bitcast %..any* %32 to %..rawptr
	%189 = call %..rawptr @mem.zero(%..rawptr %188, i64 16) noinline
	store %..any zeroinitializer, %..any* %32
	%190 = bitcast %..string* %31 to %..rawptr
	%191 = getelementptr inbounds %..any, %..any* %32, i64 0, i32 0
	store %..rawptr %190, %..rawptr* %191
	%192 = getelementptr inbounds %..any, %..any* %32, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %192
	%193 = load %..any, %..any* %32, align 8
	; variadic call argument generation
	%194 = bitcast {%..any*, i64}* %33 to %..rawptr
	%195 = call %..rawptr @mem.zero(%..rawptr %194, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %33
	%196 = bitcast [3 x %..any]* %34 to %..rawptr
	%197 = call %..rawptr @mem.zero(%..rawptr %196, i64 48) noinline
	store [3 x %..any] zeroinitializer, [3 x %..any]* %34
	%198 = getelementptr inbounds [3 x %..any], [3 x %..any]* %34, i64 0, i32 0
	store %..any %178, %..any* %198
	%199 = getelementptr inbounds [3 x %..any], [3 x %..any]* %34, i64 0, i32 1
	store %..any %184, %..any* %199
	%200 = getelementptr inbounds [3 x %..any], [3 x %..any]* %34, i64 0, i32 2
	store %..any %193, %..any* %200
	%201 = getelementptr inbounds [3 x %..any], [3 x %..any]* %34, i64 0, i32 0
	%202 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %33, i64 0, i32 0
	store %..any* %201, %..any** %202
	%203 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %33, i64 0, i32 1
	store i64 3, i64* %203
	%204 = load {%..any*, i64}, {%..any*, i64}* %33, align 8
	%205 = bitcast {%..any*, i64}* %35 to %..rawptr
	%206 = call %..rawptr @mem.zero(%..rawptr %205, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %35
	store {%..any*, i64} %204, {%..any*, i64}* %35
	%207 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* @prebuild.generated_code, {%..any*, i64}* %35, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-5

if.done-5:
	%208 = bitcast %..string* %36 to %..rawptr
	%209 = call %..rawptr @mem.zero(%..rawptr %208, i64 16) noinline
	store %..string zeroinitializer, %..string* %36
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$270, i64 0, i32 0), i64 2}, %..string* %36
	%210 = load %..string, %..string* %36, align 8
	%211 = bitcast %..any* %37 to %..rawptr
	%212 = call %..rawptr @mem.zero(%..rawptr %211, i64 16) noinline
	store %..any zeroinitializer, %..any* %37
	%213 = bitcast %..string* %36 to %..rawptr
	%214 = getelementptr inbounds %..any, %..any* %37, i64 0, i32 0
	store %..rawptr %213, %..rawptr* %214
	%215 = getelementptr inbounds %..any, %..any* %37, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %215
	%216 = load %..any, %..any* %37, align 8
	; variadic call argument generation
	%217 = bitcast {%..any*, i64}* %38 to %..rawptr
	%218 = call %..rawptr @mem.zero(%..rawptr %217, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %38
	%219 = bitcast [1 x %..any]* %39 to %..rawptr
	%220 = call %..rawptr @mem.zero(%..rawptr %219, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %39
	%221 = getelementptr inbounds [1 x %..any], [1 x %..any]* %39, i64 0, i32 0
	store %..any %216, %..any* %221
	%222 = getelementptr inbounds [1 x %..any], [1 x %..any]* %39, i64 0, i32 0
	%223 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %38, i64 0, i32 0
	store %..any* %222, %..any** %223
	%224 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %38, i64 0, i32 1
	store i64 1, i64* %224
	%225 = load {%..any*, i64}, {%..any*, i64}* %38, align 8
	%226 = bitcast {%..any*, i64}* %40 to %..rawptr
	%227 = call %..rawptr @mem.zero(%..rawptr %226, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %40
	store {%..any*, i64} %225, {%..any*, i64}* %40
	%228 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* @prebuild.generated_code, {%..any*, i64}* %40, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; AssignStmt
	%229 = load i64, i64* @prebuild.indent_level, align 8
	%230 = add i64 %229, 1
	store i64 %230, i64* @prebuild.indent_level
	ret void
}

define void @prebuild.procedure_line(%..string %line, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..any, align 16
	%2 = alloca %..string, align 16
	%3 = alloca %..any, align 16
	%4 = alloca {%..any*, i64}, align 16
	%5 = alloca [2 x %..any], align 16
	%6 = alloca {%..any*, i64}, align 16
	store %..string %line, %..string* %0
	call void @prebuild.indent(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = load %..string, %..string* %0, align 8
	%8 = bitcast %..any* %1 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 16) noinline
	store %..any zeroinitializer, %..any* %1
	%10 = bitcast %..string* %0 to %..rawptr
	%11 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	store %..rawptr %10, %..rawptr* %11
	%12 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %12
	%13 = load %..any, %..any* %1, align 8
	%14 = bitcast %..string* %2 to %..rawptr
	%15 = call %..rawptr @mem.zero(%..rawptr %14, i64 16) noinline
	store %..string zeroinitializer, %..string* %2
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$271, i64 0, i32 0), i64 1}, %..string* %2
	%16 = load %..string, %..string* %2, align 8
	%17 = bitcast %..any* %3 to %..rawptr
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 16) noinline
	store %..any zeroinitializer, %..any* %3
	%19 = bitcast %..string* %2 to %..rawptr
	%20 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 0
	store %..rawptr %19, %..rawptr* %20
	%21 = getelementptr inbounds %..any, %..any* %3, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %21
	%22 = load %..any, %..any* %3, align 8
	; variadic call argument generation
	%23 = bitcast {%..any*, i64}* %4 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %4
	%25 = bitcast [2 x %..any]* %5 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 32) noinline
	store [2 x %..any] zeroinitializer, [2 x %..any]* %5
	%27 = getelementptr inbounds [2 x %..any], [2 x %..any]* %5, i64 0, i32 0
	store %..any %13, %..any* %27
	%28 = getelementptr inbounds [2 x %..any], [2 x %..any]* %5, i64 0, i32 1
	store %..any %22, %..any* %28
	%29 = getelementptr inbounds [2 x %..any], [2 x %..any]* %5, i64 0, i32 0
	%30 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %4, i64 0, i32 0
	store %..any* %29, %..any** %30
	%31 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %4, i64 0, i32 1
	store i64 2, i64* %31
	%32 = load {%..any*, i64}, {%..any*, i64}* %4, align 8
	%33 = bitcast {%..any*, i64}* %6 to %..rawptr
	%34 = call %..rawptr @mem.zero(%..rawptr %33, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %6
	store {%..any*, i64} %32, {%..any*, i64}* %6
	%35 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* @prebuild.generated_code, {%..any*, i64}* %6, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define void @prebuild.procedure_end(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..any, align 16
	%2 = alloca {%..any*, i64}, align 16
	%3 = alloca [1 x %..any], align 16
	%4 = alloca {%..any*, i64}, align 16
	; AssignStmt
	%5 = load i64, i64* @prebuild.indent_level, align 8
	%6 = sub i64 %5, 1
	store i64 %6, i64* @prebuild.indent_level
	call void @prebuild.indent(%runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%7 = bitcast %..string* %0 to %..rawptr
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 16) noinline
	store %..string zeroinitializer, %..string* %0
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$272, i64 0, i32 0), i64 3}, %..string* %0
	%9 = load %..string, %..string* %0, align 8
	%10 = bitcast %..any* %1 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 16) noinline
	store %..any zeroinitializer, %..any* %1
	%12 = bitcast %..string* %0 to %..rawptr
	%13 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 0
	store %..rawptr %12, %..rawptr* %13
	%14 = getelementptr inbounds %..any, %..any* %1, i64 0, i32 1
	store %..typeid 360287970189639684, %..typeid* %14
	%15 = load %..any, %..any* %1, align 8
	; variadic call argument generation
	%16 = bitcast {%..any*, i64}* %2 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %2
	%18 = bitcast [1 x %..any]* %3 to %..rawptr
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 16) noinline
	store [1 x %..any] zeroinitializer, [1 x %..any]* %3
	%20 = getelementptr inbounds [1 x %..any], [1 x %..any]* %3, i64 0, i32 0
	store %..any %15, %..any* %20
	%21 = getelementptr inbounds [1 x %..any], [1 x %..any]* %3, i64 0, i32 0
	%22 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %2, i64 0, i32 0
	store %..any* %21, %..any** %22
	%23 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %2, i64 0, i32 1
	store i64 1, i64* %23
	%24 = load {%..any*, i64}, {%..any*, i64}* %2, align 8
	%25 = bitcast {%..any*, i64}* %4 to %..rawptr
	%26 = call %..rawptr @mem.zero(%..rawptr %25, i64 16) noinline
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %4
	store {%..any*, i64} %24, {%..any*, i64}* %4
	%27 = call %..string @fmt.sbprint({i8*, i64, i64, %mem.Allocator}* @prebuild.generated_code, {%..any*, i64}* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define i8* @mem.ptr_offset-13939(i8* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca i8*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store i8* %ptr, i8** %0
	store i64 %n, i64* %1
	; new
	%3 = load i8*, i8** %0, align 8
	%4 = ptrtoint i8* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 1, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to i8*
	ret i8* %11
}

define {i8*, i64} @mem.make_slice-14294(i64 %len, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = alloca %..rawptr, align 16
	%3 = alloca %mem.Allocator, align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	%5 = alloca %mem.Raw_Slice, align 16
	%6 = alloca %mem.Raw_Slice, align 16
	store i64 %len, i64* %0
	%7 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%10 = load i64, i64* %0, align 8
	%11 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %9, %runtime.Source_Code_Location* %1
	call void @runtime.make_slice_error_loc(%runtime.Source_Code_Location* %1, i64 %10)
	; data
	%12 = load i64, i64* %0, align 8
	%13 = mul i64 1, %12
	%14 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%15 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%16 = bitcast %mem.Allocator* %3 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %3
	store %mem.Allocator %14, %mem.Allocator* %3
	%17 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location %15, %runtime.Source_Code_Location* %4
	%18 = call %..rawptr @mem.alloc(i64 %13, i64 1, %mem.Allocator* %3, %runtime.Source_Code_Location* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %18, %..rawptr* %2
	; s
	; CompoundLit
	%19 = bitcast %mem.Raw_Slice* %6 to %..rawptr
	store %mem.Raw_Slice zeroinitializer, %mem.Raw_Slice* %6
	store %mem.Raw_Slice {%..rawptr zeroinitializer, i64 zeroinitializer}, %mem.Raw_Slice* %6
	%20 = load %..rawptr, %..rawptr* %2, align 8
	%21 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %6, i64 0, i32 0
	store %..rawptr %20, %..rawptr* %21
	%22 = load i64, i64* %0, align 8
	%23 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %6, i64 0, i32 1
	store i64 %22, i64* %23
	%24 = load %mem.Raw_Slice, %mem.Raw_Slice* %6, align 8
	store %mem.Raw_Slice %24, %mem.Raw_Slice* %5
	; ReturnStmt
	%25 = load %mem.Raw_Slice, %mem.Raw_Slice* %5, align 8
	%26 = bitcast %mem.Raw_Slice* %5 to {i8*, i64}*
	%27 = load {i8*, i64}, {i8*, i64}* %26, align 8
	ret {i8*, i64} %27
}

define {%..rawptr*, i64, i64, %mem.Allocator} @mem.make_dynamic_array-14399(%mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Allocator, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%3 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; ReturnStmt
	%4 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%5 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%6 = bitcast %mem.Allocator* %0 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %0
	store %mem.Allocator %4, %mem.Allocator* %0
	%7 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %5, %runtime.Source_Code_Location* %1
	%8 = call {%..rawptr*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-20426(i64 0, i64 16, %mem.Allocator* %0, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {%..rawptr*, i64, i64, %mem.Allocator} %8
}

define i64 @runtime.append_elem-14444({%..rawptr*, i64, i64, %mem.Allocator}* %array, %..rawptr %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%..rawptr*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	%5 = alloca %mem.Raw_Dynamic_Array*, align 16
	%6 = alloca %..rawptr*, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	store {%..rawptr*, i64, i64, %mem.Allocator}* %array, {%..rawptr*, i64, i64, %mem.Allocator}** %0
	store %..rawptr %arg, %..rawptr* %1
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {%..rawptr*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %2
	; IfStmt
	%13 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %2, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %2, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %3
	; AssignStmt
	%32 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %3, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %4
	%37 = call i8 @runtime.reserve_dynamic_array-20448({%..rawptr*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %2, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %2
	; IfStmt
	%48 = load i64, i64* %2, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {%..rawptr*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %5
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %5, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to %..rawptr*
	store %..rawptr* %58, %..rawptr** %6
	%59 = load %..rawptr*, %..rawptr** %6, align 8
	%60 = icmp ne %..rawptr* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$273, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$274, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %7
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %7)
	; SelectorExpr
	; SelectorExpr
	%66 = load %..rawptr*, %..rawptr** %6, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %5, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call %..rawptr* @mem.ptr_offset-20462(%..rawptr* %66, i64 %70)
	%72 = bitcast %..rawptr* %71 to %..rawptr
	%73 = bitcast %..rawptr* %1 to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 8)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %5, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %2, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define void @runtime.clear_dynamic_array-14473({%..rawptr*, i64, i64, %mem.Allocator}* %array) alwaysinline #1 {
decls-0:
	%0 = alloca {%..rawptr*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %mem.Raw_Dynamic_Array*, align 16
	store {%..rawptr*, i64, i64, %mem.Allocator}* %array, {%..rawptr*, i64, i64, %mem.Allocator}** %0
	; IfStmt
	%2 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%3 = icmp ne {%..rawptr*, i64, i64, %mem.Allocator}* %2, zeroinitializer
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; SelectorExpr
	%6 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%7 = bitcast {%..rawptr*, i64, i64, %mem.Allocator}* %6 to %mem.Raw_Dynamic_Array*
	%8 = bitcast %mem.Raw_Dynamic_Array** %1 to %..rawptr
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 8) noinline
	store %mem.Raw_Dynamic_Array* zeroinitializer, %mem.Raw_Dynamic_Array** %1
	store %mem.Raw_Dynamic_Array* %7, %mem.Raw_Dynamic_Array** %1
	%10 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %1, align 8
	%11 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %10, i64 0
	%12 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %11, i64 0, i32 1
	store i64 0, i64* %12
	br label %if.done-2

if.done-2:
	ret void
}

define void @mem.delete_slice-14814({i8*, i64}* %array, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64}, align 16
	%1 = alloca %mem.Allocator, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = load {i8*, i64}, {i8*, i64}* %array, align 8
	%4 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%5 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%6 = load {i8*, i64}, {i8*, i64}* %array, align 8
	%7 = bitcast {i8*, i64}* %0 to %..rawptr
	store {i8*, i64} zeroinitializer, {i8*, i64}* %0
	store {i8*, i64} %6, {i8*, i64}* %0
	%8 = call i8* @mem.raw_slice_data-20567({i8*, i64}* %0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%9 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%10 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%11 = bitcast i8* %8 to %..rawptr
	%12 = bitcast %mem.Allocator* %1 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %1
	store %mem.Allocator %9, %mem.Allocator* %1
	%13 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %10, %runtime.Source_Code_Location* %2
	call void @mem.free(%..rawptr %11, %mem.Allocator* %1, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define i64 @runtime.append_string-17996({i8*, i64, i64, %mem.Allocator}* %array, {%..string*, i64}* %args, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i8*, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca {i8*, i64}, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	store {i8*, i64, i64, %mem.Allocator}* %array, {i8*, i64, i64, %mem.Allocator}** %0
	%8 = load {%..string*, i64}, {%..string*, i64}* %args, align 8
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; RangeStmt
	; arg
	%10 = bitcast %..string* %1 to %..rawptr
	%11 = call %..rawptr @mem.zero(%..rawptr %10, i64 16) noinline
	store %..string zeroinitializer, %..string* %1
	%12 = load {%..string*, i64}, {%..string*, i64}* %args, align 8
	%13 = bitcast i64* %2 to %..rawptr
	%14 = call %..rawptr @mem.zero(%..rawptr %13, i64 8) noinline
	store i64 zeroinitializer, i64* %2
	%15 = extractvalue {%..string*, i64} %12, 1
	store i64 %15, i64* %2
	%16 = bitcast i64* %3 to %..rawptr
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 8) noinline
	store i64 zeroinitializer, i64* %3
	store i64 -1, i64* %3
	br label %for.index.loop-1

for.index.loop-1:
	%18 = load i64, i64* %3, align 8
	%19 = add i64 %18, 1
	store i64 %19, i64* %3
	%20 = load i64, i64* %2, align 8
	%21 = icmp slt i64 %19, %20
	br i1 %21, label %for.index.body-2, label %for.index.done-3

for.index.body-2:
	%22 = load i64, i64* %3, align 8
	%23 = extractvalue {%..string*, i64} %12, 0
	%24 = getelementptr inbounds %..string, %..string* %23, i64 %22
	%25 = load %..string, %..string* %24, align 8
	store %..string %25, %..string* %1
	%26 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%27 = load %..string, %..string* %1, align 8
	%28 = extractvalue %..string %27, 0
	%29 = bitcast i8** %4 to %..rawptr
	%30 = call %..rawptr @mem.zero(%..rawptr %29, i64 8) noinline
	store i8* zeroinitializer, i8** %4
	store i8* %28, i8** %4
	%31 = extractvalue %..string %27, 1
	%32 = sub i64 %31, 0
	%33 = load i8*, i8** %4, align 8
	%34 = getelementptr inbounds i8, i8* %33, i64 0
	%35 = bitcast {i8*, i64}* %5 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %5
	%37 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 0
	store i8* %34, i8** %37
	%38 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i64 0, i32 1
	store i64 %32, i64* %38
	%39 = load {i8*, i64}, {i8*, i64}* %5, align 8
	%40 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%41 = bitcast {i8*, i64}* %6 to %..rawptr
	%42 = call %..rawptr @mem.zero(%..rawptr %41, i64 16) noinline
	store {i8*, i64} zeroinitializer, {i8*, i64}* %6
	store {i8*, i64} %39, {i8*, i64}* %6
	%43 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%44 = call %..rawptr @mem.zero(%..rawptr %43, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location %40, %runtime.Source_Code_Location* %7
	%45 = call i64 @runtime.append_elems-18009({i8*, i64, i64, %mem.Allocator}* %26, {i8*, i64}* %6, %runtime.Source_Code_Location* %7, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %for.index.loop-1

for.index.done-3:
	; ReturnStmt
	%46 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%47 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %46, align 8
	%48 = extractvalue {i8*, i64, i64, %mem.Allocator} %47, 1
	ret i64 %48
}

define i64 @runtime.append_elems-18009({i8*, i64, i64, %mem.Allocator}* %array, {i8*, i64}* %args, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca i8*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	store {i8*, i64, i64, %mem.Allocator}* %array, {i8*, i64, i64, %mem.Allocator}** %0
	%7 = load {i8*, i64}, {i8*, i64}* %args, align 8
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {i8*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	%13 = load {i8*, i64}, {i8*, i64}* %args, align 8
	%14 = extractvalue {i8*, i64} %13, 1
	store i64 %14, i64* %1
	; IfStmt
	%15 = load i64, i64* %1, align 8
	%16 = icmp sle i64 %15, 0
	%17 = zext i1 %16 to i8
	%18 = trunc i8 %17 to i1
	br i1 %18, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	%19 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%20 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %19, align 8
	%21 = extractvalue {i8*, i64, i64, %mem.Allocator} %20, 1
	ret i64 %21

if.done-4:
	; IfStmt
	%22 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%23 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %22, align 8
	%24 = extractvalue {i8*, i64, i64, %mem.Allocator} %23, 2
	%25 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%26 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %25, align 8
	%27 = extractvalue {i8*, i64, i64, %mem.Allocator} %26, 1
	%28 = load i64, i64* %1, align 8
	%29 = add i64 %27, %28
	%30 = icmp sle i64 %24, %29
	%31 = zext i1 %30 to i8
	%32 = trunc i8 %31 to i1
	br i1 %32, label %if.then-5, label %if.done-6

if.then-5:
	; cap
	%33 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%34 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %33, align 8
	%35 = extractvalue {i8*, i64, i64, %mem.Allocator} %34, 2
	%36 = mul i64 2, %35
	; max
	%37 = load i64, i64* %1, align 8
	%38 = icmp sgt i64 8, %37
	%39 = select i1 %38, i64 8, i64 %37
	%40 = add i64 %36, %39
	store i64 %40, i64* %2
	; AssignStmt
	%41 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load i64, i64* %2, align 8
	%43 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%44 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%45 = call %..rawptr @mem.zero(%..rawptr %44, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location %43, %runtime.Source_Code_Location* %3
	%46 = call i8 @runtime.reserve_dynamic_array-21696({i8*, i64, i64, %mem.Allocator}* %41, i64 %42, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-6

if.done-6:
	; AssignStmt
	; min
	%47 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%48 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %47, align 8
	%49 = extractvalue {i8*, i64, i64, %mem.Allocator} %48, 2
	%50 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%51 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %50, align 8
	%52 = extractvalue {i8*, i64, i64, %mem.Allocator} %51, 1
	%53 = sub i64 %49, %52
	%54 = load i64, i64* %1, align 8
	%55 = icmp slt i64 %53, %54
	%56 = select i1 %55, i64 %53, i64 %54
	store i64 %56, i64* %1
	; IfStmt
	%57 = load i64, i64* %1, align 8
	%58 = icmp sgt i64 %57, 0
	%59 = zext i1 %58 to i8
	%60 = trunc i8 %59 to i1
	br i1 %60, label %if.then-7, label %if.done-8

if.then-7:
	; a
	%61 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%62 = bitcast {i8*, i64, i64, %mem.Allocator}* %61 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %62, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%63 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%64 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %63, i64 0
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0, i32 0
	%66 = load %..rawptr, %..rawptr* %65, align 8
	%67 = bitcast %..rawptr %66 to i8*
	store i8* %67, i8** %5
	%68 = load i8*, i8** %5, align 8
	%69 = icmp ne i8* %68, zeroinitializer
	%70 = zext i1 %69 to i8
	%71 = trunc i8 %70 to i1
	%72 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	%73 = call %..rawptr @mem.zero(%..rawptr %72, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %6
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$275, i64 0, i32 0), i64 58}, i64 493, i64 3, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$276, i64 0, i32 0), i64 12}}, %runtime.Source_Code_Location* %6
	%74 = call i8 @runtime.assert(i1 %71, %..string zeroinitializer, %runtime.Source_Code_Location* %6)
	; SelectorExpr
	; SelectorExpr
	%75 = load i8*, i8** %5, align 8
	; SelectorExpr
	%76 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0, i32 1
	%79 = load i64, i64* %78, align 8
	%80 = call i8* @mem.ptr_offset-13939(i8* %75, i64 %79)
	; IndexExpr
	%81 = load {i8*, i64}, {i8*, i64}* %args, align 8
	%82 = extractvalue {i8*, i64} %81, 0
	%83 = extractvalue {i8*, i64} %81, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$277, i64 0, i32 0), i64 58}, i64 494, i64 47, i64 0, i64 %83)
	%84 = getelementptr inbounds i8, i8* %82, i64 0
	%85 = load i64, i64* %1, align 8
	%86 = mul i64 1, %85
	%87 = bitcast i8* %80 to %..rawptr
	%88 = bitcast i8* %84 to %..rawptr
	%89 = call %..rawptr @mem.copy(%..rawptr %87, %..rawptr %88, i64 %86)
	; AssignStmt
	; SelectorExpr
	%90 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%91 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %90, i64 0
	%92 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %91, i64 0, i32 1
	%93 = load i64, i64* %1, align 8
	%94 = load i64, i64* %92, align 8
	%95 = add i64 %94, %93
	store i64 %95, i64* %92
	br label %if.done-8

if.done-8:
	; ReturnStmt
	%96 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%97 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %96, align 8
	%98 = extractvalue {i8*, i64, i64, %mem.Allocator} %97, 1
	ret i64 %98
}

define i64 @runtime.append_elem-18028({i8*, i64, i64, %mem.Allocator}* %array, i8 %arg, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %runtime.Source_Code_Location, align 16
	%5 = alloca %mem.Raw_Dynamic_Array*, align 16
	%6 = alloca i8*, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	store {i8*, i64, i64, %mem.Allocator}* %array, {i8*, i64, i64, %mem.Allocator}** %0
	store i8 %arg, i8* %1
	%8 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%9 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%10 = icmp eq {i8*, i64, i64, %mem.Allocator}* %9, zeroinitializer
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i64 0

if.done-2:
	; arg_len
	store i64 1, i64* %2
	; IfStmt
	%13 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%14 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %13, align 8
	%15 = extractvalue {i8*, i64, i64, %mem.Allocator} %14, 2
	%16 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {i8*, i64, i64, %mem.Allocator} %17, 1
	%19 = load i64, i64* %2, align 8
	%20 = add i64 %18, %19
	%21 = icmp sle i64 %15, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%24 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%25 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %24, align 8
	%26 = extractvalue {i8*, i64, i64, %mem.Allocator} %25, 2
	%27 = mul i64 2, %26
	; max
	%28 = load i64, i64* %2, align 8
	%29 = icmp sgt i64 8, %28
	%30 = select i1 %29, i64 8, i64 %28
	%31 = add i64 %27, %30
	store i64 %31, i64* %3
	; AssignStmt
	%32 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%33 = load i64, i64* %3, align 8
	%34 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%35 = bitcast %runtime.Source_Code_Location* %4 to %..rawptr
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %4
	store %runtime.Source_Code_Location %34, %runtime.Source_Code_Location* %4
	%37 = call i8 @runtime.reserve_dynamic_array-21696({i8*, i64, i64, %mem.Allocator}* %32, i64 %33, %runtime.Source_Code_Location* %4, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%38 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {i8*, i64, i64, %mem.Allocator} %39, 2
	%41 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%42 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %41, align 8
	%43 = extractvalue {i8*, i64, i64, %mem.Allocator} %42, 1
	%44 = sub i64 %40, %43
	%45 = load i64, i64* %2, align 8
	%46 = icmp slt i64 %44, %45
	%47 = select i1 %46, i64 %44, i64 %45
	store i64 %47, i64* %2
	; IfStmt
	%48 = load i64, i64* %2, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%52 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {i8*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %5
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %5, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i64 0
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0, i32 0
	%57 = load %..rawptr, %..rawptr* %56, align 8
	%58 = bitcast %..rawptr %57 to i8*
	store i8* %58, i8** %6
	%59 = load i8*, i8** %6, align 8
	%60 = icmp ne i8* %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	%63 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	%64 = call %..rawptr @mem.zero(%..rawptr %63, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %7
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$278, i64 0, i32 0), i64 58}, i64 471, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$279, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %7
	%65 = call i8 @runtime.assert(i1 %62, %..string zeroinitializer, %runtime.Source_Code_Location* %7)
	; SelectorExpr
	; SelectorExpr
	%66 = load i8*, i8** %6, align 8
	; SelectorExpr
	%67 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %5, align 8
	%68 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %67, i64 0
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i64 0, i32 1
	%70 = load i64, i64* %69, align 8
	%71 = call i8* @mem.ptr_offset-13939(i8* %66, i64 %70)
	%72 = bitcast i8* %71 to %..rawptr
	%73 = bitcast i8* %1 to %..rawptr
	%74 = call %..rawptr @mem.copy(%..rawptr %72, %..rawptr %73, i64 1)
	; AssignStmt
	; SelectorExpr
	%75 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %5, align 8
	%76 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %75, i64 0
	%77 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %76, i64 0, i32 1
	%78 = load i64, i64* %2, align 8
	%79 = load i64, i64* %77, align 8
	%80 = add i64 %79, %78
	store i64 %80, i64* %77
	br label %if.done-6

if.done-6:
	; ReturnStmt
	%81 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%82 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %81, align 8
	%83 = extractvalue {i8*, i64, i64, %mem.Allocator} %82, 1
	ret i64 %83
}

define {i8*, i64, i64, %mem.Allocator} @mem.make_dynamic_array-18075(%mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Allocator, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	%2 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%3 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; ReturnStmt
	%4 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%5 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%6 = bitcast %mem.Allocator* %0 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %0
	store %mem.Allocator %4, %mem.Allocator* %0
	%7 = bitcast %runtime.Source_Code_Location* %1 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %1
	store %runtime.Source_Code_Location %5, %runtime.Source_Code_Location* %1
	%8 = call {i8*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-21744(i64 0, i64 16, %mem.Allocator* %0, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret {i8*, i64, i64, %mem.Allocator} %8
}

define i64 @runtime.copy-19008({i8*, i64}* %dst, {i8*, i64}* %src) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = load {i8*, i64}, {i8*, i64}* %dst, align 8
	%2 = load {i8*, i64}, {i8*, i64}* %src, align 8
	; n
	; max
	; min
	%3 = load {i8*, i64}, {i8*, i64}* %dst, align 8
	%4 = extractvalue {i8*, i64} %3, 1
	%5 = load {i8*, i64}, {i8*, i64}* %src, align 8
	%6 = extractvalue {i8*, i64} %5, 1
	%7 = icmp slt i64 %4, %6
	%8 = select i1 %7, i64 %4, i64 %6
	%9 = icmp sgt i64 0, %8
	%10 = select i1 %9, i64 0, i64 %8
	store i64 %10, i64* %0
	; IfStmt
	%11 = load i64, i64* %0, align 8
	%12 = icmp sgt i64 %11, 0
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	; IndexExpr
	%15 = load {i8*, i64}, {i8*, i64}* %dst, align 8
	%16 = extractvalue {i8*, i64} %15, 0
	%17 = extractvalue {i8*, i64} %15, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$27a, i64 0, i32 0), i64 58}, i64 358, i64 28, i64 0, i64 %17)
	%18 = getelementptr inbounds i8, i8* %16, i64 0
	; IndexExpr
	%19 = load {i8*, i64}, {i8*, i64}* %src, align 8
	%20 = extractvalue {i8*, i64} %19, 0
	%21 = extractvalue {i8*, i64} %19, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$27b, i64 0, i32 0), i64 58}, i64 358, i64 37, i64 0, i64 %21)
	%22 = getelementptr inbounds i8, i8* %20, i64 0
	%23 = load i64, i64* %0, align 8
	%24 = mul i64 %23, 1
	%25 = bitcast i8* %18 to %..rawptr
	%26 = bitcast i8* %22 to %..rawptr
	%27 = call %..rawptr @mem.copy(%..rawptr %25, %..rawptr %26, i64 %24)
	br label %if.done-2

if.done-2:
	; ReturnStmt
	%28 = load i64, i64* %0, align 8
	ret i64 %28
}

define {%prebuild.main.Component_Definition-250*, i64} @wbml.deserialize-20347(%..string %text, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %lexer.Lexer, align 16
	%2 = alloca %lexer.Lexer, align 16
	%3 = alloca %lexer.Lexer*, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca {%prebuild.main.Component_Definition-250*, i64}, align 16
	%6 = alloca %..rawptr, align 16
	%7 = alloca %lexer.Token, align 16
	%8 = alloca i8, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca %runtime.Source_Code_Location, align 16
	%11 = alloca %lexer.Token, align 16
	store %..string %text, %..string* %0
	; _lexer
	; CompoundLit
	%12 = bitcast %lexer.Lexer* %2 to %..rawptr
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 56) noinline
	store %lexer.Lexer zeroinitializer, %lexer.Lexer* %2
	store %lexer.Lexer {%..string zeroinitializer, i64 0, i64 0, i64 0, %..any zeroinitializer}, %lexer.Lexer* %2
	%14 = load %..string, %..string* %0, align 8
	%15 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %2, i64 0, i32 0
	store %..string %14, %..string* %15
	%16 = getelementptr inbounds %lexer.Lexer, %lexer.Lexer* %2, i64 0, i32 4
	store %..any zeroinitializer, %..any* %16
	%17 = load %lexer.Lexer, %lexer.Lexer* %2, align 8
	store %lexer.Lexer %17, %lexer.Lexer* %1
	; lexer
	store %lexer.Lexer* %1, %lexer.Lexer** %3
	; ti
	%18 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 90
	store %runtime.Type_Info* %18, %runtime.Type_Info** %4
	; t
	%19 = bitcast {%prebuild.main.Component_Definition-250*, i64}* %5 to %..rawptr
	%20 = call %..rawptr @mem.zero(%..rawptr %19, i64 16) noinline
	store {%prebuild.main.Component_Definition-250*, i64} zeroinitializer, {%prebuild.main.Component_Definition-250*, i64}* %5
	; data
	%21 = bitcast {%prebuild.main.Component_Definition-250*, i64}* %5 to %..rawptr
	store %..rawptr %21, %..rawptr* %6
	; token
	; ok
	%22 = load %lexer.Lexer*, %lexer.Lexer** %3, align 8
	%23 = bitcast %runtime.Source_Code_Location* %9 to %..rawptr
	%24 = call %..rawptr @mem.zero(%..rawptr %23, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %9
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$27c, i64 0, i32 0), i64 67}, i64 146, i64 15, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$27d, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %9
	%25 = call {%lexer.Token, i8} @lexer.get_next_token(%lexer.Lexer* %22, %runtime.Source_Code_Location* %9, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	%26 = extractvalue {%lexer.Token, i8} %25, 0
	%27 = extractvalue {%lexer.Token, i8} %25, 1
	store %lexer.Token %26, %lexer.Token* %7
	store i8 %27, i8* %8
	; IfStmt
	%28 = load i8, i8* %8, align 1
	%29 = trunc i8 %28 to i1
	br i1 %29, label %if.done-2, label %if.then-1

if.then-1:
	%30 = bitcast %runtime.Source_Code_Location* %10 to %..rawptr
	%31 = call %..rawptr @mem.zero(%..rawptr %30, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %10
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$27e, i64 0, i32 0), i64 67}, i64 147, i64 12, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$27f, i64 0, i32 0), i64 11}}, %runtime.Source_Code_Location* %10
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$280, i64 0, i32 0), i64 10}, %runtime.Source_Code_Location* %10) noreturn
	br label %if.done-2

if.done-2:
	%32 = load %lexer.Lexer*, %lexer.Lexer** %3, align 8
	%33 = load %lexer.Token, %lexer.Token* %7, align 8
	%34 = load %..rawptr, %..rawptr* %6, align 8
	%35 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	%36 = bitcast %lexer.Token* %11 to %..rawptr
	%37 = call %..rawptr @mem.zero(%..rawptr %36, i64 56) noinline
	store %lexer.Token zeroinitializer, %lexer.Token* %11
	store %lexer.Token %33, %lexer.Token* %11
	call void @wbml.parse_value(%lexer.Lexer* %32, %lexer.Token* %11, %..rawptr %34, %runtime.Type_Info* %35, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; ReturnStmt
	%38 = load {%prebuild.main.Component_Definition-250*, i64}, {%prebuild.main.Component_Definition-250*, i64}* %5, align 8
	ret {%prebuild.main.Component_Definition-250*, i64} %38
}

define void @mem.delete_dynamic_array-20363({i8*, i64, i64, %mem.Allocator}* %array, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}, align 16
	%1 = alloca %mem.Allocator, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %array, align 8
	%4 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%5 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %array, align 8
	%6 = bitcast {i8*, i64, i64, %mem.Allocator}* %0 to %..rawptr
	store {i8*, i64, i64, %mem.Allocator} zeroinitializer, {i8*, i64, i64, %mem.Allocator}* %0
	store {i8*, i64, i64, %mem.Allocator} %5, {i8*, i64, i64, %mem.Allocator}* %0
	%7 = call i8* @mem.raw_dynamic_array_data-22404({i8*, i64, i64, %mem.Allocator}* %0, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	; SelectorExpr
	%8 = getelementptr inbounds {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %array, i64 0, i32 3
	%9 = load %mem.Allocator, %mem.Allocator* %8, align 8
	%10 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%11 = bitcast i8* %7 to %..rawptr
	%12 = bitcast %mem.Allocator* %1 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %1
	store %mem.Allocator %9, %mem.Allocator* %1
	%13 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %10, %runtime.Source_Code_Location* %2
	call void @mem.free(%..rawptr %11, %mem.Allocator* %1, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	ret void
}

define {%..rawptr*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-20426(i64 %len, i64 %cap, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %..rawptr, align 16
	%4 = alloca %mem.Allocator, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca %mem.Raw_Dynamic_Array, align 16
	%7 = alloca %mem.Raw_Dynamic_Array, align 16
	store i64 %len, i64* %0
	store i64 %cap, i64* %1
	%8 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%10 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%11 = load i64, i64* %0, align 8
	%12 = load i64, i64* %1, align 8
	%13 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %10, %runtime.Source_Code_Location* %2
	call void @runtime.make_dynamic_array_error_loc(%runtime.Source_Code_Location* %2, i64 %11, i64 %12)
	; data
	%14 = load i64, i64* %1, align 8
	%15 = mul i64 8, %14
	%16 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%17 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%18 = bitcast %mem.Allocator* %4 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %4
	store %mem.Allocator %16, %mem.Allocator* %4
	%19 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location %17, %runtime.Source_Code_Location* %5
	%20 = call %..rawptr @mem.alloc(i64 %15, i64 8, %mem.Allocator* %4, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %20, %..rawptr* %3
	; s
	; CompoundLit
	%21 = bitcast %mem.Raw_Dynamic_Array* %7 to %..rawptr
	store %mem.Raw_Dynamic_Array zeroinitializer, %mem.Raw_Dynamic_Array* %7
	store %mem.Raw_Dynamic_Array {%..rawptr zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %mem.Allocator zeroinitializer}, %mem.Raw_Dynamic_Array* %7
	%22 = load %..rawptr, %..rawptr* %3, align 8
	%23 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 0
	store %..rawptr %22, %..rawptr* %23
	%24 = load i64, i64* %0, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 1
	store i64 %24, i64* %25
	%26 = load i64, i64* %1, align 8
	%27 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 2
	store i64 %26, i64* %27
	%28 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%29 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 3
	store %mem.Allocator %28, %mem.Allocator* %29
	%30 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, align 8
	store %mem.Raw_Dynamic_Array %30, %mem.Raw_Dynamic_Array* %6
	; ReturnStmt
	%31 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %6, align 8
	%32 = bitcast %mem.Raw_Dynamic_Array* %6 to {%..rawptr*, i64, i64, %mem.Allocator}*
	%33 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %32, align 8
	ret {%..rawptr*, i64, i64, %mem.Allocator} %33
}

define i8 @runtime.reserve_dynamic_array-20448({%..rawptr*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%..rawptr*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {%..rawptr*, i64, i64, %mem.Allocator}* %array, {%..rawptr*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {%..rawptr*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {%..rawptr*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$281, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$282, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 8
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 8
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 8, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define %..rawptr* @mem.ptr_offset-20462(%..rawptr* %ptr, i64 %n) #0 {
decls-0:
	%0 = alloca %..rawptr*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %..rawptr* %ptr, %..rawptr** %0
	store i64 %n, i64* %1
	; new
	%3 = load %..rawptr*, %..rawptr** %0, align 8
	%4 = ptrtoint %..rawptr* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 8, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to %..rawptr*
	ret %..rawptr* %11
}

define i8* @mem.raw_slice_data-20567({i8*, i64}* %a, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %mem.Raw_Slice*, align 16
	%1 = load {i8*, i64}, {i8*, i64}* %a, align 8
	; ReturnStmt
	; SelectorExpr
	%2 = bitcast {i8*, i64}* %a to %mem.Raw_Slice*
	%3 = bitcast %mem.Raw_Slice** %0 to %..rawptr
	store %mem.Raw_Slice* zeroinitializer, %mem.Raw_Slice** %0
	store %mem.Raw_Slice* %2, %mem.Raw_Slice** %0
	%4 = load %mem.Raw_Slice*, %mem.Raw_Slice** %0, align 8
	%5 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %4, i64 0
	%6 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %5, i64 0, i32 0
	%7 = load %..rawptr, %..rawptr* %6, align 8
	%8 = bitcast %..rawptr %7 to i8*
	ret i8* %8
}

define i8 @runtime.reserve_dynamic_array-21696({i8*, i64, i64, %mem.Allocator}* %array, i64 %capacity, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store {i8*, i64, i64, %mem.Allocator}* %array, {i8*, i64, i64, %mem.Allocator}** %0
	store i64 %capacity, i64* %1
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; IfStmt
	%10 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%11 = icmp eq {i8*, i64, i64, %mem.Allocator}* %10, zeroinitializer
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%14 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%15 = bitcast {i8*, i64, i64, %mem.Allocator}* %14 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %15, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%16 = load i64, i64* %1, align 8
	; SelectorExpr
	%17 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %17, i64 0
	%19 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %18, i64 0, i32 2
	%20 = load i64, i64* %19, align 8
	%21 = icmp sle i64 %16, %20
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%24 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %24, i64 0
	%26 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %25, i64 0, i32 3
	%27 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %26, i64 0, i32 0
	%28 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %27, align 8
	%29 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i64 0
	%34 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %33, i64 0, i32 3
	; SelectorExpr
	%35 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i64 0, i32 0
	%36 = load %mem.Allocator, %mem.Allocator* %35, align 8
	store %mem.Allocator %36, %mem.Allocator* %34
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%37 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%38 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %37, i64 0
	%39 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %38, i64 0, i32 3
	%40 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %39, i64 0, i32 0
	%41 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %40, align 8
	%42 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %41, zeroinitializer
	%43 = zext i1 %42 to i8
	%44 = trunc i8 %43 to i1
	%45 = bitcast %runtime.Source_Code_Location* %3 to %..rawptr
	%46 = call %..rawptr @mem.zero(%..rawptr %45, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([59 x i8], [59 x i8]* @str$283, i64 0, i32 0), i64 58}, i64 526, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$284, i64 0, i32 0), i64 21}}, %runtime.Source_Code_Location* %3
	%47 = call i8 @runtime.assert(i1 %44, %..string zeroinitializer, %runtime.Source_Code_Location* %3)
	; old_size
	; SelectorExpr
	%48 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%49 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %48, i64 0
	%50 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %49, i64 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = mul i64 %51, 1
	store i64 %52, i64* %4
	; new_size
	%53 = load i64, i64* %1, align 8
	%54 = mul i64 %53, 1
	store i64 %54, i64* %5
	; allocator
	; SelectorExpr
	%55 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%56 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %55, i64 0
	%57 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %56, i64 0, i32 3
	%58 = load %mem.Allocator, %mem.Allocator* %57, align 8
	store %mem.Allocator %58, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%59 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 0
	%60 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %59, align 8
	; SelectorExpr
	%61 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i64 0, i32 1
	%62 = load %..rawptr, %..rawptr* %61, align 8
	%63 = load i64, i64* %5, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i64 0
	%66 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %65, i64 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = load i64, i64* %4, align 8
	%69 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%70 = bitcast %runtime.Source_Code_Location* %8 to %..rawptr
	%71 = call %..rawptr @mem.zero(%..rawptr %70, i64 48) noinline
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %8
	store %runtime.Source_Code_Location %69, %runtime.Source_Code_Location* %8
	%72 = call %..rawptr %60(%..rawptr %62, i8 3, i64 %63, i64 1, %..rawptr %67, i64 %68, i64 0, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %72, %..rawptr* %7
	; IfStmt
	%73 = load %..rawptr, %..rawptr* %7, align 8
	%74 = icmp eq %..rawptr %73, zeroinitializer
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i64 0
	%79 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %78, i64 0, i32 0
	%80 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %80, %..rawptr* %79
	; AssignStmt
	; SelectorExpr
	%81 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%82 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %81, i64 0
	%83 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %82, i64 0, i32 2
	%84 = load i64, i64* %1, align 8
	store i64 %84, i64* %83
	; ReturnStmt
	ret i8 1
}

define {i8*, i64, i64, %mem.Allocator} @mem.make_dynamic_array_len_cap-21744(i64 %len, i64 %cap, %mem.Allocator* %allocator, %runtime.Source_Code_Location* %loc, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca %..rawptr, align 16
	%4 = alloca %mem.Allocator, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca %mem.Raw_Dynamic_Array, align 16
	%7 = alloca %mem.Raw_Dynamic_Array, align 16
	store i64 %len, i64* %0
	store i64 %cap, i64* %1
	%8 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%9 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	; SelectorExpr
	%10 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%11 = load i64, i64* %0, align 8
	%12 = load i64, i64* %1, align 8
	%13 = bitcast %runtime.Source_Code_Location* %2 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %2
	store %runtime.Source_Code_Location %10, %runtime.Source_Code_Location* %2
	call void @runtime.make_dynamic_array_error_loc(%runtime.Source_Code_Location* %2, i64 %11, i64 %12)
	; data
	%14 = load i64, i64* %1, align 8
	%15 = mul i64 1, %14
	%16 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%17 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %loc, align 8
	%18 = bitcast %mem.Allocator* %4 to %..rawptr
	store %mem.Allocator zeroinitializer, %mem.Allocator* %4
	store %mem.Allocator %16, %mem.Allocator* %4
	%19 = bitcast %runtime.Source_Code_Location* %5 to %..rawptr
	store %runtime.Source_Code_Location zeroinitializer, %runtime.Source_Code_Location* %5
	store %runtime.Source_Code_Location %17, %runtime.Source_Code_Location* %5
	%20 = call %..rawptr @mem.alloc(i64 %15, i64 1, %mem.Allocator* %4, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr)
	store %..rawptr %20, %..rawptr* %3
	; s
	; CompoundLit
	%21 = bitcast %mem.Raw_Dynamic_Array* %7 to %..rawptr
	store %mem.Raw_Dynamic_Array zeroinitializer, %mem.Raw_Dynamic_Array* %7
	store %mem.Raw_Dynamic_Array {%..rawptr zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %mem.Allocator zeroinitializer}, %mem.Raw_Dynamic_Array* %7
	%22 = load %..rawptr, %..rawptr* %3, align 8
	%23 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 0
	store %..rawptr %22, %..rawptr* %23
	%24 = load i64, i64* %0, align 8
	%25 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 1
	store i64 %24, i64* %25
	%26 = load i64, i64* %1, align 8
	%27 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 2
	store i64 %26, i64* %27
	%28 = load %mem.Allocator, %mem.Allocator* %allocator, align 8
	%29 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, i64 0, i32 3
	store %mem.Allocator %28, %mem.Allocator* %29
	%30 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %7, align 8
	store %mem.Raw_Dynamic_Array %30, %mem.Raw_Dynamic_Array* %6
	; ReturnStmt
	%31 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %6, align 8
	%32 = bitcast %mem.Raw_Dynamic_Array* %6 to {i8*, i64, i64, %mem.Allocator}*
	%33 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %32, align 8
	ret {i8*, i64, i64, %mem.Allocator} %33
}

define i8* @mem.raw_dynamic_array_data-22404({i8*, i64, i64, %mem.Allocator}* %a, %runtime.Context* noalias nonnull nocapture inreg %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %mem.Raw_Dynamic_Array*, align 16
	%1 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %a, align 8
	; ReturnStmt
	; SelectorExpr
	%2 = bitcast {i8*, i64, i64, %mem.Allocator}* %a to %mem.Raw_Dynamic_Array*
	%3 = bitcast %mem.Raw_Dynamic_Array** %0 to %..rawptr
	store %mem.Raw_Dynamic_Array* zeroinitializer, %mem.Raw_Dynamic_Array** %0
	store %mem.Raw_Dynamic_Array* %2, %mem.Raw_Dynamic_Array** %0
	%4 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %0, align 8
	%5 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %4, i64 0
	%6 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %5, i64 0, i32 0
	%7 = load %..rawptr, %..rawptr* %6, align 8
	%8 = bitcast %..rawptr %7 to i8*
	ret i8* %8
}

define ccc i32 @main(i32 %argc, i8** %argv) noinline #2 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i8**, align 16
	store i32 %argc, i32* %0
	store i8** %argv, i8*** %1
	%2 = load i32, i32* %0, align 4
	%3 = load i8**, i8*** %1, align 8
	%4 = sext i32 %2 to i64
	%5 = getelementptr inbounds {i8**, i64}, {i8**, i64}* @runtime.args__, i64 0, i32 0
	store i8** %3, i8*** %5
	%6 = getelementptr inbounds {i8**, i64}, {i8**, i64}* @runtime.args__, i64 0, i32 1
	store i64 %4, i64* %6
	call void @__$startup_runtime()
	call void @prebuild.main() noinline
	ret i32 0
}

define void @__$startup_runtime() noinline #2 {
decls-0:
	call void @runtime.__init_context(%runtime.Context* @ggv$0) noinline
	%0 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 0
	%1 = getelementptr inbounds {%runtime.Type_Info*, i64}, {%runtime.Type_Info*, i64}* @runtime.type_table, i64 0, i32 0
	store %runtime.Type_Info* %0, %runtime.Type_Info** %1
	%2 = getelementptr inbounds {%runtime.Type_Info*, i64}, {%runtime.Type_Info*, i64}* @runtime.type_table, i64 0, i32 1
	store i64 105, i64* %2
	%3 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%4 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3, i64 0, i32 3
	%5 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3, i64 0, i32 0
	store i64 8, i64* %5
	%6 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3, i64 0, i32 1
	store i64 8, i64* %6
	%7 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %3, i64 0, i32 2
	store %..typeid 4683743612465315846, %..typeid* %7
	; Type_Info_Basic
	%8 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4 to %runtime.Type_Info_Integer*
	%9 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %8, i64 0, i32 0
	store i8 1, i8* %9
	%10 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %8, align 1
	%11 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %4 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %10, %runtime.Type_Info_Integer* %11
	%12 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %4, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %12
	%13 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 60
	%14 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %13, i64 0, i32 3
	%15 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %13, i64 0, i32 0
	store i64 4, i64* %15
	%16 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %13, i64 0, i32 1
	store i64 4, i64* %16
	%17 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %13, i64 0, i32 2
	store %..typeid 4683743612465315900, %..typeid* %17
	; Type_Info_Basic
	%18 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %14 to %runtime.Type_Info_Integer*
	%19 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %18, i64 0, i32 0
	store i8 1, i8* %19
	%20 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %18, align 1
	%21 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %14 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %20, %runtime.Type_Info_Integer* %21
	%22 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %14, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %22
	%23 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 7
	%24 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %23, i64 0, i32 3
	%25 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %23, i64 0, i32 0
	store i64 8, i64* %25
	%26 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %23, i64 0, i32 1
	store i64 8, i64* %26
	%27 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %23, i64 0, i32 2
	store %..typeid 7, %..typeid* %27
	; Type_Info_Basic
	%28 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %24 to %runtime.Type_Info_Type_Id*
	%29 = load %runtime.Type_Info_Type_Id, %runtime.Type_Info_Type_Id* %28, align 1
	%30 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %24 to %runtime.Type_Info_Type_Id*
	store %runtime.Type_Info_Type_Id %29, %runtime.Type_Info_Type_Id* %30
	%31 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %24, i64 0, i32 2 ; UnionTagPtr
	store i8 9, i8* %31
	%32 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%33 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %32, i64 0, i32 3
	%34 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %32, i64 0, i32 0
	store i64 80, i64* %34
	%35 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %32, i64 0, i32 1
	store i64 8, i64* %35
	%36 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %32, i64 0, i32 2
	store %..typeid 1152921504606846984, %..typeid* %36
	; Type_Info_Union
	%37 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %33 to %runtime.Type_Info_Union*
	%38 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %37, i64 0, i32 0
	%39 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %37, i64 0, i32 1
	%40 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %37, i64 0, i32 2
	%41 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %37, i64 0, i32 3
	%42 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 0
	%43 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 12
	%44 = bitcast %runtime.Type_Info* %43 to %runtime.Type_Info*
	%45 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 0
	%46 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 12
	store %runtime.Type_Info* %46, %runtime.Type_Info** %45
	%47 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 14
	%48 = bitcast %runtime.Type_Info* %47 to %runtime.Type_Info*
	%49 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 1
	%50 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 14
	store %runtime.Type_Info* %50, %runtime.Type_Info** %49
	%51 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 17
	%52 = bitcast %runtime.Type_Info* %51 to %runtime.Type_Info*
	%53 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 2
	%54 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 17
	store %runtime.Type_Info* %54, %runtime.Type_Info** %53
	%55 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 19
	%56 = bitcast %runtime.Type_Info* %55 to %runtime.Type_Info*
	%57 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 3
	%58 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 19
	store %runtime.Type_Info* %58, %runtime.Type_Info** %57
	%59 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	%60 = bitcast %runtime.Type_Info* %59 to %runtime.Type_Info*
	%61 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 4
	%62 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	store %runtime.Type_Info* %62, %runtime.Type_Info** %61
	%63 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 21
	%64 = bitcast %runtime.Type_Info* %63 to %runtime.Type_Info*
	%65 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 5
	%66 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 21
	store %runtime.Type_Info* %66, %runtime.Type_Info** %65
	%67 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 23
	%68 = bitcast %runtime.Type_Info* %67 to %runtime.Type_Info*
	%69 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 6
	%70 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 23
	store %runtime.Type_Info* %70, %runtime.Type_Info** %69
	%71 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 24
	%72 = bitcast %runtime.Type_Info* %71 to %runtime.Type_Info*
	%73 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 7
	%74 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 24
	store %runtime.Type_Info* %74, %runtime.Type_Info** %73
	%75 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 25
	%76 = bitcast %runtime.Type_Info* %75 to %runtime.Type_Info*
	%77 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 8
	%78 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 25
	store %runtime.Type_Info* %78, %runtime.Type_Info** %77
	%79 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 26
	%80 = bitcast %runtime.Type_Info* %79 to %runtime.Type_Info*
	%81 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 9
	%82 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 26
	store %runtime.Type_Info* %82, %runtime.Type_Info** %81
	%83 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 28
	%84 = bitcast %runtime.Type_Info* %83 to %runtime.Type_Info*
	%85 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 10
	%86 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 28
	store %runtime.Type_Info* %86, %runtime.Type_Info** %85
	%87 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 32
	%88 = bitcast %runtime.Type_Info* %87 to %runtime.Type_Info*
	%89 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 11
	%90 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 32
	store %runtime.Type_Info* %90, %runtime.Type_Info** %89
	%91 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 34
	%92 = bitcast %runtime.Type_Info* %91 to %runtime.Type_Info*
	%93 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 12
	%94 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 34
	store %runtime.Type_Info* %94, %runtime.Type_Info** %93
	%95 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 36
	%96 = bitcast %runtime.Type_Info* %95 to %runtime.Type_Info*
	%97 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 13
	%98 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 36
	store %runtime.Type_Info* %98, %runtime.Type_Info** %97
	%99 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 37
	%100 = bitcast %runtime.Type_Info* %99 to %runtime.Type_Info*
	%101 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 14
	%102 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 37
	store %runtime.Type_Info* %102, %runtime.Type_Info** %101
	%103 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 43
	%104 = bitcast %runtime.Type_Info* %103 to %runtime.Type_Info*
	%105 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 15
	%106 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 43
	store %runtime.Type_Info* %106, %runtime.Type_Info** %105
	%107 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 50
	%108 = bitcast %runtime.Type_Info* %107 to %runtime.Type_Info*
	%109 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 16
	%110 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 50
	store %runtime.Type_Info* %110, %runtime.Type_Info** %109
	%111 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 52
	%112 = bitcast %runtime.Type_Info* %111 to %runtime.Type_Info*
	%113 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 17
	%114 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 52
	store %runtime.Type_Info* %114, %runtime.Type_Info** %113
	%115 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 67
	%116 = bitcast %runtime.Type_Info* %115 to %runtime.Type_Info*
	%117 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 18
	%118 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 67
	store %runtime.Type_Info* %118, %runtime.Type_Info** %117
	%119 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 69
	%120 = bitcast %runtime.Type_Info* %119 to %runtime.Type_Info*
	%121 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 19
	%122 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 69
	store %runtime.Type_Info* %122, %runtime.Type_Info** %121
	%123 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 73
	%124 = bitcast %runtime.Type_Info* %123 to %runtime.Type_Info*
	%125 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %42, i64 20
	%126 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 73
	store %runtime.Type_Info* %126, %runtime.Type_Info** %125
	%127 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %38, i64 0, i32 0
	store %runtime.Type_Info** %42, %runtime.Type_Info*** %127
	%128 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %38, i64 0, i32 1
	store i64 21, i64* %128
	store i64 72, i64* %39
	%129 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	store %runtime.Type_Info* %129, %runtime.Type_Info** %40
	store i8 0, i8* %41
	%130 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %37, align 8
	%131 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %33 to %runtime.Type_Info_Union*
	store %runtime.Type_Info_Union %130, %runtime.Type_Info_Union* %131
	%132 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %33, i64 0, i32 2 ; UnionTagPtr
	store i8 17, i8* %132
	%133 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%134 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %133, i64 0, i32 3
	%135 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %133, i64 0, i32 0
	store i64 8, i64* %135
	%136 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %133, i64 0, i32 1
	store i64 8, i64* %136
	%137 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %133, i64 0, i32 2
	store %..typeid 648518346341351433, %..typeid* %137
	; Type_Info_Pointer
	%138 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %134 to %runtime.Type_Info_Pointer*
	%139 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 10
	%140 = bitcast %runtime.Type_Info* %139 to %runtime.Type_Info*
	%141 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %138, i64 0, i32 0
	store %runtime.Type_Info* %140, %runtime.Type_Info** %141
	%142 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %138, align 8
	%143 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %134 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %142, %runtime.Type_Info_Pointer* %143
	%144 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %134, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %144
	%145 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 10
	%146 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %145, i64 0, i32 3
	%147 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %145, i64 0, i32 0
	store i64 104, i64* %147
	%148 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %145, i64 0, i32 1
	store i64 8, i64* %148
	%149 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %145, i64 0, i32 2
	store %..typeid 3386706919782613002, %..typeid* %149
	; Type_Info_Named
	%150 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %146 to %runtime.Type_Info_Named*
	%151 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%152 = bitcast %runtime.Type_Info* %151 to %runtime.Type_Info*
	%153 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %150, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$285, i64 0, i32 0), i64 9}, %..string* %153
	%154 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %150, i64 0, i32 1
	store %runtime.Type_Info* %152, %runtime.Type_Info** %154
	%155 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %150, align 8
	%156 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %146 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %155, %runtime.Type_Info_Named* %156
	%157 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %146, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %157
	%158 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 11
	%159 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %158, i64 0, i32 3
	%160 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %158, i64 0, i32 0
	store i64 104, i64* %160
	%161 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %158, i64 0, i32 1
	store i64 8, i64* %161
	%162 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %158, i64 0, i32 2
	store %..typeid 1080863910568919051, %..typeid* %162
	; Type_Info_Struct
	%163 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %159 to %runtime.Type_Info_Struct*
	%164 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %163, i64 0, i32 4
	store i8 0, i8* %164
	%165 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %163, i64 0, i32 5
	store i8 0, i8* %165
	%166 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %163, i64 0, i32 6
	store i8 0, i8* %166
	%167 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 21
	%168 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 0
	%169 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 0
	%170 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 0
	%171 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%172 = bitcast %runtime.Type_Info* %171 to %runtime.Type_Info*
	%173 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %167, i64 0
	%174 = getelementptr inbounds i64, i64* %169, i64 0
	%175 = getelementptr inbounds i8, i8* %170, i64 0
	%176 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %176, %runtime.Type_Info** %173
	%177 = getelementptr inbounds %..string, %..string* %168, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$286, i64 0, i32 0), i64 4}, %..string* %177
	store i64 0, i64* %174
	store i8 0, i8* %175
	%178 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%179 = bitcast %runtime.Type_Info* %178 to %runtime.Type_Info*
	%180 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %167, i64 1
	%181 = getelementptr inbounds i64, i64* %169, i64 1
	%182 = getelementptr inbounds i8, i8* %170, i64 1
	%183 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %183, %runtime.Type_Info** %180
	%184 = getelementptr inbounds %..string, %..string* %168, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$287, i64 0, i32 0), i64 5}, %..string* %184
	store i64 8, i64* %181
	store i8 0, i8* %182
	%185 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 7
	%186 = bitcast %runtime.Type_Info* %185 to %runtime.Type_Info*
	%187 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %167, i64 2
	%188 = getelementptr inbounds i64, i64* %169, i64 2
	%189 = getelementptr inbounds i8, i8* %170, i64 2
	%190 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 7
	store %runtime.Type_Info* %190, %runtime.Type_Info** %187
	%191 = getelementptr inbounds %..string, %..string* %168, i64 2
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$288, i64 0, i32 0), i64 2}, %..string* %191
	store i64 16, i64* %188
	store i8 0, i8* %189
	%192 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%193 = bitcast %runtime.Type_Info* %192 to %runtime.Type_Info*
	%194 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %167, i64 3
	%195 = getelementptr inbounds i64, i64* %169, i64 3
	%196 = getelementptr inbounds i8, i8* %170, i64 3
	%197 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	store %runtime.Type_Info* %197, %runtime.Type_Info** %194
	%198 = getelementptr inbounds %..string, %..string* %168, i64 3
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$289, i64 0, i32 0), i64 7}, %..string* %198
	store i64 24, i64* %195
	store i8 0, i8* %196
	%199 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %163, i64 0, i32 0
	%200 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %199, i64 0, i32 0
	store %runtime.Type_Info** %167, %runtime.Type_Info*** %200
	%201 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %199, i64 0, i32 1
	store i64 4, i64* %201
	%202 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %163, i64 0, i32 1
	%203 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %202, i64 0, i32 0
	store %..string* %168, %..string** %203
	%204 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %202, i64 0, i32 1
	store i64 4, i64* %204
	%205 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %163, i64 0, i32 2
	%206 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %205, i64 0, i32 0
	store i64* %169, i64** %206
	%207 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %205, i64 0, i32 1
	store i64 4, i64* %207
	%208 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %163, i64 0, i32 3
	%209 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %208, i64 0, i32 0
	store i8* %170, i8** %209
	%210 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %208, i64 0, i32 1
	store i64 4, i64* %210
	%211 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %163, align 8
	%212 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %159 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %211, %runtime.Type_Info_Struct* %212
	%213 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %159, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %213
	%214 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 12
	%215 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %214, i64 0, i32 3
	%216 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %214, i64 0, i32 0
	store i64 24, i64* %216
	%217 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %214, i64 0, i32 1
	store i64 8, i64* %217
	%218 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %214, i64 0, i32 2
	store %..typeid 3386706919782613004, %..typeid* %218
	; Type_Info_Named
	%219 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %215 to %runtime.Type_Info_Named*
	%220 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 13
	%221 = bitcast %runtime.Type_Info* %220 to %runtime.Type_Info*
	%222 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %219, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$28a, i64 0, i32 0), i64 15}, %..string* %222
	%223 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %219, i64 0, i32 1
	store %runtime.Type_Info* %221, %runtime.Type_Info** %223
	%224 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %219, align 8
	%225 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %215 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %224, %runtime.Type_Info_Named* %225
	%226 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %215, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %226
	%227 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 13
	%228 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %227, i64 0, i32 3
	%229 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %227, i64 0, i32 0
	store i64 24, i64* %229
	%230 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %227, i64 0, i32 1
	store i64 8, i64* %230
	%231 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %227, i64 0, i32 2
	store %..typeid 1080863910568919053, %..typeid* %231
	; Type_Info_Struct
	%232 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %228 to %runtime.Type_Info_Struct*
	%233 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %232, i64 0, i32 4
	store i8 0, i8* %233
	%234 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %232, i64 0, i32 5
	store i8 0, i8* %234
	%235 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %232, i64 0, i32 6
	store i8 0, i8* %235
	%236 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 25
	%237 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 4
	%238 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 4
	%239 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 4
	%240 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%241 = bitcast %runtime.Type_Info* %240 to %runtime.Type_Info*
	%242 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %236, i64 0
	%243 = getelementptr inbounds i64, i64* %238, i64 0
	%244 = getelementptr inbounds i8, i8* %239, i64 0
	%245 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	store %runtime.Type_Info* %245, %runtime.Type_Info** %242
	%246 = getelementptr inbounds %..string, %..string* %237, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$28b, i64 0, i32 0), i64 4}, %..string* %246
	store i64 0, i64* %243
	store i8 0, i8* %244
	%247 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%248 = bitcast %runtime.Type_Info* %247 to %runtime.Type_Info*
	%249 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %236, i64 1
	%250 = getelementptr inbounds i64, i64* %238, i64 1
	%251 = getelementptr inbounds i8, i8* %239, i64 1
	%252 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	store %runtime.Type_Info* %252, %runtime.Type_Info** %249
	%253 = getelementptr inbounds %..string, %..string* %237, i64 1
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$28c, i64 0, i32 0), i64 4}, %..string* %253
	store i64 16, i64* %250
	store i8 0, i8* %251
	%254 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %232, i64 0, i32 0
	%255 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %254, i64 0, i32 0
	store %runtime.Type_Info** %236, %runtime.Type_Info*** %255
	%256 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %254, i64 0, i32 1
	store i64 2, i64* %256
	%257 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %232, i64 0, i32 1
	%258 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %257, i64 0, i32 0
	store %..string* %237, %..string** %258
	%259 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %257, i64 0, i32 1
	store i64 2, i64* %259
	%260 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %232, i64 0, i32 2
	%261 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %260, i64 0, i32 0
	store i64* %238, i64** %261
	%262 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %260, i64 0, i32 1
	store i64 2, i64* %262
	%263 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %232, i64 0, i32 3
	%264 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %263, i64 0, i32 0
	store i8* %239, i8** %264
	%265 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %263, i64 0, i32 1
	store i64 2, i64* %265
	%266 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %232, align 8
	%267 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %228 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %266, %runtime.Type_Info_Struct* %267
	%268 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %228, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %268
	%269 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%270 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %269, i64 0, i32 3
	%271 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %269, i64 0, i32 0
	store i64 16, i64* %271
	%272 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %269, i64 0, i32 1
	store i64 8, i64* %272
	%273 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %269, i64 0, i32 2
	store %..typeid 360287970189639684, %..typeid* %273
	; Type_Info_Basic
	%274 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %270 to %runtime.Type_Info_String*
	%275 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %274, align 1
	%276 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %270 to %runtime.Type_Info_String*
	store %runtime.Type_Info_String %275, %runtime.Type_Info_String* %276
	%277 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %270, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %277
	%278 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 5
	%279 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %278, i64 0, i32 3
	%280 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %278, i64 0, i32 0
	store i64 8, i64* %280
	%281 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %278, i64 0, i32 1
	store i64 8, i64* %281
	%282 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %278, i64 0, i32 2
	store %..typeid 648518346341351429, %..typeid* %282
	; Type_Info_Pointer
	%283 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %279 to %runtime.Type_Info_Pointer*
	%284 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	%285 = bitcast %runtime.Type_Info* %284 to %runtime.Type_Info*
	%286 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %283, i64 0, i32 0
	store %runtime.Type_Info* %285, %runtime.Type_Info** %286
	%287 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %283, align 8
	%288 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %279 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %287, %runtime.Type_Info_Pointer* %288
	%289 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %279, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %289
	%290 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	%291 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %290, i64 0, i32 3
	%292 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %290, i64 0, i32 0
	store i64 1, i64* %292
	%293 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %290, i64 0, i32 1
	store i64 1, i64* %293
	%294 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %290, i64 0, i32 2
	store %..typeid 72057594037927939, %..typeid* %294
	; Type_Info_Basic
	%295 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %291 to %runtime.Type_Info_Integer*
	%296 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %295, i64 0, i32 0
	store i8 0, i8* %296
	%297 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %295, align 1
	%298 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %291 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %297, %runtime.Type_Info_Integer* %298
	%299 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %291, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %299
	%300 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 14
	%301 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %300, i64 0, i32 3
	%302 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %300, i64 0, i32 0
	store i64 1, i64* %302
	%303 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %300, i64 0, i32 1
	store i64 1, i64* %303
	%304 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %300, i64 0, i32 2
	store %..typeid 3386706919782613006, %..typeid* %304
	; Type_Info_Named
	%305 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %301 to %runtime.Type_Info_Named*
	%306 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 15
	%307 = bitcast %runtime.Type_Info* %306 to %runtime.Type_Info*
	%308 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %305, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$28d, i64 0, i32 0), i64 17}, %..string* %308
	%309 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %305, i64 0, i32 1
	store %runtime.Type_Info* %307, %runtime.Type_Info** %309
	%310 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %305, align 8
	%311 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %301 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %310, %runtime.Type_Info_Named* %311
	%312 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %301, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %312
	%313 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 15
	%314 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %313, i64 0, i32 3
	%315 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %313, i64 0, i32 0
	store i64 1, i64* %315
	%316 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %313, i64 0, i32 1
	store i64 1, i64* %316
	%317 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %313, i64 0, i32 2
	store %..typeid 1080863910568919055, %..typeid* %317
	; Type_Info_Struct
	%318 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %314 to %runtime.Type_Info_Struct*
	%319 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %318, i64 0, i32 4
	store i8 0, i8* %319
	%320 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %318, i64 0, i32 5
	store i8 0, i8* %320
	%321 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %318, i64 0, i32 6
	store i8 0, i8* %321
	%322 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 27
	%323 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 6
	%324 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 6
	%325 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 6
	%326 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	%327 = bitcast %runtime.Type_Info* %326 to %runtime.Type_Info*
	%328 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %322, i64 0
	%329 = getelementptr inbounds i64, i64* %324, i64 0
	%330 = getelementptr inbounds i8, i8* %325, i64 0
	%331 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	store %runtime.Type_Info* %331, %runtime.Type_Info** %328
	%332 = getelementptr inbounds %..string, %..string* %323, i64 0
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$28e, i64 0, i32 0), i64 6}, %..string* %332
	store i64 0, i64* %329
	store i8 0, i8* %330
	%333 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %318, i64 0, i32 0
	%334 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %333, i64 0, i32 0
	store %runtime.Type_Info** %322, %runtime.Type_Info*** %334
	%335 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %333, i64 0, i32 1
	store i64 1, i64* %335
	%336 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %318, i64 0, i32 1
	%337 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %336, i64 0, i32 0
	store %..string* %323, %..string** %337
	%338 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %336, i64 0, i32 1
	store i64 1, i64* %338
	%339 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %318, i64 0, i32 2
	%340 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %339, i64 0, i32 0
	store i64* %324, i64** %340
	%341 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %339, i64 0, i32 1
	store i64 1, i64* %341
	%342 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %318, i64 0, i32 3
	%343 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %342, i64 0, i32 0
	store i8* %325, i8** %343
	%344 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %342, i64 0, i32 1
	store i64 1, i64* %344
	%345 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %318, align 8
	%346 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %314 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %345, %runtime.Type_Info_Struct* %346
	%347 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %314, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %347
	%348 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	%349 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %348, i64 0, i32 3
	%350 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %348, i64 0, i32 0
	store i64 1, i64* %350
	%351 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %348, i64 0, i32 1
	store i64 1, i64* %351
	%352 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %348, i64 0, i32 2
	store %..typeid 432345564227567632, %..typeid* %352
	; Type_Info_Basic
	%353 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %349 to %runtime.Type_Info_Boolean*
	%354 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %353, align 1
	%355 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %349 to %runtime.Type_Info_Boolean*
	store %runtime.Type_Info_Boolean %354, %runtime.Type_Info_Boolean* %355
	%356 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %349, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %356
	%357 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 17
	%358 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %357, i64 0, i32 3
	%359 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %357, i64 0, i32 0
	store i64 0, i64* %359
	%360 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %357, i64 0, i32 1
	store i64 1, i64* %360
	%361 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %357, i64 0, i32 2
	store %..typeid 3386706919782613009, %..typeid* %361
	; Type_Info_Named
	%362 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %358 to %runtime.Type_Info_Named*
	%363 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 18
	%364 = bitcast %runtime.Type_Info* %363 to %runtime.Type_Info*
	%365 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %362, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$28f, i64 0, i32 0), i64 14}, %..string* %365
	%366 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %362, i64 0, i32 1
	store %runtime.Type_Info* %364, %runtime.Type_Info** %366
	%367 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %362, align 8
	%368 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %358 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %367, %runtime.Type_Info_Named* %368
	%369 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %358, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %369
	%370 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 18
	%371 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %370, i64 0, i32 3
	%372 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %370, i64 0, i32 0
	store i64 0, i64* %372
	%373 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %370, i64 0, i32 1
	store i64 1, i64* %373
	%374 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %370, i64 0, i32 2
	store %..typeid 1080863910568919058, %..typeid* %374
	; Type_Info_Struct
	%375 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %371 to %runtime.Type_Info_Struct*
	%376 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %375, i64 0, i32 4
	store i8 0, i8* %376
	%377 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %375, i64 0, i32 5
	store i8 0, i8* %377
	%378 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %375, i64 0, i32 6
	store i8 0, i8* %378
	%379 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %375, align 8
	%380 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %371 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %379, %runtime.Type_Info_Struct* %380
	%381 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %371, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %381
	%382 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 19
	%383 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %382, i64 0, i32 3
	%384 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %382, i64 0, i32 0
	store i64 0, i64* %384
	%385 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %382, i64 0, i32 1
	store i64 1, i64* %385
	%386 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %382, i64 0, i32 2
	store %..typeid 3386706919782613011, %..typeid* %386
	; Type_Info_Named
	%387 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %383 to %runtime.Type_Info_Named*
	%388 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 18
	%389 = bitcast %runtime.Type_Info* %388 to %runtime.Type_Info*
	%390 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %387, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$290, i64 0, i32 0), i64 15}, %..string* %390
	%391 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %387, i64 0, i32 1
	store %runtime.Type_Info* %389, %runtime.Type_Info** %391
	%392 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %387, align 8
	%393 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %383 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %392, %runtime.Type_Info_Named* %393
	%394 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %383, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %394
	%395 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 20
	%396 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %395, i64 0, i32 3
	%397 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %395, i64 0, i32 0
	store i64 0, i64* %397
	%398 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %395, i64 0, i32 1
	store i64 1, i64* %398
	%399 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %395, i64 0, i32 2
	store %..typeid 3386706919782613012, %..typeid* %399
	; Type_Info_Named
	%400 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %396 to %runtime.Type_Info_Named*
	%401 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 18
	%402 = bitcast %runtime.Type_Info* %401 to %runtime.Type_Info*
	%403 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %400, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$291, i64 0, i32 0), i64 17}, %..string* %403
	%404 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %400, i64 0, i32 1
	store %runtime.Type_Info* %402, %runtime.Type_Info** %404
	%405 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %400, align 8
	%406 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %396 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %405, %runtime.Type_Info_Named* %406
	%407 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %396, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %407
	%408 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 21
	%409 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %408, i64 0, i32 3
	%410 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %408, i64 0, i32 0
	store i64 1, i64* %410
	%411 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %408, i64 0, i32 1
	store i64 1, i64* %411
	%412 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %408, i64 0, i32 2
	store %..typeid 3386706919782613013, %..typeid* %412
	; Type_Info_Named
	%413 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %409 to %runtime.Type_Info_Named*
	%414 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 22
	%415 = bitcast %runtime.Type_Info* %414 to %runtime.Type_Info*
	%416 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %413, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$292, i64 0, i32 0), i64 16}, %..string* %416
	%417 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %413, i64 0, i32 1
	store %runtime.Type_Info* %415, %runtime.Type_Info** %417
	%418 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %413, align 8
	%419 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %409 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %418, %runtime.Type_Info_Named* %419
	%420 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %409, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %420
	%421 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 22
	%422 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %421, i64 0, i32 3
	%423 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %421, i64 0, i32 0
	store i64 1, i64* %423
	%424 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %421, i64 0, i32 1
	store i64 1, i64* %424
	%425 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %421, i64 0, i32 2
	store %..typeid 1080863910568919062, %..typeid* %425
	; Type_Info_Struct
	%426 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %422 to %runtime.Type_Info_Struct*
	%427 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %426, i64 0, i32 4
	store i8 0, i8* %427
	%428 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %426, i64 0, i32 5
	store i8 0, i8* %428
	%429 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %426, i64 0, i32 6
	store i8 0, i8* %429
	%430 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 28
	%431 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 7
	%432 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 7
	%433 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 7
	%434 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	%435 = bitcast %runtime.Type_Info* %434 to %runtime.Type_Info*
	%436 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %430, i64 0
	%437 = getelementptr inbounds i64, i64* %432, i64 0
	%438 = getelementptr inbounds i8, i8* %433, i64 0
	%439 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	store %runtime.Type_Info* %439, %runtime.Type_Info** %436
	%440 = getelementptr inbounds %..string, %..string* %431, i64 0
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$293, i64 0, i32 0), i64 10}, %..string* %440
	store i64 0, i64* %437
	store i8 0, i8* %438
	%441 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %426, i64 0, i32 0
	%442 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %441, i64 0, i32 0
	store %runtime.Type_Info** %430, %runtime.Type_Info*** %442
	%443 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %441, i64 0, i32 1
	store i64 1, i64* %443
	%444 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %426, i64 0, i32 1
	%445 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %444, i64 0, i32 0
	store %..string* %431, %..string** %445
	%446 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %444, i64 0, i32 1
	store i64 1, i64* %446
	%447 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %426, i64 0, i32 2
	%448 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %447, i64 0, i32 0
	store i64* %432, i64** %448
	%449 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %447, i64 0, i32 1
	store i64 1, i64* %449
	%450 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %426, i64 0, i32 3
	%451 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %450, i64 0, i32 0
	store i8* %433, i8** %451
	%452 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %450, i64 0, i32 1
	store i64 1, i64* %452
	%453 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %426, align 8
	%454 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %422 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %453, %runtime.Type_Info_Struct* %454
	%455 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %422, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %455
	%456 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 23
	%457 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %456, i64 0, i32 3
	%458 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %456, i64 0, i32 0
	store i64 0, i64* %458
	%459 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %456, i64 0, i32 1
	store i64 1, i64* %459
	%460 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %456, i64 0, i32 2
	store %..typeid 3386706919782613015, %..typeid* %460
	; Type_Info_Named
	%461 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %457 to %runtime.Type_Info_Named*
	%462 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 18
	%463 = bitcast %runtime.Type_Info* %462 to %runtime.Type_Info*
	%464 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %461, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$294, i64 0, i32 0), i64 17}, %..string* %464
	%465 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %461, i64 0, i32 1
	store %runtime.Type_Info* %463, %runtime.Type_Info** %465
	%466 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %461, align 8
	%467 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %457 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %466, %runtime.Type_Info_Named* %467
	%468 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %457, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %468
	%469 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 24
	%470 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %469, i64 0, i32 3
	%471 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %469, i64 0, i32 0
	store i64 0, i64* %471
	%472 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %469, i64 0, i32 1
	store i64 1, i64* %472
	%473 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %469, i64 0, i32 2
	store %..typeid 3386706919782613016, %..typeid* %473
	; Type_Info_Named
	%474 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %470 to %runtime.Type_Info_Named*
	%475 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 18
	%476 = bitcast %runtime.Type_Info* %475 to %runtime.Type_Info*
	%477 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %474, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$295, i64 0, i32 0), i64 13}, %..string* %477
	%478 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %474, i64 0, i32 1
	store %runtime.Type_Info* %476, %runtime.Type_Info** %478
	%479 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %474, align 8
	%480 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %470 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %479, %runtime.Type_Info_Named* %480
	%481 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %470, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %481
	%482 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 25
	%483 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %482, i64 0, i32 3
	%484 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %482, i64 0, i32 0
	store i64 0, i64* %484
	%485 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %482, i64 0, i32 1
	store i64 1, i64* %485
	%486 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %482, i64 0, i32 2
	store %..typeid 3386706919782613017, %..typeid* %486
	; Type_Info_Named
	%487 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %483 to %runtime.Type_Info_Named*
	%488 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 18
	%489 = bitcast %runtime.Type_Info* %488 to %runtime.Type_Info*
	%490 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %487, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$296, i64 0, i32 0), i64 17}, %..string* %490
	%491 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %487, i64 0, i32 1
	store %runtime.Type_Info* %489, %runtime.Type_Info** %491
	%492 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %487, align 8
	%493 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %483 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %492, %runtime.Type_Info_Named* %493
	%494 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %483, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %494
	%495 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 26
	%496 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %495, i64 0, i32 3
	%497 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %495, i64 0, i32 0
	store i64 8, i64* %497
	%498 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %495, i64 0, i32 1
	store i64 8, i64* %498
	%499 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %495, i64 0, i32 2
	store %..typeid 3386706919782613018, %..typeid* %499
	; Type_Info_Named
	%500 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %496 to %runtime.Type_Info_Named*
	%501 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 27
	%502 = bitcast %runtime.Type_Info* %501 to %runtime.Type_Info*
	%503 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %500, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$297, i64 0, i32 0), i64 17}, %..string* %503
	%504 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %500, i64 0, i32 1
	store %runtime.Type_Info* %502, %runtime.Type_Info** %504
	%505 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %500, align 8
	%506 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %496 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %505, %runtime.Type_Info_Named* %506
	%507 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %496, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %507
	%508 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 27
	%509 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %508, i64 0, i32 3
	%510 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %508, i64 0, i32 0
	store i64 8, i64* %510
	%511 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %508, i64 0, i32 1
	store i64 8, i64* %511
	%512 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %508, i64 0, i32 2
	store %..typeid 1080863910568919067, %..typeid* %512
	; Type_Info_Struct
	%513 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %509 to %runtime.Type_Info_Struct*
	%514 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %513, i64 0, i32 4
	store i8 0, i8* %514
	%515 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %513, i64 0, i32 5
	store i8 0, i8* %515
	%516 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %513, i64 0, i32 6
	store i8 0, i8* %516
	%517 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 29
	%518 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 8
	%519 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 8
	%520 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 8
	%521 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%522 = bitcast %runtime.Type_Info* %521 to %runtime.Type_Info*
	%523 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %517, i64 0
	%524 = getelementptr inbounds i64, i64* %519, i64 0
	%525 = getelementptr inbounds i8, i8* %520, i64 0
	%526 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	store %runtime.Type_Info* %526, %runtime.Type_Info** %523
	%527 = getelementptr inbounds %..string, %..string* %518, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$298, i64 0, i32 0), i64 4}, %..string* %527
	store i64 0, i64* %524
	store i8 0, i8* %525
	%528 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %513, i64 0, i32 0
	%529 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %528, i64 0, i32 0
	store %runtime.Type_Info** %517, %runtime.Type_Info*** %529
	%530 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %528, i64 0, i32 1
	store i64 1, i64* %530
	%531 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %513, i64 0, i32 1
	%532 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %531, i64 0, i32 0
	store %..string* %518, %..string** %532
	%533 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %531, i64 0, i32 1
	store i64 1, i64* %533
	%534 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %513, i64 0, i32 2
	%535 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %534, i64 0, i32 0
	store i64* %519, i64** %535
	%536 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %534, i64 0, i32 1
	store i64 1, i64* %536
	%537 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %513, i64 0, i32 3
	%538 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %537, i64 0, i32 0
	store i8* %520, i8** %538
	%539 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %537, i64 0, i32 1
	store i64 1, i64* %539
	%540 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %513, align 8
	%541 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %509 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %540, %runtime.Type_Info_Struct* %541
	%542 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %509, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %542
	%543 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 28
	%544 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %543, i64 0, i32 3
	%545 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %543, i64 0, i32 0
	store i64 32, i64* %545
	%546 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %543, i64 0, i32 1
	store i64 8, i64* %546
	%547 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %543, i64 0, i32 2
	store %..typeid 3386706919782613020, %..typeid* %547
	; Type_Info_Named
	%548 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %544 to %runtime.Type_Info_Named*
	%549 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 29
	%550 = bitcast %runtime.Type_Info* %549 to %runtime.Type_Info*
	%551 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %548, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$299, i64 0, i32 0), i64 19}, %..string* %551
	%552 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %548, i64 0, i32 1
	store %runtime.Type_Info* %550, %runtime.Type_Info** %552
	%553 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %548, align 8
	%554 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %544 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %553, %runtime.Type_Info_Named* %554
	%555 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %544, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %555
	%556 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 29
	%557 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %556, i64 0, i32 3
	%558 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %556, i64 0, i32 0
	store i64 32, i64* %558
	%559 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %556, i64 0, i32 1
	store i64 8, i64* %559
	%560 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %556, i64 0, i32 2
	store %..typeid 1080863910568919069, %..typeid* %560
	; Type_Info_Struct
	%561 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %557 to %runtime.Type_Info_Struct*
	%562 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %561, i64 0, i32 4
	store i8 0, i8* %562
	%563 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %561, i64 0, i32 5
	store i8 0, i8* %563
	%564 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %561, i64 0, i32 6
	store i8 0, i8* %564
	%565 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 30
	%566 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 9
	%567 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 9
	%568 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 9
	%569 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%570 = bitcast %runtime.Type_Info* %569 to %runtime.Type_Info*
	%571 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %565, i64 0
	%572 = getelementptr inbounds i64, i64* %567, i64 0
	%573 = getelementptr inbounds i8, i8* %568, i64 0
	%574 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	store %runtime.Type_Info* %574, %runtime.Type_Info** %571
	%575 = getelementptr inbounds %..string, %..string* %566, i64 0
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$29a, i64 0, i32 0), i64 6}, %..string* %575
	store i64 0, i64* %572
	store i8 0, i8* %573
	%576 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%577 = bitcast %runtime.Type_Info* %576 to %runtime.Type_Info*
	%578 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %565, i64 1
	%579 = getelementptr inbounds i64, i64* %567, i64 1
	%580 = getelementptr inbounds i8, i8* %568, i64 1
	%581 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	store %runtime.Type_Info* %581, %runtime.Type_Info** %578
	%582 = getelementptr inbounds %..string, %..string* %566, i64 1
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$29b, i64 0, i32 0), i64 7}, %..string* %582
	store i64 8, i64* %579
	store i8 0, i8* %580
	%583 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	%584 = bitcast %runtime.Type_Info* %583 to %runtime.Type_Info*
	%585 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %565, i64 2
	%586 = getelementptr inbounds i64, i64* %567, i64 2
	%587 = getelementptr inbounds i8, i8* %568, i64 2
	%588 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	store %runtime.Type_Info* %588, %runtime.Type_Info** %585
	%589 = getelementptr inbounds %..string, %..string* %566, i64 2
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$29c, i64 0, i32 0), i64 8}, %..string* %589
	store i64 16, i64* %586
	store i8 0, i8* %587
	%590 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 30
	%591 = bitcast %runtime.Type_Info* %590 to %runtime.Type_Info*
	%592 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %565, i64 3
	%593 = getelementptr inbounds i64, i64* %567, i64 3
	%594 = getelementptr inbounds i8, i8* %568, i64 3
	%595 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 30
	store %runtime.Type_Info* %595, %runtime.Type_Info** %592
	%596 = getelementptr inbounds %..string, %..string* %566, i64 3
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$29d, i64 0, i32 0), i64 10}, %..string* %596
	store i64 24, i64* %593
	store i8 0, i8* %594
	%597 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %561, i64 0, i32 0
	%598 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %597, i64 0, i32 0
	store %runtime.Type_Info** %565, %runtime.Type_Info*** %598
	%599 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %597, i64 0, i32 1
	store i64 4, i64* %599
	%600 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %561, i64 0, i32 1
	%601 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %600, i64 0, i32 0
	store %..string* %566, %..string** %601
	%602 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %600, i64 0, i32 1
	store i64 4, i64* %602
	%603 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %561, i64 0, i32 2
	%604 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %603, i64 0, i32 0
	store i64* %567, i64** %604
	%605 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %603, i64 0, i32 1
	store i64 4, i64* %605
	%606 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %561, i64 0, i32 3
	%607 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %606, i64 0, i32 0
	store i8* %568, i8** %607
	%608 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %606, i64 0, i32 1
	store i64 4, i64* %608
	%609 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %561, align 8
	%610 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %557 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %609, %runtime.Type_Info_Struct* %610
	%611 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %557, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %611
	%612 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 30
	%613 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %612, i64 0, i32 3
	%614 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %612, i64 0, i32 0
	store i64 8, i64* %614
	%615 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %612, i64 0, i32 1
	store i64 8, i64* %615
	%616 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %612, i64 0, i32 2
	store %..typeid 3530822107858468894, %..typeid* %616
	; Type_Info_Named
	%617 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %613 to %runtime.Type_Info_Named*
	%618 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 31
	%619 = bitcast %runtime.Type_Info* %618 to %runtime.Type_Info*
	%620 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %617, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$29e, i64 0, i32 0), i64 18}, %..string* %620
	%621 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %617, i64 0, i32 1
	store %runtime.Type_Info* %619, %runtime.Type_Info** %621
	%622 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %617, align 8
	%623 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %613 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %622, %runtime.Type_Info_Named* %623
	%624 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %613, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %624
	%625 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 31
	%626 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %625, i64 0, i32 3
	%627 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %625, i64 0, i32 0
	store i64 8, i64* %627
	%628 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %625, i64 0, i32 1
	store i64 8, i64* %628
	%629 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %625, i64 0, i32 2
	store %..typeid 1224979098644774943, %..typeid* %629
	; Type_Info_Enum
	%630 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %626 to %runtime.Type_Info_Enum*
	%631 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%632 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %630, i64 0, i32 0
	store %runtime.Type_Info* %631, %runtime.Type_Info** %632
	%633 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-1f, i64 0, i32 0
	%634 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-1f, i64 0, i32 0
	%635 = bitcast %runtime.Type_Info_Enum_Value* %634 to i64*
	store i64 0, i64* %635
	%636 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %634, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %636
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$29f, i64 0, i32 0), i64 7}, %..string* %633
	%637 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-1f, i64 0, i32 1
	%638 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-1f, i64 0, i32 1
	%639 = bitcast %runtime.Type_Info_Enum_Value* %638 to i64*
	store i64 1, i64* %639
	%640 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %638, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %640
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2a0, i64 0, i32 0), i64 4}, %..string* %637
	%641 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-1f, i64 0, i32 2
	%642 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-1f, i64 0, i32 2
	%643 = bitcast %runtime.Type_Info_Enum_Value* %642 to i64*
	store i64 2, i64* %643
	%644 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %642, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %644
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$2a1, i64 0, i32 0), i64 11}, %..string* %641
	%645 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-1f, i64 0, i32 3
	%646 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-1f, i64 0, i32 3
	%647 = bitcast %runtime.Type_Info_Enum_Value* %646 to i64*
	store i64 3, i64* %647
	%648 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %646, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %648
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$2a2, i64 0, i32 0), i64 1}, %..string* %645
	%649 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-1f, i64 0, i32 4
	%650 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-1f, i64 0, i32 4
	%651 = bitcast %runtime.Type_Info_Enum_Value* %650 to i64*
	store i64 4, i64* %651
	%652 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %650, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %652
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2a3, i64 0, i32 0), i64 3}, %..string* %649
	%653 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-1f, i64 0, i32 5
	%654 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-1f, i64 0, i32 5
	%655 = bitcast %runtime.Type_Info_Enum_Value* %654 to i64*
	store i64 5, i64* %655
	%656 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %654, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %656
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2a4, i64 0, i32 0), i64 4}, %..string* %653
	%657 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %630, i64 0, i32 1
	%658 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-1f, i64 0, i32 0
	%659 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %657, i64 0, i32 0
	store %..string* %658, %..string** %659
	%660 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %657, i64 0, i32 1
	store i64 6, i64* %660
	%661 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %630, i64 0, i32 2
	%662 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-1f, i64 0, i32 0
	%663 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %661, i64 0, i32 0
	store %runtime.Type_Info_Enum_Value* %662, %runtime.Type_Info_Enum_Value** %663
	%664 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %661, i64 0, i32 1
	store i64 6, i64* %664
	%665 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %630, align 8
	%666 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %626 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %665, %runtime.Type_Info_Enum* %666
	%667 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %626, i64 0, i32 2 ; UnionTagPtr
	store i8 18, i8* %667
	%668 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 32
	%669 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %668, i64 0, i32 3
	%670 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %668, i64 0, i32 0
	store i64 24, i64* %670
	%671 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %668, i64 0, i32 1
	store i64 8, i64* %671
	%672 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %668, i64 0, i32 2
	store %..typeid 3386706919782613024, %..typeid* %672
	; Type_Info_Named
	%673 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %669 to %runtime.Type_Info_Named*
	%674 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 33
	%675 = bitcast %runtime.Type_Info* %674 to %runtime.Type_Info*
	%676 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %673, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$2a5, i64 0, i32 0), i64 15}, %..string* %676
	%677 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %673, i64 0, i32 1
	store %runtime.Type_Info* %675, %runtime.Type_Info** %677
	%678 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %673, align 8
	%679 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %669 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %678, %runtime.Type_Info_Named* %679
	%680 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %669, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %680
	%681 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 33
	%682 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %681, i64 0, i32 3
	%683 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %681, i64 0, i32 0
	store i64 24, i64* %683
	%684 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %681, i64 0, i32 1
	store i64 8, i64* %684
	%685 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %681, i64 0, i32 2
	store %..typeid 1080863910568919073, %..typeid* %685
	; Type_Info_Struct
	%686 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %682 to %runtime.Type_Info_Struct*
	%687 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %686, i64 0, i32 4
	store i8 0, i8* %687
	%688 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %686, i64 0, i32 5
	store i8 0, i8* %688
	%689 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %686, i64 0, i32 6
	store i8 0, i8* %689
	%690 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 34
	%691 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 13
	%692 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 13
	%693 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 13
	%694 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%695 = bitcast %runtime.Type_Info* %694 to %runtime.Type_Info*
	%696 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %690, i64 0
	%697 = getelementptr inbounds i64, i64* %692, i64 0
	%698 = getelementptr inbounds i8, i8* %693, i64 0
	%699 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	store %runtime.Type_Info* %699, %runtime.Type_Info** %696
	%700 = getelementptr inbounds %..string, %..string* %691, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2a6, i64 0, i32 0), i64 4}, %..string* %700
	store i64 0, i64* %697
	store i8 0, i8* %698
	%701 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%702 = bitcast %runtime.Type_Info* %701 to %runtime.Type_Info*
	%703 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %690, i64 1
	%704 = getelementptr inbounds i64, i64* %692, i64 1
	%705 = getelementptr inbounds i8, i8* %693, i64 1
	%706 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %706, %runtime.Type_Info** %703
	%707 = getelementptr inbounds %..string, %..string* %691, i64 1
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$2a7, i64 0, i32 0), i64 9}, %..string* %707
	store i64 8, i64* %704
	store i8 0, i8* %705
	%708 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%709 = bitcast %runtime.Type_Info* %708 to %runtime.Type_Info*
	%710 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %690, i64 2
	%711 = getelementptr inbounds i64, i64* %692, i64 2
	%712 = getelementptr inbounds i8, i8* %693, i64 2
	%713 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %713, %runtime.Type_Info** %710
	%714 = getelementptr inbounds %..string, %..string* %691, i64 2
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$2a8, i64 0, i32 0), i64 5}, %..string* %714
	store i64 16, i64* %711
	store i8 0, i8* %712
	%715 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %686, i64 0, i32 0
	%716 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %715, i64 0, i32 0
	store %runtime.Type_Info** %690, %runtime.Type_Info*** %716
	%717 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %715, i64 0, i32 1
	store i64 3, i64* %717
	%718 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %686, i64 0, i32 1
	%719 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %718, i64 0, i32 0
	store %..string* %691, %..string** %719
	%720 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %718, i64 0, i32 1
	store i64 3, i64* %720
	%721 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %686, i64 0, i32 2
	%722 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %721, i64 0, i32 0
	store i64* %692, i64** %722
	%723 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %721, i64 0, i32 1
	store i64 3, i64* %723
	%724 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %686, i64 0, i32 3
	%725 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %724, i64 0, i32 0
	store i8* %693, i8** %725
	%726 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %724, i64 0, i32 1
	store i64 3, i64* %726
	%727 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %686, align 8
	%728 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %682 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %727, %runtime.Type_Info_Struct* %728
	%729 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %682, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %729
	%730 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 34
	%731 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %730, i64 0, i32 3
	%732 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %730, i64 0, i32 0
	store i64 16, i64* %732
	%733 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %730, i64 0, i32 1
	store i64 8, i64* %733
	%734 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %730, i64 0, i32 2
	store %..typeid 3386706919782613026, %..typeid* %734
	; Type_Info_Named
	%735 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %731 to %runtime.Type_Info_Named*
	%736 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 35
	%737 = bitcast %runtime.Type_Info* %736 to %runtime.Type_Info*
	%738 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %735, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$2a9, i64 0, i32 0), i64 23}, %..string* %738
	%739 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %735, i64 0, i32 1
	store %runtime.Type_Info* %737, %runtime.Type_Info** %739
	%740 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %735, align 8
	%741 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %731 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %740, %runtime.Type_Info_Named* %741
	%742 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %731, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %742
	%743 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 35
	%744 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %743, i64 0, i32 3
	%745 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %743, i64 0, i32 0
	store i64 16, i64* %745
	%746 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %743, i64 0, i32 1
	store i64 8, i64* %746
	%747 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %743, i64 0, i32 2
	store %..typeid 1080863910568919075, %..typeid* %747
	; Type_Info_Struct
	%748 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %744 to %runtime.Type_Info_Struct*
	%749 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %748, i64 0, i32 4
	store i8 0, i8* %749
	%750 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %748, i64 0, i32 5
	store i8 0, i8* %750
	%751 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %748, i64 0, i32 6
	store i8 0, i8* %751
	%752 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 37
	%753 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 16
	%754 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 16
	%755 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 16
	%756 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%757 = bitcast %runtime.Type_Info* %756 to %runtime.Type_Info*
	%758 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %752, i64 0
	%759 = getelementptr inbounds i64, i64* %754, i64 0
	%760 = getelementptr inbounds i8, i8* %755, i64 0
	%761 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	store %runtime.Type_Info* %761, %runtime.Type_Info** %758
	%762 = getelementptr inbounds %..string, %..string* %753, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2aa, i64 0, i32 0), i64 4}, %..string* %762
	store i64 0, i64* %759
	store i8 0, i8* %760
	%763 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%764 = bitcast %runtime.Type_Info* %763 to %runtime.Type_Info*
	%765 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %752, i64 1
	%766 = getelementptr inbounds i64, i64* %754, i64 1
	%767 = getelementptr inbounds i8, i8* %755, i64 1
	%768 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %768, %runtime.Type_Info** %765
	%769 = getelementptr inbounds %..string, %..string* %753, i64 1
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$2ab, i64 0, i32 0), i64 9}, %..string* %769
	store i64 8, i64* %766
	store i8 0, i8* %767
	%770 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %748, i64 0, i32 0
	%771 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %770, i64 0, i32 0
	store %runtime.Type_Info** %752, %runtime.Type_Info*** %771
	%772 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %770, i64 0, i32 1
	store i64 2, i64* %772
	%773 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %748, i64 0, i32 1
	%774 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %773, i64 0, i32 0
	store %..string* %753, %..string** %774
	%775 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %773, i64 0, i32 1
	store i64 2, i64* %775
	%776 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %748, i64 0, i32 2
	%777 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %776, i64 0, i32 0
	store i64* %754, i64** %777
	%778 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %776, i64 0, i32 1
	store i64 2, i64* %778
	%779 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %748, i64 0, i32 3
	%780 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %779, i64 0, i32 0
	store i8* %755, i8** %780
	%781 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %779, i64 0, i32 1
	store i64 2, i64* %781
	%782 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %748, align 8
	%783 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %744 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %782, %runtime.Type_Info_Struct* %783
	%784 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %744, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %784
	%785 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 36
	%786 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %785, i64 0, i32 3
	%787 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %785, i64 0, i32 0
	store i64 16, i64* %787
	%788 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %785, i64 0, i32 1
	store i64 8, i64* %788
	%789 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %785, i64 0, i32 2
	store %..typeid 3386706919782613028, %..typeid* %789
	; Type_Info_Named
	%790 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %786 to %runtime.Type_Info_Named*
	%791 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 35
	%792 = bitcast %runtime.Type_Info* %791 to %runtime.Type_Info*
	%793 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %790, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$2ac, i64 0, i32 0), i64 15}, %..string* %793
	%794 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %790, i64 0, i32 1
	store %runtime.Type_Info* %792, %runtime.Type_Info** %794
	%795 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %790, align 8
	%796 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %786 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %795, %runtime.Type_Info_Named* %796
	%797 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %786, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %797
	%798 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 37
	%799 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %798, i64 0, i32 3
	%800 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %798, i64 0, i32 0
	store i64 32, i64* %800
	%801 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %798, i64 0, i32 1
	store i64 8, i64* %801
	%802 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %798, i64 0, i32 2
	store %..typeid 3386706919782613029, %..typeid* %802
	; Type_Info_Named
	%803 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %799 to %runtime.Type_Info_Named*
	%804 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 38
	%805 = bitcast %runtime.Type_Info* %804 to %runtime.Type_Info*
	%806 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %803, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$2ad, i64 0, i32 0), i64 15}, %..string* %806
	%807 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %803, i64 0, i32 1
	store %runtime.Type_Info* %805, %runtime.Type_Info** %807
	%808 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %803, align 8
	%809 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %799 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %808, %runtime.Type_Info_Named* %809
	%810 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %799, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %810
	%811 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 38
	%812 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %811, i64 0, i32 3
	%813 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %811, i64 0, i32 0
	store i64 32, i64* %813
	%814 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %811, i64 0, i32 1
	store i64 8, i64* %814
	%815 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %811, i64 0, i32 2
	store %..typeid 1080863910568919078, %..typeid* %815
	; Type_Info_Struct
	%816 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %812 to %runtime.Type_Info_Struct*
	%817 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %816, i64 0, i32 4
	store i8 0, i8* %817
	%818 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %816, i64 0, i32 5
	store i8 0, i8* %818
	%819 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %816, i64 0, i32 6
	store i8 0, i8* %819
	%820 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 39
	%821 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 18
	%822 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 18
	%823 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 18
	%824 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 39
	%825 = bitcast %runtime.Type_Info* %824 to %runtime.Type_Info*
	%826 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %820, i64 0
	%827 = getelementptr inbounds i64, i64* %822, i64 0
	%828 = getelementptr inbounds i8, i8* %823, i64 0
	%829 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 39
	store %runtime.Type_Info* %829, %runtime.Type_Info** %826
	%830 = getelementptr inbounds %..string, %..string* %821, i64 0
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$2ae, i64 0, i32 0), i64 5}, %..string* %830
	store i64 0, i64* %827
	store i8 0, i8* %828
	%831 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 41
	%832 = bitcast %runtime.Type_Info* %831 to %runtime.Type_Info*
	%833 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %820, i64 1
	%834 = getelementptr inbounds i64, i64* %822, i64 1
	%835 = getelementptr inbounds i8, i8* %823, i64 1
	%836 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 41
	store %runtime.Type_Info* %836, %runtime.Type_Info** %833
	%837 = getelementptr inbounds %..string, %..string* %821, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$2af, i64 0, i32 0), i64 5}, %..string* %837
	store i64 16, i64* %834
	store i8 0, i8* %835
	%838 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %816, i64 0, i32 0
	%839 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %838, i64 0, i32 0
	store %runtime.Type_Info** %820, %runtime.Type_Info*** %839
	%840 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %838, i64 0, i32 1
	store i64 2, i64* %840
	%841 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %816, i64 0, i32 1
	%842 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %841, i64 0, i32 0
	store %..string* %821, %..string** %842
	%843 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %841, i64 0, i32 1
	store i64 2, i64* %843
	%844 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %816, i64 0, i32 2
	%845 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %844, i64 0, i32 0
	store i64* %822, i64** %845
	%846 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %844, i64 0, i32 1
	store i64 2, i64* %846
	%847 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %816, i64 0, i32 3
	%848 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %847, i64 0, i32 0
	store i8* %823, i8** %848
	%849 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %847, i64 0, i32 1
	store i64 2, i64* %849
	%850 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %816, align 8
	%851 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %812 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %850, %runtime.Type_Info_Struct* %851
	%852 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %812, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %852
	%853 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 39
	%854 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %853, i64 0, i32 3
	%855 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %853, i64 0, i32 0
	store i64 16, i64* %855
	%856 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %853, i64 0, i32 1
	store i64 8, i64* %856
	%857 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %853, i64 0, i32 2
	store %..typeid 936748722493063207, %..typeid* %857
	; Type_Info_Slice
	%858 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %854 to %runtime.Type_Info_Slice*
	%859 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%860 = bitcast %runtime.Type_Info* %859 to %runtime.Type_Info*
	%861 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %858, i64 0, i32 0
	store %runtime.Type_Info* %860, %runtime.Type_Info** %861
	%862 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %858, i64 0, i32 1
	store i64 8, i64* %862
	%863 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %858, align 8
	%864 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %854 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %863, %runtime.Type_Info_Slice* %864
	%865 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %854, i64 0, i32 2 ; UnionTagPtr
	store i8 14, i8* %865
	%866 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 40
	%867 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %866, i64 0, i32 3
	%868 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %866, i64 0, i32 0
	store i64 8, i64* %868
	%869 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %866, i64 0, i32 1
	store i64 8, i64* %869
	%870 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %866, i64 0, i32 2
	store %..typeid 648518346341351464, %..typeid* %870
	; Type_Info_Pointer
	%871 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %867 to %runtime.Type_Info_Pointer*
	%872 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%873 = bitcast %runtime.Type_Info* %872 to %runtime.Type_Info*
	%874 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %871, i64 0, i32 0
	store %runtime.Type_Info* %873, %runtime.Type_Info** %874
	%875 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %871, align 8
	%876 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %867 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %875, %runtime.Type_Info_Pointer* %876
	%877 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %867, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %877
	%878 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 41
	%879 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %878, i64 0, i32 3
	%880 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %878, i64 0, i32 0
	store i64 16, i64* %880
	%881 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %878, i64 0, i32 1
	store i64 8, i64* %881
	%882 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %878, i64 0, i32 2
	store %..typeid 936748722493063209, %..typeid* %882
	; Type_Info_Slice
	%883 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %879 to %runtime.Type_Info_Slice*
	%884 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%885 = bitcast %runtime.Type_Info* %884 to %runtime.Type_Info*
	%886 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %883, i64 0, i32 0
	store %runtime.Type_Info* %885, %runtime.Type_Info** %886
	%887 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %883, i64 0, i32 1
	store i64 16, i64* %887
	%888 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %883, align 8
	%889 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %879 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %888, %runtime.Type_Info_Slice* %889
	%890 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %879, i64 0, i32 2 ; UnionTagPtr
	store i8 14, i8* %890
	%891 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 42
	%892 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %891, i64 0, i32 3
	%893 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %891, i64 0, i32 0
	store i64 8, i64* %893
	%894 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %891, i64 0, i32 1
	store i64 8, i64* %894
	%895 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %891, i64 0, i32 2
	store %..typeid 648518346341351466, %..typeid* %895
	; Type_Info_Pointer
	%896 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %892 to %runtime.Type_Info_Pointer*
	%897 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%898 = bitcast %runtime.Type_Info* %897 to %runtime.Type_Info*
	%899 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %896, i64 0, i32 0
	store %runtime.Type_Info* %898, %runtime.Type_Info** %899
	%900 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %896, align 8
	%901 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %892 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %900, %runtime.Type_Info_Pointer* %901
	%902 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %892, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %902
	%903 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 43
	%904 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %903, i64 0, i32 3
	%905 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %903, i64 0, i32 0
	store i64 72, i64* %905
	%906 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %903, i64 0, i32 1
	store i64 8, i64* %906
	%907 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %903, i64 0, i32 2
	store %..typeid 3386706919782613035, %..typeid* %907
	; Type_Info_Named
	%908 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %904 to %runtime.Type_Info_Named*
	%909 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 44
	%910 = bitcast %runtime.Type_Info* %909 to %runtime.Type_Info*
	%911 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %908, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$2b0, i64 0, i32 0), i64 16}, %..string* %911
	%912 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %908, i64 0, i32 1
	store %runtime.Type_Info* %910, %runtime.Type_Info** %912
	%913 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %908, align 8
	%914 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %904 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %913, %runtime.Type_Info_Named* %914
	%915 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %904, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %915
	%916 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 44
	%917 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %916, i64 0, i32 3
	%918 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %916, i64 0, i32 0
	store i64 72, i64* %918
	%919 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %916, i64 0, i32 1
	store i64 8, i64* %919
	%920 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %916, i64 0, i32 2
	store %..typeid 1080863910568919084, %..typeid* %920
	; Type_Info_Struct
	%921 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %917 to %runtime.Type_Info_Struct*
	%922 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, i64 0, i32 4
	store i8 0, i8* %922
	%923 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, i64 0, i32 5
	store i8 0, i8* %923
	%924 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, i64 0, i32 6
	store i8 0, i8* %924
	%925 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 41
	%926 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 20
	%927 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 20
	%928 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 20
	%929 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 39
	%930 = bitcast %runtime.Type_Info* %929 to %runtime.Type_Info*
	%931 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %925, i64 0
	%932 = getelementptr inbounds i64, i64* %927, i64 0
	%933 = getelementptr inbounds i8, i8* %928, i64 0
	%934 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 39
	store %runtime.Type_Info* %934, %runtime.Type_Info** %931
	%935 = getelementptr inbounds %..string, %..string* %926, i64 0
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$2b1, i64 0, i32 0), i64 5}, %..string* %935
	store i64 0, i64* %932
	store i8 0, i8* %933
	%936 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 41
	%937 = bitcast %runtime.Type_Info* %936 to %runtime.Type_Info*
	%938 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %925, i64 1
	%939 = getelementptr inbounds i64, i64* %927, i64 1
	%940 = getelementptr inbounds i8, i8* %928, i64 1
	%941 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 41
	store %runtime.Type_Info* %941, %runtime.Type_Info** %938
	%942 = getelementptr inbounds %..string, %..string* %926, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$2b2, i64 0, i32 0), i64 5}, %..string* %942
	store i64 16, i64* %939
	store i8 0, i8* %940
	%943 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 45
	%944 = bitcast %runtime.Type_Info* %943 to %runtime.Type_Info*
	%945 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %925, i64 2
	%946 = getelementptr inbounds i64, i64* %927, i64 2
	%947 = getelementptr inbounds i8, i8* %928, i64 2
	%948 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 45
	store %runtime.Type_Info* %948, %runtime.Type_Info** %945
	%949 = getelementptr inbounds %..string, %..string* %926, i64 2
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$2b3, i64 0, i32 0), i64 7}, %..string* %949
	store i64 32, i64* %946
	store i8 0, i8* %947
	%950 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 48
	%951 = bitcast %runtime.Type_Info* %950 to %runtime.Type_Info*
	%952 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %925, i64 3
	%953 = getelementptr inbounds i64, i64* %927, i64 3
	%954 = getelementptr inbounds i8, i8* %928, i64 3
	%955 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 48
	store %runtime.Type_Info* %955, %runtime.Type_Info** %952
	%956 = getelementptr inbounds %..string, %..string* %926, i64 3
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$2b4, i64 0, i32 0), i64 6}, %..string* %956
	store i64 48, i64* %953
	store i8 0, i8* %954
	%957 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	%958 = bitcast %runtime.Type_Info* %957 to %runtime.Type_Info*
	%959 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %925, i64 4
	%960 = getelementptr inbounds i64, i64* %927, i64 4
	%961 = getelementptr inbounds i8, i8* %928, i64 4
	%962 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	store %runtime.Type_Info* %962, %runtime.Type_Info** %959
	%963 = getelementptr inbounds %..string, %..string* %926, i64 4
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$2b5, i64 0, i32 0), i64 9}, %..string* %963
	store i64 64, i64* %960
	store i8 0, i8* %961
	%964 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	%965 = bitcast %runtime.Type_Info* %964 to %runtime.Type_Info*
	%966 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %925, i64 5
	%967 = getelementptr inbounds i64, i64* %927, i64 5
	%968 = getelementptr inbounds i8, i8* %928, i64 5
	%969 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	store %runtime.Type_Info* %969, %runtime.Type_Info** %966
	%970 = getelementptr inbounds %..string, %..string* %926, i64 5
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$2b6, i64 0, i32 0), i64 12}, %..string* %970
	store i64 65, i64* %967
	store i8 0, i8* %968
	%971 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	%972 = bitcast %runtime.Type_Info* %971 to %runtime.Type_Info*
	%973 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %925, i64 6
	%974 = getelementptr inbounds i64, i64* %927, i64 6
	%975 = getelementptr inbounds i8, i8* %928, i64 6
	%976 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	store %runtime.Type_Info* %976, %runtime.Type_Info** %973
	%977 = getelementptr inbounds %..string, %..string* %926, i64 6
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$2b7, i64 0, i32 0), i64 12}, %..string* %977
	store i64 66, i64* %974
	store i8 0, i8* %975
	%978 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, i64 0, i32 0
	%979 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %978, i64 0, i32 0
	store %runtime.Type_Info** %925, %runtime.Type_Info*** %979
	%980 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %978, i64 0, i32 1
	store i64 7, i64* %980
	%981 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, i64 0, i32 1
	%982 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %981, i64 0, i32 0
	store %..string* %926, %..string** %982
	%983 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %981, i64 0, i32 1
	store i64 7, i64* %983
	%984 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, i64 0, i32 2
	%985 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %984, i64 0, i32 0
	store i64* %927, i64** %985
	%986 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %984, i64 0, i32 1
	store i64 7, i64* %986
	%987 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, i64 0, i32 3
	%988 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %987, i64 0, i32 0
	store i8* %928, i8** %988
	%989 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %987, i64 0, i32 1
	store i64 7, i64* %989
	%990 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, align 8
	%991 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %917 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %990, %runtime.Type_Info_Struct* %991
	%992 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %917, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %992
	%993 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 45
	%994 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %993, i64 0, i32 3
	%995 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %993, i64 0, i32 0
	store i64 16, i64* %995
	%996 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %993, i64 0, i32 1
	store i64 8, i64* %996
	%997 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %993, i64 0, i32 2
	store %..typeid 936748722493063213, %..typeid* %997
	; Type_Info_Slice
	%998 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %994 to %runtime.Type_Info_Slice*
	%999 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 46
	%1000 = bitcast %runtime.Type_Info* %999 to %runtime.Type_Info*
	%1001 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %998, i64 0, i32 0
	store %runtime.Type_Info* %1000, %runtime.Type_Info** %1001
	%1002 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %998, i64 0, i32 1
	store i64 8, i64* %1002
	%1003 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %998, align 8
	%1004 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %994 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1003, %runtime.Type_Info_Slice* %1004
	%1005 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %994, i64 0, i32 2 ; UnionTagPtr
	store i8 14, i8* %1005
	%1006 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 46
	%1007 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1006, i64 0, i32 3
	%1008 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1006, i64 0, i32 0
	store i64 8, i64* %1008
	%1009 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1006, i64 0, i32 1
	store i64 8, i64* %1009
	%1010 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1006, i64 0, i32 2
	store %..typeid 72057594037927982, %..typeid* %1010
	; Type_Info_Basic
	%1011 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1007 to %runtime.Type_Info_Integer*
	%1012 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1011, i64 0, i32 0
	store i8 0, i8* %1012
	%1013 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1011, align 1
	%1014 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1007 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1013, %runtime.Type_Info_Integer* %1014
	%1015 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1007, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1015
	%1016 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 47
	%1017 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1016, i64 0, i32 3
	%1018 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1016, i64 0, i32 0
	store i64 8, i64* %1018
	%1019 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1016, i64 0, i32 1
	store i64 8, i64* %1019
	%1020 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1016, i64 0, i32 2
	store %..typeid 648518346341351471, %..typeid* %1020
	; Type_Info_Pointer
	%1021 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1017 to %runtime.Type_Info_Pointer*
	%1022 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 46
	%1023 = bitcast %runtime.Type_Info* %1022 to %runtime.Type_Info*
	%1024 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1021, i64 0, i32 0
	store %runtime.Type_Info* %1023, %runtime.Type_Info** %1024
	%1025 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1021, align 8
	%1026 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1017 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1025, %runtime.Type_Info_Pointer* %1026
	%1027 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1017, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %1027
	%1028 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 48
	%1029 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1028, i64 0, i32 3
	%1030 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1028, i64 0, i32 0
	store i64 16, i64* %1030
	%1031 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1028, i64 0, i32 1
	store i64 8, i64* %1031
	%1032 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1028, i64 0, i32 2
	store %..typeid 936748722493063216, %..typeid* %1032
	; Type_Info_Slice
	%1033 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1029 to %runtime.Type_Info_Slice*
	%1034 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	%1035 = bitcast %runtime.Type_Info* %1034 to %runtime.Type_Info*
	%1036 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1033, i64 0, i32 0
	store %runtime.Type_Info* %1035, %runtime.Type_Info** %1036
	%1037 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1033, i64 0, i32 1
	store i64 1, i64* %1037
	%1038 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1033, align 8
	%1039 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1029 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1038, %runtime.Type_Info_Slice* %1039
	%1040 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1029, i64 0, i32 2 ; UnionTagPtr
	store i8 14, i8* %1040
	%1041 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 49
	%1042 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1041, i64 0, i32 3
	%1043 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1041, i64 0, i32 0
	store i64 8, i64* %1043
	%1044 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1041, i64 0, i32 1
	store i64 8, i64* %1044
	%1045 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1041, i64 0, i32 2
	store %..typeid 648518346341351473, %..typeid* %1045
	; Type_Info_Pointer
	%1046 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1042 to %runtime.Type_Info_Pointer*
	%1047 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	%1048 = bitcast %runtime.Type_Info* %1047 to %runtime.Type_Info*
	%1049 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1046, i64 0, i32 0
	store %runtime.Type_Info* %1048, %runtime.Type_Info** %1049
	%1050 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1046, align 8
	%1051 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1042 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1050, %runtime.Type_Info_Pointer* %1051
	%1052 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1042, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %1052
	%1053 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 50
	%1054 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1053, i64 0, i32 3
	%1055 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1053, i64 0, i32 0
	store i64 40, i64* %1055
	%1056 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1053, i64 0, i32 1
	store i64 8, i64* %1056
	%1057 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1053, i64 0, i32 2
	store %..typeid 3386706919782613042, %..typeid* %1057
	; Type_Info_Named
	%1058 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1054 to %runtime.Type_Info_Named*
	%1059 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 51
	%1060 = bitcast %runtime.Type_Info* %1059 to %runtime.Type_Info*
	%1061 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1058, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$2b8, i64 0, i32 0), i64 15}, %..string* %1061
	%1062 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1058, i64 0, i32 1
	store %runtime.Type_Info* %1060, %runtime.Type_Info** %1062
	%1063 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1058, align 8
	%1064 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1054 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1063, %runtime.Type_Info_Named* %1064
	%1065 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1054, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1065
	%1066 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 51
	%1067 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1066, i64 0, i32 3
	%1068 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1066, i64 0, i32 0
	store i64 40, i64* %1068
	%1069 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1066, i64 0, i32 1
	store i64 8, i64* %1069
	%1070 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1066, i64 0, i32 2
	store %..typeid 1080863910568919091, %..typeid* %1070
	; Type_Info_Struct
	%1071 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1067 to %runtime.Type_Info_Struct*
	%1072 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1071, i64 0, i32 4
	store i8 0, i8* %1072
	%1073 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1071, i64 0, i32 5
	store i8 0, i8* %1073
	%1074 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1071, i64 0, i32 6
	store i8 0, i8* %1074
	%1075 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 48
	%1076 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 27
	%1077 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 27
	%1078 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 27
	%1079 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 39
	%1080 = bitcast %runtime.Type_Info* %1079 to %runtime.Type_Info*
	%1081 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1075, i64 0
	%1082 = getelementptr inbounds i64, i64* %1077, i64 0
	%1083 = getelementptr inbounds i8, i8* %1078, i64 0
	%1084 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 39
	store %runtime.Type_Info* %1084, %runtime.Type_Info** %1081
	%1085 = getelementptr inbounds %..string, %..string* %1076, i64 0
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$2b9, i64 0, i32 0), i64 8}, %..string* %1085
	store i64 0, i64* %1082
	store i8 0, i8* %1083
	%1086 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 46
	%1087 = bitcast %runtime.Type_Info* %1086 to %runtime.Type_Info*
	%1088 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1075, i64 1
	%1089 = getelementptr inbounds i64, i64* %1077, i64 1
	%1090 = getelementptr inbounds i8, i8* %1078, i64 1
	%1091 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 46
	store %runtime.Type_Info* %1091, %runtime.Type_Info** %1088
	%1092 = getelementptr inbounds %..string, %..string* %1076, i64 1
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$2ba, i64 0, i32 0), i64 10}, %..string* %1092
	store i64 16, i64* %1089
	store i8 0, i8* %1090
	%1093 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%1094 = bitcast %runtime.Type_Info* %1093 to %runtime.Type_Info*
	%1095 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1075, i64 2
	%1096 = getelementptr inbounds i64, i64* %1077, i64 2
	%1097 = getelementptr inbounds i8, i8* %1078, i64 2
	%1098 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	store %runtime.Type_Info* %1098, %runtime.Type_Info** %1095
	%1099 = getelementptr inbounds %..string, %..string* %1076, i64 2
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$2bb, i64 0, i32 0), i64 8}, %..string* %1099
	store i64 24, i64* %1096
	store i8 0, i8* %1097
	%1100 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	%1101 = bitcast %runtime.Type_Info* %1100 to %runtime.Type_Info*
	%1102 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1075, i64 3
	%1103 = getelementptr inbounds i64, i64* %1077, i64 3
	%1104 = getelementptr inbounds i8, i8* %1078, i64 3
	%1105 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	store %runtime.Type_Info* %1105, %runtime.Type_Info** %1102
	%1106 = getelementptr inbounds %..string, %..string* %1076, i64 3
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$2bc, i64 0, i32 0), i64 12}, %..string* %1106
	store i64 32, i64* %1103
	store i8 0, i8* %1104
	%1107 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1071, i64 0, i32 0
	%1108 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1107, i64 0, i32 0
	store %runtime.Type_Info** %1075, %runtime.Type_Info*** %1108
	%1109 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1107, i64 0, i32 1
	store i64 4, i64* %1109
	%1110 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1071, i64 0, i32 1
	%1111 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1110, i64 0, i32 0
	store %..string* %1076, %..string** %1111
	%1112 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1110, i64 0, i32 1
	store i64 4, i64* %1112
	%1113 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1071, i64 0, i32 2
	%1114 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1113, i64 0, i32 0
	store i64* %1077, i64** %1114
	%1115 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1113, i64 0, i32 1
	store i64 4, i64* %1115
	%1116 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1071, i64 0, i32 3
	%1117 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1116, i64 0, i32 0
	store i8* %1078, i8** %1117
	%1118 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1116, i64 0, i32 1
	store i64 4, i64* %1118
	%1119 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1071, align 8
	%1120 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1067 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1119, %runtime.Type_Info_Struct* %1120
	%1121 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1067, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1121
	%1122 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 52
	%1123 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1122, i64 0, i32 3
	%1124 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1122, i64 0, i32 0
	store i64 40, i64* %1124
	%1125 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1122, i64 0, i32 1
	store i64 8, i64* %1125
	%1126 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1122, i64 0, i32 2
	store %..typeid 3386706919782613044, %..typeid* %1126
	; Type_Info_Named
	%1127 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1123 to %runtime.Type_Info_Named*
	%1128 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 53
	%1129 = bitcast %runtime.Type_Info* %1128 to %runtime.Type_Info*
	%1130 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1127, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$2bd, i64 0, i32 0), i64 14}, %..string* %1130
	%1131 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1127, i64 0, i32 1
	store %runtime.Type_Info* %1129, %runtime.Type_Info** %1131
	%1132 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1127, align 8
	%1133 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1123 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1132, %runtime.Type_Info_Named* %1133
	%1134 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1123, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1134
	%1135 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 53
	%1136 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1135, i64 0, i32 3
	%1137 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1135, i64 0, i32 0
	store i64 40, i64* %1137
	%1138 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1135, i64 0, i32 1
	store i64 8, i64* %1138
	%1139 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1135, i64 0, i32 2
	store %..typeid 1080863910568919093, %..typeid* %1139
	; Type_Info_Struct
	%1140 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1136 to %runtime.Type_Info_Struct*
	%1141 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1140, i64 0, i32 4
	store i8 0, i8* %1141
	%1142 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1140, i64 0, i32 5
	store i8 0, i8* %1142
	%1143 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1140, i64 0, i32 6
	store i8 0, i8* %1143
	%1144 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 52
	%1145 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 31
	%1146 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 31
	%1147 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 31
	%1148 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%1149 = bitcast %runtime.Type_Info* %1148 to %runtime.Type_Info*
	%1150 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1144, i64 0
	%1151 = getelementptr inbounds i64, i64* %1146, i64 0
	%1152 = getelementptr inbounds i8, i8* %1147, i64 0
	%1153 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	store %runtime.Type_Info* %1153, %runtime.Type_Info** %1150
	%1154 = getelementptr inbounds %..string, %..string* %1145, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2be, i64 0, i32 0), i64 4}, %..string* %1154
	store i64 0, i64* %1151
	store i8 0, i8* %1152
	%1155 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 41
	%1156 = bitcast %runtime.Type_Info* %1155 to %runtime.Type_Info*
	%1157 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1144, i64 1
	%1158 = getelementptr inbounds i64, i64* %1146, i64 1
	%1159 = getelementptr inbounds i8, i8* %1147, i64 1
	%1160 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 41
	store %runtime.Type_Info* %1160, %runtime.Type_Info** %1157
	%1161 = getelementptr inbounds %..string, %..string* %1145, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$2bf, i64 0, i32 0), i64 5}, %..string* %1161
	store i64 8, i64* %1158
	store i8 0, i8* %1159
	%1162 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 54
	%1163 = bitcast %runtime.Type_Info* %1162 to %runtime.Type_Info*
	%1164 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1144, i64 2
	%1165 = getelementptr inbounds i64, i64* %1146, i64 2
	%1166 = getelementptr inbounds i8, i8* %1147, i64 2
	%1167 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 54
	store %runtime.Type_Info* %1167, %runtime.Type_Info** %1164
	%1168 = getelementptr inbounds %..string, %..string* %1145, i64 2
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$2c0, i64 0, i32 0), i64 6}, %..string* %1168
	store i64 24, i64* %1165
	store i8 0, i8* %1166
	%1169 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1140, i64 0, i32 0
	%1170 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1169, i64 0, i32 0
	store %runtime.Type_Info** %1144, %runtime.Type_Info*** %1170
	%1171 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1169, i64 0, i32 1
	store i64 3, i64* %1171
	%1172 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1140, i64 0, i32 1
	%1173 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1172, i64 0, i32 0
	store %..string* %1145, %..string** %1173
	%1174 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1172, i64 0, i32 1
	store i64 3, i64* %1174
	%1175 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1140, i64 0, i32 2
	%1176 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1175, i64 0, i32 0
	store i64* %1146, i64** %1176
	%1177 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1175, i64 0, i32 1
	store i64 3, i64* %1177
	%1178 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1140, i64 0, i32 3
	%1179 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1178, i64 0, i32 0
	store i8* %1147, i8** %1179
	%1180 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1178, i64 0, i32 1
	store i64 3, i64* %1180
	%1181 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1140, align 8
	%1182 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1136 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1181, %runtime.Type_Info_Struct* %1182
	%1183 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1136, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1183
	%1184 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 54
	%1185 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1184, i64 0, i32 3
	%1186 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1184, i64 0, i32 0
	store i64 16, i64* %1186
	%1187 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1184, i64 0, i32 1
	store i64 8, i64* %1187
	%1188 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1184, i64 0, i32 2
	store %..typeid 936748722493063222, %..typeid* %1188
	; Type_Info_Slice
	%1189 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1185 to %runtime.Type_Info_Slice*
	%1190 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 55
	%1191 = bitcast %runtime.Type_Info* %1190 to %runtime.Type_Info*
	%1192 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1189, i64 0, i32 0
	store %runtime.Type_Info* %1191, %runtime.Type_Info** %1192
	%1193 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1189, i64 0, i32 1
	store i64 16, i64* %1193
	%1194 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1189, align 8
	%1195 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1185 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1194, %runtime.Type_Info_Slice* %1195
	%1196 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1185, i64 0, i32 2 ; UnionTagPtr
	store i8 14, i8* %1196
	%1197 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 55
	%1198 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1197, i64 0, i32 3
	%1199 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1197, i64 0, i32 0
	store i64 16, i64* %1199
	%1200 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1197, i64 0, i32 1
	store i64 8, i64* %1200
	%1201 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1197, i64 0, i32 2
	store %..typeid 3458764513820540983, %..typeid* %1201
	; Type_Info_Named
	%1202 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1198 to %runtime.Type_Info_Named*
	%1203 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 56
	%1204 = bitcast %runtime.Type_Info* %1203 to %runtime.Type_Info*
	%1205 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1202, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$2c1, i64 0, i32 0), i64 20}, %..string* %1205
	%1206 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1202, i64 0, i32 1
	store %runtime.Type_Info* %1204, %runtime.Type_Info** %1206
	%1207 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1202, align 8
	%1208 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1198 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1207, %runtime.Type_Info_Named* %1208
	%1209 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1198, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1209
	%1210 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 56
	%1211 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1210, i64 0, i32 3
	%1212 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1210, i64 0, i32 0
	store i64 16, i64* %1212
	%1213 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1210, i64 0, i32 1
	store i64 8, i64* %1213
	%1214 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1210, i64 0, i32 2
	store %..typeid 1152921504606847032, %..typeid* %1214
	; Type_Info_Union
	%1215 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1211 to %runtime.Type_Info_Union*
	%1216 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1215, i64 0, i32 0
	%1217 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1215, i64 0, i32 1
	%1218 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1215, i64 0, i32 2
	%1219 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1215, i64 0, i32 3
	%1220 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 55
	%1221 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 57
	%1222 = bitcast %runtime.Type_Info* %1221 to %runtime.Type_Info*
	%1223 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1220, i64 0
	%1224 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 57
	store %runtime.Type_Info* %1224, %runtime.Type_Info** %1223
	%1225 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 58
	%1226 = bitcast %runtime.Type_Info* %1225 to %runtime.Type_Info*
	%1227 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1220, i64 1
	%1228 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 58
	store %runtime.Type_Info* %1228, %runtime.Type_Info** %1227
	%1229 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 59
	%1230 = bitcast %runtime.Type_Info* %1229 to %runtime.Type_Info*
	%1231 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1220, i64 2
	%1232 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 59
	store %runtime.Type_Info* %1232, %runtime.Type_Info** %1231
	%1233 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 60
	%1234 = bitcast %runtime.Type_Info* %1233 to %runtime.Type_Info*
	%1235 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1220, i64 3
	%1236 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 60
	store %runtime.Type_Info* %1236, %runtime.Type_Info** %1235
	%1237 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 61
	%1238 = bitcast %runtime.Type_Info* %1237 to %runtime.Type_Info*
	%1239 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1220, i64 4
	%1240 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 61
	store %runtime.Type_Info* %1240, %runtime.Type_Info** %1239
	%1241 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%1242 = bitcast %runtime.Type_Info* %1241 to %runtime.Type_Info*
	%1243 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1220, i64 5
	%1244 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	store %runtime.Type_Info* %1244, %runtime.Type_Info** %1243
	%1245 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	%1246 = bitcast %runtime.Type_Info* %1245 to %runtime.Type_Info*
	%1247 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1220, i64 6
	%1248 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	store %runtime.Type_Info* %1248, %runtime.Type_Info** %1247
	%1249 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 62
	%1250 = bitcast %runtime.Type_Info* %1249 to %runtime.Type_Info*
	%1251 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1220, i64 7
	%1252 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 62
	store %runtime.Type_Info* %1252, %runtime.Type_Info** %1251
	%1253 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 63
	%1254 = bitcast %runtime.Type_Info* %1253 to %runtime.Type_Info*
	%1255 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1220, i64 8
	%1256 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 63
	store %runtime.Type_Info* %1256, %runtime.Type_Info** %1255
	%1257 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 64
	%1258 = bitcast %runtime.Type_Info* %1257 to %runtime.Type_Info*
	%1259 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1220, i64 9
	%1260 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 64
	store %runtime.Type_Info* %1260, %runtime.Type_Info** %1259
	%1261 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 65
	%1262 = bitcast %runtime.Type_Info* %1261 to %runtime.Type_Info*
	%1263 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1220, i64 10
	%1264 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 65
	store %runtime.Type_Info* %1264, %runtime.Type_Info** %1263
	%1265 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 46
	%1266 = bitcast %runtime.Type_Info* %1265 to %runtime.Type_Info*
	%1267 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1220, i64 11
	%1268 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 46
	store %runtime.Type_Info* %1268, %runtime.Type_Info** %1267
	%1269 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1216, i64 0, i32 0
	store %runtime.Type_Info** %1220, %runtime.Type_Info*** %1269
	%1270 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1216, i64 0, i32 1
	store i64 12, i64* %1270
	store i64 8, i64* %1217
	%1271 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	store %runtime.Type_Info* %1271, %runtime.Type_Info** %1218
	store i8 0, i8* %1219
	%1272 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1215, align 8
	%1273 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1211 to %runtime.Type_Info_Union*
	store %runtime.Type_Info_Union %1272, %runtime.Type_Info_Union* %1273
	%1274 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1211, i64 0, i32 2 ; UnionTagPtr
	store i8 17, i8* %1274
	%1275 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 57
	%1276 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1275, i64 0, i32 3
	%1277 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1275, i64 0, i32 0
	store i64 4, i64* %1277
	%1278 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1275, i64 0, i32 1
	store i64 4, i64* %1278
	%1279 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1275, i64 0, i32 2
	store %..typeid 4755801206503243833, %..typeid* %1279
	; Type_Info_Basic
	%1280 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1276 to %runtime.Type_Info_Rune*
	%1281 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %1280, align 1
	%1282 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1276 to %runtime.Type_Info_Rune*
	store %runtime.Type_Info_Rune %1281, %runtime.Type_Info_Rune* %1282
	%1283 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1276, i64 0, i32 2 ; UnionTagPtr
	store i8 3, i8* %1283
	%1284 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 58
	%1285 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1284, i64 0, i32 3
	%1286 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1284, i64 0, i32 0
	store i64 1, i64* %1286
	%1287 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1284, i64 0, i32 1
	store i64 1, i64* %1287
	%1288 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1284, i64 0, i32 2
	store %..typeid 4683743612465315898, %..typeid* %1288
	; Type_Info_Basic
	%1289 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1285 to %runtime.Type_Info_Integer*
	%1290 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1289, i64 0, i32 0
	store i8 1, i8* %1290
	%1291 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1289, align 1
	%1292 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1285 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1291, %runtime.Type_Info_Integer* %1292
	%1293 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1285, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1293
	%1294 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 59
	%1295 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1294, i64 0, i32 3
	%1296 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1294, i64 0, i32 0
	store i64 2, i64* %1296
	%1297 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1294, i64 0, i32 1
	store i64 2, i64* %1297
	%1298 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1294, i64 0, i32 2
	store %..typeid 4683743612465315899, %..typeid* %1298
	; Type_Info_Basic
	%1299 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1295 to %runtime.Type_Info_Integer*
	%1300 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1299, i64 0, i32 0
	store i8 1, i8* %1300
	%1301 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1299, align 1
	%1302 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1295 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1301, %runtime.Type_Info_Integer* %1302
	%1303 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1295, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1303
	%1304 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 61
	%1305 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1304, i64 0, i32 3
	%1306 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1304, i64 0, i32 0
	store i64 8, i64* %1306
	%1307 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1304, i64 0, i32 1
	store i64 8, i64* %1307
	%1308 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1304, i64 0, i32 2
	store %..typeid 4683743612465315901, %..typeid* %1308
	; Type_Info_Basic
	%1309 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1305 to %runtime.Type_Info_Integer*
	%1310 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1309, i64 0, i32 0
	store i8 1, i8* %1310
	%1311 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1309, align 1
	%1312 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1305 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1311, %runtime.Type_Info_Integer* %1312
	%1313 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1305, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1313
	%1314 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 62
	%1315 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1314, i64 0, i32 3
	%1316 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1314, i64 0, i32 0
	store i64 2, i64* %1316
	%1317 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1314, i64 0, i32 1
	store i64 2, i64* %1317
	%1318 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1314, i64 0, i32 2
	store %..typeid 72057594037927998, %..typeid* %1318
	; Type_Info_Basic
	%1319 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1315 to %runtime.Type_Info_Integer*
	%1320 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1319, i64 0, i32 0
	store i8 0, i8* %1320
	%1321 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1319, align 1
	%1322 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1315 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1321, %runtime.Type_Info_Integer* %1322
	%1323 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1315, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1323
	%1324 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 63
	%1325 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1324, i64 0, i32 3
	%1326 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1324, i64 0, i32 0
	store i64 4, i64* %1326
	%1327 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1324, i64 0, i32 1
	store i64 4, i64* %1327
	%1328 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1324, i64 0, i32 2
	store %..typeid 72057594037927999, %..typeid* %1328
	; Type_Info_Basic
	%1329 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1325 to %runtime.Type_Info_Integer*
	%1330 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1329, i64 0, i32 0
	store i8 0, i8* %1330
	%1331 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1329, align 1
	%1332 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1325 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1331, %runtime.Type_Info_Integer* %1332
	%1333 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1325, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1333
	%1334 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 64
	%1335 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1334, i64 0, i32 3
	%1336 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1334, i64 0, i32 0
	store i64 8, i64* %1336
	%1337 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1334, i64 0, i32 1
	store i64 8, i64* %1337
	%1338 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1334, i64 0, i32 2
	store %..typeid 72057594037928000, %..typeid* %1338
	; Type_Info_Basic
	%1339 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1335 to %runtime.Type_Info_Integer*
	%1340 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1339, i64 0, i32 0
	store i8 0, i8* %1340
	%1341 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1339, align 1
	%1342 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1335 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1341, %runtime.Type_Info_Integer* %1342
	%1343 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1335, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1343
	%1344 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 65
	%1345 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1344, i64 0, i32 3
	%1346 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1344, i64 0, i32 0
	store i64 8, i64* %1346
	%1347 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1344, i64 0, i32 1
	store i64 8, i64* %1347
	%1348 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1344, i64 0, i32 2
	store %..typeid 72057594037928001, %..typeid* %1348
	; Type_Info_Basic
	%1349 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1345 to %runtime.Type_Info_Integer*
	%1350 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1349, i64 0, i32 0
	store i8 0, i8* %1350
	%1351 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1349, align 1
	%1352 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1345 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1351, %runtime.Type_Info_Integer* %1352
	%1353 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1345, i64 0, i32 2 ; UnionTagPtr
	store i8 2, i8* %1353
	%1354 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 66
	%1355 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1354, i64 0, i32 3
	%1356 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1354, i64 0, i32 0
	store i64 8, i64* %1356
	%1357 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1354, i64 0, i32 1
	store i64 8, i64* %1357
	%1358 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1354, i64 0, i32 2
	store %..typeid 648518346341351490, %..typeid* %1358
	; Type_Info_Pointer
	%1359 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1355 to %runtime.Type_Info_Pointer*
	%1360 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 55
	%1361 = bitcast %runtime.Type_Info* %1360 to %runtime.Type_Info*
	%1362 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1359, i64 0, i32 0
	store %runtime.Type_Info* %1361, %runtime.Type_Info** %1362
	%1363 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1359, align 8
	%1364 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1355 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1363, %runtime.Type_Info_Pointer* %1364
	%1365 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1355, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %1365
	%1366 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 67
	%1367 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1366, i64 0, i32 3
	%1368 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1366, i64 0, i32 0
	store i64 24, i64* %1368
	%1369 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1366, i64 0, i32 1
	store i64 8, i64* %1369
	%1370 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1366, i64 0, i32 2
	store %..typeid 3386706919782613059, %..typeid* %1370
	; Type_Info_Named
	%1371 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1367 to %runtime.Type_Info_Named*
	%1372 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 68
	%1373 = bitcast %runtime.Type_Info* %1372 to %runtime.Type_Info*
	%1374 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1371, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$2c2, i64 0, i32 0), i64 13}, %..string* %1374
	%1375 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1371, i64 0, i32 1
	store %runtime.Type_Info* %1373, %runtime.Type_Info** %1375
	%1376 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1371, align 8
	%1377 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1367 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1376, %runtime.Type_Info_Named* %1377
	%1378 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1367, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1378
	%1379 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 68
	%1380 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1379, i64 0, i32 3
	%1381 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1379, i64 0, i32 0
	store i64 24, i64* %1381
	%1382 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1379, i64 0, i32 1
	store i64 8, i64* %1382
	%1383 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1379, i64 0, i32 2
	store %..typeid 1080863910568919108, %..typeid* %1383
	; Type_Info_Struct
	%1384 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1380 to %runtime.Type_Info_Struct*
	%1385 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1384, i64 0, i32 4
	store i8 0, i8* %1385
	%1386 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1384, i64 0, i32 5
	store i8 0, i8* %1386
	%1387 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1384, i64 0, i32 6
	store i8 0, i8* %1387
	%1388 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 67
	%1389 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 34
	%1390 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 34
	%1391 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 34
	%1392 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%1393 = bitcast %runtime.Type_Info* %1392 to %runtime.Type_Info*
	%1394 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1388, i64 0
	%1395 = getelementptr inbounds i64, i64* %1390, i64 0
	%1396 = getelementptr inbounds i8, i8* %1391, i64 0
	%1397 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	store %runtime.Type_Info* %1397, %runtime.Type_Info** %1394
	%1398 = getelementptr inbounds %..string, %..string* %1389, i64 0
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$2c3, i64 0, i32 0), i64 3}, %..string* %1398
	store i64 0, i64* %1395
	store i8 0, i8* %1396
	%1399 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%1400 = bitcast %runtime.Type_Info* %1399 to %runtime.Type_Info*
	%1401 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1388, i64 1
	%1402 = getelementptr inbounds i64, i64* %1390, i64 1
	%1403 = getelementptr inbounds i8, i8* %1391, i64 1
	%1404 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	store %runtime.Type_Info* %1404, %runtime.Type_Info** %1401
	%1405 = getelementptr inbounds %..string, %..string* %1389, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$2c4, i64 0, i32 0), i64 5}, %..string* %1405
	store i64 8, i64* %1402
	store i8 0, i8* %1403
	%1406 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%1407 = bitcast %runtime.Type_Info* %1406 to %runtime.Type_Info*
	%1408 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1388, i64 2
	%1409 = getelementptr inbounds i64, i64* %1390, i64 2
	%1410 = getelementptr inbounds i8, i8* %1391, i64 2
	%1411 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	store %runtime.Type_Info* %1411, %runtime.Type_Info** %1408
	%1412 = getelementptr inbounds %..string, %..string* %1389, i64 2
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$2c5, i64 0, i32 0), i64 16}, %..string* %1412
	store i64 16, i64* %1409
	store i8 0, i8* %1410
	%1413 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1384, i64 0, i32 0
	%1414 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1413, i64 0, i32 0
	store %runtime.Type_Info** %1388, %runtime.Type_Info*** %1414
	%1415 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1413, i64 0, i32 1
	store i64 3, i64* %1415
	%1416 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1384, i64 0, i32 1
	%1417 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1416, i64 0, i32 0
	store %..string* %1389, %..string** %1417
	%1418 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1416, i64 0, i32 1
	store i64 3, i64* %1418
	%1419 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1384, i64 0, i32 2
	%1420 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1419, i64 0, i32 0
	store i64* %1390, i64** %1420
	%1421 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1419, i64 0, i32 1
	store i64 3, i64* %1421
	%1422 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1384, i64 0, i32 3
	%1423 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1422, i64 0, i32 0
	store i8* %1391, i8** %1423
	%1424 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1422, i64 0, i32 1
	store i64 3, i64* %1424
	%1425 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1384, align 8
	%1426 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1380 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1425, %runtime.Type_Info_Struct* %1426
	%1427 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1380, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1427
	%1428 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 69
	%1429 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1428, i64 0, i32 3
	%1430 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1428, i64 0, i32 0
	store i64 48, i64* %1430
	%1431 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1428, i64 0, i32 1
	store i64 8, i64* %1431
	%1432 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1428, i64 0, i32 2
	store %..typeid 3386706919782613061, %..typeid* %1432
	; Type_Info_Named
	%1433 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1429 to %runtime.Type_Info_Named*
	%1434 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 70
	%1435 = bitcast %runtime.Type_Info* %1434 to %runtime.Type_Info*
	%1436 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1433, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$2c6, i64 0, i32 0), i64 19}, %..string* %1436
	%1437 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1433, i64 0, i32 1
	store %runtime.Type_Info* %1435, %runtime.Type_Info** %1437
	%1438 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1433, align 8
	%1439 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1429 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1438, %runtime.Type_Info_Named* %1439
	%1440 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1429, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1440
	%1441 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 70
	%1442 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1441, i64 0, i32 3
	%1443 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1441, i64 0, i32 0
	store i64 48, i64* %1443
	%1444 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1441, i64 0, i32 1
	store i64 8, i64* %1444
	%1445 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1441, i64 0, i32 2
	store %..typeid 1080863910568919110, %..typeid* %1445
	; Type_Info_Struct
	%1446 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1442 to %runtime.Type_Info_Struct*
	%1447 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1446, i64 0, i32 4
	store i8 0, i8* %1447
	%1448 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1446, i64 0, i32 5
	store i8 0, i8* %1448
	%1449 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1446, i64 0, i32 6
	store i8 0, i8* %1449
	%1450 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 70
	%1451 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 37
	%1452 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 37
	%1453 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 37
	%1454 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 41
	%1455 = bitcast %runtime.Type_Info* %1454 to %runtime.Type_Info*
	%1456 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1450, i64 0
	%1457 = getelementptr inbounds i64, i64* %1452, i64 0
	%1458 = getelementptr inbounds i8, i8* %1453, i64 0
	%1459 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 41
	store %runtime.Type_Info* %1459, %runtime.Type_Info** %1456
	%1460 = getelementptr inbounds %..string, %..string* %1451, i64 0
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$2c7, i64 0, i32 0), i64 5}, %..string* %1460
	store i64 0, i64* %1457
	store i8 0, i8* %1458
	%1461 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 71
	%1462 = bitcast %runtime.Type_Info* %1461 to %runtime.Type_Info*
	%1463 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1450, i64 1
	%1464 = getelementptr inbounds i64, i64* %1452, i64 1
	%1465 = getelementptr inbounds i8, i8* %1453, i64 1
	%1466 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 71
	store %runtime.Type_Info* %1466, %runtime.Type_Info** %1463
	%1467 = getelementptr inbounds %..string, %..string* %1451, i64 1
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2c8, i64 0, i32 0), i64 4}, %..string* %1467
	store i64 16, i64* %1464
	store i8 0, i8* %1465
	%1468 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 71
	%1469 = bitcast %runtime.Type_Info* %1468 to %runtime.Type_Info*
	%1470 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1450, i64 2
	%1471 = getelementptr inbounds i64, i64* %1452, i64 2
	%1472 = getelementptr inbounds i8, i8* %1453, i64 2
	%1473 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 71
	store %runtime.Type_Info* %1473, %runtime.Type_Info** %1470
	%1474 = getelementptr inbounds %..string, %..string* %1451, i64 2
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$2c9, i64 0, i32 0), i64 7}, %..string* %1474
	store i64 32, i64* %1471
	store i8 0, i8* %1472
	%1475 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1446, i64 0, i32 0
	%1476 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1475, i64 0, i32 0
	store %runtime.Type_Info** %1450, %runtime.Type_Info*** %1476
	%1477 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1475, i64 0, i32 1
	store i64 3, i64* %1477
	%1478 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1446, i64 0, i32 1
	%1479 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1478, i64 0, i32 0
	store %..string* %1451, %..string** %1479
	%1480 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1478, i64 0, i32 1
	store i64 3, i64* %1480
	%1481 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1446, i64 0, i32 2
	%1482 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1481, i64 0, i32 0
	store i64* %1452, i64** %1482
	%1483 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1481, i64 0, i32 1
	store i64 3, i64* %1483
	%1484 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1446, i64 0, i32 3
	%1485 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1484, i64 0, i32 0
	store i8* %1453, i8** %1485
	%1486 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1484, i64 0, i32 1
	store i64 3, i64* %1486
	%1487 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1446, align 8
	%1488 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1442 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1487, %runtime.Type_Info_Struct* %1488
	%1489 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1442, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1489
	%1490 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 71
	%1491 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1490, i64 0, i32 3
	%1492 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1490, i64 0, i32 0
	store i64 16, i64* %1492
	%1493 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1490, i64 0, i32 1
	store i64 8, i64* %1493
	%1494 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1490, i64 0, i32 2
	store %..typeid 936748722493063239, %..typeid* %1494
	; Type_Info_Slice
	%1495 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1491 to %runtime.Type_Info_Slice*
	%1496 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 60
	%1497 = bitcast %runtime.Type_Info* %1496 to %runtime.Type_Info*
	%1498 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1495, i64 0, i32 0
	store %runtime.Type_Info* %1497, %runtime.Type_Info** %1498
	%1499 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1495, i64 0, i32 1
	store i64 4, i64* %1499
	%1500 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1495, align 8
	%1501 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1491 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1500, %runtime.Type_Info_Slice* %1501
	%1502 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1491, i64 0, i32 2 ; UnionTagPtr
	store i8 14, i8* %1502
	%1503 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 72
	%1504 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1503, i64 0, i32 3
	%1505 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1503, i64 0, i32 0
	store i64 8, i64* %1505
	%1506 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1503, i64 0, i32 1
	store i64 8, i64* %1506
	%1507 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1503, i64 0, i32 2
	store %..typeid 648518346341351496, %..typeid* %1507
	; Type_Info_Pointer
	%1508 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1504 to %runtime.Type_Info_Pointer*
	%1509 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 60
	%1510 = bitcast %runtime.Type_Info* %1509 to %runtime.Type_Info*
	%1511 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1508, i64 0, i32 0
	store %runtime.Type_Info* %1510, %runtime.Type_Info** %1511
	%1512 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1508, align 8
	%1513 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1504 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1512, %runtime.Type_Info_Pointer* %1513
	%1514 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1504, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %1514
	%1515 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 73
	%1516 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1515, i64 0, i32 3
	%1517 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1515, i64 0, i32 0
	store i64 32, i64* %1517
	%1518 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1515, i64 0, i32 1
	store i64 8, i64* %1518
	%1519 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1515, i64 0, i32 2
	store %..typeid 3386706919782613065, %..typeid* %1519
	; Type_Info_Named
	%1520 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1516 to %runtime.Type_Info_Named*
	%1521 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 74
	%1522 = bitcast %runtime.Type_Info* %1521 to %runtime.Type_Info*
	%1523 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1520, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$2ca, i64 0, i32 0), i64 17}, %..string* %1523
	%1524 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1520, i64 0, i32 1
	store %runtime.Type_Info* %1522, %runtime.Type_Info** %1524
	%1525 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1520, align 8
	%1526 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1516 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1525, %runtime.Type_Info_Named* %1526
	%1527 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1516, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1527
	%1528 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 74
	%1529 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1528, i64 0, i32 3
	%1530 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1528, i64 0, i32 0
	store i64 32, i64* %1530
	%1531 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1528, i64 0, i32 1
	store i64 8, i64* %1531
	%1532 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1528, i64 0, i32 2
	store %..typeid 1080863910568919114, %..typeid* %1532
	; Type_Info_Struct
	%1533 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1529 to %runtime.Type_Info_Struct*
	%1534 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1533, i64 0, i32 4
	store i8 0, i8* %1534
	%1535 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1533, i64 0, i32 5
	store i8 0, i8* %1535
	%1536 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1533, i64 0, i32 6
	store i8 0, i8* %1536
	%1537 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 73
	%1538 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 40
	%1539 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 40
	%1540 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 40
	%1541 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%1542 = bitcast %runtime.Type_Info* %1541 to %runtime.Type_Info*
	%1543 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1537, i64 0
	%1544 = getelementptr inbounds i64, i64* %1539, i64 0
	%1545 = getelementptr inbounds i8, i8* %1540, i64 0
	%1546 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	store %runtime.Type_Info* %1546, %runtime.Type_Info** %1543
	%1547 = getelementptr inbounds %..string, %..string* %1538, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2cb, i64 0, i32 0), i64 4}, %..string* %1547
	store i64 0, i64* %1544
	store i8 0, i8* %1545
	%1548 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	%1549 = bitcast %runtime.Type_Info* %1548 to %runtime.Type_Info*
	%1550 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1537, i64 1
	%1551 = getelementptr inbounds i64, i64* %1539, i64 1
	%1552 = getelementptr inbounds i8, i8* %1540, i64 1
	%1553 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 9
	store %runtime.Type_Info* %1553, %runtime.Type_Info** %1550
	%1554 = getelementptr inbounds %..string, %..string* %1538, i64 1
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$2cc, i64 0, i32 0), i64 10}, %..string* %1554
	store i64 8, i64* %1551
	store i8 0, i8* %1552
	%1555 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 61
	%1556 = bitcast %runtime.Type_Info* %1555 to %runtime.Type_Info*
	%1557 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1537, i64 2
	%1558 = getelementptr inbounds i64, i64* %1539, i64 2
	%1559 = getelementptr inbounds i8, i8* %1540, i64 2
	%1560 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 61
	store %runtime.Type_Info* %1560, %runtime.Type_Info** %1557
	%1561 = getelementptr inbounds %..string, %..string* %1538, i64 2
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$2cd, i64 0, i32 0), i64 5}, %..string* %1561
	store i64 16, i64* %1558
	store i8 0, i8* %1559
	%1562 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 61
	%1563 = bitcast %runtime.Type_Info* %1562 to %runtime.Type_Info*
	%1564 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1537, i64 3
	%1565 = getelementptr inbounds i64, i64* %1539, i64 3
	%1566 = getelementptr inbounds i8, i8* %1540, i64 3
	%1567 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 61
	store %runtime.Type_Info* %1567, %runtime.Type_Info** %1564
	%1568 = getelementptr inbounds %..string, %..string* %1538, i64 3
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$2ce, i64 0, i32 0), i64 5}, %..string* %1568
	store i64 24, i64* %1565
	store i8 0, i8* %1566
	%1569 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1533, i64 0, i32 0
	%1570 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1569, i64 0, i32 0
	store %runtime.Type_Info** %1537, %runtime.Type_Info*** %1570
	%1571 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1569, i64 0, i32 1
	store i64 4, i64* %1571
	%1572 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1533, i64 0, i32 1
	%1573 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1572, i64 0, i32 0
	store %..string* %1538, %..string** %1573
	%1574 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1572, i64 0, i32 1
	store i64 4, i64* %1574
	%1575 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1533, i64 0, i32 2
	%1576 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1575, i64 0, i32 0
	store i64* %1539, i64** %1576
	%1577 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1575, i64 0, i32 1
	store i64 4, i64* %1577
	%1578 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1533, i64 0, i32 3
	%1579 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1578, i64 0, i32 0
	store i8* %1540, i8** %1579
	%1580 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1578, i64 0, i32 1
	store i64 4, i64* %1580
	%1581 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1533, align 8
	%1582 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1529 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1581, %runtime.Type_Info_Struct* %1582
	%1583 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1529, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1583
	%1584 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 1
	%1585 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1584, i64 0, i32 3
	%1586 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1584, i64 0, i32 0
	store i64 1, i64* %1586
	%1587 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1584, i64 0, i32 1
	store i64 1, i64* %1587
	%1588 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1584, i64 0, i32 2
	store %..typeid 3530822107858468865, %..typeid* %1588
	; Type_Info_Named
	%1589 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1585 to %runtime.Type_Info_Named*
	%1590 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 2
	%1591 = bitcast %runtime.Type_Info* %1590 to %runtime.Type_Info*
	%1592 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1589, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$2cf, i64 0, i32 0), i64 14}, %..string* %1592
	%1593 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1589, i64 0, i32 1
	store %runtime.Type_Info* %1591, %runtime.Type_Info** %1593
	%1594 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1589, align 8
	%1595 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1585 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1594, %runtime.Type_Info_Named* %1595
	%1596 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1585, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1596
	%1597 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 2
	%1598 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1597, i64 0, i32 3
	%1599 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1597, i64 0, i32 0
	store i64 1, i64* %1599
	%1600 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1597, i64 0, i32 1
	store i64 1, i64* %1600
	%1601 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1597, i64 0, i32 2
	store %..typeid 1224979098644774914, %..typeid* %1601
	; Type_Info_Enum
	%1602 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1598 to %runtime.Type_Info_Enum*
	%1603 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	%1604 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %1602, i64 0, i32 0
	store %runtime.Type_Info* %1603, %runtime.Type_Info** %1604
	%1605 = getelementptr inbounds [4 x %..string], [4 x %..string]* @$enum_names-2, i64 0, i32 0
	%1606 = getelementptr inbounds [4 x %runtime.Type_Info_Enum_Value], [4 x %runtime.Type_Info_Enum_Value]* @$enum_values-2, i64 0, i32 0
	%1607 = bitcast %runtime.Type_Info_Enum_Value* %1606 to i8*
	store i8 0, i8* %1607
	%1608 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1606, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %1608
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$2d0, i64 0, i32 0), i64 5}, %..string* %1605
	%1609 = getelementptr inbounds [4 x %..string], [4 x %..string]* @$enum_names-2, i64 0, i32 1
	%1610 = getelementptr inbounds [4 x %runtime.Type_Info_Enum_Value], [4 x %runtime.Type_Info_Enum_Value]* @$enum_values-2, i64 0, i32 1
	%1611 = bitcast %runtime.Type_Info_Enum_Value* %1610 to i8*
	store i8 1, i8* %1611
	%1612 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1610, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %1612
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2d1, i64 0, i32 0), i64 4}, %..string* %1609
	%1613 = getelementptr inbounds [4 x %..string], [4 x %..string]* @$enum_names-2, i64 0, i32 2
	%1614 = getelementptr inbounds [4 x %runtime.Type_Info_Enum_Value], [4 x %runtime.Type_Info_Enum_Value]* @$enum_values-2, i64 0, i32 2
	%1615 = bitcast %runtime.Type_Info_Enum_Value* %1614 to i8*
	store i8 2, i8* %1615
	%1616 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1614, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %1616
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$2d2, i64 0, i32 0), i64 8}, %..string* %1613
	%1617 = getelementptr inbounds [4 x %..string], [4 x %..string]* @$enum_names-2, i64 0, i32 3
	%1618 = getelementptr inbounds [4 x %runtime.Type_Info_Enum_Value], [4 x %runtime.Type_Info_Enum_Value]* @$enum_values-2, i64 0, i32 3
	%1619 = bitcast %runtime.Type_Info_Enum_Value* %1618 to i8*
	store i8 3, i8* %1619
	%1620 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1618, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %1620
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$2d3, i64 0, i32 0), i64 6}, %..string* %1617
	%1621 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %1602, i64 0, i32 1
	%1622 = getelementptr inbounds [4 x %..string], [4 x %..string]* @$enum_names-2, i64 0, i32 0
	%1623 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1621, i64 0, i32 0
	store %..string* %1622, %..string** %1623
	%1624 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1621, i64 0, i32 1
	store i64 4, i64* %1624
	%1625 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %1602, i64 0, i32 2
	%1626 = getelementptr inbounds [4 x %runtime.Type_Info_Enum_Value], [4 x %runtime.Type_Info_Enum_Value]* @$enum_values-2, i64 0, i32 0
	%1627 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %1625, i64 0, i32 0
	store %runtime.Type_Info_Enum_Value* %1626, %runtime.Type_Info_Enum_Value** %1627
	%1628 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %1625, i64 0, i32 1
	store i64 4, i64* %1628
	%1629 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %1602, align 8
	%1630 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1598 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %1629, %runtime.Type_Info_Enum* %1630
	%1631 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1598, i64 0, i32 2 ; UnionTagPtr
	store i8 18, i8* %1631
	%1632 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 88
	%1633 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1632, i64 0, i32 3
	%1634 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1632, i64 0, i32 0
	store i64 16, i64* %1634
	%1635 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1632, i64 0, i32 1
	store i64 8, i64* %1635
	%1636 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1632, i64 0, i32 2
	store %..typeid 936748722493063256, %..typeid* %1636
	; Type_Info_Slice
	%1637 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1633 to %runtime.Type_Info_Slice*
	%1638 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 77
	%1639 = bitcast %runtime.Type_Info* %1638 to %runtime.Type_Info*
	%1640 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1637, i64 0, i32 0
	store %runtime.Type_Info* %1639, %runtime.Type_Info** %1640
	%1641 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1637, i64 0, i32 1
	store i64 16, i64* %1641
	%1642 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1637, align 8
	%1643 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1633 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1642, %runtime.Type_Info_Slice* %1643
	%1644 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1633, i64 0, i32 2 ; UnionTagPtr
	store i8 14, i8* %1644
	%1645 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 77
	%1646 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1645, i64 0, i32 3
	%1647 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1645, i64 0, i32 0
	store i64 16, i64* %1647
	%1648 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1645, i64 0, i32 1
	store i64 8, i64* %1648
	%1649 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1645, i64 0, i32 2
	store %..typeid 77, %..typeid* %1649
	; Type_Info_Basic
	%1650 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1646 to %runtime.Type_Info_Any*
	%1651 = load %runtime.Type_Info_Any, %runtime.Type_Info_Any* %1650, align 1
	%1652 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1646 to %runtime.Type_Info_Any*
	store %runtime.Type_Info_Any %1651, %runtime.Type_Info_Any* %1652
	%1653 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1646, i64 0, i32 2 ; UnionTagPtr
	store i8 8, i8* %1653
	%1654 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 78
	%1655 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1654, i64 0, i32 3
	%1656 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1654, i64 0, i32 0
	store i64 8, i64* %1656
	%1657 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1654, i64 0, i32 1
	store i64 8, i64* %1657
	%1658 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1654, i64 0, i32 2
	store %..typeid 648518346341351502, %..typeid* %1658
	; Type_Info_Basic
	%1659 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1655 to %runtime.Type_Info_Pointer*
	%1660 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1659, align 8
	%1661 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1655 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1660, %runtime.Type_Info_Pointer* %1661
	%1662 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1655, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %1662
	%1663 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 89
	%1664 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1663, i64 0, i32 3
	%1665 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1663, i64 0, i32 0
	store i64 8, i64* %1665
	%1666 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1663, i64 0, i32 1
	store i64 8, i64* %1666
	%1667 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1663, i64 0, i32 2
	store %..typeid 648518346341351513, %..typeid* %1667
	; Type_Info_Pointer
	%1668 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1664 to %runtime.Type_Info_Pointer*
	%1669 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 77
	%1670 = bitcast %runtime.Type_Info* %1669 to %runtime.Type_Info*
	%1671 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1668, i64 0, i32 0
	store %runtime.Type_Info* %1670, %runtime.Type_Info** %1671
	%1672 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1668, align 8
	%1673 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1664 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1672, %runtime.Type_Info_Pointer* %1673
	%1674 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1664, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %1674
	%1675 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 83
	%1676 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1675, i64 0, i32 3
	%1677 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1675, i64 0, i32 0
	store i64 4, i64* %1677
	%1678 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1675, i64 0, i32 1
	store i64 4, i64* %1678
	%1679 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1675, i64 0, i32 2
	store %..typeid 216172782113783891, %..typeid* %1679
	; Type_Info_Basic
	%1680 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1676 to %runtime.Type_Info_Float*
	%1681 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %1680, align 1
	%1682 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1676 to %runtime.Type_Info_Float*
	store %runtime.Type_Info_Float %1681, %runtime.Type_Info_Float* %1682
	%1683 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1676, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %1683
	%1684 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 79
	%1685 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1684, i64 0, i32 3
	%1686 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1684, i64 0, i32 0
	store i64 1, i64* %1686
	%1687 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1684, i64 0, i32 1
	store i64 1, i64* %1687
	%1688 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1684, i64 0, i32 2
	store %..typeid 432345564227567695, %..typeid* %1688
	; Type_Info_Basic
	%1689 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1685 to %runtime.Type_Info_Boolean*
	%1690 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %1689, align 1
	%1691 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1685 to %runtime.Type_Info_Boolean*
	store %runtime.Type_Info_Boolean %1690, %runtime.Type_Info_Boolean* %1691
	%1692 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1685, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %1692
	%1693 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 80
	%1694 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1693, i64 0, i32 3
	%1695 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1693, i64 0, i32 0
	store i64 2, i64* %1695
	%1696 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1693, i64 0, i32 1
	store i64 2, i64* %1696
	%1697 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1693, i64 0, i32 2
	store %..typeid 432345564227567696, %..typeid* %1697
	; Type_Info_Basic
	%1698 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1694 to %runtime.Type_Info_Boolean*
	%1699 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %1698, align 1
	%1700 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1694 to %runtime.Type_Info_Boolean*
	store %runtime.Type_Info_Boolean %1699, %runtime.Type_Info_Boolean* %1700
	%1701 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1694, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %1701
	%1702 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 81
	%1703 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1702, i64 0, i32 3
	%1704 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1702, i64 0, i32 0
	store i64 4, i64* %1704
	%1705 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1702, i64 0, i32 1
	store i64 4, i64* %1705
	%1706 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1702, i64 0, i32 2
	store %..typeid 432345564227567697, %..typeid* %1706
	; Type_Info_Basic
	%1707 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1703 to %runtime.Type_Info_Boolean*
	%1708 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %1707, align 1
	%1709 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1703 to %runtime.Type_Info_Boolean*
	store %runtime.Type_Info_Boolean %1708, %runtime.Type_Info_Boolean* %1709
	%1710 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1703, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %1710
	%1711 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 82
	%1712 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1711, i64 0, i32 3
	%1713 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1711, i64 0, i32 0
	store i64 8, i64* %1713
	%1714 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1711, i64 0, i32 1
	store i64 8, i64* %1714
	%1715 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1711, i64 0, i32 2
	store %..typeid 432345564227567698, %..typeid* %1715
	; Type_Info_Basic
	%1716 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1712 to %runtime.Type_Info_Boolean*
	%1717 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %1716, align 1
	%1718 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1712 to %runtime.Type_Info_Boolean*
	store %runtime.Type_Info_Boolean %1717, %runtime.Type_Info_Boolean* %1718
	%1719 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1712, i64 0, i32 2 ; UnionTagPtr
	store i8 7, i8* %1719
	%1720 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 84
	%1721 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1720, i64 0, i32 3
	%1722 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1720, i64 0, i32 0
	store i64 8, i64* %1722
	%1723 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1720, i64 0, i32 1
	store i64 8, i64* %1723
	%1724 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1720, i64 0, i32 2
	store %..typeid 216172782113783892, %..typeid* %1724
	; Type_Info_Basic
	%1725 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1721 to %runtime.Type_Info_Float*
	%1726 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %1725, align 1
	%1727 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1721 to %runtime.Type_Info_Float*
	store %runtime.Type_Info_Float %1726, %runtime.Type_Info_Float* %1727
	%1728 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1721, i64 0, i32 2 ; UnionTagPtr
	store i8 4, i8* %1728
	%1729 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 85
	%1730 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1729, i64 0, i32 3
	%1731 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1729, i64 0, i32 0
	store i64 8, i64* %1731
	%1732 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1729, i64 0, i32 1
	store i64 4, i64* %1732
	%1733 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1729, i64 0, i32 2
	store %..typeid 288230376151711829, %..typeid* %1733
	; Type_Info_Basic
	%1734 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1730 to %runtime.Type_Info_Complex*
	%1735 = load %runtime.Type_Info_Complex, %runtime.Type_Info_Complex* %1734, align 1
	%1736 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1730 to %runtime.Type_Info_Complex*
	store %runtime.Type_Info_Complex %1735, %runtime.Type_Info_Complex* %1736
	%1737 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1730, i64 0, i32 2 ; UnionTagPtr
	store i8 5, i8* %1737
	%1738 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 86
	%1739 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1738, i64 0, i32 3
	%1740 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1738, i64 0, i32 0
	store i64 16, i64* %1740
	%1741 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1738, i64 0, i32 1
	store i64 8, i64* %1741
	%1742 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1738, i64 0, i32 2
	store %..typeid 288230376151711830, %..typeid* %1742
	; Type_Info_Basic
	%1743 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1739 to %runtime.Type_Info_Complex*
	%1744 = load %runtime.Type_Info_Complex, %runtime.Type_Info_Complex* %1743, align 1
	%1745 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1739 to %runtime.Type_Info_Complex*
	store %runtime.Type_Info_Complex %1744, %runtime.Type_Info_Complex* %1745
	%1746 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1739, i64 0, i32 2 ; UnionTagPtr
	store i8 5, i8* %1746
	%1747 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 87
	%1748 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1747, i64 0, i32 3
	%1749 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1747, i64 0, i32 0
	store i64 8, i64* %1749
	%1750 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1747, i64 0, i32 1
	store i64 8, i64* %1750
	%1751 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1747, i64 0, i32 2
	store %..typeid 4971973988617027671, %..typeid* %1751
	; Type_Info_Basic
	%1752 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1748 to %runtime.Type_Info_String*
	%1753 = getelementptr inbounds %runtime.Type_Info_String, %runtime.Type_Info_String* %1752, i64 0, i32 0
	store i8 1, i8* %1753
	%1754 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %1752, align 1
	%1755 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1748 to %runtime.Type_Info_String*
	store %runtime.Type_Info_String %1754, %runtime.Type_Info_String* %1755
	%1756 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1748, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %1756
	%1757 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 94
	%1758 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1757, i64 0, i32 3
	%1759 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1757, i64 0, i32 0
	store i64 40, i64* %1759
	%1760 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1757, i64 0, i32 1
	store i64 8, i64* %1760
	%1761 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1757, i64 0, i32 2
	store %..typeid 1152921504606847070, %..typeid* %1761
	; Type_Info_Union
	%1762 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1758 to %runtime.Type_Info_Union*
	%1763 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1762, i64 0, i32 0
	%1764 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1762, i64 0, i32 1
	%1765 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1762, i64 0, i32 2
	%1766 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1762, i64 0, i32 3
	%1767 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 77
	%1768 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 95
	%1769 = bitcast %runtime.Type_Info* %1768 to %runtime.Type_Info*
	%1770 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1767, i64 0
	%1771 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 95
	store %runtime.Type_Info* %1771, %runtime.Type_Info** %1770
	%1772 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 97
	%1773 = bitcast %runtime.Type_Info* %1772 to %runtime.Type_Info*
	%1774 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1767, i64 1
	%1775 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 97
	store %runtime.Type_Info* %1775, %runtime.Type_Info** %1774
	%1776 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 99
	%1777 = bitcast %runtime.Type_Info* %1776 to %runtime.Type_Info*
	%1778 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1767, i64 2
	%1779 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 99
	store %runtime.Type_Info* %1779, %runtime.Type_Info** %1778
	%1780 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 100
	%1781 = bitcast %runtime.Type_Info* %1780 to %runtime.Type_Info*
	%1782 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1767, i64 3
	%1783 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 100
	store %runtime.Type_Info* %1783, %runtime.Type_Info** %1782
	%1784 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1763, i64 0, i32 0
	store %runtime.Type_Info** %1767, %runtime.Type_Info*** %1784
	%1785 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1763, i64 0, i32 1
	store i64 4, i64* %1785
	store i64 32, i64* %1764
	%1786 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 3
	store %runtime.Type_Info* %1786, %runtime.Type_Info** %1765
	store i8 0, i8* %1766
	%1787 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1762, align 8
	%1788 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1758 to %runtime.Type_Info_Union*
	store %runtime.Type_Info_Union %1787, %runtime.Type_Info_Union* %1788
	%1789 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1758, i64 0, i32 2 ; UnionTagPtr
	store i8 17, i8* %1789
	%1790 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 95
	%1791 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1790, i64 0, i32 3
	%1792 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1790, i64 0, i32 0
	store i64 16, i64* %1792
	%1793 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1790, i64 0, i32 1
	store i64 8, i64* %1793
	%1794 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1790, i64 0, i32 2
	store %..typeid 3386706919782613087, %..typeid* %1794
	; Type_Info_Named
	%1795 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1791 to %runtime.Type_Info_Named*
	%1796 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 96
	%1797 = bitcast %runtime.Type_Info* %1796 to %runtime.Type_Info*
	%1798 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1795, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$2d4, i64 0, i32 0), i64 16}, %..string* %1798
	%1799 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1795, i64 0, i32 1
	store %runtime.Type_Info* %1797, %runtime.Type_Info** %1799
	%1800 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1795, align 8
	%1801 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1791 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1800, %runtime.Type_Info_Named* %1801
	%1802 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1791, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1802
	%1803 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 96
	%1804 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1803, i64 0, i32 3
	%1805 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1803, i64 0, i32 0
	store i64 16, i64* %1805
	%1806 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1803, i64 0, i32 1
	store i64 8, i64* %1806
	%1807 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1803, i64 0, i32 2
	store %..typeid 1080863910568919136, %..typeid* %1807
	; Type_Info_Struct
	%1808 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1804 to %runtime.Type_Info_Struct*
	%1809 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1808, i64 0, i32 4
	store i8 0, i8* %1809
	%1810 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1808, i64 0, i32 5
	store i8 0, i8* %1810
	%1811 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1808, i64 0, i32 6
	store i8 0, i8* %1811
	%1812 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 81
	%1813 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 44
	%1814 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 44
	%1815 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 44
	%1816 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%1817 = bitcast %runtime.Type_Info* %1816 to %runtime.Type_Info*
	%1818 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1812, i64 0
	%1819 = getelementptr inbounds i64, i64* %1814, i64 0
	%1820 = getelementptr inbounds i8, i8* %1815, i64 0
	%1821 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	store %runtime.Type_Info* %1821, %runtime.Type_Info** %1818
	%1822 = getelementptr inbounds %..string, %..string* %1813, i64 0
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$2d5, i64 0, i32 0), i64 5}, %..string* %1822
	store i64 0, i64* %1819
	store i8 0, i8* %1820
	%1823 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1808, i64 0, i32 0
	%1824 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1823, i64 0, i32 0
	store %runtime.Type_Info** %1812, %runtime.Type_Info*** %1824
	%1825 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1823, i64 0, i32 1
	store i64 1, i64* %1825
	%1826 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1808, i64 0, i32 1
	%1827 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1826, i64 0, i32 0
	store %..string* %1813, %..string** %1827
	%1828 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1826, i64 0, i32 1
	store i64 1, i64* %1828
	%1829 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1808, i64 0, i32 2
	%1830 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1829, i64 0, i32 0
	store i64* %1814, i64** %1830
	%1831 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1829, i64 0, i32 1
	store i64 1, i64* %1831
	%1832 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1808, i64 0, i32 3
	%1833 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1832, i64 0, i32 0
	store i8* %1815, i8** %1833
	%1834 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1832, i64 0, i32 1
	store i64 1, i64* %1834
	%1835 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1808, align 8
	%1836 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1804 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1835, %runtime.Type_Info_Struct* %1836
	%1837 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1804, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1837
	%1838 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 97
	%1839 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1838, i64 0, i32 3
	%1840 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1838, i64 0, i32 0
	store i64 32, i64* %1840
	%1841 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1838, i64 0, i32 1
	store i64 8, i64* %1841
	%1842 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1838, i64 0, i32 2
	store %..typeid 3386706919782613089, %..typeid* %1842
	; Type_Info_Named
	%1843 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1839 to %runtime.Type_Info_Named*
	%1844 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 98
	%1845 = bitcast %runtime.Type_Info* %1844 to %runtime.Type_Info*
	%1846 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1843, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$2d6, i64 0, i32 0), i64 12}, %..string* %1846
	%1847 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1843, i64 0, i32 1
	store %runtime.Type_Info* %1845, %runtime.Type_Info** %1847
	%1848 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1843, align 8
	%1849 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1839 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1848, %runtime.Type_Info_Named* %1849
	%1850 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1839, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1850
	%1851 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 98
	%1852 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1851, i64 0, i32 3
	%1853 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1851, i64 0, i32 0
	store i64 32, i64* %1853
	%1854 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1851, i64 0, i32 1
	store i64 8, i64* %1854
	%1855 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1851, i64 0, i32 2
	store %..typeid 1080863910568919138, %..typeid* %1855
	; Type_Info_Struct
	%1856 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1852 to %runtime.Type_Info_Struct*
	%1857 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1856, i64 0, i32 4
	store i8 0, i8* %1857
	%1858 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1856, i64 0, i32 5
	store i8 0, i8* %1858
	%1859 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1856, i64 0, i32 6
	store i8 0, i8* %1859
	%1860 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 82
	%1861 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 45
	%1862 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 45
	%1863 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 45
	%1864 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 61
	%1865 = bitcast %runtime.Type_Info* %1864 to %runtime.Type_Info*
	%1866 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1860, i64 0
	%1867 = getelementptr inbounds i64, i64* %1862, i64 0
	%1868 = getelementptr inbounds i8, i8* %1863, i64 0
	%1869 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 61
	store %runtime.Type_Info* %1869, %runtime.Type_Info** %1866
	%1870 = getelementptr inbounds %..string, %..string* %1861, i64 0
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$2d7, i64 0, i32 0), i64 9}, %..string* %1870
	store i64 0, i64* %1867
	store i8 0, i8* %1868
	%1871 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 64
	%1872 = bitcast %runtime.Type_Info* %1871 to %runtime.Type_Info*
	%1873 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1860, i64 1
	%1874 = getelementptr inbounds i64, i64* %1862, i64 1
	%1875 = getelementptr inbounds i8, i8* %1863, i64 1
	%1876 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 64
	store %runtime.Type_Info* %1876, %runtime.Type_Info** %1873
	%1877 = getelementptr inbounds %..string, %..string* %1861, i64 1
	store %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$2d8, i64 0, i32 0), i64 18}, %..string* %1877
	store i64 8, i64* %1874
	store i8 0, i8* %1875
	%1878 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 84
	%1879 = bitcast %runtime.Type_Info* %1878 to %runtime.Type_Info*
	%1880 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1860, i64 2
	%1881 = getelementptr inbounds i64, i64* %1862, i64 2
	%1882 = getelementptr inbounds i8, i8* %1863, i64 2
	%1883 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 84
	store %runtime.Type_Info* %1883, %runtime.Type_Info** %1880
	%1884 = getelementptr inbounds %..string, %..string* %1861, i64 2
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$2d9, i64 0, i32 0), i64 11}, %..string* %1884
	store i64 16, i64* %1881
	store i8 0, i8* %1882
	%1885 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	%1886 = bitcast %runtime.Type_Info* %1885 to %runtime.Type_Info*
	%1887 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1860, i64 3
	%1888 = getelementptr inbounds i64, i64* %1862, i64 3
	%1889 = getelementptr inbounds i8, i8* %1863, i64 3
	%1890 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 16
	store %runtime.Type_Info* %1890, %runtime.Type_Info** %1887
	%1891 = getelementptr inbounds %..string, %..string* %1861, i64 3
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$2da, i64 0, i32 0), i64 9}, %..string* %1891
	store i64 24, i64* %1888
	store i8 0, i8* %1889
	%1892 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1856, i64 0, i32 0
	%1893 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1892, i64 0, i32 0
	store %runtime.Type_Info** %1860, %runtime.Type_Info*** %1893
	%1894 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1892, i64 0, i32 1
	store i64 4, i64* %1894
	%1895 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1856, i64 0, i32 1
	%1896 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1895, i64 0, i32 0
	store %..string* %1861, %..string** %1896
	%1897 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1895, i64 0, i32 1
	store i64 4, i64* %1897
	%1898 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1856, i64 0, i32 2
	%1899 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1898, i64 0, i32 0
	store i64* %1862, i64** %1899
	%1900 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1898, i64 0, i32 1
	store i64 4, i64* %1900
	%1901 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1856, i64 0, i32 3
	%1902 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1901, i64 0, i32 0
	store i8* %1863, i8** %1902
	%1903 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1901, i64 0, i32 1
	store i64 4, i64* %1903
	%1904 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1856, align 8
	%1905 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1852 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1904, %runtime.Type_Info_Struct* %1905
	%1906 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1852, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1906
	%1907 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 99
	%1908 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1907, i64 0, i32 3
	%1909 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1907, i64 0, i32 0
	store i64 16, i64* %1909
	%1910 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1907, i64 0, i32 1
	store i64 8, i64* %1910
	%1911 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1907, i64 0, i32 2
	store %..typeid 3386706919782613091, %..typeid* %1911
	; Type_Info_Named
	%1912 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1908 to %runtime.Type_Info_Named*
	%1913 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 96
	%1914 = bitcast %runtime.Type_Info* %1913 to %runtime.Type_Info*
	%1915 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1912, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$2db, i64 0, i32 0), i64 12}, %..string* %1915
	%1916 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1912, i64 0, i32 1
	store %runtime.Type_Info* %1914, %runtime.Type_Info** %1916
	%1917 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1912, align 8
	%1918 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1908 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1917, %runtime.Type_Info_Named* %1918
	%1919 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1908, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1919
	%1920 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 100
	%1921 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1920, i64 0, i32 3
	%1922 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1920, i64 0, i32 0
	store i64 4, i64* %1922
	%1923 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1920, i64 0, i32 1
	store i64 4, i64* %1923
	%1924 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1920, i64 0, i32 2
	store %..typeid 3386706919782613092, %..typeid* %1924
	; Type_Info_Named
	%1925 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1921 to %runtime.Type_Info_Named*
	%1926 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 101
	%1927 = bitcast %runtime.Type_Info* %1926 to %runtime.Type_Info*
	%1928 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1925, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$2dc, i64 0, i32 0), i64 12}, %..string* %1928
	%1929 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1925, i64 0, i32 1
	store %runtime.Type_Info* %1927, %runtime.Type_Info** %1929
	%1930 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1925, align 8
	%1931 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1921 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1930, %runtime.Type_Info_Named* %1931
	%1932 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1921, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %1932
	%1933 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 101
	%1934 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1933, i64 0, i32 3
	%1935 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1933, i64 0, i32 0
	store i64 4, i64* %1935
	%1936 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1933, i64 0, i32 1
	store i64 4, i64* %1936
	%1937 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1933, i64 0, i32 2
	store %..typeid 1080863910568919141, %..typeid* %1937
	; Type_Info_Struct
	%1938 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1934 to %runtime.Type_Info_Struct*
	%1939 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1938, i64 0, i32 4
	store i8 0, i8* %1939
	%1940 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1938, i64 0, i32 5
	store i8 0, i8* %1940
	%1941 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1938, i64 0, i32 6
	store i8 0, i8* %1941
	%1942 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 86
	%1943 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 49
	%1944 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 49
	%1945 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 49
	%1946 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 57
	%1947 = bitcast %runtime.Type_Info* %1946 to %runtime.Type_Info*
	%1948 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1942, i64 0
	%1949 = getelementptr inbounds i64, i64* %1944, i64 0
	%1950 = getelementptr inbounds i8, i8* %1945, i64 0
	%1951 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 57
	store %runtime.Type_Info* %1951, %runtime.Type_Info** %1948
	%1952 = getelementptr inbounds %..string, %..string* %1943, i64 0
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$2dd, i64 0, i32 0), i64 5}, %..string* %1952
	store i64 0, i64* %1949
	store i8 0, i8* %1950
	%1953 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1938, i64 0, i32 0
	%1954 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1953, i64 0, i32 0
	store %runtime.Type_Info** %1942, %runtime.Type_Info*** %1954
	%1955 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1953, i64 0, i32 1
	store i64 1, i64* %1955
	%1956 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1938, i64 0, i32 1
	%1957 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1956, i64 0, i32 0
	store %..string* %1943, %..string** %1957
	%1958 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1956, i64 0, i32 1
	store i64 1, i64* %1958
	%1959 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1938, i64 0, i32 2
	%1960 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1959, i64 0, i32 0
	store i64* %1944, i64** %1960
	%1961 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1959, i64 0, i32 1
	store i64 1, i64* %1961
	%1962 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1938, i64 0, i32 3
	%1963 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1962, i64 0, i32 0
	store i8* %1945, i8** %1963
	%1964 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1962, i64 0, i32 1
	store i64 1, i64* %1964
	%1965 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1938, align 8
	%1966 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1934 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1965, %runtime.Type_Info_Struct* %1966
	%1967 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1934, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %1967
	%1968 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 102
	%1969 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1968, i64 0, i32 3
	%1970 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1968, i64 0, i32 0
	store i64 8, i64* %1970
	%1971 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1968, i64 0, i32 1
	store i64 8, i64* %1971
	%1972 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1968, i64 0, i32 2
	store %..typeid 648518346341351526, %..typeid* %1972
	; Type_Info_Pointer
	%1973 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1969 to %runtime.Type_Info_Pointer*
	%1974 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 8
	%1975 = bitcast %runtime.Type_Info* %1974 to %runtime.Type_Info*
	%1976 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1973, i64 0, i32 0
	store %runtime.Type_Info* %1975, %runtime.Type_Info** %1976
	%1977 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1973, align 8
	%1978 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1969 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1977, %runtime.Type_Info_Pointer* %1978
	%1979 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1969, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %1979
	%1980 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 103
	%1981 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1980, i64 0, i32 3
	%1982 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1980, i64 0, i32 0
	store i64 8, i64* %1982
	%1983 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1980, i64 0, i32 1
	store i64 8, i64* %1983
	%1984 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1980, i64 0, i32 2
	store %..typeid 648518346341351527, %..typeid* %1984
	; Type_Info_Pointer
	%1985 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1981 to %runtime.Type_Info_Pointer*
	%1986 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 12
	%1987 = bitcast %runtime.Type_Info* %1986 to %runtime.Type_Info*
	%1988 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1985, i64 0, i32 0
	store %runtime.Type_Info* %1987, %runtime.Type_Info** %1988
	%1989 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1985, align 8
	%1990 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1981 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1989, %runtime.Type_Info_Pointer* %1990
	%1991 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1981, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %1991
	%1992 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 104
	%1993 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1992, i64 0, i32 3
	%1994 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1992, i64 0, i32 0
	store i64 8, i64* %1994
	%1995 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1992, i64 0, i32 1
	store i64 8, i64* %1995
	%1996 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1992, i64 0, i32 2
	store %..typeid 648518346341351528, %..typeid* %1996
	; Type_Info_Pointer
	%1997 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1993 to %runtime.Type_Info_Pointer*
	%1998 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 43
	%1999 = bitcast %runtime.Type_Info* %1998 to %runtime.Type_Info*
	%2000 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1997, i64 0, i32 0
	store %runtime.Type_Info* %1999, %runtime.Type_Info** %2000
	%2001 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1997, align 8
	%2002 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %1993 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %2001, %runtime.Type_Info_Pointer* %2002
	%2003 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %1993, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %2003
	%2004 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 75
	%2005 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2004, i64 0, i32 3
	%2006 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2004, i64 0, i32 0
	store i64 8, i64* %2006
	%2007 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2004, i64 0, i32 1
	store i64 8, i64* %2007
	%2008 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2004, i64 0, i32 2
	store %..typeid 3530822107858468939, %..typeid* %2008
	; Type_Info_Named
	%2009 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2005 to %runtime.Type_Info_Named*
	%2010 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 76
	%2011 = bitcast %runtime.Type_Info* %2010 to %runtime.Type_Info*
	%2012 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2009, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$2de, i64 0, i32 0), i64 8}, %..string* %2012
	%2013 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2009, i64 0, i32 1
	store %runtime.Type_Info* %2011, %runtime.Type_Info** %2013
	%2014 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2009, align 8
	%2015 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2005 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %2014, %runtime.Type_Info_Named* %2015
	%2016 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2005, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %2016
	%2017 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 76
	%2018 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2017, i64 0, i32 3
	%2019 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2017, i64 0, i32 0
	store i64 8, i64* %2019
	%2020 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2017, i64 0, i32 1
	store i64 8, i64* %2020
	%2021 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2017, i64 0, i32 2
	store %..typeid 1224979098644774988, %..typeid* %2021
	; Type_Info_Enum
	%2022 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2018 to %runtime.Type_Info_Enum*
	%2023 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 6
	%2024 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2022, i64 0, i32 0
	store %runtime.Type_Info* %2023, %runtime.Type_Info** %2024
	%2025 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-4c, i64 0, i32 0
	%2026 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-4c, i64 0, i32 0
	%2027 = bitcast %runtime.Type_Info_Enum_Value* %2026 to i64*
	store i64 0, i64* %2027
	%2028 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2026, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %2028
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$2df, i64 0, i32 0), i64 6}, %..string* %2025
	%2029 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-4c, i64 0, i32 1
	%2030 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-4c, i64 0, i32 1
	%2031 = bitcast %runtime.Type_Info_Enum_Value* %2030 to i64*
	store i64 1, i64* %2031
	%2032 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2030, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %2032
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$2e0, i64 0, i32 0), i64 4}, %..string* %2029
	%2033 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-4c, i64 0, i32 2
	%2034 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-4c, i64 0, i32 2
	%2035 = bitcast %runtime.Type_Info_Enum_Value* %2034 to i64*
	store i64 2, i64* %2035
	%2036 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %2034, i64 0, i32 2 ; UnionTagPtr
	store i8 6, i8* %2036
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$2e1, i64 0, i32 0), i64 5}, %..string* %2033
	%2037 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2022, i64 0, i32 1
	%2038 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-4c, i64 0, i32 0
	%2039 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2037, i64 0, i32 0
	store %..string* %2038, %..string** %2039
	%2040 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2037, i64 0, i32 1
	store i64 3, i64* %2040
	%2041 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2022, i64 0, i32 2
	%2042 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-4c, i64 0, i32 0
	%2043 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %2041, i64 0, i32 0
	store %runtime.Type_Info_Enum_Value* %2042, %runtime.Type_Info_Enum_Value** %2043
	%2044 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %2041, i64 0, i32 1
	store i64 3, i64* %2044
	%2045 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %2022, align 8
	%2046 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2018 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %2045, %runtime.Type_Info_Enum* %2046
	%2047 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2018, i64 0, i32 2 ; UnionTagPtr
	store i8 18, i8* %2047
	%2048 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 90
	%2049 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2048, i64 0, i32 3
	%2050 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2048, i64 0, i32 0
	store i64 16, i64* %2050
	%2051 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2048, i64 0, i32 1
	store i64 8, i64* %2051
	%2052 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2048, i64 0, i32 2
	store %..typeid 936748722493063258, %..typeid* %2052
	; Type_Info_Slice
	%2053 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2049 to %runtime.Type_Info_Slice*
	%2054 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 91
	%2055 = bitcast %runtime.Type_Info* %2054 to %runtime.Type_Info*
	%2056 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %2053, i64 0, i32 0
	store %runtime.Type_Info* %2055, %runtime.Type_Info** %2056
	%2057 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %2053, i64 0, i32 1
	store i64 96, i64* %2057
	%2058 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %2053, align 8
	%2059 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2049 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %2058, %runtime.Type_Info_Slice* %2059
	%2060 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2049, i64 0, i32 2 ; UnionTagPtr
	store i8 14, i8* %2060
	%2061 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 91
	%2062 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2061, i64 0, i32 3
	%2063 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2061, i64 0, i32 0
	store i64 96, i64* %2063
	%2064 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2061, i64 0, i32 1
	store i64 8, i64* %2064
	%2065 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2061, i64 0, i32 2
	store %..typeid 3386706919782613083, %..typeid* %2065
	; Type_Info_Named
	%2066 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2062 to %runtime.Type_Info_Named*
	%2067 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 92
	%2068 = bitcast %runtime.Type_Info* %2067 to %runtime.Type_Info*
	%2069 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2066, i64 0, i32 0
	store %..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$2e2, i64 0, i32 0), i64 20}, %..string* %2069
	%2070 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2066, i64 0, i32 1
	store %runtime.Type_Info* %2068, %runtime.Type_Info** %2070
	%2071 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2066, align 8
	%2072 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2062 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %2071, %runtime.Type_Info_Named* %2072
	%2073 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2062, i64 0, i32 2 ; UnionTagPtr
	store i8 1, i8* %2073
	%2074 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 92
	%2075 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2074, i64 0, i32 3
	%2076 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2074, i64 0, i32 0
	store i64 96, i64* %2076
	%2077 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2074, i64 0, i32 1
	store i64 8, i64* %2077
	%2078 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2074, i64 0, i32 2
	store %..typeid 1080863910568919132, %..typeid* %2078
	; Type_Info_Struct
	%2079 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2075 to %runtime.Type_Info_Struct*
	%2080 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2079, i64 0, i32 4
	store i8 0, i8* %2080
	%2081 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2079, i64 0, i32 5
	store i8 0, i8* %2081
	%2082 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2079, i64 0, i32 6
	store i8 0, i8* %2082
	%2083 = getelementptr inbounds [93 x %runtime.Type_Info*], [93 x %runtime.Type_Info*]* @__$type_info_types_data, i64 0, i32 87
	%2084 = getelementptr inbounds [93 x %..string], [93 x %..string]* @__$type_info_names_data, i64 0, i32 50
	%2085 = getelementptr inbounds [93 x i64], [93 x i64]* @__$type_info_offsets_data, i64 0, i32 50
	%2086 = getelementptr inbounds [93 x i8], [93 x i8]* @__$type_info_usings_data, i64 0, i32 50
	%2087 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%2088 = bitcast %runtime.Type_Info* %2087 to %runtime.Type_Info*
	%2089 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %2083, i64 0
	%2090 = getelementptr inbounds i64, i64* %2085, i64 0
	%2091 = getelementptr inbounds i8, i8* %2086, i64 0
	%2092 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	store %runtime.Type_Info* %2092, %runtime.Type_Info** %2089
	%2093 = getelementptr inbounds %..string, %..string* %2084, i64 0
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$2e3, i64 0, i32 0), i64 9}, %..string* %2093
	store i64 0, i64* %2090
	store i8 0, i8* %2091
	%2094 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%2095 = bitcast %runtime.Type_Info* %2094 to %runtime.Type_Info*
	%2096 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %2083, i64 1
	%2097 = getelementptr inbounds i64, i64* %2085, i64 1
	%2098 = getelementptr inbounds i8, i8* %2086, i64 1
	%2099 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	store %runtime.Type_Info* %2099, %runtime.Type_Info** %2096
	%2100 = getelementptr inbounds %..string, %..string* %2084, i64 1
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$2e4, i64 0, i32 0), i64 16}, %..string* %2100
	store i64 16, i64* %2097
	store i8 0, i8* %2098
	%2101 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%2102 = bitcast %runtime.Type_Info* %2101 to %runtime.Type_Info*
	%2103 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %2083, i64 2
	%2104 = getelementptr inbounds i64, i64* %2085, i64 2
	%2105 = getelementptr inbounds i8, i8* %2086, i64 2
	%2106 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	store %runtime.Type_Info* %2106, %runtime.Type_Info** %2103
	%2107 = getelementptr inbounds %..string, %..string* %2084, i64 2
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$2e5, i64 0, i32 0), i64 9}, %..string* %2107
	store i64 32, i64* %2104
	store i8 0, i8* %2105
	%2108 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%2109 = bitcast %runtime.Type_Info* %2108 to %runtime.Type_Info*
	%2110 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %2083, i64 3
	%2111 = getelementptr inbounds i64, i64* %2085, i64 3
	%2112 = getelementptr inbounds i8, i8* %2086, i64 3
	%2113 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	store %runtime.Type_Info* %2113, %runtime.Type_Info** %2110
	%2114 = getelementptr inbounds %..string, %..string* %2084, i64 3
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$2e6, i64 0, i32 0), i64 11}, %..string* %2114
	store i64 48, i64* %2111
	store i8 0, i8* %2112
	%2115 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%2116 = bitcast %runtime.Type_Info* %2115 to %runtime.Type_Info*
	%2117 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %2083, i64 4
	%2118 = getelementptr inbounds i64, i64* %2085, i64 4
	%2119 = getelementptr inbounds i8, i8* %2086, i64 4
	%2120 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	store %runtime.Type_Info* %2120, %runtime.Type_Info** %2117
	%2121 = getelementptr inbounds %..string, %..string* %2084, i64 4
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$2e7, i64 0, i32 0), i64 11}, %..string* %2121
	store i64 64, i64* %2118
	store i8 0, i8* %2119
	%2122 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	%2123 = bitcast %runtime.Type_Info* %2122 to %runtime.Type_Info*
	%2124 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %2083, i64 5
	%2125 = getelementptr inbounds i64, i64* %2085, i64 5
	%2126 = getelementptr inbounds i8, i8* %2086, i64 5
	%2127 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 4
	store %runtime.Type_Info* %2127, %runtime.Type_Info** %2124
	%2128 = getelementptr inbounds %..string, %..string* %2084, i64 5
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$2e8, i64 0, i32 0), i64 12}, %..string* %2128
	store i64 80, i64* %2125
	store i8 0, i8* %2126
	%2129 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2079, i64 0, i32 0
	%2130 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %2129, i64 0, i32 0
	store %runtime.Type_Info** %2083, %runtime.Type_Info*** %2130
	%2131 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %2129, i64 0, i32 1
	store i64 6, i64* %2131
	%2132 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2079, i64 0, i32 1
	%2133 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2132, i64 0, i32 0
	store %..string* %2084, %..string** %2133
	%2134 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2132, i64 0, i32 1
	store i64 6, i64* %2134
	%2135 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2079, i64 0, i32 2
	%2136 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %2135, i64 0, i32 0
	store i64* %2085, i64** %2136
	%2137 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %2135, i64 0, i32 1
	store i64 6, i64* %2137
	%2138 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2079, i64 0, i32 3
	%2139 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2138, i64 0, i32 0
	store i8* %2086, i8** %2139
	%2140 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2138, i64 0, i32 1
	store i64 6, i64* %2140
	%2141 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %2079, align 8
	%2142 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2075 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %2141, %runtime.Type_Info_Struct* %2142
	%2143 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2075, i64 0, i32 2 ; UnionTagPtr
	store i8 16, i8* %2143
	%2144 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 93
	%2145 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2144, i64 0, i32 3
	%2146 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2144, i64 0, i32 0
	store i64 8, i64* %2146
	%2147 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2144, i64 0, i32 1
	store i64 8, i64* %2147
	%2148 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2144, i64 0, i32 2
	store %..typeid 648518346341351517, %..typeid* %2148
	; Type_Info_Pointer
	%2149 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2145 to %runtime.Type_Info_Pointer*
	%2150 = getelementptr inbounds [105 x %runtime.Type_Info], [105 x %runtime.Type_Info]* @__$type_info_data, i64 0, i32 91
	%2151 = bitcast %runtime.Type_Info* %2150 to %runtime.Type_Info*
	%2152 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %2149, i64 0, i32 0
	store %runtime.Type_Info* %2151, %runtime.Type_Info** %2152
	%2153 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %2149, align 8
	%2154 = bitcast {[0 x <8 x i8>], [72 x i8], i8}* %2145 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %2153, %runtime.Type_Info_Pointer* %2154
	%2155 = getelementptr inbounds {[0 x <8 x i8>], [72 x i8], i8}, {[0 x <8 x i8>], [72 x i8], i8}* %2145, i64 0, i32 2 ; UnionTagPtr
	store i8 10, i8* %2155
	store i32 1, i32* @os.stdout
	store i32 2, i32* @os.stderr
	store [5 x %utf8.Accept_Range] [%utf8.Accept_Range {i8 128, i8 191}, %utf8.Accept_Range {i8 160, i8 191}, %utf8.Accept_Range {i8 128, i8 159}, %utf8.Accept_Range {i8 144, i8 191}, %utf8.Accept_Range {i8 128, i8 143}], [5 x %utf8.Accept_Range]* @utf8.accept_ranges
	store [256 x i8] [i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 19, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 35, i8 3, i8 3, i8 52, i8 4, i8 4, i8 4, i8 68, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241], [256 x i8]* @utf8.accept_sizes
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$2e9, i64 0, i32 0), i64 17}, %..string* @fmt.__DIGITS_LOWER
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$2ea, i64 0, i32 0), i64 17}, %..string* @fmt.__DIGITS_UPPER
	store %strconv.FloatInfo {i64 23, i64 8, i64 -127}, %strconv.FloatInfo* @strconv._f32_info
	store %strconv.FloatInfo {i64 52, i64 11, i64 -1023}, %strconv.FloatInfo* @strconv._f64_info
	store %..string {i8* getelementptr inbounds ([37 x i8], [37 x i8]* @str$2eb, i64 0, i32 0), i64 36}, %..string* @strconv.digits
	store i64 0, i64* @prebuild.indent_level
	ret void
}
@__$type_info_data = private global [105 x %runtime.Type_Info] zeroinitializer
@__$type_info_types_data = global [93 x %runtime.Type_Info*] zeroinitializer
@__$type_info_names_data = global [93 x %..string] zeroinitializer
@__$type_info_offsets_data = global [93 x i64] zeroinitializer
@__$type_info_usings_data = global [93 x i8] zeroinitializer
@ggv$0 = global %runtime.Context zeroinitializer
@runtime.type_table = global {%runtime.Type_Info*, i64} zeroinitializer
@runtime.args__ = global {i8**, i64} zeroinitializer
@runtime.global_scratch_allocator_data = global %mem.Scratch_Allocator zeroinitializer
@os.stdout = global i32 1
@os.stderr = global i32 2
@utf8.accept_ranges = global [5 x %utf8.Accept_Range] [%utf8.Accept_Range {i8 128, i8 191}, %utf8.Accept_Range {i8 160, i8 191}, %utf8.Accept_Range {i8 128, i8 159}, %utf8.Accept_Range {i8 144, i8 191}, %utf8.Accept_Range {i8 128, i8 143}]
@utf8.accept_sizes = global [256 x i8] [i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 19, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 35, i8 3, i8 3, i8 52, i8 4, i8 4, i8 4, i8 68, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241]
@fmt.__DIGITS_LOWER = global %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$2ec, i64 0, i32 0), i64 17}
@fmt.__DIGITS_UPPER = global %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$2ed, i64 0, i32 0), i64 17}
@strconv._f32_info = global %strconv.FloatInfo {i64 23, i64 8, i64 -127}
@strconv._f64_info = global %strconv.FloatInfo {i64 52, i64 11, i64 -1023}
@strconv.digits = global %..string {i8* getelementptr inbounds ([37 x i8], [37 x i8]* @str$2ee, i64 0, i32 0), i64 36}
@prebuild.generated_code = global {i8*, i64, i64, %mem.Allocator} zeroinitializer
@prebuild.indent_level = global i64 0
@csba$0 = global [1 x i8] [i8 zeroinitializer]
@$enum_names-1f = private global [6 x %..string] zeroinitializer
@$enum_values-1f = private global [6 x %runtime.Type_Info_Enum_Value] zeroinitializer
@$enum_names-2 = private global [4 x %..string] zeroinitializer
@$enum_values-2 = private global [4 x %runtime.Type_Info_Enum_Value] zeroinitializer
@$enum_names-4c = private global [3 x %..string] zeroinitializer
@$enum_values-4c = private global [3 x %runtime.Type_Info_Enum_Value] zeroinitializer
@str$0 = private global [11 x i8] c"0123456789\00"
@str$1 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$2 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$3 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$4 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$5 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$6 = private global [11 x i8] c"0123456789\00"
@str$7 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$8 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$9 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$a = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$b = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$c = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$d = private global [4 x i8] c"nil\00"
@str$e = private global [4 x i8] c"int\00"
@str$f = private global [5 x i8] c"uint\00"
@str$10 = private global [8 x i8] c"uintptr\00"
@str$11 = private global [5 x i8] c"rune\00"
@str$12 = private global [8 x i8] c"complex\00"
@str$13 = private global [7 x i8] c"string\00"
@str$14 = private global [5 x i8] c"bool\00"
@str$15 = private global [4 x i8] c"any\00"
@str$16 = private global [7 x i8] c"typeid\00"
@str$17 = private global [7 x i8] c"rawptr\00"
@str$18 = private global [2 x i8] c"\5E\00"
@str$19 = private global [5 x i8] c"proc\00"
@str$1a = private global [3 x i8] c"\28\29\00"
@str$1b = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$1c = private global [2 x i8] c"\28\00"
@str$1d = private global [3 x i8] c"\2C\20\00"
@str$1e = private global [2 x i8] c"\29\00"
@str$1f = private global [5 x i8] c"\20-\3E\20\00"
@str$20 = private global [2 x i8] c"\28\00"
@str$21 = private global [3 x i8] c"\2C\20\00"
@str$22 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$23 = private global [3 x i8] c"\3A\20\00"
@str$24 = private global [2 x i8] c"\29\00"
@str$25 = private global [2 x i8] c"\5B\00"
@str$26 = private global [2 x i8] c"\5D\00"
@str$27 = private global [10 x i8] c"\5Bdynamic\5D\00"
@str$28 = private global [3 x i8] c"\5B\5D\00"
@str$29 = private global [5 x i8] c"map\5B\00"
@str$2a = private global [8 x i8] c"struct\20\00"
@str$2b = private global [9 x i8] c"\23packed\20\00"
@str$2c = private global [12 x i8] c"\23raw_union\20\00"
@str$2d = private global [8 x i8] c"\23align\20\00"
@str$2e = private global [3 x i8] c"\2C\20\00"
@str$2f = private global [3 x i8] c"\3A\20\00"
@str$30 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$31 = private global [8 x i8] c"union\20\7B\00"
@str$32 = private global [3 x i8] c"\2C\20\00"
@str$33 = private global [2 x i8] c"\7D\00"
@str$34 = private global [6 x i8] c"enum\20\00"
@str$35 = private global [3 x i8] c"\20\7B\00"
@str$36 = private global [3 x i8] c"\2C\20\00"
@str$37 = private global [2 x i8] c"\7D\00"
@str$38 = private global [11 x i8] c"bit_field\20\00"
@str$39 = private global [8 x i8] c"\23align\20\00"
@str$3a = private global [3 x i8] c"\20\7B\00"
@str$3b = private global [3 x i8] c"\2C\20\00"
@str$3c = private global [3 x i8] c"\3A\20\00"
@str$3d = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$3e = private global [2 x i8] c"\7D\00"
@str$3f = private global [9 x i8] c"bit_set\5B\00"
@str$40 = private global [3 x i8] c"..\00"
@str$41 = private global [3 x i8] c"..\00"
@str$42 = private global [3 x i8] c"\3B\20\00"
@str$43 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$44 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$45 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$46 = private global [63 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$47 = private global [8 x i8] c"\20Index\20\00"
@str$48 = private global [27 x i8] c"\20is\20out\20of\20bounds\20range\200\3A\00"
@str$49 = private global [25 x i8] c"\20Invalid\20slice\20indices\3A\20\00"
@str$4a = private global [2 x i8] c"\3A\00"
@str$4b = private global [2 x i8] c"\3A\00"
@str$4c = private global [32 x i8] c"\20Invalid\20dynamic\20array\20values\3A\20\00"
@str$4d = private global [2 x i8] c"\3A\00"
@str$4e = private global [2 x i8] c"\3A\00"
@str$4f = private global [30 x i8] c"\20Invalid\20type\20assertion\20from\20\00"
@str$50 = private global [5 x i8] c"\20to\20\00"
@str$51 = private global [33 x i8] c"\20Invalid\20slice\20length\20for\20make\3A\20\00"
@str$52 = private global [45 x i8] c"\20Invalid\20dynamic\20array\20parameters\20for\20make\3A\20\00"
@str$53 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$54 = private global [2 x i8] c"\20\00"
@str$55 = private global [3 x i8] c"\3A\20\00"
@str$56 = private global [18 x i8] c"Runtime\20assertion\00"
@str$57 = private global [6 x i8] c"Panic\00"
@str$58 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Fmem.odin\00"
@str$59 = private global [22 x i8] c"align_forward_uintptr\00"
@str$5a = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$5b = private global [23 x i8] c"scratch_allocator_proc\00"
@str$5c = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$5d = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$5e = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$5f = private global [23 x i8] c"scratch_allocator_proc\00"
@str$60 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$61 = private global [23 x i8] c"scratch_allocator_proc\00"
@str$62 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$63 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$64 = private global [23 x i8] c"scratch_allocator_proc\00"
@str$65 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fmem\2Falloc.odin\00"
@str$66 = private global [52 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos.odin\00"
@str$67 = private global [3 x i8] c"\5Ca\00"
@str$68 = private global [3 x i8] c"\5Cb\00"
@str$69 = private global [3 x i8] c"\5Ce\00"
@str$6a = private global [3 x i8] c"\5Cf\00"
@str$6b = private global [3 x i8] c"\5Cn\00"
@str$6c = private global [3 x i8] c"\5Cr\00"
@str$6d = private global [3 x i8] c"\5Ct\00"
@str$6e = private global [3 x i8] c"\5Cv\00"
@str$6f = private global [3 x i8] c"\5Cx\00"
@str$70 = private global [52 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos.odin\00"
@str$71 = private global [3 x i8] c"00\00"
@str$72 = private global [52 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos.odin\00"
@str$73 = private global [17 x i8] c"read_entire_file\00"
@str$74 = private global [52 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos.odin\00"
@str$75 = private global [17 x i8] c"read_entire_file\00"
@str$76 = private global [52 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos.odin\00"
@str$77 = private global [52 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos.odin\00"
@str$78 = private global [20 x i8] c"heap_allocator_proc\00"
@str$79 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$7a = private global [12 x i8] c"open_simple\00"
@str$7b = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$7c = private global [12 x i8] c"open_simple\00"
@str$7d = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$7e = private global [6 x i8] c"write\00"
@str$7f = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$80 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$81 = private global [5 x i8] c"read\00"
@str$82 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$83 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$84 = private global [5 x i8] c"seek\00"
@str$85 = private global [56 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fos\2Fos_osx.odin\00"
@str$86 = private global [11 x i8] c"heap_alloc\00"
@str$87 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$88 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$89 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$8a = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$8b = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$8c = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$8d = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$8e = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$8f = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$90 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$91 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$92 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$93 = private global [64 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$94 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$95 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$96 = private global [13 x i8] c"write_string\00"
@str$97 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$98 = private global [12 x i8] c"write_bytes\00"
@str$99 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$9a = private global [11 x i8] c"write_byte\00"
@str$9b = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$9c = private global [3 x i8] c"\5Ca\00"
@str$9d = private global [3 x i8] c"\5Cb\00"
@str$9e = private global [3 x i8] c"\5Ce\00"
@str$9f = private global [3 x i8] c"\5Cf\00"
@str$a0 = private global [3 x i8] c"\5Cn\00"
@str$a1 = private global [3 x i8] c"\5Cr\00"
@str$a2 = private global [3 x i8] c"\5Ct\00"
@str$a3 = private global [3 x i8] c"\5Cv\00"
@str$a4 = private global [3 x i8] c"\5Cx\00"
@str$a5 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$a6 = private global [3 x i8] c"00\00"
@str$a7 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$a8 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$a9 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$aa = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$ab = private global [7 x i8] c"tprint\00"
@str$ac = private global [4 x i8] c"nil\00"
@str$ad = private global [4 x i8] c"int\00"
@str$ae = private global [5 x i8] c"uint\00"
@str$af = private global [8 x i8] c"uintptr\00"
@str$b0 = private global [5 x i8] c"rune\00"
@str$b1 = private global [8 x i8] c"complex\00"
@str$b2 = private global [8 x i8] c"cstring\00"
@str$b3 = private global [7 x i8] c"string\00"
@str$b4 = private global [5 x i8] c"bool\00"
@str$b5 = private global [4 x i8] c"any\00"
@str$b6 = private global [7 x i8] c"typeid\00"
@str$b7 = private global [7 x i8] c"rawptr\00"
@str$b8 = private global [2 x i8] c"\5E\00"
@str$b9 = private global [5 x i8] c"proc\00"
@str$ba = private global [3 x i8] c"\28\29\00"
@str$bb = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$bc = private global [2 x i8] c"\28\00"
@str$bd = private global [3 x i8] c"\2C\20\00"
@str$be = private global [2 x i8] c"\29\00"
@str$bf = private global [5 x i8] c"\20-\3E\20\00"
@str$c0 = private global [2 x i8] c"\28\00"
@str$c1 = private global [3 x i8] c"\2C\20\00"
@str$c2 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$c3 = private global [3 x i8] c"\3A\20\00"
@str$c4 = private global [2 x i8] c"\29\00"
@str$c5 = private global [2 x i8] c"\5B\00"
@str$c6 = private global [2 x i8] c"\5D\00"
@str$c7 = private global [10 x i8] c"\5Bdynamic\5D\00"
@str$c8 = private global [3 x i8] c"\5B\5D\00"
@str$c9 = private global [5 x i8] c"map\5B\00"
@str$ca = private global [8 x i8] c"struct\20\00"
@str$cb = private global [9 x i8] c"\23packed\20\00"
@str$cc = private global [12 x i8] c"\23raw_union\20\00"
@str$cd = private global [8 x i8] c"\23align\20\00"
@str$ce = private global [3 x i8] c"\2C\20\00"
@str$cf = private global [3 x i8] c"\3A\20\00"
@str$d0 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$d1 = private global [7 x i8] c"union\20\00"
@str$d2 = private global [8 x i8] c"\23align\20\00"
@str$d3 = private global [3 x i8] c"\2C\20\00"
@str$d4 = private global [2 x i8] c"\7D\00"
@str$d5 = private global [6 x i8] c"enum\20\00"
@str$d6 = private global [3 x i8] c"\20\7B\00"
@str$d7 = private global [3 x i8] c"\2C\20\00"
@str$d8 = private global [2 x i8] c"\7D\00"
@str$d9 = private global [11 x i8] c"bit_field\20\00"
@str$da = private global [8 x i8] c"\23align\20\00"
@str$db = private global [3 x i8] c"\20\7B\00"
@str$dc = private global [3 x i8] c"\2C\20\00"
@str$dd = private global [3 x i8] c"\3A\20\00"
@str$de = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$df = private global [2 x i8] c"\7D\00"
@str$e0 = private global [9 x i8] c"bit_set\5B\00"
@str$e1 = private global [3 x i8] c"..\00"
@str$e2 = private global [3 x i8] c"..\00"
@str$e3 = private global [3 x i8] c"\3B\20\00"
@str$e4 = private global [3 x i8] c"\25\21\00"
@str$e5 = private global [6 x i8] c"\3Cnil\3E\00"
@str$e6 = private global [5 x i8] c"true\00"
@str$e7 = private global [6 x i8] c"false\00"
@str$e8 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$e9 = private global [9 x i8] c"_fmt_int\00"
@str$ea = private global [54 x i8] c"_fmt_int\3A\20buffer\20overrun.\20Width\20and\20precision\20too\20big\00"
@str$eb = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$ec = private global [9 x i8] c"_fmt_int\00"
@str$ed = private global [31 x i8] c"_fmt_int\3A\20unknown\20base\2C\20whoops\00"
@str$ee = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$ef = private global [3 x i8] c"U\2B\00"
@str$f0 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$f1 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$f2 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$f3 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$f4 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$f5 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$f6 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$f7 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$f8 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$f9 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$fa = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$fb = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$fc = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$fd = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$fe = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$ff = private global [3 x i8] c"0x\00"
@str$100 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$101 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$102 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$103 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$104 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$105 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$106 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$107 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$108 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$109 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$10a = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$10b = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$10c = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$10d = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$10e = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$10f = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$110 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$111 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$112 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$113 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$114 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$115 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$116 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$117 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$118 = private global [6 x i8] c"\3Cnil\3E\00"
@str$119 = private global [19 x i8] c"\21\25\28BAD\20ENUM\20VALUE\29\00"
@str$11a = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$11b = private global [12 x i8] c"fmt_bit_set\00"
@str$11c = private global [22 x i8] c"unknown\20bit_size\20size\00"
@str$11d = private global [3 x i8] c"\2C\20\00"
@str$11e = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$11f = private global [5 x i8] c"HERE\00"
@str$120 = private global [11 x i8] c"bit_field\7B\00"
@str$121 = private global [3 x i8] c"\2C\20\00"
@str$122 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$123 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$124 = private global [4 x i8] c"\20\3D\20\00"
@str$125 = private global [6 x i8] c"\3Cnil\3E\00"
@str$126 = private global [3 x i8] c"\7B\7D\00"
@str$127 = private global [3 x i8] c"\2C\20\00"
@str$128 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$129 = private global [4 x i8] c"\20\3D\20\00"
@str$12a = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$12b = private global [6 x i8] c"any\7B\7D\00"
@str$12c = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$12d = private global [3 x i8] c"\2C\0A\00"
@str$12e = private global [3 x i8] c"\2C\20\00"
@str$12f = private global [3 x i8] c"\2C\20\00"
@str$130 = private global [3 x i8] c"\2C\20\00"
@str$131 = private global [5 x i8] c"map\5B\00"
@str$132 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$133 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$134 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$135 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$136 = private global [3 x i8] c"\2C\20\00"
@str$137 = private global [2 x i8] c"\3D\00"
@str$138 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$139 = private global [12 x i8] c"\28raw_union\29\00"
@str$13a = private global [3 x i8] c"\2C\20\00"
@str$13b = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$13c = private global [4 x i8] c"\20\3D\20\00"
@str$13d = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$13e = private global [6 x i8] c"any\7B\7D\00"
@str$13f = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$140 = private global [3 x i8] c"\2C\0A\00"
@str$141 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$142 = private global [10 x i8] c"fmt_value\00"
@str$143 = private global [23 x i8] c"Invalid\20union\20tag\20type\00"
@str$144 = private global [4 x i8] c"nil\00"
@str$145 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$146 = private global [4 x i8] c"nil\00"
@str$147 = private global [4 x i8] c"\20\40\20\00"
@str$148 = private global [6 x i8] c"\3Cnil\3E\00"
@str$149 = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$14a = private global [54 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$14b = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$14c = private global [12 x i8] c"parse_value\00"
@str$14d = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$14e = private global [12 x i8] c"parse_value\00"
@str$14f = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$150 = private global [12 x i8] c"parse_value\00"
@str$151 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$152 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$153 = private global [12 x i8] c"parse_value\00"
@str$154 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$155 = private global [12 x i8] c"parse_value\00"
@str$156 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$157 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$158 = private global [20 x i8] c"couldn\27t\20find\20name\20\00"
@str$159 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$15a = private global [12 x i8] c"parse_value\00"
@str$15b = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$15c = private global [12 x i8] c"parse_value\00"
@str$15d = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$15e = private global [12 x i8] c"parse_value\00"
@str$15f = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$160 = private global [12 x i8] c"parse_value\00"
@str$161 = private global [24 x i8] c"Too\20many\20array\20elements\00"
@str$162 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$163 = private global [12 x i8] c"parse_value\00"
@str$164 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$165 = private global [12 x i8] c"parse_value\00"
@str$166 = private global [30 x i8] c"End\20of\20text\20from\20within\20array\00"
@str$167 = private global [24 x i8] c"Symbol\20token\20in\20array\3A\20\00"
@str$168 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$169 = private global [12 x i8] c"parse_value\00"
@str$16a = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$16b = private global [12 x i8] c"parse_value\00"
@str$16c = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$16d = private global [12 x i8] c"parse_value\00"
@str$16e = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$16f = private global [12 x i8] c"parse_value\00"
@str$170 = private global [30 x i8] c"End\20of\20text\20from\20within\20array\00"
@str$171 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$172 = private global [24 x i8] c"Symbol\20token\20in\20array\3A\20\00"
@str$173 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$174 = private global [12 x i8] c"parse_value\00"
@str$175 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$176 = private global [12 x i8] c"parse_value\00"
@str$177 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$178 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$179 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$17a = private global [12 x i8] c"parse_value\00"
@str$17b = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$17c = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$17d = private global [12 x i8] c"parse_value\00"
@str$17e = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$17f = private global [12 x i8] c"parse_value\00"
@str$180 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$181 = private global [12 x i8] c"parse_value\00"
@str$182 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$183 = private global [12 x i8] c"parse_value\00"
@str$184 = private global [30 x i8] c"End\20of\20text\20from\20within\20array\00"
@str$185 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$186 = private global [24 x i8] c"Symbol\20token\20in\20array\3A\20\00"
@str$187 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$188 = private global [12 x i8] c"parse_value\00"
@str$189 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$18a = private global [12 x i8] c"parse_value\00"
@str$18b = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$18c = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$18d = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$18e = private global [12 x i8] c"parse_value\00"
@str$18f = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$190 = private global [5 x i8] c"true\00"
@str$191 = private global [5 x i8] c"True\00"
@str$192 = private global [5 x i8] c"TRUE\00"
@str$193 = private global [6 x i8] c"false\00"
@str$194 = private global [6 x i8] c"False\00"
@str$195 = private global [6 x i8] c"FALSE\00"
@str$196 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$197 = private global [12 x i8] c"parse_value\00"
@str$198 = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$199 = private global [12 x i8] c"parse_value\00"
@str$19a = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$19b = private global [12 x i8] c"parse_value\00"
@str$19c = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$19d = private global [12 x i8] c"parse_value\00"
@str$19e = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$19f = private global [12 x i8] c"parse_value\00"
@str$1a0 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1a1 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1a2 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1a3 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1a4 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1a5 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1a6 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1a7 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1a8 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1a9 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1aa = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1ab = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1ac = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1ad = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1ae = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1af = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1b0 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1b1 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1b2 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1b3 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1b4 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1b5 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1b6 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1b7 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1b8 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1b9 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1ba = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1bb = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1bc = private global [13 x i8] c"generic_ftoa\00"
@str$1bd = private global [26 x i8] c"strconv\3A\20invalid\20bit_size\00"
@str$1be = private global [4 x i8] c"NaN\00"
@str$1bf = private global [5 x i8] c"-Inf\00"
@str$1c0 = private global [5 x i8] c"\2BInf\00"
@str$1c1 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1c2 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1c3 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1c4 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1c5 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1c6 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1c7 = private global [14 x i8] c"format_digits\00"
@str$1c8 = private global [49 x i8] c"strconv\3A\20e\2FE\20float\20printing\20is\20not\20yet\20supported\00"
@str$1c9 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1ca = private global [14 x i8] c"format_digits\00"
@str$1cb = private global [49 x i8] c"strconv\3A\20g\2FG\20float\20printing\20is\20not\20yet\20supported\00"
@str$1cc = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1cd = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1ce = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1cf = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1d0 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1d1 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1d2 = private global [20 x i8] c"is_integer_negative\00"
@str$1d3 = private global [42 x i8] c"is_integer_negative\3A\20Unknown\20integer\20size\00"
@str$1d4 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1d5 = private global [12 x i8] c"append_bits\00"
@str$1d6 = private global [44 x i8] c"strconv\3A\20illegal\20base\20passed\20to\20append_bits\00"
@str$1d7 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1d8 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1d9 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1da = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1db = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1dc = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1dd = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1de = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1df = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1e0 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1e1 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1e2 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1e3 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1e4 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1e5 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrconv\2Fstrconv.odin\00"
@str$1e6 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrings\2Fstrings.odin\00"
@str$1e7 = private global [11 x i8] c"new_string\00"
@str$1e8 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrings\2Fstrings.odin\00"
@str$1e9 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrings\2Fstrings.odin\00"
@str$1ea = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrings\2Fstrings.odin\00"
@str$1eb = private global [12 x i8] c"new_cstring\00"
@str$1ec = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrings\2Fstrings.odin\00"
@str$1ed = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fstrings\2Fstrings.odin\00"
@str$1ee = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1ef = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1f0 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1f1 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1f2 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1f3 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1f4 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1f5 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1f6 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1f7 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1f8 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1f9 = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1fa = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1fb = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1fc = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1fd = private global [62 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$1fe = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$1ff = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$200 = private global [31 x i8] c"End\20of\20text\20from\20within\20string\00"
@str$201 = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$202 = private global [15 x i8] c"get_next_token\00"
@str$203 = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$204 = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$205 = private global [31 x i8] c"End\20of\20text\20from\20within\20string\00"
@str$206 = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$207 = private global [15 x i8] c"get_next_token\00"
@str$208 = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$209 = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$20a = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$20b = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$20c = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$20d = private global [15 x i8] c"Unknown\20token\3A\00"
@str$20e = private global [8 x i8] c"at\20line\00"
@str$20f = private global [7 x i8] c"column\00"
@str$210 = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$211 = private global [15 x i8] c"get_next_token\00"
@str$212 = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$213 = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$214 = private global [15 x i8] c"get_next_token\00"
@str$215 = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$216 = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$217 = private global [15 x i8] c"get_next_token\00"
@str$218 = private global [69 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Flexer\2Fmain.odin\00"
@str$219 = private global [40 x i8] c"package\20main\0A\0Ausing\20import\20\22core\3Afmt\22\0A\0A\00"
@str$21a = private global [28 x i8] c"..\2Fsrc\2Fcomponent_types.wbml\00"
@str$21b = private global [15 x i8] c"Couldn\27t\20find\20\00"
@str$21c = private global [28 x i8] c"..\2Fsrc\2Fcomponent_types.wbml\00"
@str$21d = private global [74 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Fprebuild\2Fodinscape_prebuild.odin\00"
@str$21e = private global [5 x i8] c"main\00"
@str$21f = private global [15 x i8] c"Component_Type\00"
@str$220 = private global [7 x i8] c"entity\00"
@str$221 = private global [7 x i8] c"Entity\00"
@str$222 = private global [6 x i8] c"$Type\00"
@str$223 = private global [7 x i8] c"typeid\00"
@str$224 = private global [14 x i8] c"add_component\00"
@str$225 = private global [6 x i8] c"\5EType\00"
@str$226 = private global [14 x i8] c"when\20Type\20\3D\3D\20\00"
@str$227 = private global [3 x i8] c"\20\7B\00"
@str$228 = private global [30 x i8] c"_t\3A\20Type\3B\20_t.entity\20\3D\20entity\3B\00"
@str$229 = private global [9 x i8] c"append\28\26\00"
@str$22a = private global [7 x i8] c"\2C\20_t\29\3B\00"
@str$22b = private global [7 x i8] c"t\20\3A\3D\20\26\00"
@str$22c = private global [6 x i8] c"\5Blen\28\00"
@str$22d = private global [6 x i8] c"\29-1\5D\3B\00"
@str$22e = private global [5 x i8] c"\28t\29\3B\00"
@str$22f = private global [10 x i8] c"return\20t\3B\00"
@str$230 = private global [2 x i8] c"\7D\00"
@str$231 = private global [169 x i8] c"panic\28tprint\28\22No\20generated\20code\20for\20type\20\22\2C\20type_info_of\28Type\29\2C\20\22\20in\20add_component\28\29.\20Make\20sure\20you\20add\20your\20new\20component\20types\20to\20component_types.wbml\22\29\29\3B\20return\20nil\3B\00"
@str$232 = private global [7 x i8] c"entity\00"
@str$233 = private global [7 x i8] c"Entity\00"
@str$234 = private global [6 x i8] c"$Type\00"
@str$235 = private global [7 x i8] c"typeid\00"
@str$236 = private global [14 x i8] c"get_component\00"
@str$237 = private global [6 x i8] c"\5EType\00"
@str$238 = private global [14 x i8] c"when\20Type\20\3D\3D\20\00"
@str$239 = private global [3 x i8] c"\20\7B\00"
@str$23a = private global [13 x i8] c"for\20_\2C\20i\20in\20\00"
@str$23b = private global [3 x i8] c"\20\7B\00"
@str$23c = private global [7 x i8] c"c\20\3A\3D\20\26\00"
@str$23d = private global [40 x i8] c"\5Bi\5D\3B\20if\20c.entity\20\3D\3D\20entity\20do\20return\20c\3B\00"
@str$23e = private global [2 x i8] c"\7D\00"
@str$23f = private global [2 x i8] c"\7D\00"
@str$240 = private global [169 x i8] c"panic\28tprint\28\22No\20generated\20code\20for\20type\20\22\2C\20type_info_of\28Type\29\2C\20\22\20in\20get_component\28\29.\20Make\20sure\20you\20add\20your\20new\20component\20types\20to\20component_types.wbml\22\29\29\3B\20return\20nil\3B\00"
@str$241 = private global [10 x i8] c"component\00"
@str$242 = private global [6 x i8] c"$Type\00"
@str$243 = private global [18 x i8] c"destroy_component\00"
@str$244 = private global [14 x i8] c"when\20Type\20\3D\3D\20\00"
@str$245 = private global [3 x i8] c"\20\7B\00"
@str$246 = private global [13 x i8] c"for\20_\2C\20i\20in\20\00"
@str$247 = private global [3 x i8] c"\20\7B\00"
@str$248 = private global [7 x i8] c"c\20\3A\3D\20\26\00"
@str$249 = private global [40 x i8] c"\5Bi\5D\3B\20if\20c.entity\20\3D\3D\20entity\20do\20return\20c\3B\00"
@str$24a = private global [2 x i8] c"\7D\00"
@str$24b = private global [2 x i8] c"\7D\00"
@str$24c = private global [23 x i8] c"call_component_updates\00"
@str$24d = private global [13 x i8] c"for\20_\2C\20i\20in\20\00"
@str$24e = private global [3 x i8] c"\20\7B\00"
@str$24f = private global [7 x i8] c"c\20\3A\3D\20\26\00"
@str$250 = private global [6 x i8] c"\5Bi\5D\3B\20\00"
@str$251 = private global [5 x i8] c"\28c\29\3B\00"
@str$252 = private global [2 x i8] c"\7D\00"
@str$253 = private global [23 x i8] c"call_component_renders\00"
@str$254 = private global [13 x i8] c"for\20_\2C\20i\20in\20\00"
@str$255 = private global [3 x i8] c"\20\7B\00"
@str$256 = private global [7 x i8] c"c\20\3A\3D\20\26\00"
@str$257 = private global [6 x i8] c"\5Bi\5D\3B\20\00"
@str$258 = private global [5 x i8] c"\28c\29\3B\00"
@str$259 = private global [2 x i8] c"\7D\00"
@str$25a = private global [24 x i8] c"call_component_destroys\00"
@str$25b = private global [13 x i8] c"for\20_\2C\20i\20in\20\00"
@str$25c = private global [3 x i8] c"\20\7B\00"
@str$25d = private global [7 x i8] c"c\20\3A\3D\20\26\00"
@str$25e = private global [6 x i8] c"\5Bi\5D\3B\20\00"
@str$25f = private global [5 x i8] c"\28c\29\3B\00"
@str$260 = private global [2 x i8] c"\7D\00"
@str$261 = private global [74 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Fprebuild\2Fodinscape_prebuild.odin\00"
@str$262 = private global [5 x i8] c"main\00"
@str$263 = private global [37 x i8] c"..\2Fsrc\2Fodinscape_generated_code.odin\00"
@str$264 = private global [74 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2Fodinscape\2Fprebuild\2Fodinscape_prebuild.odin\00"
@str$265 = private global [5 x i8] c"main\00"
@str$266 = private global [2 x i8] c"\09\00"
@str$267 = private global [13 x i8] c"\20\3A\3A\20union\20\7B\0A\00"
@str$268 = private global [3 x i8] c"\2C\0A\00"
@str$269 = private global [4 x i8] c"\7D\0A\0A\00"
@str$26a = private global [10 x i8] c"\20\3A\3A\20proc\28\00"
@str$26b = private global [3 x i8] c"\2C\20\00"
@str$26c = private global [3 x i8] c"\3A\20\00"
@str$26d = private global [3 x i8] c"\29\20\00"
@str$26e = private global [4 x i8] c"-\3E\20\00"
@str$26f = private global [2 x i8] c"\20\00"
@str$270 = private global [3 x i8] c"\7B\0A\00"
@str$271 = private global [2 x i8] c"\0A\00"
@str$272 = private global [4 x i8] c"\7D\0A\0A\00"
@str$273 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$274 = private global [12 x i8] c"append_elem\00"
@str$275 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$276 = private global [13 x i8] c"append_elems\00"
@str$277 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$278 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$279 = private global [12 x i8] c"append_elem\00"
@str$27a = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$27b = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$27c = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$27d = private global [12 x i8] c"deserialize\00"
@str$27e = private global [68 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fshared\2Fworkbench\2Fwbml\2Fmain.odin\00"
@str$27f = private global [12 x i8] c"deserialize\00"
@str$280 = private global [11 x i8] c"empty\20text\00"
@str$281 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$282 = private global [22 x i8] c"reserve_dynamic_array\00"
@str$283 = private global [59 x i8] c"\2FUsers\2Fjake\2FDocuments\2FDev\2Fodin\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$284 = private global [22 x i8] c"reserve_dynamic_array\00"
@str$285 = private global [10 x i8] c"Type_Info\00"
@str$286 = private global [5 x i8] c"size\00"
@str$287 = private global [6 x i8] c"align\00"
@str$288 = private global [3 x i8] c"id\00"
@str$289 = private global [8 x i8] c"variant\00"
@str$28a = private global [16 x i8] c"Type_Info_Named\00"
@str$28b = private global [5 x i8] c"name\00"
@str$28c = private global [5 x i8] c"base\00"
@str$28d = private global [18 x i8] c"Type_Info_Integer\00"
@str$28e = private global [7 x i8] c"signed\00"
@str$28f = private global [15 x i8] c"Type_Info_Rune\00"
@str$290 = private global [16 x i8] c"Type_Info_Float\00"
@str$291 = private global [18 x i8] c"Type_Info_Complex\00"
@str$292 = private global [17 x i8] c"Type_Info_String\00"
@str$293 = private global [11 x i8] c"is_cstring\00"
@str$294 = private global [18 x i8] c"Type_Info_Boolean\00"
@str$295 = private global [14 x i8] c"Type_Info_Any\00"
@str$296 = private global [18 x i8] c"Type_Info_Type_Id\00"
@str$297 = private global [18 x i8] c"Type_Info_Pointer\00"
@str$298 = private global [5 x i8] c"elem\00"
@str$299 = private global [20 x i8] c"Type_Info_Procedure\00"
@str$29a = private global [7 x i8] c"params\00"
@str$29b = private global [8 x i8] c"results\00"
@str$29c = private global [9 x i8] c"variadic\00"
@str$29d = private global [11 x i8] c"convention\00"
@str$29e = private global [19 x i8] c"Calling_Convention\00"
@str$29f = private global [8 x i8] c"Invalid\00"
@str$2a0 = private global [5 x i8] c"Odin\00"
@str$2a1 = private global [12 x i8] c"Contextless\00"
@str$2a2 = private global [2 x i8] c"C\00"
@str$2a3 = private global [4 x i8] c"Std\00"
@str$2a4 = private global [5 x i8] c"Fast\00"
@str$2a5 = private global [16 x i8] c"Type_Info_Array\00"
@str$2a6 = private global [5 x i8] c"elem\00"
@str$2a7 = private global [10 x i8] c"elem_size\00"
@str$2a8 = private global [6 x i8] c"count\00"
@str$2a9 = private global [24 x i8] c"Type_Info_Dynamic_Array\00"
@str$2aa = private global [5 x i8] c"elem\00"
@str$2ab = private global [10 x i8] c"elem_size\00"
@str$2ac = private global [16 x i8] c"Type_Info_Slice\00"
@str$2ad = private global [16 x i8] c"Type_Info_Tuple\00"
@str$2ae = private global [6 x i8] c"types\00"
@str$2af = private global [6 x i8] c"names\00"
@str$2b0 = private global [17 x i8] c"Type_Info_Struct\00"
@str$2b1 = private global [6 x i8] c"types\00"
@str$2b2 = private global [6 x i8] c"names\00"
@str$2b3 = private global [8 x i8] c"offsets\00"
@str$2b4 = private global [7 x i8] c"usings\00"
@str$2b5 = private global [10 x i8] c"is_packed\00"
@str$2b6 = private global [13 x i8] c"is_raw_union\00"
@str$2b7 = private global [13 x i8] c"custom_align\00"
@str$2b8 = private global [16 x i8] c"Type_Info_Union\00"
@str$2b9 = private global [9 x i8] c"variants\00"
@str$2ba = private global [11 x i8] c"tag_offset\00"
@str$2bb = private global [9 x i8] c"tag_type\00"
@str$2bc = private global [13 x i8] c"custom_align\00"
@str$2bd = private global [15 x i8] c"Type_Info_Enum\00"
@str$2be = private global [5 x i8] c"base\00"
@str$2bf = private global [6 x i8] c"names\00"
@str$2c0 = private global [7 x i8] c"values\00"
@str$2c1 = private global [21 x i8] c"Type_Info_Enum_Value\00"
@str$2c2 = private global [14 x i8] c"Type_Info_Map\00"
@str$2c3 = private global [4 x i8] c"key\00"
@str$2c4 = private global [6 x i8] c"value\00"
@str$2c5 = private global [17 x i8] c"generated_struct\00"
@str$2c6 = private global [20 x i8] c"Type_Info_Bit_Field\00"
@str$2c7 = private global [6 x i8] c"names\00"
@str$2c8 = private global [5 x i8] c"bits\00"
@str$2c9 = private global [8 x i8] c"offsets\00"
@str$2ca = private global [18 x i8] c"Type_Info_Bit_Set\00"
@str$2cb = private global [5 x i8] c"elem\00"
@str$2cc = private global [11 x i8] c"underlying\00"
@str$2cd = private global [6 x i8] c"lower\00"
@str$2ce = private global [6 x i8] c"upper\00"
@str$2cf = private global [15 x i8] c"Allocator_Mode\00"
@str$2d0 = private global [6 x i8] c"Alloc\00"
@str$2d1 = private global [5 x i8] c"Free\00"
@str$2d2 = private global [9 x i8] c"Free_All\00"
@str$2d3 = private global [7 x i8] c"Resize\00"
@str$2d4 = private global [17 x i8] c"Token_Identifier\00"
@str$2d5 = private global [6 x i8] c"value\00"
@str$2d6 = private global [13 x i8] c"Token_Number\00"
@str$2d7 = private global [10 x i8] c"int_value\00"
@str$2d8 = private global [19 x i8] c"unsigned_int_value\00"
@str$2d9 = private global [12 x i8] c"float_value\00"
@str$2da = private global [10 x i8] c"has_a_dot\00"
@str$2db = private global [13 x i8] c"Token_String\00"
@str$2dc = private global [13 x i8] c"Token_Symbol\00"
@str$2dd = private global [6 x i8] c"value\00"
@str$2de = private global [9 x i8] c"Int_Flag\00"
@str$2df = private global [7 x i8] c"Prefix\00"
@str$2e0 = private global [5 x i8] c"Plus\00"
@str$2e1 = private global [6 x i8] c"Space\00"
@str$2e2 = private global [21 x i8] c"Component_Definition\00"
@str$2e3 = private global [10 x i8] c"type_name\00"
@str$2e4 = private global [17 x i8] c"storage_variable\00"
@str$2e5 = private global [10 x i8] c"init_proc\00"
@str$2e6 = private global [12 x i8] c"update_proc\00"
@str$2e7 = private global [12 x i8] c"render_proc\00"
@str$2e8 = private global [13 x i8] c"destroy_proc\00"
@str$2e9 = private global [18 x i8] c"0123456789abcdefx\00"
@str$2ea = private global [18 x i8] c"0123456789ABCDEFX\00"
@str$2eb = private global [37 x i8] c"0123456789abcdefghijklmnopqrstuvwxyz\00"
@str$2ec = private global [18 x i8] c"0123456789abcdefx\00"
@str$2ed = private global [18 x i8] c"0123456789ABCDEFX\00"
@str$2ee = private global [37 x i8] c"0123456789abcdefghijklmnopqrstuvwxyz\00"
attributes #0 = {nounwind uwtable}
attributes #1 = {nounwind alwaysinline uwtable}
attributes #2 = {nounwind noinline optnone uwtable}
attributes #3 = {nounwind readnone}
